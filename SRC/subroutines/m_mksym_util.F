      module m_mksym_util
      contains
      subroutine pvsym2(mode,nbas,nclass,ics,ipc,nspec,slabl,ssite,
     .dclabl,nrc)
      use m_struc_def  !Cgetarg
C- Create class labels from species labels (double precision format)
C ----------------------------------------------------------------------
Ci Inputs:
Ci   nosplt: T copy class and species
Ci     mode: 0 do nothing
Ci           1 create class labels clabl
Ci           2 create number of sites in each class nrc
Ci      ipc: for padding sites ib ipc(ib) = class
Ci   nclass: number of classes
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: *
Ci     Stored:    clabel
Co Outputs:
Co   dclabl: class labels in double precision format
Co      nrc: number of sites in each class
Cu Updates
Cu   18 Dec 01 Packs class label into ssite->clabel
C ----------------------------------------------------------------------
      implicit none
      integer mode,nbas,nclass,nspec,ics(1),ipc(nbas),nrc(1)
      type(s_site)::ssite(*)
      character*8 slabl(nspec)
      integer ic,iclbsj,idx,is,ib
      character(8):: clabl,dclabl(nclass)
C --- Make class labels from species labels ---
      if (mod(mode,2) .eq. 1) then
        do  10  is = 1, nspec
          do  12  idx = 1, nbas
            ic = iclbsj(is,ics,-nclass,idx)
            if (ic .lt. 0) goto 13
            call clabel(slabl,is,idx,clabl)
c            call s8tor8(clabl,dclabl(ic))
            dclabl(ic)=clabl
   12     continue
   13     continue
   10   continue
      endif
      do  20  ib = 1, nbas
        ic = ipc(ib)
        ssite(ib)%clabel = dclabl(ic) !clabl
   20 continue
C --- Create nrc ---
      if (mod(mode/2,2) .eq. 1) then
        call iinit(nrc,nclass)
        do  30  ib = 1, nbas
          ic = ipc(ib)
          nrc(ic) = nrc(ic)+1
   30   continue
      endif
      end subroutine pvsym2

      subroutine gensym(slabl,gens,usegen,lcar,lfix,fptol,lsmall,nbas,
     .nspec,ngmx,plat,platcv,ldist,dist,bas,ips,nrspec,ng,g,
     .ag,ngen,gen,nwgens,nggen,isym,istab)
C- Generate the space group
C ----------------------------------------------------------------------
Ci Inputs:
Ci   slabl: name of the different species.
Ci   gens:  a list of generators, in symbolic representation
Ci          NB: this list is not required; see Remarks.
Ci   usegen:0 Find any additional group operations for this basis.
Ci          1 Also, extra basis atoms are added as needed to guarantee
Ci            the group operations created from gens are valid.
Ci          2 Do neither 0 nor 1.
Ci   lcar:  (not used)
Ci          T express ag,positions in cartesian coordinates
Ci          F express in units of conventional unit cell
Ci   lfix:  T: do not rotate or shift lattice
Ci   fptol: >0:Adjust positions slightly, rendering them as exactly
Ci          possible consistent with the symmetry group.  Any sites
Ci          within a lattice vector of tol are considered to be
Ci          at the same point.
Ci   nspec: number of classes, atoms in same class are symmetry-related
Ci   plat:  primitive lattice vectors (scaled by alat)
Ci   platcv:Used to scale translation part of generators,
Ci         :when translation part specified as a multiple of
Ci         :lattice vectors.  Can be same as plat but
Ci         :primitive lattice vectors of "conventional unit cell"
Ci         :are sometimes used to specify these translations, e.g.
Ci         :when generated from spacegroup data in some books.
Ci   ldist: lattice deformation matrix key; see lattdf
Ci   dist:  lattice deformation matrix; see lattdf
Cio Inputs/Outputs (altered only if usegen=F)
Cio  nbas:  On input, number of atoms in the basis
Cio         On output nbas may be enlarged, depending symops and usegen
Cio  bas:   basis vectors
Cio         On output bas may be enlarged, depending symops and usegen
Cio  ips:   the jth atom belongs to spec ips(j)
Cio         On output ips may be enlarged, depending symops and usegen
Co Outputs:
Co   istab: site ib is transformed into istab(ib,ig) by operation ig
Co   g:     symmetry operation matrix (assumed dimensioned >=ngmx)
Co   ag:    symmetry operation vector (assumed dimensioned >=ngmx)
Co   ... The following are generated if usegen=F
Co   isym:  numbers characterizing the symmetry of lattice and crystal
Co          isym(1) produces index for underlying lattice (see symlat)
Co   lsmall:if T: a smaller unit cell can be found
Co   nrspec:number of atoms in the ith class
Co   ng:    number of group operations
Co   ngen:  number of symmetry generators
Co   gen:   generators in matrix form
Co   nwgens:generators in ascii form
Co   nggen :number of group ops generated by generators.
Co         :Usually nggen=ng; however nggen can exceed ng if
Co         :supercell is artificial -> extra translations; see groupg
Cl Local variables
Cl   modes: 0 -> sgroup compares point and space groups
Cl          1 -> sgroup compares point groups only
Cl          (set with 'points' keyword in gens)
Cr Remarks:
Cr   gensym generates the space group, using the following prescription:
Cr     1.  Any generators supplied from input gens
Cr         are checked for consistency with the underlying lattice.
Cr     2.  The space group is made from these generators.
Cr     3.  if usegen<2, missing basis atoms are added to make
Cr         the basis consistent with the supplied symmetry.
Cr     4.  nrspec is created
Cr     ... Unless usegen is 0, nothing more is done
Cr     5.  The point group of the underlying lattice without the
Cr         basis is generated.
Cr     6.  The full space group is generated from the point group
Cr     7.  A set of generators for this group is created
Cr   This program was adapted from the Stuttgart ASA version lmto-46.
Cb Bugs:
Cb   auto symmetry finder can fail with supercells, where extra
Cb   group operations include the same point group but inequivalent
Cb   translations.  Solution: have symcry call sgroup to see
Cb   if the space group is enlarged.  If so, space group should be
Cb   enlarged.
Cu Updates
Cu   04 Jan 06 Enabled keyword 'point' in ssymgr, returns if ng>ngmx
Cu   13 Dec 03 Uses platcv when scaling translation part of symgrp
Cu   05 Apr 03 Call sgroup looking only for point group ops;see bugs
Cu   03 Nov 01 Shortened argument list, eliminating duplicate bas,ips
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer nbas,isym(*),istab(nbas,*),nspec,ngen,ngmx,
     .ng,nrspec(nspec),usegen,ldist,ips(nbas),nggen
C     integer istab2(nbas,*)
      double precision plat(9),platcv(9),g(9,*),ag(3,*),dist(3,3),
     .bas(3,nbas),fptol
      character*8  slabl(*), gens*(*), nwgens*(*)
      logical lcar,lfix
C Local parameters:
      integer:: i , j , ibas , ic , iprint , ngnmx , igen , mxint , 
     .modes
      real(8) ,allocatable :: wk_rv(:)

      double precision qlat(3,3),vol,platt(9)
      logical lsmall,latvec
      parameter(ngnmx=10)
      double precision gen(9,ngnmx),agen(3,ngnmx)
C heap:
      integer ::iwdummy,iwdummy1(1)
      call rxx(.not. lcar, 'gensym not implemented lcar')
      call rxx(lfix,  'gensym not implemented lfix')
      call rxx(lsmall,'gensym not implemented lsmall')

C --- Reciprocal lattice vectors ---
      call dinv33(plat,1,qlat,vol)

C --- Symmetry group as given by input generators ---
      nwgens = gens
      modes = 0
      call words(gens,ngen)
      if (ngen .gt. 0) then
        call word(gens,ngen,i,j)
        if (gens(i:j) .eq. 'point') then
          j = i-1
          modes = 1
        endif
        call psymop(gens(1:j),platcv,gen,agen,ngen)
        nwgens = gens(1:j)
      endif

C ... Rotate the generators
      call pshpr(iprint()-11)
      call lattdf ( - ldist , dist , plat , 0 , iwdummy , ngen , gen 
     . )

      call poppr
      do  10  igen = 1, ngen
        call grpprd(gen(1,igen),plat,platt)
C       call dmpy(gen(1,igen),3,1,plat,3,1,platt,3,1,3,3,3)
        if (.not. latvec(3,1d-5,qlat,platt))
     .  call fexit(-1,111,' Exit -1 GENSYM: '//
     .  'generator %i imcompatible with underlying lattice',igen)
   10 continue

C ... Set up space group (g,ag,ng) given point group generators gen
      call sgroup(10+modes,gen,agen,ngen,g,ag,nggen,ngmx,qlat)
      ng = min(nggen,ngmx)
      if (nggen .gt. ngmx) return

C --- Add new atoms to the basis according to symmetry ---
      if (usegen .lt. 2) then
        call addbas(fptol,bas,slabl,ips,nbas,ng,qlat,g,ag)
      endif
C ... Make nrspec ... i should be nspec
      i = mxint(nbas,ips)
      if (i .ne. nspec .and. iprint() .gt. 0)
     .call awrit2(' GENSYM (warning) %i species supplied but only '//
     .'%i spec used ...%N%8fpossible errors in class data',' ',120,6,
     .nspec,i)
      nspec = i
      call iinit(nrspec,nspec)
      do  22  ibas = 1, nbas
        ic = ips(ibas)
        nrspec(ic) = nrspec(ic)+1
   22 continue

C --- check if unit cell is the smallest possible one (not implemented)
C      call chkcel(alat,bas,csym,ips,isym,lsmall,nbas,nspec,
C     .            nrspec,plat,qlat)

C --- Complete the space group ---
      if (usegen .eq. 0) then
C       call rotlat(alat,bas,csym,isym,lfix,nbas,plat,qlat)
C   ... Symmetry of lattice without basis
        call symlat(plat,ng,g,isym(1))
C   ... Symmetry of lattice with basis
        allocate(wk_rv(3*nbas))

C       call prmx('pos',bas,3,3,nbas)
        call symcry ( fptol , bas , wk_rv , ips , nbas , nspec , nrspec 
     .  , ng , plat , qlat , g , ag , istab )

        if (allocated(wk_rv)) deallocate(wk_rv)

        if (ng .gt. ngmx) return
C       ngen = 0
        nwgens = ' '
        call groupg(0,ng,g,ag,plat,ngen,gen,agen,nwgens,nggen)
      else
        nggen = 0
        call symtbl ( 0 , fptol , nbas , iwdummy1 , bas , g , ag , ng , qlat , istab )
      endif

C --- Make istab2 ---
C      do  i = 1, ng
C        do  ibas = 1, nbas
C          ic = istab(ibas,i)
C          istab2(ic,i) = ibas
C        enddo
C      enddo

      if (iprint() .ge. 80 .and. ng .gt. 1) then
        call info0(0,0,0,
     .  ' GENSYM: site permutation table for group operations ...')
        call shoist(istab,nbas,ag,g,ng)
C       call shoist(istab2,nbas,ag,g,ng)
      endif

C     pause

C --- Adjust basis to conform with symops to numerical precision ---
      if (fptol .gt. 0) then
        call fixpos(bas,nbas,fptol,ng,plat,g,ag,istab)
      endif

C  ... debugging
C      call shoist(istab,nbas,ag,g,ng)
C      call symtbl(0,nbas,w,bas,g,ag,ng,qlat,istab)
C      call shoist(istab,nbas,ag,g,ng)
C
C      call symtab(nbas,w,bas,g,ag,-ng,plat,qlat,w,istab)
C      call shoist(istab,nbas,ag,g,ng)
C      call symtbl(1,nbas,w,bas,g,ag,ng,qlat,istab)
C      call shoist(istab,nbas,ag,g,ng)
C      stop

      end

      subroutine addbas(tol,bas,clabl,ips,nbas,ngrp,qlat,g,ag)
C- Adds the missing basis atoms to get the right symmetry
C ----------------------------------------------------------------------
Ci Inputs:
Ci   clabl :name of the different inequivalent atom
Ci   ips:the jth atom belongs to spec ips(j)
Ci   ngrp  :number of group operations
Ci   qlat  :primitive translation vectors in reciprocal space
Ci   g     :symmetry operation matrix
Ci   symops:symmetry operation symbol
Ci   ag    :symmetry operation vector (dimensionless)
Cio Inputs/Output:
Cio  bas   :basis vectors (dimensionless)
Cio         on output list has been completed by the new positions
Cio  nbas  :number of atoms in the basis
Cr Remarks:
Cr For each atom, the symmetry-related positions are generated.
Cr If this position is empty a new atom is added.
Cr At the end, a check is made to ensure that
Cr atoms of different speces do not occupy the same positions.
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer ips(*),nbas,ngrp
      double precision qlat(3,3),bas(3,*),g(9,*),ag(3,*),tol
      character*8 clabl(*)
C Local parameters:
      integer i,isop,ipr,lgunit,nbasnw,ibas,jbas,ic,jc,m,novlp,stdo
      double precision bast(3),dbas(3),tol1
      logical latvec
      character*50 sg
C External calls:
      external  daxpy,dcopy,dmpy,errmsg,iprint,lgunit
C Intrinsic functions:
      intrinsic  idnint
      character(200)::aaa

      tol1 = tol
      if (tol .eq. 0) tol1 = 1d-5
      stdo = lgunit(1)

C --- If no atom of same spec at the rotated site, add it ---
      call getpr(ipr)
      nbasnw = nbas
      do  10  ibas = 1, nbas
        do  20  isop = 2, ngrp
          ic = ips(ibas)
          call dmpy(g(1,isop),3,1,bas(1,ibas),3,1,bast,3,1,3,1,3)
          call daxpy(3,1.d0,ag(1,isop),1,bast,1)
          do  30  jbas = 1, nbasnw
            jc = ips(jbas)
            if (ic .eq. jc) then
              do  32  m = 1, 3
                dbas(m) = bast(m)-bas(m,jbas)
   32         continue
              if (latvec(1,tol1,qlat,dbas)) goto 22
            endif
   30     continue
          nbasnw = nbasnw+1
          if (ipr .ge. 50) then
            if (nbasnw .eq. nbas+1) write(stdo,304)
            call asymop(g(1,isop),ag(1,isop),' ',sg)
            call skpblb(sg,len(sg),i)
            write(stdo,303) clabl(ic),ibas,nbasnw,sg(1:i+1)
          endif
          ips(nbasnw) = ic
          call dcopy(3,bast,1,bas(1,nbasnw),1)
   22     continue
   20   continue
   10 continue

C --- Printout ---
      if (nbasnw > nbas) then
        if (ipr >= 10) then
c          call awrit2('%N ADDBAS: The basis was enlarged from %i'//
c     .    ' to %i sites%N         The additional sites are: %N',
          write(stdo,"(/,' ADDBAS: The basis was enlarged from ',i0,
     &     ' to ',i0,' sites',/,'         The additional sites are: ')") nbas,nbasnw
          write(stdo,301) (clabl(ips(ibas)),(bas(i,ibas),i=1,3), ibas=nbas+1,nbasnw)
          write(stdo,'(a)') ' '
        endif
        nbas = nbasnw
      else
        if (ipr>40) write(stdo,'('' ADDBAS: basis is already complete --- no sites added'')')
      endif

C --- Error whether atoms are sitting on same position ---
      novlp = 0
      do  40  ibas = 1, nbas
        ic = ips(ibas)
        do  50  jbas = 1, ibas-1
          jc = ips(jbas)
          do  52  m = 1, 3
            dbas(m) = bas(m,ibas)-bas(m,jbas)
   52     continue
          if (latvec(1,tol1,qlat,dbas)) then
            write(stdo,400) ibas,clabl(ic),(bas(m,ibas),m=1,3),
     .      jbas,clabl(jc),(bas(m,jbas),m=1,3)
            novlp = novlp+1
          endif
   50   continue
   40 continue
      if (novlp>0) then
         write(aaa,"(' ADDBAS: basis has ',i0,' overlapping site(s)')")novlp
         call rx(aaa)
      endif   
c     call fexit(-1,111,' Exit -1 ADDBAS: basis has %i overlapping site(s)',novlp)
  301 format(8x,'ATOM=',a4,1x,'POS=',3f12.7)
  303 format(10x,a4,2x,i3,2x,'-> ',i3,3x,5x,a)
  304 format(/' ADDBAS: Spec   Atom  New_atom     Operation'/9x,35('-'))
  400 format(/' ADDBAS: atom ',i3,', SPEC ',a4,' POS=',3f9.5, 
     ./'     and atom ',i3,', SPEC ',a4,' POS=',3f9.5,
     ./'     are at the same positions. '/)
      end
!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      subroutine sgroup(mode,gen,agen,ngen,g,ag,ng,ngmx,qb)
      use m_lmfinit,only: stdo
C- Sets up space group given generators (gen,agen).
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :a compound set of switches
Ci         :1s digit
Ci         :0 two groups compare to equal when both their point
Ci         :  and space parts compare equal
Ci         :1 two groups compare to equal when their point
Ci         :  group compares equal.  This eliminates
Ci         :  space groups that that have the same point group
Ci         :  but differing translational symmetry, which can
Ci         :  occur for artifically large supercells
Ci         :10s digit
Ci         :0 if ng>ngmx, abort with error message
Ci         :1 if ng>ngmx, return with ng=ngmx+1
Ci   gen   :rotation part of generators of the group
Ci   agen  :translation part of space group generator
Ci   ngen  :number of generators
Ci   ngmx  :maximum allowed number of group operations
Ci   qb    :vectors of a microcell in the Brillouin zone
Co Outputs
Co   g     :point group operations
Co   ag    :translation part of space group
Co   ng    :number of group operations
Cr Remarks
Cr   Operations are defined as (g,a)(v):=g*v+a
Cr   where g is a (3x3) matrix, a is a vector.
Cr   Always returns the identity operation as one group operation
Cu Updates
Cu   04 Jan 06 Added 10s digit mode
Cu   14 Mar 03 Added mode
C ----------------------------------------------------------------------
      implicit none
      integer:: mode,ngen,ng,ngmx
      integer:: ipr,igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,is,nnew,n,m,mode0,mode1
      real(8):: gen(9,ngen),g(9,ngmx),qb(3,3),agen(3,ngen),ag(3,ngmx),
     &     h(9),hh(9),e(9),sig(9),asig(3),ah(3),ahh(3),ae(3)
      logical :: spgeql
      character:: sout*80,sg*35
      data e/1d0,0d0,0d0, 0d0,1d0,0d0, 0d0,0d0,1d0/, ae/0d0,0d0,0d0/
      call getpr(ipr)
      sout = ' '
      call spgcop(e,ae,g,ag)
      ng = 1
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
C --- For each generator, do ---
      do  80  igen = 1, ngen
        call spgcop(gen(1,igen),agen(1,igen),sig,asig)
C --- Extend the group by all products with sig ----
        do  9  ig = 1, ng
          if (spgeql(mode0,g(1,ig),ag(1,ig),sig,asig,qb)) then
            if (ipr .gt. 30) call awrit2(' Generator %i already in group '//
     .      'as element %i',' ',80,stdo,igen,ig)
C        write(stdo,650) igen,ig
C  650   format(' generator',i3,'  is already in group as element',i3)
            goto 80
          endif
    9   continue
C ... Determine order (= power of sig that restores unit operation)
        call spgcop(sig,asig,h,ah)
        do  1  itry = 1, 100
          iord = itry
          if (spgeql(mode0,h,ah,e,ae,qb)) goto 2
          call spgprd(sig,asig,h,ah,h,ah)
    1   continue
C ... Products of type  g1 sig**p g2
    2   nnow = ng
        if (ipr .ge. 40) call awrit2('%a  %i is %i,',sout,80,0,igen,iord)
        do  8  j = 1, ng
          call spgcop(g(1,j),ag(1,j),h,ah)
          do  10  ip = 1, iord-1
            call spgprd(sig,asig,h,ah,h,ah)
            do  11  i = 1, ng
              call spgprd(g(1,i),ag(1,i),h,ah,hh,ahh)
              do  12  k = 1, nnow
                if ( spgeql(mode0,g(1,k),ag(1,k),hh,ahh,qb) ) goto 11
   12         continue
C         call asymop(hh,ahh,' ',sg)
C         write(stdo,'('' sgroup adding'',i3,2x,a)') nnow+1,sg
              nnow = nnow+1
              if (nnow .gt. ngmx) goto 99
              call spgcop(hh,ahh,g(1,nnow),ag(1,nnow))
   11       continue
   10     continue
          if (j .eq. 1) n2 = nnow
    8   continue
C ... Products with more than one sandwiched sigma-factor
        m1 = ng+1
        m2 = nnow
        do  20  is = 2, 50
          nnew = 0
          do 211 n = ng+1,n2
          do 21  m = m1, m2
            call spgprd(g(1,n),ag(1,n),g(1,m),ag(1,m),h,ah)
            do  22  k = 1, nnow
              if (spgeql(mode0,g(1,k),ag(1,k),h,ah,qb)) goto 21
   22       continue
            nnew = nnew+1
            nnow = nnow+1
            if (nnow .gt. ngmx) goto 99
            call spgcop(h,ah,g(1,nnow),ag(1,nnow))
   21     continue
 211      continue
          m1 = m2+1
          m2 = nnow
          if (nnew .eq. 0) goto 25
   20   continue
   25   continue
        ng = nnow
   80 continue
C --- Printout ---
      if (ipr .ge. 30) then
        if (sout .ne. ' ' .and. ipr .ge. 60) call awrit0
     .  (' Order of generator'//sout//'%a%b',' ',80,stdo)
        call awrit2(' SGROUP: %i symmetry operations from %i '//
     .  'generators',' ',80,stdo,ng,ngen)
        if (ipr .ge. 60 .and. ng .gt. 1) then
          write(stdo,'('' ig  group op'')')
          do  60  ig = 1, ng
            call asymop(g(1,ig),ag(1,ig),' ',sg)
            write(stdo,'(i4,2x,a)') ig,sg
   60     continue
        endif
      endif
      return
   99 continue
      if (mode1 .eq. 0) call rx1(
     .'SGROUP: ng greater than ngmx=%i: probably bad translation',ngmx)
C      call info2(1,0,0,
C     .  ' SGROUP (warning) ng greater than ngmx=%i ... exiting',ngmx,0)
      ng = ngmx+1
      end
      
      subroutine spgprd(g1,a1,g2,a2,g,a)
C     implicit none
      double precision
     .g1(3,3),g2(3,3),g(3,3),sum,a1(3),a2(3),a(3),h(3,3),ah(3)
      integer i,j,k
      do 101 i=1,3
      do 10 j=1,3
        sum=0d0
        do 11 k=1,3
          sum=sum+g1(i,k)*g2(k,j)
   11   continue
        h(i,j)=sum
   10 continue
 101  continue
      do j=1,3
      do i=1,3
         g(i,j)=h(i,j)
      enddo
      enddo
      do  i=1,3
        ah(i)=a1(i)
      do  j=1,3
         ah(i)=ah(i)+g1(i,j)*a2(j)
      enddo
      enddo
      do 14 i=1,3
        a(i)=ah(i)
   14 continue
      return
      end
      
      subroutine spgcop(g,ag,h,ah)
      integer i
      double precision h(9),g(9),ag(3),ah(3)
      do 10 i=1,9
        h(i)=g(i)
        if (dabs(h(i)).lt.1.d-10) h(i)=0d0
   10 continue
      do 11 i=1,3
        ah(i)=ag(i)
        if (dabs(ah(i)).lt.1.d-10) ah(i)=0d0
   11 continue
      end
      
      subroutine gpfndx(g,ag,ia,ja,pos,nrc,rb,qb)
C- Finds atom ja which is transformed into ia by group operation g,ag.
C     implicit none
      integer ia,ja
      double precision g(3,3),ag(3),pos(3,1),d(3),rb(3,3),qb(3,3)
      integer ka,nrc,m,k
C     integer mode(3)
C      mode(1) = 2
C      mode(2) = 2
C      mode(3) = 2
      ja = 0
      do  11  ka = 1, nrc
        do  m = 1, 3
          d(m) = ag(m) - pos(m,ia)
        do  k = 1, 3
           d(m) = d(m) + g(m,k)*pos(k,ka)
        enddo
        enddo
        call shorbz(d,d,rb,qb)
        if (abs(d(1))+abs(d(2))+abs(d(3)) .lt. 1d-4) then
          ja = ka
          return
        endif
   11 continue
      end
      
      subroutine groupg(mode,ng,g,ag,plat,ngen,gen,agen,gens,ngout)
      use m_lmfinit,only: stdo
C- Finds a set of generators for the symmetry group
C ----------------------------------------------------------------------
Ci Inputs:
Ci   mode  :0 two groups compare to equal when both their point
Ci         :  and space parts compare equal
Ci         :1 two groups compare to equal when their point
Ci         :  group compares equal.  This eliminates
Ci         :  space groups that that have the same point group
Ci         :  but differing translational symmetry, which can
Ci         :  occur for artifically large supercells.
Ci   plat  :primitive translation vectors in real space
Ci   qlat  :primitive translation vectors in reciprocal space
Ci   g:symmetry operation symbol
Ci   ng:number of symmetry operations as supplied by the generators
Co Outputs:
Co   gen,ngen:generators, and number needed to produce g
Co   ngout :number of group ops generated by (gen,ngen)
Co         :usually ngout=ng unless artificial translations
Co   gens  :ascii representation of generators
Cr Remarks:
Cr   The smallest set of generators is sought.
Cr   This subroutine performs the inverse function of sgroup.
Cu Updates
Cu   09 Jul 08 Extra check to find new generators beyond
Cu             the given ones.
Cu   12 May 07 Always returns gens, independent of verbosity
Cu   04 Jan 06 Returns ngout
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer mode,ngen,ng,ngout
      double precision plat(9)
      double precision gen(9,*),agen(3,*),g(9,*),ag(3,*)
      character*(*) gens
C Local parameters:
      integer imax,isop,ngloc,ngmax,iprint,ngen0,ngmx
      integer i1,i2,j1,j2
      parameter (ngmx=48*64)
      character*100 sg,sg1,sout,sout2
      double precision gloc(3,3,ngmx),agloc(3,ngmx),qlat(9),xx,vec(3)

cChangenglob      stdo = nglob('stdo')
c      stdo = globalvariables%stdo

C --- Starting number of group ops ---
      call mkqlat(plat,qlat,xx)
      call pshpr(1)
      ngen0 = ngen
      call sgroup(0,gen,agen,ngen,gloc,agloc,ngout,ngmx,qlat)

   10 continue
C --- Do until enough generators added to make whole group ---
      if (ngout .lt. ng) then
C   ... Run through all symops, choosing whichever adds the most ops
        imax = 0
        ngmax = 0
        do  isop = 1, ng
          call dcopy(9,g(1,isop),1,gen(1,ngen+1),1)
          call dcopy(3,ag(1,isop),1,agen(1,ngen+1),1)
C         call pshpr(61)
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
C         call poppr
          if (ngloc .gt. ngmax) then
            imax = isop
            ngmax = ngloc
            ngout = ngloc
          endif
        enddo
        ngen = ngen+1
        call dcopy(9,g(1,imax),1,gen(1,ngen),1)
        call dcopy(3,ag(1,imax),1,agen(1,ngen),1)
        goto 10
      endif

C     One last pass in case extra generators
      if (.true.) then
C   ... Run through all symops, choosing whichever adds the most ops
        imax = 0
        ngmax = ngout
        do  isop = 1, ng
          call dcopy(9,g(1,isop),1,gen(1,ngen+1),1)
          call dcopy(3,ag(1,isop),1,agen(1,ngen+1),1)
C         call pshpr(61)
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
C         call poppr
          if (ngloc .gt. ngmax) then
            imax = isop
            ngmax = ngloc
            ngout = ngloc
          endif
        enddo
        if (ngout .gt. ngmax) then
          ngen = ngen+1
          call dcopy(9,g(1,imax),1,gen(1,ngen),1)
          call dcopy(3,ag(1,imax),1,agen(1,ngen),1)
        endif
      endif

      call poppr

C --- Create gens, optionally printout ---
C     if (iprint() .ge. 20)  then
      if (ngen0 .eq. 0) then
        call info0(20,0,0,' GROUPG: the following '//
     .  'are sufficient to generate the space group:')
      else
        call info2(20,0,0,' GROUPG: %i generator(s) were added to '//
     .  'complete the group%?#n#:',ngen-ngen0,ngen-ngen0)
      endif
      sout = ' '
      sout2 = ' '
      do  20  isop = 1, ngen
        call asymop(gen(1,isop),agen(1,isop),':',sg)
        call awrit0('%a '//sg,sout(9:),len(sout)-9,0)
        call dcopy(3,agen(1,isop),1,vec,1)
        call dgemm('N','N',1,3,3,1d0,agen(1,isop),1,qlat,3,0d0,vec,1)
        call asymop(gen(1,isop),vec,'::',sg1)
        call word(sg1,1,i1,i2)
        call shorbz(vec,vec,plat,qlat)
        call asymop(gen(1,isop),vec,'::',sg)
        call word(sg,1,j1,j2)
        if (i2-i1 .lt. j2-j1) sg = sg1
        call awrit0('%a '//sg,sout2(9:),len(sout2)-9,0)
        !print *,'len(sout2)=',isop,len(sout2)
   20 continue
      if (ngen .gt. ngen0 .and. iprint() .ge. 20) then
        write(stdo,"(' Generator(cart): ', a)") trim(adjustl(sout))  ! call awrit0('%a',sout,len(sout),-stdo)
        write(stdo,"(' Generator(frac): ', a)") trim(adjustl(sout2)) ! call awrit0('%a',sout2,len(sout2),-stdo)
      endif
      gens = sout2
C     endif
      if (ngout .gt. ng) then
        call info2(20,0,0,
     .  '%9f(warning) %i group ops supplied but generators create'//
     .  ' %i ops',ng,ngout)
      endif
      end
!ssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      subroutine fixpos(pos,nbas,tol,ng,plat,g,ag,istab)
C- Adjusts site positions to agree with given symmmetry
C  to machine precision
C ----------------------------------------------------------------------
Ci Inputs:
Ci   pos:   basis vectors (scaled by alat)
Ci   nbas:  number of atoms in the basis
Ci   tol:   largest separation at which atoms are considered coincident
Ci   ng:    number of symmetry operations
Ci   plat:  primitive lattice vectors (scaled by alat)
Ci   g,ag:  point and translation group operators
Ci   istab: atom transformation table; see symtab
Co Outputs:
Co   pos:   basis vectors are adjusted.
Cr Remarks:
Cr   Generally atoms of the same class do not sit exactly on
Cr   symmetry-related positions. In this subroutine each atomic
Cr   position is replaced by the average of the position itself and
Cr   the generated positions of the atoms of the same class.
C ----------------------------------------------------------------------
      implicit none
C Passed parameters:
      integer nbas,ng,istab(nbas,ng)
      double precision pos(3,*),plat(*),g(9,*),ag(3,*),tol
      integer ibas,jbas,m,ig,lgunit
      double precision dbas(3),bast(3),sum,tol2,qlat(3,3),vol,ddot
      double precision sdpos(3,nbas)
      tol2 = 2*tol
      call dpzero(sdpos,3*nbas)
      sum = 0
      call dinv33(plat,1,qlat,vol)
      do  10  ibas = 1, nbas
        do  20  ig = 1, ng
          jbas = istab(ibas,ig)
          call dmpy(g(1,ig),3,1,pos(1,ibas),3,1,bast,3,1,3,1,3)
          do  30  m = 1, 3
            dbas(m) = bast(m) + ag(m,ig) - pos(m,jbas)
   30     continue
  333     format(a,3f12.6)
          call shorbz(dbas,dbas,plat,qlat)
c         print 334, 'output dbas', dbas
C     ... Debugging check
          sum = sum + abs(dbas(1))+abs(dbas(2))+abs(dbas(3))
          if (abs(dbas(1)) .gt. tol2 .or. abs(dbas(2)) .gt. tol2.or.
     .    abs(dbas(3)) .gt. tol2) call fexit(-1,111,
     .    'Exit -1 FIXPOS: positions incompatible with symgrp:'//
     .    '  dpos=%d',max(dbas(1),dbas(2),dbas(3)))
          if (abs(dbas(1)) .gt. tol .or. abs(dbas(2)) .gt. tol .or.
     .    abs(dbas(3)) .gt. tol) call awrit4(
     .    ' FIXPOS (warning): sites %i,%i incompatible '//
     .    'with grp op %i:  dpos=%d',' ',80,lgunit(1),
     .    ibas,jbas,ig,max(dbas(1),dbas(2),dbas(3)))
  334     format(a,3f18.12)
          call daxpy(3,1d0,dbas,1,sdpos(1,jbas),1)
   20   continue
   10 continue
      sum = dsqrt(ddot(3*nbas,sdpos,1,sdpos,1)/3/nbas)
      call daxpy(3*nbas,1d0/ng,sdpos,1,pos,1)
      call awrit1(' FIXPOS: shifted site positions by average %;3g',' ',
     .80,lgunit(1),sum/ng)
      end
!!
      subroutine grpgen(gen,ngen,symops,ng,ngmx)
      use m_lmfinit,only: stdo
C- Generate all point symmetry operations from the generation group
C ----------------------------------------------------------------
Ci Inputs
Ci   gen,ngen,ngmx
Ci   ng  (12 Sep 96): if>0 , add symops to the ng already in list.
Co Outputs
Co   symops,ng
Cr Remarks
Cr   This works for point groups only and is set up for integer
Cr   generators.
C ----------------------------------------------------------------
C     implicit none
      integer ngen,ng,ngmx
      double precision gen(9,ngen),symops(9,ngmx)
      double precision h(9),hh(9),e(9),sig(9),ae(3)
      integer igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,n,m
      integer ipr
      logical grpeql
      character*80 sout
      data e /1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0/, ae/0d0,0d0,0d0/

cChangenglob      stdo = nglob('stdo')
c      stdo = globalvariables%stdo
      call getpr(ipr)
      sout = ' '
      call grpcop(e,symops)
      if (ng .lt. 1) ng = 1
      do  80  igen = 1, ngen
        call grpcop(gen(1,igen),sig)
C ---   Extend the group by all products with sig ---
        do  9  ig = 1, ng
          if (grpeql(symops(1,ig),sig) .and. ipr .gt. 30)
     .    call awrit2(' Generator %i already in group as element %i',
     .    ' ',80,stdo,igen,ig)
          if (grpeql(symops(1,ig),sig)) goto 80
    9   continue

C ---   Determine order ---
        call grpcop(sig,h)
        do  1  itry = 1, 100
          iord = itry
          if (grpeql(h,e)) goto 2
          call grpprd(sig,h,h)
    1   continue
C --- Products of type  g1 sig**p g2 ---
    2   nnow = ng
        if(ipr .ge. 40) call awrit2('%a  %i is %i,',sout,80,0,igen,iord)
        do  8  j = 1, ng
          call grpcop(symops(1,j),h)
          do  10  ip = 1, iord-1
C ... h = sig**ip
            call grpprd(sig,h,h)
            do  11  i = 1, ng
C ... hh = symops_i sig**ip
              call grpprd(symops(1,i),h,hh)
              do  12  k = 1, nnow
                if ( grpeql(symops(1,k),hh) ) goto 11
   12         continue
              nnow = nnow+1
              if (nnow .gt. ngmx) goto 99
              call grpcop(hh,symops(1,nnow))
C              print 333, (symops(k,nnow), k=1,9), nnow
C  333         format(9f12.6,i3)
   11       continue
   10     continue
          if (j .eq. 1) n2 = nnow
    8   continue

C --- Products with more than one sandwiched sigma-factor ---
        m1 = ng+1
        m2 = nnow
        do  20  i = 2, 50
          do  121  n = ng+1, n2
          do  21  m = m1, m2
            call grpprd(symops(1,n),symops(1,m),h)
            do  22  k = 1, nnow
              if (grpeql(symops(1,k),h)) goto 21
   22       continue
            nnow = nnow+1
            if (nnow .gt. ngmx) goto 99
            call grpcop(h,symops(1,nnow))
   21     continue
  121     continue
          if (m2 .eq. nnow) goto 25
          m1 = m2 + 1
          m2 = nnow
   20   continue
   25   continue
        ng = nnow
   80 continue

C --- Printout ---
      if (ipr .ge. 30) then
        if (sout .ne. ' ' .and. ipr .ge. 60) call awrit0
     .  (' Order of generator'//sout//'%a%b',' ',80,stdo)
        call awrit2(' GRPGEN: %i symmetry operations from %i '//
     .  'generator(s)',' ',80,stdo,ng,ngen)
      endif
      if (ipr .ge. 80 .and. ng .gt. 1) then
        write(stdo,'('' ig  group op'')')
        do  60  ig = 1, ng
          call asymop(symops(1,ig),ae,' ',sout)
          write(stdo,'(i4,2x,a)') ig,sout(1:35)
   60   continue
      endif

C      if (ipr .ge. 110) then
C        print *, 'group operations:'
C        call ywrm(0,' ',1,i1mach(2),'(5f12.6)',symops,1,9,9,ng)
C      endif
      return
   99 call rx('GRPGEN: too many elements')
      end
      subroutine grpcop(g,h)
C- Copy matrix
C     implicit none
      double precision h(9),g(9)
      integer i
      do  10  i = 1, 9
        h(i) = g(i)
   10 continue
      end
     
      subroutine grpprd(g1,g2,g1xg2)
C- Returns the product of two point group operations
C     implicit none
      double precision g1(3,3),g2(3,3),g1xg2(3,3),h(3,3),sum
      integer i,j,k
      do   i = 1, 3
      do    j = 1, 3
        sum = 0d0
        do  11  k = 1, 3
          sum = sum + g1(i,k)*g2(k,j)
   11   continue
        h(i,j) = sum
      enddo
      enddo
      do   j = 1, 3
      do   i = 1, 3
        g1xg2(i,j) = h(i,j)
      enddo
      enddo
      end
!! -------------------------------------
      subroutine psymop(t,plat,g,ag,ng)
C- Parse symbolic representation of symmetry group operations
C ----------------------------------------------------------------------
Ci Inputs:
Ci   t,nt  string of symmetry operations, separated by spaces
Ci   plat  lattice vectors that scale translation part ag
Ci         (if needed, i.e. if translation specified by '::')
Co Outputs:
Co   g,ng  group op (3x3 matrix) for each input, and number
Cr Remarks:
Cr   Symbols have two parts, first the point group part, followed
Cr   By an optional translation.  The point group part has the form
Cr   O(nx,ny,nz) where O is one of M, I or Rj for mirror, inversion
Cr   and j-fold rotations, respectively, and nx,ny,nz are a triplet
Cr   of indices specifying the axis of operation.
Cr   (nx,ny,nz) is one of (1,0,0), (0,1,0), (0,0,1) and (1,1,1),
Cr   it can be abbreviated as x,X, y,Y, z,Z and d,D, respectively.
Cr   Also permissible are products, eg I*R4X.
Cr   The translation is also of the form (n1,n2,n3)
Cr   Example: the following input
Cr     R3D(0,0,0) Mx R2(1/2,sqrt(3)/2,0)(pi,0,0) my*i'
Cr   is nonsensical, but permissible and generates four group ops.
Cr   10 Jan 1997 now generates g=transpose of prior versions.
C ----------------------------------------------------------------------
C     implicit none
      character*(*) t
      double precision plat(3,3),g(9,1),h(9),hh(9),ag(3,1),vec(3)
      integer nt,ng,i
      logical parsvc,flgp
      character*1:: leftp='('
C --- Do until no more symbolic representation, do ---
      nt = len(t)
      ng = 0
      i = 0
   90 call skipbl(t,nt,i)
      if (i .ge. nt) return
      ng = ng+1
      call parsop(t,i,g(1,ng))
      if (t(i+1:i+1) .eq. '*') then
        i = i+1
        call parsop(t,i,h)
        call grpprd(g(1,ng),h,hh)
C       call dmpy(g(1,ng),3,1,h,3,1,hh,3,1,3,3,3)
C       call dvcpy(hh,1,g(1,ng),1,9)
        call dcopy(9,hh,1,g(1,ng),1)
      endif
      call dpzero(ag(1,ng),3)
C ... Compatibility with old :T(x,y,z)
      if (t(i+1:i+2) .eq. ':T' .or. t(i+1:i+2) .eq. ':t') i=i+2
C ... Compatibility with ::(x,y,z)
      flgp = .false.
      if (t(i+1:i+2) .eq. '::') then
        flgp = .true.
        i=i+2
      elseif (t(i+1:i+1) .eq. ':') then
        i=i+1
      endif
      if (t(i+1:i+1) .eq. leftp) then
        if (.not. parsvc(-1,t,i,ag(1,ng)))
     .  call fexit(-1,111,' Exit -1 PSYMOP: '//
     .  'failed to parse translation, ig=%i',ng)
        if (flgp) then
          call dcopy(3,ag(1,ng),1,vec,1)
          call grpop(vec,ag(1,ng),plat,1)
C         call dgemm('N','N',3,1,3,1d0,plat,3,vec,3,0d0,ag(1,ng),3)
        endif
      endif
      goto 90
      end
      subroutine parsop(t,i,a)
C- Parse string for a point group operator
      double precision v(3),sp,c,s,pi2,a(3,3),ddot
      character*1 t(0:*)
      logical parsvc
      integer i,j,k,nrot,iii
      pi2 = 8*datan(1d0)
      if (t(i) .eq. 'r' .or. t(i) .eq. 'R') then
        i = i+1
        read(t(i),'(i1)',err=99) nrot
        i = i+1
        if (.not. parsvc(-1,t,i,v)) goto 99
        sp = ddot(3,v,1,v,1)
        sp = 1d0/dsqrt(sp)
        do  14  k = 1, 3
          v(k) = v(k)*sp
   14   continue
        c = dcos(pi2/nrot)
        s = dsin(pi2/nrot)
        do  16  k = 1, 3
          do  15  j = 1, 3
            a(k,j) = (1-c)*v(j)*v(k)
   15     continue
          a(k,k) = a(k,k) + c
   16   continue
        a(2,1) = a(2,1) + s*v(3)
        a(1,3) = a(1,3) + s*v(2)
        a(3,2) = a(3,2) + s*v(1)
        a(1,2) = a(1,2) - s*v(3)
        a(3,1) = a(3,1) - s*v(2)
        a(2,3) = a(2,3) - s*v(1)
      else if (t(i) .eq. 'm' .or. t(i) .eq. 'M') then
        i = i+1
        if (.not. parsvc(-1,t,i,v)) goto 99
        sp = ddot(3,v,1,v,1)
        do  11  j = 1, 3
          do  12  k = 1, 3
            a(j,k) = -2.d0*v(k)*v(j)/sp
   12     continue
          a(j,j) = a(j,j) + 1d0
   11   continue
      else if (t(i) .eq. 'i' .or. t(i) .eq. 'I') then
        i = i+1
C       call dvcpy(0d0,0,a,1,9)
C       call dvcpy(-1d0,0,a,4,3)
        call dpzero(a,9)
        a(1,1) = -1
        a(2,2) = -1
        a(3,3) = -1
      else if (t(i) .eq. 'e' .or. t(i) .eq. 'E') then
        i = i+1
C       call dvcpy(0d0,0,a,1,9)
C       call dvcpy(-1d0,0,a,4,3)
        call dpzero(a,9)
        a(1,1) = 1
        a(2,2) = 1
        a(3,3) = 1
      else
        goto 99
      endif
      return
   99 print *, 'PARSOP: parse error at ',(t(iii),iii = 0,i),'  ...'
      call fexit(-1,119,' ',0)
      end
!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss      
      subroutine symlat(platcp,ngrp,grp,isym)
C- Generates the (point) symmetry operations of the lattice
C ----------------------------------------------------------------------
Ci Inputs:
Ci   platcp:lattice vectors of most compact primitive unit cell
Co Outputs:
Co   ngrp  :number of allowed symmetry operations
Co   grp   :symmetry operation matrix
Co   isym  :index to lattice type, calculated from ngrp:
Co          ngrp   isym    name
Co                  0     shouldn't happen
Co            2     1     triclinic
Co            4     2     monoclinic
Co            8     3     orthorhombic
Co           16     4     tetragonal
Co           12     5     rhombohedral
Co           24     6     hexagonal
Co           48     7     cubic
Cr Remarks:
Cr   symlat analyzes the primitive translations of the bravais
Cr   lattice in order to supply the symmetry operations of the lattice.
Cr   It gives the number ngrp of allowed operations as well as
Cr   these operations themselves.
C ----------------------------------------------------------------------
      implicit none
      integer ngrp,isym
      double precision platcp(3,3),grp(9,*)
      integer i,iprint,ltmax,ll1,lgunit,m,m1,m2,m3,mm,nrot(4)
      parameter(ltmax=3,ll1=ltmax*2+1)
      double precision platt(9),qlatcp(3,3),mat(9),vecg(3),vol
      logical latvec,lirr
      character*12 csym1(0:7)
      data nrot /2,3,4,6/
      data csym1 /'indefinite','triclinic','monoclinic','orthorhombic',
     .'tetragonal','rhombohedral','hexagonal','cubic'/
      mm(i,m) = ltmax-(mod(i,ll1**m)-mod(i,ll1**(m-1)))/ll1**(m-1)
      call dinv33(platcp,1,qlatcp,vol)
C --- Start out with E and I ---
      ngrp = 2
      call csymop(-1,grp(1,1),.false.,1,[0d0,0d0,0d0])
      call csymop(-1,grp(1,2), .true.,1,[0d0,0d0,0d0])
C --- Find all possible rotation axes ---
      do  10  i = 0, (ll1**3-1)/2-1
        m1 = mm(i,1)
        m2 = mm(i,2)
        m3 = mm(i,3)
        lirr = .true.
        do  12  m = 2, ll1
          lirr = lirr.and.(mod(m1,m).ne.0.or.mod(m2,m).ne.0.or.
     .    mod(m3,m).ne.0)
   12   continue
        if (lirr) then
          do  14  m = 1, 3
            vecg(m) = m1*platcp(m,1) + m2*platcp(m,2) + m3*platcp(m,3)
   14     continue

          do  16  m = 1, 4
C       ... Matrix for this symmetry operation
            call csymop(-1,mat,.false.,nrot(m),vecg)
            call grpprd(mat,platcp,platt)
C           call dmpy(mat,3,1,platcp,3,1,platt,3,1,3,3,3)
C       ... Add it and i*symop, if allowed
            if (latvec(3,1d-5,qlatcp,platt)) then
              call csymop(-1,grp(1,ngrp+1),.false.,nrot(m),vecg)
              call csymop(-1,grp(1,ngrp+2),.true. ,nrot(m),vecg)
              ngrp = ngrp+2
              if (m .ne. 1) then
                call csymop(-1,grp(1,ngrp+1),.false.,-nrot(m),vecg)
                call csymop(-1,grp(1,ngrp+2),.true. ,-nrot(m),vecg)
                ngrp = ngrp+2
              endif
            endif
   16     continue
        endif
   10 continue
      isym = 0
      if (ngrp .eq. 2) isym=1
      if (ngrp .eq. 4) isym=2
      if (ngrp .eq. 8) isym=3
      if (ngrp .eq.16) isym=4
      if (ngrp .eq.12) isym=5
      if (ngrp .eq.24) isym=6
      if (ngrp .eq.48) isym=7
      if (iprint() .ge. 30) call awrit1(' SYMLAT: Bravais system is '
     .//csym1(isym)//'%a with %i symmetry operations.',' ',80,lgunit(1),ngrp)
      end
!ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss!
      subroutine symcry(tol,bas,bast,ipc,nbas,nclass,nrclas,
     .ng,plat,qlat,g,ag,istab)
C- Generates the symmetry ops of the crystal from those of the lattice
C ----------------------------------------------------------------------
Ci Inputs:
Ci   tol:   tol for which atoms are considered to be at the same site
Ci          use 0 for symtbl to pick internal default
Ci   bas   :basis vectors (scaled by alat)
Ci   ipc   :the jth atom belongs to class ipc(j)
Ci   nbas  :number of atoms in the basis
Ci   nclass:number of classes, atoms in same class are symmetry-related
Ci   nrclas:number of atoms in the ith class
Ci   plat  :primitive lattice vectors (scaled by alat)
Ci   qlat  :primitive translation vectors in reciprocal space
Ci   bast  :work array of same dimension as bas
Cio Inputs/Outputs:
Cio  ng    :number of allowed symmetry operations (see Remarks)
Cio         on input  number of symmetry operations of the lattice
Cio         on output number of symmetry operations of the crystal
Cio  g     :symmetry operation matrices
Co Outputs:
Co   ag    :symmetry operation vector
Co   istab :site ib is transformed into istab(ib,ig) by operation ig
Cr Remarks:
Cr   symcry finds the subset of the allowed ng point operations of the
Cr   lattice without a basis (see symlat.f) that are valid for
Cr   the crystal.
Cr
Cr   This routine is based on ATFTMT written by Worlton and Warren,
Cr   CPC 3, 88 (1972).
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer nbas,ng,ipc(nbas),nclass,istab(nbas,ng),nrclas(nclass)
      double precision plat(9,*),qlat(*),bas(3,*),bast(3,*),
     .g(9,*),ag(3,*),tol
C Local parameters:
      integer ibas,ic,iclbsj,icmin,ig,ipr,jbas,kbas,kc,
     .lgunit,m,mbas,nj,nm,ng0,stdo
C     integer mode(3)
      double precision dbas(3),tol0,tol1
      parameter (tol0=1d-5)
      logical latvec
      character sg*35

      call getpr(ipr)
      stdo = lgunit(1)
      tol1 = tol
      if (tol .eq. 0) tol1 = tol0

C --- Find the class with minimum number of atoms ---
      icmin = 1
      do  5  ic = 1, nclass
        if (nrclas(ic).lt.nrclas(icmin) .and. nrclas(ic).gt.0) icmin = ic
    5 continue
      ibas = iclbsj(icmin,ipc,nbas,1)

C --- For each group op, see whether it only shifts basis by some T ---
      ng0 = ng
      ng = 0
      do  30  ig = 1, ng0
C   ... Rotate the basis by g
        call dmpy(g(1,ig),3,1,bas,3,1,bast,3,1,3,nbas,3)
        do  20  nj = 1, nrclas(icmin)
          jbas = iclbsj(icmin,ipc,nbas,nj)
C     ... This is a candidate for translation ag
          do  22  m = 1, 3
            ag(m,ng+1) = bas(m,jbas)-bast(m,ibas)
   22     continue
          call shorbz(ag(1,ng+1),ag(1,ng+1),plat,qlat)
C          mode(1) = 2
C          mode(2) = 2
C          mode(3) = 2
C          call shorps(1,plat,mode,ag(1,ng+1),ag(1,ng+1))
C     ... See whether candidate works for all sites; also make istab
          do  10  kbas = 1, nbas
            kc = ipc(kbas)
            do  12  nm = 1, nrclas(kc)
              mbas = iclbsj(kc,ipc,nbas,nm)
              do  14  m = 1,3
                dbas(m) = bas(m,mbas)-bast(m,kbas)-ag(m,ng+1)
   14         continue
              if (latvec(1,tol1,qlat,dbas)) then
                istab(kbas,ng+1) = mbas
                goto 10
              endif
   12       continue
C       ... Candidate not valid
            if (ipr .ge. 90) then
              call asymop(g(1,ig),ag(1,ng+1),' ',sg)
              call awrit1(' symcry: excluded candidate ig=%,2i  '//sg
     .        //'%a',' ',80,stdo,ig)
            endif
            goto 20
   10     continue

C     --- Valid ag found; add g to list ---
          ng = ng+1
          if (ig .gt. ng) call dcopy(9,g(1,ig),1,g(1,ng),1)
          if (ipr .ge. 70) then
            call asymop(g(1,ng),ag(1,ng),' ',sg)
            call awrit1(' symcry: accepted candidate ig=%,2i  '//sg
     .      //'%a',' ',80,stdo,ig)
          endif
          goto 30
   20   continue
   30 continue
      if (ipr .ge. 30) call awrit2(' SYMCRY: crystal invariant under '//
     .'%i symmetry operations for tol=%;3g',' ',80,stdo,ng,tol1)
      if (ipr .ge. 60 .and. ng .gt. 1) then
        write(stdo,'('' ig  group op'')')
        do  60  ig = 1, ng
          call asymop(g(1,ig),ag(1,ig),' ',sg)
          write(stdo,'(i4,2x,a)') ig,sg
   60   continue
      endif
      end
!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss 
      subroutine asymop(grp,ag,asep,sg)
C- Generate the symbolic representation of a group operation
C ----------------------------------------------------------------------
Ci Inputs:
Ci  grp,ag :  space group rotation + translation matrix
Ci  asep:     If first character is 'f', rot. and trans. vectors
Ci            are not converted into small algebraic expressions.
Ci            If first char. is 'f', The second-* character are
Ci            used for the separators.
Co Outputs:
Co  sg  :  symbolic representation of group op
Cb Bugs
Cb  No check is made on the length of sg
C ----------------------------------------------------------------------
C     implicit none
      double precision grp(3,3),ag(3)
      character*(*) sg,asep
C Local variables
      double precision vecg(3),dasum,tiny
      integer nrot,ip,isw,awrite,i1,i2,fmtv
      logical li,parsvc
      parameter(tiny=1d-4)
C --- Get consitutents of grp ---
      call csymop(1,grp,li,nrot,vecg)
C --- Rotational part ---
      i1 = 1
      fmtv = 0
      if (asep(1:1) .eq. 'f') then
        fmtv = 4
        i1 = 2
      endif
      sg = ' '
      if (nrot .eq. 1) then
        sg = 'i*i'
        ip = 3
        if (li) sg = 'i'
        if (li) ip = 1
      else
        if (li .and. nrot .eq. 2) then
          sg = 'm'
          ip = 1
        else
          ip = awrite('%?#n#i*##r%i',sg,len(sg),0,isw(li),nrot,
     .    0,0,0,0,0,0)
        endif
        call rxx(.not. parsvc(2+fmtv,sg,ip,vecg),'bug in asymop')
      endif
C --- Translational part ---
      if (dasum(3,ag,1) .gt. tiny) then
        if (asep(i1:i1) .ne. ' ') then
          call nword(asep,1,i1,i2)
          sg(ip+1:) = asep(i1:i2)
          ip = ip+i2-i1+1
        endif
        call rxx(.not. parsvc(1+fmtv,sg,ip,ag),'bug in asymop')
      endif
      end
!!ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      subroutine csymop(iopt,grp,li,nrot,vecg)
C- Decomposes a group operation into its consitutents, or vice-versa
C ----------------------------------------------------------------------
Ci Inputs:
Ci   iopt  := -1 to convert (nrot,vecg,li) to grp
Ci          =  1 to convert grp to to (nrot,vecg,li)
Co Inputs/Outputs:
Cio grp   :group operation matrix
Cio li    :if T: inversion or rotoinversion
Cio nrot  :rotation angle = 2*pi/nrot
Cio vecg  :rotation axis
Cr Remarks
Cr   for nrot > 2 the matrix is non-symmetric and the rotation
Cr   axis can be calculated from the antisymmetric part.
Cr   For nrot = 2 this not possible.  However, the squared vector
Cr   components are given by:  mat(i,i) = 2 v_i * v_i - 1.
Cr   This is used for the largest component. The others are taken
Cr   from: mat(i,j) = 2 v_i * v_j for i ne j.  This way we also
Cr   get the right phases between the components.
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer nrot,iopt
      double precision vecg(3),grp(3,3)
      logical li
C Local parameters:
      integer i,idamax,j,in
      double precision costbn,detop,ddet33,dnrm2,sinpb3,tiny,twopi,vfac,
     .wk(9),sintbn,omcos,ddot
      parameter(tiny=1d-5)
C External calls:
      external daxpy,dcopy,ddet33,dpzero,dnrm2,dscal,idamax,ddot

      twopi = 8*datan(1d0)
C --- Make grp from (nrot,vecg,li) ---
      if (iopt .eq. -1) then
        call dpzero(grp,9)
        in = iabs(nrot)
        if (in.le.0.or.in.eq.5.or.in.gt.6)
     .  call fexit(-1,111,'%N Exit -1 CSYMOP: '//
     .  'abs(nrot) must 1,2,3,4 or 6, but is %i',in)
        if (in .eq. 1) then
          call dcopy(3,1d0,0,grp,4)
        else
          sintbn = dsin(twopi/nrot)
          costbn = dcos(twopi/nrot)
          omcos  = 1d0-costbn
          call rxx(dnrm2(3,vecg,1).lt.tiny,
     .    'CSYMOP: zero rotation vector')
          call dscal(3,1/sqrt(ddot(3,vecg,1,vecg,1)),vecg,1)
          grp(1,1) = omcos*vecg(1)*vecg(1) + costbn
          grp(1,2) = omcos*vecg(1)*vecg(2) - sintbn*vecg(3)
          grp(1,3) = omcos*vecg(1)*vecg(3) + sintbn*vecg(2)
          grp(2,1) = omcos*vecg(2)*vecg(1) + sintbn*vecg(3)
          grp(2,2) = omcos*vecg(2)*vecg(2) + costbn
          grp(2,3) = omcos*vecg(2)*vecg(3) - sintbn*vecg(1)
          grp(3,1) = omcos*vecg(3)*vecg(1) - sintbn*vecg(2)
          grp(3,2) = omcos*vecg(3)*vecg(2) + sintbn*vecg(1)
          grp(3,3) = omcos*vecg(3)*vecg(3) + costbn
        endif
        if (li) call dscal(9,-1d0,grp(1,1),1)
C --- Make (nrot,vecg,li) from grp ---
      else if (iopt .eq. 1) then
C ... Require |determinant=1|
        call dinv33(grp,0,wk,detop)
        if (dabs(dabs(detop)-1.0d0) .gt. tiny)
     .  call fexit(-1,111,'%N Exit -1 ASYMOP: '//
     .  'determinant of group op must be +/- 1, but is %d',detop)
        detop = dsign(1.d0,detop)
C   ... li is T if to multiply by inversion
        li = detop .lt. 0d0
C   ... Multiply operation grp with detop to guarantee pure rotation
        call dscal(9,detop,grp(1,1),1)
C   --- Calculate rotation angle from the normalization of v ---
C       sum_i grp(i,i) = sum_i (1-cos) v_i*v_i + 3*cos = 1 + 2 * cos
C       costbn = -0.5d0
C       call daxpy(3,0.5d0,grp(1,1),4,costbn,0)
        costbn = 0.5d0*(-1 + grp(1,1) + grp(2,2) + grp(3,3))

        if (dabs(costbn-1d0) .lt. tiny) then
          nrot = 1
          call dpzero(vecg,3)
        else
C     ... See Remarks
          nrot = idnint(twopi/dacos(dmax1(-1d0,costbn)))
          if (nrot .eq. 2) then
            do  10  i = 1, 3
              vecg(i) = 0.5d0*(grp(i,i)+1.0d0)
   10       continue
            j = idamax(3,vecg,1)
            if (vecg(j) .lt. 0d0)
     .      call fexit2(-1,111,' Exit -1 ASYMOP:  bad component %i'//
     .      ' of operation.  Diagonal element = %d',j,grp(j,j))
            vecg(j) = dsqrt(vecg(j))
            vfac = 0.5d0/vecg(j)
            do  12  i = 1, 3
              if (i .ne. j) vecg(i) = vfac*grp(i,j)
   12       continue
          else
            vecg(1) = grp(3,2)-grp(2,3)
            vecg(2) = grp(1,3)-grp(3,1)
            vecg(3) = grp(2,1)-grp(1,2)
          endif

C     --- Renormalize at least one component to 1 ---
C         to allow for abbreviations as 'D', 'X', 'Y' or 'Z'
          sinpb3 = dsqrt(.75d0)
          if (dabs((sinpb3-dabs(vecg(1)))*(sinpb3-dabs(vecg(2)))*
     .    (sinpb3-dabs(vecg(3)))) .gt. tiny) then
            do  20  j = 3, 1,-1
              vfac = dabs(vecg(j))
              if(vfac .gt. tiny) call dscal(3,1.d0/vfac,vecg,1)
   20       continue
          endif
        endif
        call dscal(9,detop,grp(1,1),1)
      endif
      end
!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      subroutine symtbl(mode,tol,nbas,ipc,pos,g,ag,ng,qlat,istab)
C- Make symmetry transformation table for posis atoms; check classes
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :1st digit
Ci         :0  site ib is transformed into istab(ib,ig) by grp op ig
Ci         :1  site istab(i,ig) is transformed into site i by grp op ig
Ci         :   (NB: old routine gpfndx used this convention)
Ci         :10s digit
Ci         :1  check atom classes
Ci   tol   :tol for which atoms are considered to be at the same site
Ci         :use 0 for symtbl to pick internal default
Ci   nbas  :size of basis
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci   pos   :pos(i,j) are Cartesian coordinates of jth atom in basis
Ci   g     :point group operations
Ci   ag    :translation part of space group
Ci   ng    :number of group operations
Ci   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
Co Outputs
Co   istab :table of site permutations for each group op; see mode
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters
      integer nbas,ng,mode
      integer ipc(1),istab(nbas,1)
      double precision pos(3,1),g(9,1),ag(3,1),qlat(9),tol
C Local variables
      integer ib,ic,ig,jb,jc,mode1,mode10 !,oiwk
      double precision tol0,tol1
      character(200)::aaa
      parameter (tol0=1d-5)
      integer,allocatable:: w_oiwk(:)
      if (ng .eq. 0) return
      mode1 = mod(mode,10)
      mode10 = mod(mode/10,10)
      tol1 = tol
      if (tol .eq. 0) tol1 = tol0
C     --- Make atom transformation table ---
      do  20  ig = 1, ng
        do  10  ib = 1, nbas
          call grpfnd(tol1,g,ag,ig,pos,nbas,qlat,ib,jb)
          if (jb .eq. 0) then
c     .    call fexit2(-1,111,' Exit -1 SYMTBL: no map for atom '//
c     .    'ib=%i, ig=%i',ib,ig)
            write(aaa,"('SYMTBL: no map for atom ib=',i0,' ig=',i0)") ib,ig
            call rx(aaa)
          endif
          if (mode10 .ne. 0) then
            ic = ipc(ib)
            jc = ipc(jb)
            if (ic .ne. jc) then
               write(aaa,"('SYMTBL: site ',i0,' not in same class as mapped site ',i0,', ig=',i0)")
     &              ib,jb,ig
               call rx(aaa)
c               call fexit3(-1,111,' Exit -1 SYMTBL: '//
c     .      'site %i not in same class as mapped site %i, ig=%i',
c     .      ib,jb,ig)
           endif    
          endif
          if (mode1 .eq. 0) then
            istab(ib,ig) = jb
          else
            istab(jb,ig) = ib
          endif
   10   continue
   20 continue
      if (mode10 .eq. 0) return
C --- Check atom classes ---
      allocate(w_oiwk(nbas))
      do  50  ib = 1, nbas
        ic = ipc(ib)
        w_oiwk=0
        do  30  ig = 1, ng
          w_oiwk(istab(ib,ig)) = 1
   30   continue
        do  40  jb = 1, nbas
          if (w_oiwk(jb) .eq. 1) goto 40
          jc = ipc(jb)
          if (ic .eq. jc) call fexit2(-1,111,' Exit -1 SYMTBL:  '//
     .    'site ib=%i in same class as inequivalent site jb=%i',ib,jb)
   40   continue
   50 continue
      deallocate(w_oiwk)
      end

      subroutine istbpm(istab,nbas,ng,istab2)
C- Makes inverse of istab
      integer nbas,ng
      integer istab(nbas,ng),istab2(nbas,ng)
      integer ib,ig,ibp
      do  ig = 1, ng
        do  ib = 1, nbas
          ibp = istab(ib,ig)
          istab2(ibp,ig) = ib
        enddo
      enddo
      end
     
      end module m_mksym_util

!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      subroutine grpfnd(tol,g,ag,ig,pos,nbas,qlat,ia,ja)
C- Find index to site ja site into which g,ag transforms site ia
C ----------------------------------------------------------------------
Ci Inputs
Ci   tol   :tolerance in site positions
Ci   g     :rotation part of space group
Ci   ag    :translation part of space group
Ci   ig    :which group operation
Ci   pos   :basis vectors
Ci   nbas  :size of basis
Ci   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
Ci   ia    :site for which to find equivalent by group op (g,ag)
Ci         :If ia<0, absolute value of ia is used and additionally
Ci         :point group operation -g is used.
Co Outputs
Co   ja    :site that ia is transformed into by (g,ag)
Co         :i.e. R(ja) = g(ig) R(ia) + ag(ig)
Co         :if zero, no equivalent site was found.
Cu Updates
Cu   26 Jan 01  Add ability to operate with -g (ia<0)
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters
      integer ia,ja,ig
      double precision g(3,3,ig),ag(3,ig),pos(3,1),qlat(3,3),tol
C Local parameters
      double precision d(3),d2(3)
      logical latvec
      integer ka,nbas,m,k
      ka = iabs(ia)
      do    m = 1, 3
        d(m) = ag(m,ig)
      do    k = 1, 3
         d(m) = d(m) + g(m,k,ig)*pos(k,ka)
      enddo
      enddo
      if (ia .lt. 0) call dscal(3,-1d0,d,1)

      ja = 0
      do  10  ka = 1, nbas
        d2(1) = d(1) - pos(1,ka)
        d2(2) = d(2) - pos(2,ka)
        d2(3) = d(3) - pos(3,ka)
        if (latvec(1,tol,qlat,d2)) then
          ja = ka
          return
        endif
   10 continue
      end
      
!ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
      logical function spgeql(mode,g1,a1,g2,a2,qb)
C- Determines whether space group op g1 is equal to g2
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0 -> space group is compared
Ci         :1 -> only point group is compared
Ci   g1,a1 :first space group
Ci   g2,a2 :second space group
Ci   qb    :reciprocal lattice vectors
Cu Updates
C ----------------------------------------------------------------------
      implicit none
      integer mode
      double precision g1(9),g2(9),a1(3),a2(3),qb(3,3)
      integer m,iq,iac
      double precision c,ca,dc
      spgeql=.true.
      do 10 m=1,9
        if (dabs(g1(m)-g2(m)).gt.1.d-5) then
          spgeql=.false.
          return
        endif
  10  continue
      if (mode .eq. 1) return
      do 20 iq=1,3
        c=(a1(1)-a2(1))*qb(1,iq)+(a1(2)-a2(2))*qb(2,iq) +(a1(3)-a2(3))*qb(3,iq)
        ca=dabs(c)
        iac=ca+0.5d0
        dc=ca-iac
        if (dabs(dc).gt.1.d-5) then
          spgeql=.false.
          return
        endif
  20  continue
      return
      end
!sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss      
      logical function grpeql(g1,g2)
C- Checks if G1 is equal to G2
C     implicit none
      double precision g1(9),g2(9),dabs,tol,x1,x2
      parameter (tol = 1d-8)
      logical ddif
      integer i
      ddif(x1,x2) = dabs(x1-x2) .gt. tol
      grpeql = .false.
      do  10  i = 1, 9
        if (ddif(g1(i),g2(i))) return
   10 continue
      grpeql = .true.
      end
