c$$$      integer function rdtok(token,instr,descr,sep0,sep,cast,swt,
c$$$     .n1,count,resn,resc)
c$$$C- Seek a token within a string and read associated data into array
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   token: string marking data to follow token
c$$$Ci   instr: string in which to seek token
c$$$Ci   descr: descriptor string composed of one or more parts.
c$$$Ci        : It is used to format printouts generated by rdtok,
c$$$Ci        : in 'print' modes
c$$$Ci        :*The first part, if present, is a formatting string
c$$$Ci        : for writing the contents of a token, awrite conventions
c$$$Ci        : It is delimited by a double-colon, e.g.
c$$$Ci        :    descr = '%;6d,,string-for-remaining-parts'
c$$$Ci        : The format statement is used when the token's contents
c$$$Ci        : are written out (swt(5)>2, below).  A default format
c$$$Ci        : is used if one is not supplied
c$$$Ci        :*The second part, if present, is a character consisting
c$$$Ci        : of a single digit '0'..'9', and is the number of spaces
c$$$Ci        : to indent before writing the token, in all modes swt(5).
c$$$Ci        : It is delimited by a double-semicolon, e.g.
c$$$Ci        :    descr = '%;6d,,4;;string-for-remaining-part'
c$$$Ci        : If not present, a default indentation of 2 is used.
c$$$Ci        :*The third part, if present, describe the token's purpose.
c$$$Ci        : It is used only for input mode 0 (swt(5)=0).
c$$$Ci        : It consists of any part of the string after the first or
c$$$Ci        : second parts.
c$$$Ci    sep0: the character immediately to the left of the token
c$$$Ci          must be one of the characters in sep0
c$$$Ci    sep:  The token's arguments are delineated by characters in
c$$$Ci       :  this list.
c$$$Ci    cast: data following token is one of the following.
c$$$Ci          cast    class of token
c$$$Ci           0      logical
c$$$Ci           1      char
c$$$Ci           2      int
c$$$Ci           3      real
c$$$Ci           4      double
c$$$Ci        : result is stored into resn for cast=0,2,3,4
c$$$Ci        :           stored into resc for cast=1
c$$$Ci     n1 : Data associated with token are put into:
c$$$Ci          resn(n1),resn(n1+1),... for cast=0,2,3,4    and
c$$$Ci          resc(n1),resc(n1+1),... for cast=1
c$$$Ci   count: The number of elements (numbers or strings) to try and parse
c$$$Ci        : It may be permissible to read fewer than `count' elements;
c$$$Ci        : see swt(3)
c$$$Ci Inputs/Outputs
c$$$Cio  swt  : a vector of switches governing how gtcat and rdtok behave.
c$$$Cio       : Its internal structure is described in stswt, below.
c$$$Cio       : User is advised to set these parameters via routine stswt.
c$$$Cio       : and query the state of using quswt; then there is no need
c$$$Cio       : know the internal structure of swt.
c$$$Cio       : As described in detail in stst, quantities that can be set
c$$$Cio       : and probed are the following:
c$$$Cio       : structure of swt.
c$$$Cio       : swt()  function (see stswt)
c$$$Ci        :  1     offset to instr where parsing begins
c$$$Cio       :  2     parse up to this character
c$$$Ci        :  3     governs behavior when token or some data is missing,
c$$$Ci        :        whether tokens are optional or required, if
c$$$Ci        :        there may be multiple occurences of this token, and
c$$$Ci        :        whether number of elements may be less than count.
c$$$Ci        :  5     read and printout mode
c$$$Ci        :        0=> do not attempt to read token but show
c$$$Ci        :            what token would have been sought
c$$$Ci        :        1=> attempt to find token and read contents
c$$$Ci        :        2=> print token name
c$$$Ci        :        3=> combination of 1 and 2
c$$$Ci        :  6     file logical unit for printout
c$$$Co        :  7     index to last character parsed
c$$$Co Outputs
c$$$Co   rtdok: -999   No token was sought
c$$$Co        :   0    No match to token is found
c$$$Co        :   n    token matched and converted sans error n elements
c$$$Co        :        (for count=0, returns 1 if token matched)
c$$$Co        :  -n    if error on conversion of argument n
c$$$Cl Local variables
c$$$Cl   lopt :  0 if token is optional
c$$$Cl        :  1 if token is required
c$$$Cl        :  2 alternate token may be subst.
c$$$Cl        :  3 if token is ignored
c$$$Cb Bugs
c$$$Cb   when n1>0, data not placed in proper location for integer, logical
c$$$Cb   arrays
c$$$Cu Updates
c$$$Cu   06 Nov 01 Initially created
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$C ... Passed parameters
c$$$      integer swt(7),cast,n1,count
c$$$      character*(1) instr(*)
c$$$      character*(*) token,descr,resc(1),sep0,sep
c$$$      double precision resn(1)
c$$$C ... Local parameters
c$$$      logical logval,parstr,l1,l2,lhelp,lshow,lread
c$$$      integer a2vec,awrite,i,ifipr,ifmt,io,ip,is,isave,it(99),ival,k,ks,
c$$$     .linstr,rdtk2,recl,retval,ltok,quswt,lfixl,lopt,lmult,lio
c$$$      parameter (recl=500)
c$$$      character   aa*(recl),prs*(recl)
c$$$      character*8 nmcast(0:4),fmt*20
c$$$      save ip,prs
c$$$      data nmcast /'logical','char','integer','real','double'/
c$$$      data ip /0/
c$$$
c$$$C ... Setup
c$$$      lopt  = quswt('token,opt',swt)
c$$$      if (lopt .eq. 3) then
c$$$        rdtok = -999
c$$$        return
c$$$      endif
c$$$      ifipr = quswt('lunit',swt)
c$$$      ltok = len(token)
c$$$      lhelp = quswt('io,help',swt) .eq. 1
c$$$      lshow = quswt('io,w',swt) .eq. 1
c$$$      lread = quswt('io,r',swt) .eq. 1
c$$$      lio   = quswt('io',swt)
c$$$      lfixl = quswt('token,fixlen',swt)
c$$$      lmult = quswt('token,mult',swt)
c$$$
c$$$C --- Show what token would have been sought ---
c$$$      if (lhelp) then
c$$$
c$$$C       Find indentation, offset to descriptor string
c$$$C       Default indentation
c$$$        ks = 2
c$$$C       Default offset to start of descriptor
c$$$        i = 0
c$$$        if (descr .ne. ' ') then
c$$$C         Strip off first parts, if either exists
c$$$          l2 = parstr(descr,';;',len(descr)-1,2,'a',i,k)
c$$$          if (l2) then
c$$$            ks = ichar(descr(i:i)) - ichar('0')
c$$$          else
c$$$            i = 0
c$$$            l1 = parstr(descr,',,',len(descr)-1,2,'a',i,k)
c$$$            if (.not. l1) i = -2
c$$$          endif
c$$$        endif
c$$$        fmt = ' '
c$$$        is= ltok
c$$$        if (count .eq. 0) then
c$$$          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
c$$$     .    '%a (no arguments; %?#(n==0)#optional#required#)'
c$$$          call awrit1(aa,' ',72,ifipr,lopt)
c$$$        elseif (count .eq. 1) then
c$$$          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
c$$$     .    '%a takes 1 argument of cast '//nmcast(cast)//
c$$$     .    '%a %?#(n==0)#(optional)##%-1j'//
c$$$     .    '%a %?#(n==1)#(required)##%-1j'//
c$$$     .    '%a %?#(n==2)#%N'//fmt(1:ks)//
c$$$     .    '   (choose either this token or the next one)##'
c$$$          call awrit1(aa,' ',128,ifipr,lopt)
c$$$        else
c$$$          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
c$$$     .    '%a takes %?#(n==0)#up to ##'//
c$$$     .    '%i arguments of cast '//nmcast(cast)//
c$$$     .    '%a %?#(n==0)#(optional)##%-1j'//
c$$$     .    '%a %?#(n==1)#(required)##%-1j'//
c$$$     .    '%a %?#(n==2)#%N'//fmt(1:ks)//
c$$$     .    '   (choose either this token or the next one)##'
c$$$          call awrit3(aa,' ',128,ifipr,lfixl,count,lopt)
c$$$        endif
c$$$        if (descr .ne. ' ') then
c$$$          fmt = ' '
c$$$          aa = '   ' // fmt(1:ks) // descr(i+3:)
c$$$          call awrit0(aa,' ',-len(aa),ifipr)
c$$$        endif
c$$$        rdtok = -999
c$$$        ip = 0
c$$$        return
c$$$
c$$$C --- No token to read ---
c$$$      elseif (.not. lread) then
c$$$        retval = -999
c$$$        goto 999
c$$$      endif
c$$$
c$$$C --- Try and find token ---
c$$$      linstr = swt(2)
c$$$      if (token .eq. ' ') then
c$$$        is = swt(1)
c$$$      else
c$$$        is = rdtk2(instr,linstr,token,sep0,lopt.eq.1,swt(1))
c$$$      endif
c$$$C ... No token found ... exit
c$$$      if (is .le. 0) then
c$$$        swt(7) = linstr
c$$$        rdtok = 0
c$$$        return
c$$$      endif
c$$$
c$$$C --- Parse for token arguments ---
c$$$      swt(7) = is
c$$$
c$$$C ... Case count=0
c$$$      if (count .eq. 0) then
c$$$        retval = 1
c$$$        goto 999
c$$$      endif
c$$$
c$$$C ... Case further delimit range of search
c$$$      if (lmult .ne. 0) then
c$$$        ks = rdtk2(instr,linstr,token,sep0,.false.,is)
c$$$        if (ks .gt. 0) linstr = ks-ltok-1
c$$$        swt(2) = linstr
c$$$      endif
c$$$
c$$$C ... Parse for vector of character arguments
c$$$      if (cast .eq. 1) then
c$$$        isave = is - ltok
c$$$        do  i = 1, count
c$$$
c$$$C         Skip past leading blanks
c$$$          is = is-1
c$$$          call skipbl(instr,linstr,is)
c$$$          is = is+1
c$$$
c$$$C         End-of-category encountered before loop over count exhausted
c$$$          if (is .ge. linstr) then
c$$$            if (lfixl .ne. 0) then
c$$$              if (count .eq. 1) then
c$$$                aa = 'Exit -1 rdtok: no string after token '//
c$$$     .          token(1:ltok)
c$$$                call fexit(-1,1,aa,0)
c$$$              else
c$$$                aa = 'Exit -1 rdtok: failed to parse %i strings, token'
c$$$                call strncp(aa,instr,53,isave,min(recl-53,linstr-isave)-1)
c$$$              endif
c$$$              call fexit(-1,1,aa,count)
c$$$            endif
c$$$            retval = -i
c$$$            swt(7) = linstr+1
c$$$            goto 999
c$$$          endif
c$$$
c$$$          call cpstr(instr,linstr,1001,sep,is,io,resc(i+n1-1))
c$$$          is = is+1
c$$$        enddo
c$$$        swt(7) = is-1
c$$$        retval = count
c$$$        goto 999
c$$$      endif
c$$$
c$$$C ... Parse for vector of numerical arguments
c$$$      isave = is - ltok
c$$$      swt(7) = is
c$$$      is = is-1
c$$$      k = a2vec(instr,linstr,is,cast,sep,len(sep),-99,-count,it,
c$$$     .resn(n1))
c$$$      retval = k
c$$$
c$$$C ... a2vec encountered an illegitimate expression
c$$$      if (k .lt. 0) then
c$$$        if (lfixl .ne. 0) then
c$$$          aa = ' Exit -1 rdtok: error parsing expr no %i, token'
c$$$          call strncp(aa,instr,52,isave,min(recl-52,linstr-isave)-1)
c$$$          call fexit(-1,1,aa,-k)
c$$$        endif
c$$$C ... a2vec read fewer than count expressions
c$$$      elseif (k .lt. count) then
c$$$        if (lfixl .ne. 0) then
c$$$          aa = ' Exit -1 rdtok: read only %i of %i values, token'
c$$$          call strncp(aa,instr,52,isave,min(recl-52,linstr-isave)-1)
c$$$          call fexit2(-1,1,aa,k,count)
c$$$        endif
c$$$        retval = -k
c$$$      endif
c$$$
c$$$C --- Cleanup: check for printout ---
c$$$  999 continue
c$$$      rdtok = retval
c$$$      if (.not. lshow) return
c$$$
c$$$C     Find format, if supplied, and indentation
c$$$C     Default indentation
c$$$      ks = 2
c$$$      fmt = ' '
c$$$      if (descr .ne. ' ') then
c$$$        i = 0
c$$$        l2 = parstr(descr,';;',len(descr)-1,2,'a',i,k)
c$$$        if (l2) then
c$$$          ks = ichar(descr(i:i)) - ichar('0')
c$$$        endif
c$$$        ifmt = 0
c$$$        l1 = parstr(descr,',,',len(descr)-1,2,'a',ifmt,k)
c$$$        if (l1) fmt = descr(1:ifmt)
c$$$      endif
c$$$
c$$$C ... Write token name to string
c$$$      if (ip .eq. 0) then
c$$$        prs = ' '
c$$$      else
c$$$        ks = min(ks,2)
c$$$      endif
c$$$      ip = ks + ip + awrite(token,prs(ks+ip+1:),128,0,0,0,0,0,0,0,0,0)
c$$$      if (count .eq. 0) then
c$$$C   ... format applied after token write
c$$$C        if (fmt .ne. ' ')
c$$$C     .  ip = awrite(fmt,prs,128,0,0,0,0,0,0,0,0,0)
c$$$        goto 998
c$$$      endif
c$$$
c$$$C ... Write token contents to string, vec of length |retval|
c$$$C     ip = ip+1
c$$$
c$$$C     Number of elements to write
c$$$      k = retval
c$$$      if (retval .lt. 0) k = -retval-1
c$$$      if (lio .eq. 2) k = count
c$$$C     Write the elements
c$$$      do  i = 1, k
c$$$        if (cast .eq. 1) then
c$$$          ip = ip + awrite(resc(n1+i-1),prs(ip+1:),128,
c$$$     .    0,0,0,0,0,0,0,0,0)
c$$$          call skpblb(prs,ip,ip)
c$$$          ip = ip+1
c$$$          if (fmt .ne. ' ')
c$$$     .    ip = awrite(fmt(1:ifmt),prs,128,0,0,0,0,0,0,0,0,0)
c$$$        elseif (cast .eq. 0) then
c$$$          if (fmt .eq. ' ') then
c$$$            fmt = '%l'
c$$$            ifmt = 2
c$$$          endif
c$$$          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,
c$$$     .    logval(resn,n1+i-1),0,0,0,0,0,0,0)
c$$$        elseif (cast .eq. 2) then
c$$$          if (fmt .eq. ' ') then
c$$$            fmt = '%i'
c$$$            ifmt = 2
c$$$          endif
c$$$          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,
c$$$     .    ival(resn,n1+i-1),0,0,0,0,0,0,0)
c$$$        elseif (cast .eq. 4) then
c$$$          if (fmt .eq. ' ') then
c$$$            fmt = '%;10F'
c$$$            ifmt = 5
c$$$          endif
c$$$          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,resn(n1+i-1),
c$$$     .    0,0,0,0,0,0,0)
c$$$        endif
c$$$C       ip = ip+2
c$$$        if (i .lt. k) then
c$$$          if (prs(ip:ip) .ne. sep(1:1)) then
c$$$            ip = ip+1
c$$$            write(prs(ip:ip),'(a)') sep(1:1)
c$$$          endif
c$$$        elseif (retval .lt. 0 .and. lio .ne. 2) then
c$$$          ip = ip+1
c$$$          write(prs(ip:),'(a,''***'')') sep(1:1)
c$$$          ip = ip+3
c$$$        endif
c$$$      enddo
c$$$
c$$$  998 continue
c$$$c     call skpblb(prs,ip,ip)
c$$$C     ip = ip+1
c$$$
c$$$C ... Printout, or just preserve in string prs if ifipr is 0
c$$$      if (ifipr .gt. 0) then
c$$$        write(ifipr,'(a)') prs(1:ip)
c$$$        ip = 0
c$$$      else
c$$$      endif
c$$$
c$$$      end
c$$$
c$$$      integer function rdtk2(instr,linstr,token,sep0,lreqd,i1)
c$$$C- Kernel called by rdtok to find a token
c$$$C ----------------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   instr :string in which to seek token
c$$$Ci   linstr:length of instr
c$$$Ci   token :token
c$$$Ci    sep0 :the character immediately to the left of the token
c$$$Ci         :must be one of the characters in sep0
c$$$Ci   lreqd :T, abort with error if token is not found
c$$$Ci    i1   :start search at i1
c$$$Co Outputs
c$$$Co   rdtk2 :if token found, rdtk2 points to first character past token
c$$$Co         :if no token found, rdtok = -linstr
c$$$Cu Updates
c$$$Cu   02 Nov 01 First created
c$$$C ----------------------------------------------------------------------
c$$$C     implicit none
c$$$C ... Passed parameters
c$$$      logical lreqd
c$$$      integer linstr,i1
c$$$      character*(*) token,sep0
c$$$      character*(1) instr(linstr)
c$$$C ... Local parameters
c$$$      integer ltok,k,iterm,is,lgunit,stderr
c$$$      character ct*1
c$$$
c$$$      ltok = len(token)
c$$$      ct = token
c$$$      stderr = lgunit(2)
c$$$
c$$$C --- Loop over length of string ---
c$$$C     Match by:
c$$$C     1.  First character matches at instr(k)
c$$$C     2.  character to left matches on of sep0
c$$$C     3.  token matches
c$$$      do  k = i1, linstr
c$$$
c$$$        if (instr(k) .eq. ct) then
c$$$          iterm = 1
c$$$          if (k .gt. 1) then
c$$$            is = 0
c$$$            call chrps2(instr(k-1),sep0,len(sep0),0,is,iterm)
c$$$          endif
c$$$          if (iterm .gt. 0) then
c$$$            do  is = 1, ltok
c$$$              if (instr(k+is-1) .ne. token(is:is)) goto 31
c$$$            enddo
c$$$C           A match was found
c$$$            rdtk2 = ltok+k
c$$$            return
c$$$          endif
c$$$        endif
c$$$   31   continue
c$$$      enddo
c$$$C ... We have fallen through the loop, so no token found
c$$$      rdtk2 = -linstr
c$$$      if (lreqd) then
c$$$        write(stderr,'(1x)')
c$$$        call rxs2('rdtok: failed to find token `',token,'''')
c$$$      endif
c$$$      end
c$$$
