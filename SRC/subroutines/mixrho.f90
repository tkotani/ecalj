module m_mixrho !mixing routine of density given by smrho and orho
  use m_lmfinit,only: z_i=>z,nr_i=>nr,rmt_i=>rmt,lmxl_i=>lmxl,spec_a,rg_i=>rg,rsmv_i=>rsmv,nbas
  use m_ll,only:ll
  use m_lgunit,only:stdo,stml !  integer,parameter,public:: kmxv=15
  public:: mixrho
  private
  real(8),parameter::pi = 4d0*datan(1d0), srfpi = dsqrt(4d0*pi)
  logical:: old2023mixing=.true.
contains
  subroutine mixrho(iter, qval,  sv_p_orhnew, sv_p_orho, smrnew, smrho,rmsdel)! Mix old and new charge densities =  Takao's version: real space mixing of smrho. It works OK. However, we may need to fix it so that this is well-defined chi=|rho-f(rho)|**2 minimization mixing.
    use m_struc_def
    use m_supot,only: iv_a_okv,rv_a_ogv,n1,n2,n3
    use m_lmfinit,only:alat=>lat_alat,nbas,stdl,ispec,nsp,broyinit,nmixinit,betainit,killj,wtinit,wc,bexist,mix_nsave
    use m_lattic,only: vol=>lat_vol
    use m_supot,only:  ng=>lat_ng,n1,n2,n3
    use m_ext,only:    sname
    use m_ftox
    implicit none
    !!     Warn. For Co case, I found broyden mixing works wrong.! ITER    NIT=30 MIX=B3,n=5,b=.7,w=1,0 However, as in copt, Broyden mixing is efficient.
    ! i iter
    ! i qval  :total valence charge, used to estimate Lindhard parameter
    ! i Read mixing parameter from m_lmfinit
    ! i   orhnew:On input, local parts of the density that generated the ham. =>DESTROYED on output
    ! i   smrnew:smooth density generated by the H(rhold,smrho)               =>DESTROYED on output
    ! i/o  orho:Local parts of the density that the hamiltonian generated
    !         :On output, the mixed density
    ! i/o  smrho :On input, smooth density that generated the hamiltonian H
    !         :On output mixed smooth density
    ! o Mixing parameters from m_lmfinit
    ! o         : broy  :mixing scheme: 0->Anderson 1->Broyden
    ! o         : beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
    ! o         : wc    :Broyden weights for prior iterations
    ! o         : wt    weights for n^+ + n^- and n^+ - n^- in spin pol cases
    ! o                Avg, diff weighted by wt(1) and wt(2) in the mixing.
    ! o                As special cases,
    ! o                wt(2)=0 freezes the moments and mixes the charge only
    ! o                wt(1)=0 freezes the charge and mixes the moments only
    ! o         : mxsav : maximum number of prior iter to save on disk
    ! o         : mmix  : maximum number of prior iter to mix
    ! o         : nkill : kill mixing file after multiples nkill
    ! o         : betv  : special potential mixing parameter
    ! o         :Outputs
    ! o         : rmsdel : rms (output-input) density
    ! o         : rmsl   : rms (output-input) local density
    ! o         : nmix   : number of prior iter actually mixed
    ! o         : broy   : actual mixing scheme used
    ! o         : beta   : actual mixing beta used
    ! o         : tj  : Anderson mixing coefficients
    ! o         :(25)        : (spin polarized case only)
    ! o                      : 1  if weight for n^+ + n^- is nonzero
    ! o                      : 10 if weight for n^+ - n^- is nonzero
    ! o                      : 11 if both nonzero

    !l Local variables
    !l   locmix=3 :2  Local densities are further mapped onto a G_kL expansion.
    !l          :   whose coefficients are included in the Anderson/Broyden
    !l          :   mixing schemes, including the nonspherical densities.
    !l          :   the residual (what is left of rho beyond the G_kL expansion)  is linearly mixed.
    !l          :   But l=0 part is of the G_kL expansion is projected out.
    !l          :
    !l   rms2   : <(rout-rin)**2>, where rin and rout are the input and
    !l          : screened output densities represented as a vector,
    !l          : including smoothed and local parts.  rmsdel changes with
    !l          : the choice of transformation of local densities;see locmix
    !l          : above.
    !l   rmsdel : (linked to dmxp(11)).
    !l          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
    !l          : On output, rmsdel is overwritten by rms2.
    !l   rms    : RMS difference in output-input sm. density, screened
    !l   kmxr   : k-cutoff for G_kL expansion used to smooth local densities for mixing
    !l   ng0    : condensed number of G vectors. That rho(G) is hermitian is exploited to reduce ng to ng0
    !l   qcell  : cell charge

    !b   Mixing scheme needs some revision.  For now, uses locmix=3 and k9=10
    !b   Problem:  Mark notes that G-kL expansion may be not good enough to represent rim density well; not good for rho1+rho2.
    !    TK fixed a minor bug exp(+(r/rf)**2) looked strange. Probably the rim density problem?
    !
    !  For nonspherical parts, mix coefficient to multipole in the Anderson/Broyden scheme; linearly mix the rest.
    type(s_rv1) :: sv_p_orho(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    character sout*80,fnam*8
    character(20) :: ext
    character(26) :: datim
    character(120) :: strn
    logical::        mixrealsmooth, init=.true., initd=.true. !noelind,
    logical :: mlog!,cmdopt
    integer :: numprocs, ierr
    integer ::isp,nnnx,ng02,ng2, iprint
    integer::  iter,procid,master
    integer :: i,i1,i2,i3,ib,ipl,ipr,is,k0, lmxl,nlml,nr,nmixr,nda,ifi, &
         kkk,nnnew,nnmix,nx,nkill,isw,naa,kmxr,kmxs,locmix,offx,off2,nlmlx,ng0
    integer,save:: broy,nmix,mxsav
    real(8),save:: rmsdelsave,beta
    real(8),save:: wt(2)
    real(8):: smmin,sss,wgtsmooth,qval !elinl
    real(8) :: starttime, endtime
    real(8) :: a,beta0,dif,difx,difxu,fac,rms,rmt,summ,top,tpiba,dquns,ddot,q1,&
         qin(2),qout(2),qscr(2),qcell,rms2,rms2f,rsmv,qmx, rmsdel,xx
    real(8),allocatable :: rofi_rv(:),rwgt_rv(:), wn1_rv(:),wn2_rv(:),co_rv(:,:,:,:)
    real(8),allocatable:: w_oqkl(:), w_oa(:,:,:,:),w_oaa(:), cn_rv(:,:,:,:),rho1bk(:),rho2bk(:)
    complex(8):: smrnew(n1,n2,n3,nsp),smrho(n1,n2,n3,nsp)
    complex(8),allocatable :: cg1_zv(:), cg2_zv(:),fkl_zv(:)
    complex(8),allocatable:: smrnewbk(:,:,:,:),w_owk(:),cn_rvc(:),co_rvc(:)
    include "mpif.h"
    call tcn('mixrho')
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr )
    call getpr(ipr)
    master = 0
    mlog = .false. !cmdopt('--mlog',6,0,strn)
    ipl = 1
    kkk = n1*n2*n3 !    locmix = 3 !original lmv7 by mark. !    kmxs = 3
    kmxr = 8
    if(initd) then
       mxsav = mix_nsave !out 
       rmsdelsave=0d0
       beta=1d0
       initd=.false.
    endif
    rms2 = 0
    fnam = 'mixm' 
    nmix = nmixinit
    broy = broyinit
    if(bexist) beta=betainit
    nkill = max(killj,0) ! Periodic file deletion (nkill):   
    if (nkill>1 .and. mod(iter,nkill) == 0) nkill=-nkill
    if (nkill == 1) nkill=-nkill
    rmsdel = rmsdelsave
    if (nmix == 0) broy = 0
    if (nmix < 0) nmix = mxsav
    call rhoqm(smrho, n1,n2,n3,nsp,vol,qin ) ! ... Initial charges
    call rhoqm(smrnew,n1,n2,n3,nsp,vol,qout)
    fac = vol/(n1*n2*n3)
    rms = sum((smrnew(:,:,:,:)-smrho(:,:,:,:))**2) ! RMS difference. Before 2023-10-8, it is sum of the differenc of charge (not spin density).
    rms = dsqrt(fac*rms/vol)
    !!== elind mode ==> removed
    nlmlx=maxval((lmxl_i+1)**2)
    nda=0
    do ib = 1, nbas
       is = ispec(ib) 
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       nr  =nr_i(is)
       nlml = (lmxl+1)**2
       allocate(rho1bk,source=sv_p_orho(1,ib)%v)
       allocate(rho2bk,source=sv_p_orho(2,ib)%v)
       sv_p_orho(1,ib)%v=rho1bk+rho2bk
       sv_p_orho(2,ib)%v=rho1bk-rho2bk   
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=rho1bk+rho2bk
       sv_p_orhnew(2,ib)%v=rho1bk-rho2bk   
       deallocate(rho1bk,rho2bk) 
       nda = nda + 2*(kmxr+1)*(lmxl+1)**2 + 2*nr_i(is) ! include spherical part of local densities and non-spherical part of rho1-rho2
    enddo          ! if(mixrealsmooth()) then
    ng02 = n1*n2*n3
    ng2 = ng02
    nda = nda + ng02
    wgtsmooth=1d0/ng02**0.5d0 !try this relative weight. Not correct weight charge mixing.
    if(iprint()>10) print *,'wgtsmooth=',wgtsmooth
    allocate(cn_rv(n1,n2,n3,nsp),co_rv(n1,n2,n3,nsp))
    cn_rv= dreal(smrnew)*wgtsmooth 
    co_rv= dreal(smrho)*wgtsmooth 
    allocate(w_oa(nda,nsp,(mxsav+2),2),source=0d0)
    allocate(w_oqkl(2*(kmxr+1)*nlmlx*nsp*4*nbas))
    w_oqkl=0d0
    ! --- 9. Read prior iterations from disk; update with current iter ---
    if (procid==master) open(newunit=ifi,file=trim(fnam)//'.'//trim(sname),form='unformatted')
    call pvmix5(nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx, nsp,sv_p_orho & !Setup mixing array w_oa
        ,sv_p_orhnew,co_rv,cn_rv,ng2,ng02,nda, w_oa,w_oqkl,rms2,nmixr ) !w_oa contains mixingsource
    rmsdel = rms2
    nmix = min(nmix,nmixr)
    WriteThisANDPriorIterationsONTOdisk:block
      integer:: j
      if (procid==master) then
         rewind(ifi)
         write(ifi) min(nmix+1,mxsav), nda*nsp
         do  j = 1, min(nmix+1,mxsav)
            write(ifi)w_oa(:,:,j,1)
            write(ifi)w_oa(:,:,j,2)
         enddo
      endif
    endblock WriteThisANDPriorIterationsONTOdisk
    if (nkill < 0) then
       if(ipr>=20) then
          sout = ' ...  deleting file '//fnam
          write(stdo,"(a,i5)") trim(sout)//" nkill=",nkill
       endif
       if(procid==master) close(ifi,status='delete')
    else
       if(procid==master) close(ifi)
    endif
    call rhoqm(smrnew,n1,n2,n3,nsp,vol,qscr)
    if(ipr >45) then
       write(stdo,"(' charges:',7x,'old',11x,'new',9x,'screened',6x,'rms diff',7x,'lin mix'/' smooth ',5f14.6)")&
            qin(1),qout(1),qscr(1),rms,beta*qscr(1)+(1-beta)*qin(1)
       if(nsp == 2) write(stdo,"(' mmom   ',2f14.6,28x,f14.6)") qin(2),qout(2),beta*qscr(2)+(1-beta)*qin(2)
    endif
    call pvmix3( nbas,nsp,beta,kmxr,nlmlx,w_oqkl,sv_p_orho,sv_p_orhnew,difx ) !Linear mixing of remnants. And take out qkl part
    difxu = difx
    if (nsp == 2) then 
       naa = 0
       wt(1:2)   = wtinit     
       if (nsp == 1) wt(2)=0d0
       if (sum(wt**2)==0d0) call rx('MIXRHO: bad mixing weights wt=0')
       wt= wt/sum(wt**2)**.5 
       if (wt(1) /= 0) naa = naa+nda
       if (wt(2) /= 0) naa = naa+nda
       offx = 0                !offset to extra elements (none now)
       off2 = (nsp-1)*nda      !offset to spin down part of a
       allocate(w_oaa(naa*(mxsav+2)*2),source=0d0)
       call pqsclf(nda*nsp,nda,offx,off2,naa,mxsav,wt, w_oa,w_oaa,rms2f)
       if (wt(1)*wt(2) ==0d0 ) then
          write(stdo,ftox)' Constrained spin mixing wt =',ftof(wt),' Constrained rms DQ=',ftod(rms2f)
          rmsdel = rms2f
       endif
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oaa) !main part of mixing
       call pqsclb(nda*nsp,nda,offx,off2,naa,mxsav,wt,w_oa,w_oaa) !Restore matrix a to rho+, rho===
        w_oa(:,:,1,1)=w_oa(:,:,1,2) 
       deallocate(w_oaa)
    else
       naa = nda
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oa) !main part of mixing
    endif
    call pvmix7(nbas,nsp,nda,w_oa,n1,n2,n3,kmxr,nlmlx,w_oqkl,ng,ng02,iv_a_okv,rv_a_ogv,wgtsmooth, smrho,sv_p_orho) !Get mixed smrho,orho
    deallocate(w_oqkl,w_oa,co_rv,cn_rv)
    qmx=0d0
    do ib = 1, nbas ! ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-'
       is = ispec(ib)
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       allocate(rho1bk,source=sv_p_orho(1,ib)%v)
       allocate(rho2bk,source=sv_p_orho(2,ib)%v)
       sv_p_orho(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orho(2,ib)%v=.5d0*(rho1bk-rho2bk) 
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orhnew(2,ib)%v=.5d0*(rho1bk-rho2bk)
       deallocate(rho1bk,rho2bk)
       nlml = (lmxl+1)**2
       nr=nr_i(is)
       allocate(rwgt_rv(nr))
       call radwgt( rmt_i(is),spec_a(is),nr,rwgt_rv)
       do i = 1, nsp !  Net local site charge q1-q2
          off2 = 1 + nr*nlml*(i-1)
          associate(rho1s=> sv_p_orho(1,ib)%v(off2:off2+nr-1), rho2s=> sv_p_orho(2,ib)%v(off2:off2+nr-1)) 
            qmx = qmx+srfpi*sum((rho1s-rho2s)*rwgt_rv)
          endassociate
       enddo
       deallocate(rwgt_rv)
    enddo      
    summ = sum(smrho) ! ... Net interstitial charge and cell charge
    qcell= qval - summ*fac - qmx !     Net system charge
    xx = qcell/(vol*nsp)
    if(iprint()>10) write(6,"(a,4d13.5)")' mixrho: add corrections to qcell smrho =',qcell,xx,qmx,summ
    smrho=smrho+xx ! Add constant to smrho to force charge neutrality
    rmsdelsave = rmsdel
    if(ipr>=10 .AND. abs(qcell) > 1d-6) write(stdo,'('' add q='',f10.6,'' to preserve neutrality'')') qcell
    nnnx=count(dreal(smrho)<0d0)
    smmin=minval(dreal(smrho))
    if(nnnx>0 ) write(6,"(a,i8,d13.5)") ' mixrho: warning. negative smrho; isp number min=',nnnx,smmin
    if(nnnx<=0) write(6,"(a)") ' mixrho: all smrho are positive'
    call tcx('mixrho') ! ... old code=> call rhopos(smrho,n1,n2,n3,n1,n2,n3) to enforce density positive
  end subroutine mixrho
!-------------------------------------------------------------------------------------
  subroutine pvmix3 ( nbas,nsp,beta,kmxr,nlmlx,qkl,sv_p_orho,sv_p_orhnew,difx  )! Linearly mix local densities, possibly subtracting G_kL expansion
    use m_struc_def  
    use m_lmfinit,only: ispec
    !i   beta  :linear mixing parameter
    !l Local variables
    !i   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
    !i   nlmlx   :second dimension of qkl
    !i   qkl    :(locmix>=2) G_kL expansion of local densities
    !i          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !i          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !i          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !i          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    ! o Inputs/Outputs
    ! o  orho :On input, local densities generating hamiltonian
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orho).
    ! o         :On output, w(orho) is overwritten by the linear
    ! o         :combination (1-beta)*w(orho) + beta*w(orhnew)
    ! o  orhnew :On input, local densities gen. by ham. (maybe screened)
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhnew).
    !o Outputs
    !o   difx   :maximum rms difference in rhonew-rhoold
    implicit none
    integer :: nbas,nsp,kmxr,nlmlx,locmix
    type(s_rv1) :: sv_p_orho(3,nbas)
    type(s_rv1) :: sv_p_orhnew(3,nbas)
    real(8):: difx,beta,qkl(0:kmxr,nlmlx,nsp,4,nbas)
    integer :: ib,is,igetss,nr,nlml,m,lmxl,ir,mode4
    real(8) ,allocatable :: ri_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    real(8) :: a,rmt,rg,difa,rf
    real(8),allocatable:: w_orsm(:,:,:,:)
    difx  = 0
    do  ib = 1, nbas
       is = ispec(ib)
       lmxl = int(lmxl_i(is))
       if (lmxl == -1) cycle
       a=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       rg=rg_i(is)
       nlml = (lmxl+1)**2
       allocate(ri_rv(nr),rwgt_rv(nr),w_orsm(nr,nlml,nsp,4))
       call radmsh( rmt,a,nr,ri_rv)
       call radwgt( rmt,a,nr,rwgt_rv)
       rf = rmt/3
       do m=1,4
          call pkl2ro(rg,kmxr,nr,nlml,nsp,ri_rv,rwgt_rv,nlmlx,qkl(0,1,1,m,ib), w_orsm(:,:,:,m))
       enddo
       if(old2023mixing) then
          forall(ir=1:nr) w_orsm(ir,:,:,1)=w_orsm(ir,:,:,1)* exp((ri_rv(ir)/rf)**2) !scale up orsm
          forall(ir=1:nr) w_orsm(ir,:,:,3)=w_orsm(ir,:,:,3)* exp((ri_rv(ir)/rf)**2)
       endif
       associate( rhos1=>w_orsm(:,:,:,1),rhos2=>w_orsm(:,:,:,2),rhns1=>w_orsm(:,:,:,3),rhns2=>w_orsm(:,:,:,4),&
            rho1=>sv_p_orho(1,ib)%v, rho2=>sv_p_orho(2,ib)%v, rho3=>sv_p_orho(3,ib)%v, &
            rhn1=>sv_p_orhnew(1,ib)%v, rhn2=>sv_p_orhnew(2,ib)%v, rhn3=>sv_p_orhnew(3,ib)%v)
         rho1=(1-beta)*rho1 +beta*rhn1 -reshape((1-beta)*rhos1+beta*rhns1 ,shape(rho1)) !Subtract scale up orsm
         rho2=(1-beta)*rho2 +beta*rhn2 -reshape((1-beta)*rhos2+beta*rhns2 ,shape(rho2))
         rho3=(1-beta)*rho3 +beta*rhn3
       endassociate
!       difx  = dmax1(difx,difa)
       deallocate(rwgt_rv,ri_rv,w_orsm)
    enddo
  end subroutine pvmix3
  subroutine pvmix5(nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx,nsp,sv_p_orho,sv_p_orhnew,co,cn,ng2,ng02,nda, a,qkl,rms2 ,nmixr)  !Set up mixing array
    use m_lmfinit,only:ispec
    use m_struc_def
    use m_ftox
    !i   nmix  :number of prior iterations sought (for printout)
    !i   mxsav :max no. prior iteration to read, also dimensions a
    !i   fnam  :file name (for printout)
    !i   ifi  :file logical unit
    !i  rmsdel :Same as rms2 (see Outputs), from prior iteration.
    !i         :If no prior iteration, rsmdel=0.  For printout only.
    !i   orho:input local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   orhnew:output local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   co    :input smooth density this iteration, in FT form
    !i   cn    :output smooth density this iteration, in FT form
    !i   ng    :leading dimension of co,cn
    !i   ng0   :number of Fourier coefficients
    !xxxx    ng02=ng0*2 in the mixrealsmooth()=F (original case)
    !o Inputs/Outputs
    ! o  nmixr :(output for ifi>0) number of prior iter read from file
    ! o        :on output number of prior iterations read from file
    ! o  a,nda :work array a and leading dimension (nda must be >= na)
    ! o         a(*,i,1) holds f(xi) for iteration i-1
    ! o         a(*,i,2) holds   xi  for iteration i-1
    !o Outputs
    !o  qkl    :(locmix>=2) G_kL expansion of local densities
    !o         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !o         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !o         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !o         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    !o  rms2   :rms difference in f-x, where f=output density and x the
    !o          input density.  f and x include smoothed and local
    !o          contributions, with the latter depending on choice of
    !o          linear transformation; see locmix above.  Thus, there
    !o          is some arbitrariness in rms2.
    !r Remarks
    !r   Content of a(*) = a(*,isp,:,:):
    !r   Case locmix = 3
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
    !r     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
    !r                                             w/ l=0 part zeroed out
    !r     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
    implicit none
    include "mpif.h"
    integer :: procid, master, numprocs, ierr
    character(20) :: ext
    character(26) :: datim
    real(8) :: starttime, endtime
    character(120) :: strn
    logical :: mlog!,cmdopt
    logical :: readerror!,lddump
    integer :: ng2,ng02,nda,nmix,mxsav,ifi,nbas,nr,nsp,kmxr,nlmlx
    type(s_rv1) :: sv_p_orho(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    real(8):: a(nda,nsp,mxsav+2,2),rms2,rmsdel
    real(8):: co(ng2,nsp),cn(ng2,nsp),qkl(0:kmxr,nlmlx,nsp,4,1)
    character fnam*8
    integer :: ib,na,i,j,k,m,np,iprint,nmixr,is,igetss, off,nlml,lmxl 
    real(8) ,allocatable :: rofi_rv(:)
    real(8) :: ddot,rmt,aat,rf
    character outs*80
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr)
    master = 0
    ! smooth part
    a(1:ng02,1:nsp,1,2)=co(1:ng02,1:nsp) !old
    a(1:ng02,1:nsp,1,1)=cn(1:ng02,1:nsp) !new
    ! atomic part
    na = 1 + ng02
    do ib = 1, nbas
       is  = ispec(ib)
       lmxl= lmxl_i(is)
       if(lmxl == -1) cycle
       nr = nr_i(is)
       rmt=rmt_i(is)
       rf = rmt/3
       nlml = (lmxl+1)**2
       np = (1+kmxr)*nlml
       block
         integer:: ir
         real(8):: rhoold1(nr,nlml,nsp),rhonew1(nr,nlml,nsp),rhoold2(nr,nlml,nsp),rhonew2(nr,nlml,nsp)
         real(8):: rofi_rv(nr)
         rhoold1=reshape(sv_p_orho(1,ib)%v, shape(rhoold1))
         rhoold2=reshape(sv_p_orho(2,ib)%v, shape(rhoold2))
         rhonew1=reshape(sv_p_orhnew(1,ib)%v, shape(rhonew1))
         rhonew2=reshape(sv_p_orhnew(2,ib)%v, shape(rhonew2))
         call radmsh( rmt,spec_a(is),nr,rofi_rv)
         if(old2023mixing) then
            forall(ir = 1:nr) rhoold1(ir,:,:) = rhoold1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
            forall(ir = 1:nr) rhonew1(ir,:,:) = rhonew1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
         endif
         do  i = 1, nsp ! spherical part 
            a(na:na+nr-1,     i,1,2)= rhoold1(:,1,i) !old
            a(na+nr:na+2*nr-1,i,1,2)= rhoold2(:,1,i)
            a(na:na+nr-1 ,    i,1,1)= rhonew1(:,1,i) !new
            a(na+nr:na+2*nr-1,i,1,1)= rhonew2(:,1,i)
         enddo
         if(.not.old2023mixing) then
            forall(ir = 1:nr) rhoold1(ir,:,:) = rhoold1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
            forall(ir = 1:nr) rhonew1(ir,:,:) = rhonew1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
         endif
         call rhogkl( ib,nsp,rhoold1,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,1,ib ) ) !old
         call rhogkl( ib,nsp,rhoold2,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,2,ib ) )
         call rhogkl( ib,nsp,rhonew1,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,3,ib ) ) !new
         call rhogkl( ib,nsp,rhonew2,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,4,ib ) )
         na=na+2*nr
         do  i = 1, nsp ! moment part
            qkl(0:kmxr,1,i,1:4,ib)=0d0 !  zero out spherical part of G_kL
            a(na:na+np-1,     i,1,2)=reshape(qkl(:,1:nlml,i,1,ib),[np]) !old
            a(na+np:na+2*np-1,i,1,2)=reshape(qkl(:,1:nlml,i,2,ib),[np])
            a(na:na+np-1,     i,1,1)=reshape(qkl(:,1:nlml,i,3,ib),[np]) !new
            a(na+np:na+2*np-1,i,1,1)=reshape(qkl(:,1:nlml,i,4,ib),[np])
         enddo
       endblock
       na = na + 2*np
    enddo         
    if(nda/= na-1) call rx('mixrho: bug in pvmix5 nda/=na-1')
    na   = nda*nsp
    rms2 = (sum((a(:,:,1,1)-a(:,:,1,2))**2)/(nda*nsp))**.5*nsp ! *nsp is right?
    if(mxsav == 0) return
    ReadPreviousIterations: block
      nmixr = 0
      if(procid == master) then
         readerror = .true.
         read (ifi,err=311,end=311) nmixr, na
         readerror = .false.
         do j = 1,  min(mxsav,nmixr)
            read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,1) 
            read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,2)
            nmixr = j
            cycle
90          continue
            write(stdo,ftox) 'pvmix5: reading only nmixr=',nmixr
            exit
         enddo
         goto 312
311      continue
      endif
312   continue
      call MPI_BCAST(readerror,1,MPI_LOGICAL,   master,MPI_COMM_WORLD,ierr)
      if(readerror) goto 9999
      call MPI_BCAST(na,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
9999  continue
      call MPI_BCAST(nmixr,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
      if(nmixr > 0) call MPI_BCAST(a,nda*nsp*(mxsav+2)*2,MPI_DOUBLE_PRECISION, master,MPI_COMM_WORLD,ierr)
    endblock ReadPreviousIterations
    if(iprint() >= 20) then !this is needed for test
       write(stdo,fmt=ftox, advance='no')' mixrho: sought',nmix,'iter from file '//trim(fnam)
       write(stdo,fmt='("; read ",g0," RMS DQ=",es8.2e1)',advance='no') nmixr, rms2
       if (rmsdel/= 0) write(stdo,"('  last it=',es8.2e1)",advance='no')rmsdel
       write(stdo,*)
    endif
  end subroutine pvmix5
  subroutine pvmix6(broy,nmix,mmix,mxsav,beta,wc,nda,a)!- Mixing of the total density
    use m_amix,only: amix
    !i  broy   : 0 for Anderson mixing,   : 1 for Broyden mixing
    !i  nmix   : nmix: number of iter to try and mix
    !i  mmix   : number of iterates available to mix
    !i  mxsav  : second dimension of a
    ! o Inputs/Outputs
    ! o  a     :On input:
    ! o         (*,i,1)  output vector for prev. iteration i
    ! o         (*,i,2)  input  vector for prev. iteration i
    ! o        :On output:
    ! o         (*,0,1) and (*,0,2) estimated new vector
    ! o         (*,i,1), i>1 destroyed
    !r  Remarks
    !r    Broyden mixing adapted from Duane Johnson.  Notation:
    !r    x^(m): input vector for iteration m
    !r    F^(m): difference between output and input vector in iteration m
    implicit none
    integer :: nda,nmix,mmix,mxsav,broy
    real(8) :: beta,a(nda,0:mxsav+1,2)
    integer :: j,iprint!,amix
    real(8) :: tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
    parameter (tjmax = 5d0) 
    real(8),allocatable:: aaa(:)
    if (nmix == 0 .OR. nmix == 1 .OR. broy == 0) then
       do  j = 1, nmix
          call daxpy(nda,-1d0,a(1,j,2),1,a(1,j,1),1) ! ... amix needs f-x for prior iterations
       enddo
       nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,a,tj,  rms2) ! --- Anderson mixing ---
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
    elseif (broy == 1) then 
       call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) ! --- Broyden mixing, Duane Johnson's approach ---
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
    else
       call rx('pvmix6: bad value for broy')
    endif
  end subroutine pvmix6
  subroutine pvmix7(nbas,nsp,nda,a,n1,n2,n3,kmxr,nlmlx,qkl,ng,ng02,kv,gv,wgtsmooth, smrho,sv_p_orho) !read from array a
    use m_lmfinit,only: ispec
    use m_struc_def 
    !i   nda   :leading dimension of a
    !i   a     :mixed density from pvmix6, smoothed + local densities
    !i         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
    !i         :locmix = 3, a contains spherical part on mesh a full rho, GkL expansion
    !i   n1..3 :FT mesh
    !i   n1..3 :dimensions smrho
    !i   ng    :number of FT G-vectors
    !i   ng0   :condensed number of G vector (excluding hermitian equiv)
    !i   kv    :indices for gather/scatter operations (gvlist.f)
    !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
    !i   wk    :complex work array of dimension (n1,n2,n3)
    !i   smrho :smooth density that generated the hamiltonian
    !i   orho:local  density that generated the hamiltonian,
    !i         :a portion of which which has been linearly mixed (pvmix4)
    !i         :orho(1) contains rho1+rho2
    !i         :orho(2) contains rho1-rho2
    !o Outputs
    !o   smrho :overwritten by mixed smooth density
    !o   orho:mixed local density is returned, in rho1+rho2,rho10rho2 form
    implicit none
    integer :: nsp,n1,n2,n3,ng,ng02,nda,na,nr,nbas, kv(ng,3),kmxr,nlmlx
    type(s_rv1) :: sv_p_orho(3,1)
    real(8):: gv(ng,3),a(nda,nsp),qkl(0:kmxr,nlmlx,nsp,4,nbas),rf, wgtsmooth
    complex(8):: smrho(n1,n2,n3,nsp),wk(n1,n2,n3)
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    integer :: ib,is,mode4,m,lmxl,nlml,off,np,orsm(2),i,ir
    real(8) :: aat,rmt,rg,xx
    real(8),allocatable:: w_orsm(:,:,:,:) !    logical:: mixrealsmooth=T
    do  i = 1, nsp
       smrho(:,:,:,i)=1d0/wgtsmooth*reshape(a(:,i),[n1,n2,n3])
    enddo
    na = 1 + ng02
    do  ib = 1, nbas
       is = ispec(ib)
       aat=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       lmxl=lmxl_i(is)
       if (lmxl == -1) cycle
       rf = rmt/3
       rg = rg_i(is)
       nlml = (lmxl+1)**2
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh(rmt,aat,nr,rofi_rv)
       call radwgt(rmt,aat,nr,rwgt_rv)
       do  i = 1, nsp
          off = 1+nr*nlml*(i-1)
          sv_p_orho(1,ib)%v(off:off+nr-1)= a(na:   na+nr-1,  i ) ! Overwrite spherical orho
          if(old2023mixing) sv_p_orho(1,ib)%v(off:off+nr-1)= a(na:   na+nr-1,  i )* exp((rofi_rv(:)/rf)**2) !scale up readin a
          sv_p_orho(2,ib)%v(off:off+nr-1)= a(na+nr:na+2*nr-1,i )
       enddo
       na = na + 2*nr
       np = (1+kmxr)*nlml
       allocate(w_orsm(nr,nlml,nsp,2))
       do  m = 1, 2
          do  i = 1, nsp
             qkl(:,1:nlml,i,m,ib)= reshape(a(na+np*(m-1):na+np*(m-1)+np-1,i),[kmxr+1,nlml])
          enddo
          call pkl2ro(rg,kmxr,nr,nlml,nsp,rofi_rv,rwgt_rv,nlmlx,qkl(0,1,1,m,ib),w_orsm(:,:,:,m))
          if(old2023mixing.and.m==1) forall(ir=1:nr) w_orsm(ir,:,:,m)=w_orsm(ir,:,:,m)* exp((rofi_rv(ir)/rf)**2) !scale up orsm
       enddo
       sv_p_orho(1,ib)%v = sv_p_orho(1,ib)%v + reshape(w_orsm(:,:,:,1),shape(sv_p_orho(1,ib)%v)) !Add mixed qkl density to existing orho
       sv_p_orho(2,ib)%v = sv_p_orho(2,ib)%v + reshape(w_orsm(:,:,:,2),shape(sv_p_orho(2,ib)%v))
       deallocate(w_orsm)
       na = na + 2*np
       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(rofi_rv)) deallocate(rofi_rv)
    enddo               
    na = na-1
    if(nda/=na) call rx('mixrho: bug in pvmix7')
  end subroutine pvmix7
  subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) !Broyden mixing of a vector, Duane Johnson's approach
    use m_ftox
    !i  mmix: number of iterates available to mix
    !i  a:    (*,i,1)  output values for prev. iteration i
    !i        (*,i,2)  input  values for prev. iteration i
    ! o nmix: nmix > 0: number of iter to try and mix    nmix < 0: use mmix instead of nmix.
    !o  nmix: (abs)  number of iter actually mixed.  (sign) <0, intended that caller update nmix for next call.
    !r  x^(m): input vector for iteration m
    !r  F^(m): difference between output and input vector in iteration m
    implicit none
    integer :: nda,nmix,mmix,mxsav,im,km,i,iprint,i1mach,imix,jmix
    real(8) :: beta,rms2,wctrue,a(nda,0:mxsav+1,2), ddot,dval,wc
    real(8) :: xmp1_rv(nda), f_rv(nda), ui_rv(nda), vti_rv(nda), xold_rv(nda), df_rv(nda), dx_rv(nda)
    real(8),allocatable:: wk_rv(:)
    imix = merge(mmix,nmix, nmix < 0) !imix is a local copy of nmix
    do while (im/=imix) ! --- Starting from iteration mmix, build the Jacobian matrix ---
       jmix = min(mmix,iabs(imix))
       do km = 1, jmix
          im = jmix-km+1
          call dcopy ( nda,a ( 1,im - 1,1 ),1,dx_rv,1 )
          call daxpy ( nda,- 1d0,a ( 1,im - 1,2 ),1,dx_rv  ,1 )
          rms2 = dsqrt ( ddot ( nda,dx_rv,1,dx_rv,1 ) / ( nda - 0 ) )
          ! ---   Determine wc_true if wc < 0 ---
          if (wc < 0) then
             wctrue = -wc/100/dsqrt(nda*rms2**2)
             wctrue = min(max(wctrue,1d0),1d4)
          else
             wctrue = wc
          endif
          if (km == 1) wctrue = .01d0
          i = iprint()
          if (km /= jmix) i = i-20
          allocate(wk_rv(nda*2*(jmix+2)))
          i = broyj ( nda,a(1,im-1,2),dx_rv,km, i,beta,0d0,0d0,0d0,wctrue,wk_rv,nda,xmp1_rv )
          deallocate(wk_rv)
       enddo
       ! --- Check for interactive change of nmix ---   ! NB negative sign signals request for permanent change in nmix
       im = imix
       if(iabs(imix) > mmix .AND. imix /= im) write(stdo,ftox)' (warning) only ',mmix,' iter available'
    enddo
    nmix = imix
    if(nmix == 0 ) return
    if(iprint() > 60 .OR. (iprint() >= 40 .AND. nda <= 100)) then
       write(stdo,"(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')") 
       do i = 1, nda
          if(dabs(a(i,0,1)-a(i,0,2))>= 5d-9 ) write(stdo,"(i5,4f14.6)")i,a( i,0,2 ),a( i,0,1 ),a(i,0,1)-a( i,0,2 ),xmp1_rv(i) 
       enddo
    endif
    call dcopy(nda,xmp1_rv,1,a ( 1,0,2 ),1 ) !Save x^(m+2) into a(*,0,2) and exit ---
  end subroutine pqmixb
  subroutine pkl2ro(rsm,kmax,nr,nlml,nsp,rofi,rwgt,nlmlx,fklr,rho1) !- Put PkL or GkL expansion of a function on a radial mesh for one site
    !i         add G_kL expansion of rho to rho1 (and possibly rho2)    !i         :    Here, fkl are coffs to G_kL expansion
    !i         add expansion to rho1 only; rho2 is not touched
    !i         coefficients fkl are real (uses fklr)
    !i         initialize rho1,rho2 before adding expansion
    !i         :mode4 10000s digit for spin polarized case
    !i         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
    !i         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
    !i   rsm   :smoothing radius for P_kL (or G_kL) expansion
    !i   kmax  :k-cutoff for P_kL (or G_kL) expansion
    !i   nr    :number of radial mesh points
    !i   nlml  :L-cutoff for rho1,rho2
    !i   nsp   :2 if fkl is spin-pol; 1 if not
    !i   rofi  :radial mesh points
    !i   rwgt  :radial mesh weights
    !i   nlmlx  :second dimension of fkl
    !i   fklc  :complex coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !i   fklr  :real coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !o Outputs
    !o  rho1  :fkL P_kL (or G_kL) added to local true density rho1
    ! ----------------------------------------------------------------------
    implicit none
    integer :: mode,kmax,nlmlx,nr,nlml,nsp,i,ilm,isp,k,l,lmxl,mode4,np 
    real(8) :: qmx,rsm
    real(8) :: rofi(nr),rwgt(nr)
    real(8) :: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),nchg(nr,nlml),nspn(nr,nlml)
    real(8) :: fklr(0:kmax,nlmlx,nsp)
    real(8) :: add,r,rl,sum1
    real(8) :: rhoc(nr,nsp)
    lmxl = ll(nlml)
    mode4 = 0!mod(mode/10000,10)
    block
      real(8):: pkl(nr,0:kmax,0:lmxl)
      do i = 2, nr
         call radgkl(rofi(i),rsm,kmax,lmxl,kmax,pkl(i,:,:))
      enddo
      do ilm = 1, nlml
         l = ll(ilm)
         do  isp = 1, nsp
            rho1(1:nr,ilm,isp) = [0d0,(sum(fklr(:,ilm,isp)*pkl(i,:,l))*rofi(i)**(l+2),i=2,nr)]
         enddo
      enddo
    endblock
  end subroutine pkl2ro
  subroutine rhoqm(smrho,n1,n2,n3,nsp,vol, qsum)    !- Return charge, magnetic moment of smooth density
    !o Outputs
    !o   qsum  :qsum(1) = smrho(+) + smrho(-)
    !o         :qsum(2) = smrho(+) - smrho(-) (for nsp=2 only)
    implicit none
    integer ::  n1,n2,n3,nsp,i
    complex(8):: smrho(n1,n2,n3,nsp)
    real(8):: vol,qsum(2),sumi(2)
    sumi = [(sum(smrho(:,:,:,i)),i=1,nsp)]
    qsum(1) = vol/(n1*n2*n3)*sum(sumi)
    if(nsp==2) qsum(2) = vol/(n1*n2*n3)*(sumi(1)-sumi(2))
  end subroutine rhoqm
  integer function broyj(n,xin,gin,ir,ipr,beta,dxmx,xtol,gtol, wc,wk,ndw,xnew)   !- One Broyden step in finding gin = f[xin]-xin = 0
    !i Inputs
    !i   n:     number of variables
    !i   ir:    Number of iterations of x and g.
    !i          1 initiates a new sequence of mixing;
    !i          broyj uses linear mixing for this iteration.
    !i   isw    1s digit (not implemented)
    !i          0  find minimum
    !i          1  find maximum
    !i         10s digit not used
    !i        100s digit not used
    !i       1000s digit governs convergence criterion:
    !i          1 return when |grad| < gtol
    !i          2 return when max dx < xtol
    !i          3 return when either (1) or (2) satisfied
    !i          4 return when both (1) and (2) are satisfied
    !i   beta:  linear mixing parameter (ir=1 only)
    !i   xin:   input vector, this iteration
    !i   gin:   output-input vector, f[xin]-xin, this iteration
    !i   wc:    weighting for this iteration
    ! o  wk     workspace of 2*ndw*(ir+2), ndw>=n
    ! o         wk must be preserved between calls to broyj.
    ! o         (*,1,0) x of the prior iteration.
    ! o         (*,2,0) g of the prior iteration.
    ! o         (*,1..2,1..ir-1) u and vt of this and prior iterations
    ! o         (*,1,ir) g(this iter) - g (prior iter).
    !o Outputs
    !o   xnew   estimate of x
    !o   broyj
    !r Remarks
    !r   Adapted from Duane Johnson
    ! ----------------------------------------------------------------------
    implicit none
    integer :: isw,ir,n,ipr,ndw
    real(8) :: beta,dxmx,wc,xin(n),gin(n),xnew(n),xtol,gtol, wk(ndw,2,0:ir)
    ! Local variables
    integer :: i,ip,j,k,irm1,irm2,lm,ln,nn,i1mach,isw1,isw2,isw3 !dinv
    integer :: ierr
    real(8) :: aij,cmj,dfnorm,fac1,fac2,gmi,one,zero,ddot,w0
    parameter (zero=0d0,one=1d0,nn=20)
    real(8) :: a(nn,nn),cm(nn),w(nn),d(nn,nn)
    real(8) :: betx,diff,gmax,xmax
    save w,cm,a,w0
    if (ir > nn) call rxi('broyj: increase nn, need',ir)
    ! --- First iteration: simple mixing ---
    if (ir == 1) then
       w0 = wc
       betx = beta
       gmax = 0
       do  k = 1, n
          gmax = max(gmax,abs(gin(k)))
       enddo
       If (dxmx > 0d0 .AND. gmax > dxmx) then
          betx = beta*dxmx/gmax
       endif
       do    k = 1, n
          xnew(k) = xin(k) + betx*gin(k)
       enddo
       ! --- Subsequent iterations: Broyden mixing ---
    else
       !   ... Make xold, gold
       do  20  k = 1, n
          wk(k,1,0) = xin(k) - wk(k,1,0)
          wk(k,1,ir) = gin(k) - wk(k,2,0)
20     enddo

       !   --- Coefficient matrices and the sum for corrections ---
       !   ... dfnorm = |g(i)-g(i-1)|, used for normalization
       dfnorm = dsqrt(ddot(n,wk(1,1,ir),1,wk(1,1,ir),1))
       fac2 = one/(dfnorm+1d-12)
       fac1 = beta*fac2
       !   ... Shuffle each prior u,vt to prior+1 iteration
       irm1 = ir-1
       irm2 = ir-2
       do  30  j = irm2, 1, -1
          call dcopy(n,wk(1,1,j),1,wk(1,1,j+1),1)
          call dcopy(n,wk(1,2,j),1,wk(1,2,j+1),1)
30     enddo
       !   ... Make u,vt for this iteration
       do    k = 1, n
          wk(k,1,1) = fac1*wk(k,1,ir) + fac2*wk(k,1,0)
          wk(k,2,1) = fac2*wk(k,1,ir)
       enddo

       !   --- Make  a and b = ( w0**2 I + a )^-1 (symmetric) ---
       do  42  j = 1, irm2
          aij = zero
          cmj = zero
          do    k = 1, n
             cmj = cmj + wk(k,2,ir-j)*gin(k)
             aij = aij + wk(k,2,ir-j)*wk(k,2,1)
          enddo
          a(irm1,j) = aij
          a(j,irm1) = aij
          cm(j) = cmj
42     enddo
       aij = zero
       cmj = zero
       do  k = 1, n
          cmj = cmj + wk(k,2,1)*gin(k)
          aij = aij + wk(k,2,1)*wk(k,2,1)
       enddo
       a(irm1,irm1) = aij
       cm(irm1) = cmj
       w(irm1) = wc

       !   ... Set up and calculate beta matrix
       do   lm = 1, irm1
          do  ln = 1, irm1
             d(ln,lm) = a(ln,lm)*w(ln)*w(lm)
          enddo
          d(lm,lm) = w0**2 + a(lm,lm)*w(lm)*w(lm)
       enddo
       !   --- Invert to make d ---
       call matinv2(irm1,d(1:irm1,1:irm1),ierr)
       !   --- xnew <- vector for the new iteration ---
       do   k = 1, n
          xnew(k) = xin(k) + beta*gin(k)
       enddo
       do  70  i = 1, irm1
          gmi = zero
          do  ip = 1, irm1
             gmi = gmi + cm(ip)*d(ip,i)*w(ip)
          enddo
          do  k = 1, n
             xnew(k) = xnew(k) - gmi*wk(k,1,ir-i)*w(i)
          enddo
70     enddo
       !   ... Cap to maximum allowed shift xnew-xin
       if (dxmx > 0d0) then
          diff = 0
          do  k = 1, n
             diff = max(diff,abs(xnew(k)-xin(k)))
          enddo
          if (diff > dxmx) then
             betx = dxmx/diff
             do   k = 1, n
                xnew(k) = xin(k) + betx*(xnew(k)-xin(k))
             enddo
          endif
       endif
    endif
    ! --- Cleanup, setup for next call ---
    xmax = 0
    gmax = 0
    diff = 0
    do  110  k = 1, n
       xmax = max(xmax,abs(xnew(k)-xin(k)))
       gmax = max(gmax,dabs(gin(k)))
       diff = diff + (xnew(k)-xin(k))**2
       wk(k,2,0) = gin(k)
       wk(k,1,0) = xin(k)
110 enddo
    diff = dsqrt(diff/n)
    j = ir+1
    broyj = j
  end function broyj
  subroutine rhogkl(ib,nsp,rho,kmax,nlml,nlmlx,nr,qkl )!- G_kL expansion of valence sphere densities
    use m_lgunit,only:stdo
    use m_struc_def  
    use m_lmfinit,only: ispec
    use m_hansr,only:corprm
    use m_freeatom,only:sspec
    !i   kmax  : make expansion coffs to polynomial cutoff kmax
    !i   orhoat: vector of offsets containing site density
    !o   qkl  :Expansion coefficients, stored as a single long vector.
    !o        := integral pkl Y_L integrand where integrand is according to mode
    !r Remarks1
    !r   Q_kL = integral p_kl (rho1-rho2) + l=0 contr. from core spillout.  Ser rhomom
    !r   The core spillout term is:
    !r      qcore(rhoc)-z  - sm_qcore-sm_qnuc
    !r   pvrgkl makes this Q_kL when mode=131; partial contr for other modes
    !r   NB: p0l = a**l and scaling factor for k=0 is 4*pi/(a**l * (2l+1)!!)
    !r       => q0l = 4*pi/(2l+1)!! q_l, where q_l is the multipole moment
    ! ----------------------------------------------------------------------
    !r Remarks2
    !r   P_kL are polyonomials orthogonal in the following sense:
    !r                                          (4a^2)^k a^l k! (2l+1)!!
    !r    int P_kL G_k'L' = delta_kk'*delta_ll'  ----------------------
    !r                                                    4pi
    !r   See defined in J. Math. Phys. 39, 3393 (1988).
    !r   Combining eqns 12.7 and 5.19 in that paper, we obtain
    !r    p_kl = a**l / (2a**2)^(k+l) (2l+1)!! / (2k+2l+1)!! phi_kl
    !r    p_0l = a**l
    !r    p_1l = a**l (2*(ar)**2/(2l+3) - 1)
    !r    p_kl = [(2*(ar)**2 - (4k+2l-1))p_k-1,l - 2(k-1)p_k-2,l]  / (2k+2l+1)
    implicit none
    integer::nsp,mode,kmax,nlmlx
    type(s_rv1) :: sv_p_orhoat(3,nbas)
    real(8):: qkl(0:kmax,nlmlx,nsp),z,qc,a,rmt,qcorg,qcorh,qsc,cofg,cofh,rg, ceh,rfoc,df(0:20),rho(nr,nlml,nsp) 
    integer:: ipr,iprint, ib,is,lmxl,nr,nlml,ilm,j,lfoc,k,l,m,isp
    real(8) ,allocatable :: rofi(:), rwgt(:)
    real(8),parameter:: fpi = 16d0*datan(1d0)
    ipr  = iprint()
    is = ispec(ib)
    lmxl=lmxl_i(is)
    if (lmxl == -1) return
    z=z_i(is)
    qc=sspec(is)%qc
    a=spec_a(is)
    nr=nr_i(is)
    rmt=rmt_i(is)
    rg=rg_i(is)
    call corprm(is,qcorg,qcorh,qsc,cofg,cofh,ceh,lfoc,rfoc,z)
    qc = qcorg+qcorh
    allocate(rofi(nr),rwgt(nr))
    call radmsh(rmt,a,nr,rofi )
    call radwgt(rmt,a,nr,rwgt )
    QKL_Pkl: block
      real(8):: dfactl(0:lmxl),kfact(0:kmax) ,pkl(nr,0:kmax,0:lmxl),a,ag
      integer::kk,lx
      a = 1d0/rg
      do l = 0, lmxl
         pkl(:,0,l) = a**l *rofi**l !Scale by r^l 
         pkl(:,1,l) = a**l*(2*a*a*rofi**2/(2*l+3)-1d0) *rofi**l
         do  k = 2, kmax ! --- Recursion for higher k ---
            pkl(:,k,l) = 1d0/(2*k+2*l+1)*((2*a*a*rofi**2-(4*k+2*l-1))*pkl(:,k-1,l) - 2*(k-1)*pkl(:,k-2,l))
         enddo
      enddo
      dfactl(0:lmxl)=[(product([(2*lx+1,lx=0,l)]),   l=0,lmxl)]
      kfact(0:kmax)= [(product([(max(1,kk),kk=0,k)]),k=0,kmax)]
      ag = 1/rg
      do isp=1,nsp
         do  ilm=1,(lmxl+1)**2
            l=ll(ilm)
            do  k = 0, kmax
               qkl(k,ilm,isp)=fpi*sum(rwgt(:)*pkl(:,k,l)*rho(:,ilm,isp))/ ((4*ag**2)**k*ag**l*kfact(k)*dfactl(l))
            enddo
         enddo
      enddo
    endblock QKL_Pkl
    checkrwrite: if(ipr >=40) then
       write(stdo,221)
       write(stdo,222) ib,0,1,((qkl(k,1,isp), k=0,kmax),isp=1,nsp)
       call stdfac(20,df)
       do isp=1,nsp
       do  ilm=1,(lmxl+1)**2
          l=ll(ilm)
          if (dabs(qkl(0,ilm,isp))*df(2*l+1) > 1d-6) write(stdo,220) isp,ilm,(qkl(k,ilm,isp)*df(2*l+1),k=0,kmax)
       enddo
       enddo
222    format(2x,'ib=',i3,i5,i6,20f12.6)
220    format(9x,i4,x,i6,f12.6,20f12.6)
221    format(/' rhogkl:    k   ilm      qkl (2l+1)!! ...')
    endif checkrwrite
  end subroutine rhogkl
  subroutine splrho(mode,nsp,nr,nlml,rho1,rho2,rhoc)  !- Overwrite spin pol local rho+,rho- with rho,rho+ - rho-, or reverse
    implicit none
    integer :: mode,nsp,nr,nlml
    real(8):: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rhoc(nr,nsp),rho1old(nr,nlml,nsp),rho2old(nr,nlml,nsp),rhocold(nr,nsp),fac
    if (nsp == 1) return
    fac = 1
    if (mod(mode,10) /= 0) fac = .5d0
    rho1old=rho1 
    rho1(:,:,1)=fac*(rho1old(:,:,1)+rho1old(:,:,2)) 
    rho1(:,:,2)=fac*(rho1old(:,:,1)-rho1old(:,:,2)) 
    rho2old=rho2
    rho2(:,:,1)=fac*(rho2old(:,:,1)+rho2old(:,:,2)) 
    rho2(:,:,2)=fac*(rho2old(:,:,1)-rho2old(:,:,2)) 
    if(mode<10) then 
       rhocold=rhoc
       rhoc(:,1)=fac*(rhocold(:,1)+rhocold(:,2))
       rhoc(:,2)=fac*(rhocold(:,1)-rhocold(:,2))
    endif  
  end subroutine splrho
  subroutine pqsclf(nda,npq,offx,off2,na,mxsav,wt,a,a2,rms2)    !- Split into (a+ + a-) and (a+ - a-); include extra data
    !i Inputs
    !i   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
    !i   nda   :leading dimension of a
    !i   npq   :number of elements to spin-split with wt(1),wt(2)
    !i   offx  :(nx>0)offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimension of a2 and number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a     :(na,1:2,i,1) output vector for prev. iteration i
    !i         :(na,1:2,i,2) input  vector for prev. iteration i
    !o Outputs
    !o   a2    :(*,i,1) output charge and moments, scaled by weights
    !o         :(*,i,2) input  charge and moments, scaled by weights
    !o   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
    !r Remarks
    !r   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
    !r   If wt(1) or wt(2) is zero, a2 holds q or mom only.
    !r   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
    ! ------------------------------------------------------------------
    !     implicit none
    integer :: mode,nda,npq,mxsav,na,offx,off2
    real(8) :: wt(2),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2), rms2,ddot
    integer :: is,ia,ja
    ja = 0
    if (wt(1) == 0 .AND. wt(2) == 0) goto 11
    do  10  is = 0, mxsav+1
       ja = 0
       do  12  ia = 1, npq
          if (wt(1) /= 0) then
             ja = ja+1             !           Given (rhnew+ + rhnew-)*wt(1), (rhold+ + rhold-)*wt(1)
             a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
             a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          endif
          if (wt(2) /= 0) then
             ja = ja+1             !           Given (rhnew+ - rhnew-)*wt(2), (rhold+ - rhold-)*wt(2)
             a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
             a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          endif
12     enddo
10  enddo
11  continue
    rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1) - 2*ddot(na,a2,1,a2(1,0,2),1) + ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))
    if (ja /= na) call rx('pqsclf: element mismatch')
  end subroutine pqsclf
  subroutine pqsclb(nda,npq,offx,off2,na,mxsav,wt,a,a2)    !- Undo split into wt1*q and wt2*mom done by pqsclf
    !i   nda   :leading dimension of a
    !i   npq   :number of P,Q
    !i   offx  :offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimensions a2; number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
    !o Outputs
    !o   a     :a2 is unscaled and restored into a
    !     implicit none
    integer :: nda,na,npq,mxsav,offx,off2
    real(8) :: wt(2),a(nda,0:mxsav+1,2),    a2(na,0:mxsav+1,2),sum,diff
    integer :: is,ia,ja
    if (wt(1) == 0 .AND. wt(2) == 0) then
       ja = 0
    elseif (wt(1) /= 0 .AND. wt(2) /= 0) then
       do  is = 0, mxsav+1
          ja = 1
          do  ia = 1, npq
             a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
             a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2!   mixed  rhonew-,rhold-
             a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
             a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
             ja = ja+2
          enddo
       enddo
       ja = 2*npq
    elseif (wt(1) /= 0) then
       diff = 0
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+off2
             sum  = a2(ia,is,1)/wt(1)
             diff = (a(ia,is,1) - a(ja,is,1))
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             sum  = a2(ia,is,2)/wt(1)
             diff = (a(ia,is,2) - a(ja,is,2))
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    elseif (wt(2) /= 0) then
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+npq
             !         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
             sum  = (a(ia,is,1) + a(ja,is,1))
             diff = a2(ia,is,1)/wt(2)
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             !         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
             sum  = (a(ia,is,2) + a(ja,is,2))
             diff = a2(ia,is,2)/wt(2)
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    endif
  end subroutine pqsclb
end module m_mixrho
