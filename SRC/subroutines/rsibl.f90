module  m_rsibl
  use m_ll,only:ll
  use m_hsibl,only: hsibl,hsibl1
  public rsibl
  private
contains
  subroutine rsibl(lfrce,isp,q,iq,ndimh,nspc,napw,igapw,nevec,evec,ewgt,k1,k2,k3,smpot,smrho,f) !Add smooth part of output density into smrho and forces.
    use m_struc_def  
    use m_lmfinit,only: lat_alat,nspec,nbas
    use m_lattic,only: lat_qlat, lat_vol,lat_plat
    use m_supot,only: n1,n2,n3, lat_ng, lat_gmax
    use m_uspecb,only:uspecb
    use m_shortn3,only:gvlst2
    !i   lfrce :if nonzero, accumulate contribution to force
    !i   nbas  :size of basis
    !i   lfrce :1 calculate contribution to forces
    !i   nbas  :size of basis
    !i   q     :Bloch vector
    !i   iq    :index to current k-point
    !i   ndimh :dimension of hamiltonian
    !i   nspc  :2 for coupled spins; otherwise 1
    !i   napw  :number of augmented PWs in basis
    !i   igapw :vector of APWs, in units of reciprocal lattice vectors
    !i   nevec :number of eigenvectors with nonzero weights
    !i   evec  :eigenvectors
    !i   ewgt  :eigenvector weights
    !i   k1..3 :dimensions smpot,smrho
    !i   smpot :smooth potential on uniform mesh, needed for forces
    !o Outputs
    !o   smrho :smooth density accumulated for this qp
    !o   f     :force contribution accumulated for this qp
    implicit none
    integer :: procid, master, nproc, mpipid
    integer :: lfrce,isp,k1,k2,k3,ndimh,nevec,iq,nspc
    integer :: napw,igapw(3,napw)
    real(8):: q(3) , ewgt(nevec) , f(3,nbas)
    complex(8):: evec(ndimh,nspc,nevec),smrho(k1,k2,k3,isp), smpot(k1,k2,k3,isp)
    integer :: n0,nkap0,nermx,npmx,nblk,nlmto
    parameter (n0=10,nkap0=3,nermx=100,npmx=128)
    integer:: nrt , net , ng , ltop , nlmtop , ogq , og2 , ohe , ohr , oiv , iprint
    integer,allocatable :: iv_a_okv(:)
    real(8),allocatable :: rv_a_ogv(:,:)
    integer :: iprt(n0,nkap0,nermx),ipet(n0,nkap0,nermx),i_copy_size
    double precision :: alat,qlat(3,3),plat(3,3),q0(3),gmax,xx(1)
!    complex(8):: w(1,1,1)!dummy 
!    real(8):: wff(1)     !dummy
    double precision :: vol
    double precision :: etab(nermx),rtab(nermx)
    integer :: nvec
    integer,allocatable:: ivp(:)
    complex(8),allocatable::psi(:,:,:),psir(:,:,:),vpsi(:,:,:), psi0(:,:,:,:)
    real(8),allocatable:: cosi(:),sini(:),wk2(:)
    integer:: ig,ixx(1),jg,i
    integer,allocatable:: igv(:,:)
    real(8),allocatable:: w_ogq(:,:),yl(:,:),w_og2(:),he(:,:),hr(:,:)
    complex(8),allocatable:: w_osmbuf(:)
    real(8),allocatable:: w_ofrbuf(:)
    real(8),parameter:: pi = 4d0*datan(1d0),tpi = 2d0*pi
    
    nproc  = mpipid(0)
    procid = mpipid(1)
    if (nevec <= 0) return
    call tcn('rsibl')
    nlmto = ndimh-napw
    alat=lat_alat
    plat = lat_plat
    qlat = lat_qlat
    gmax=lat_gmax
    ng=lat_ng
    vol=lat_vol
    ! ... Setup for q-dependent gv ... also makes kv, gv+q and iv    !     NB: gv generated by gvlst2 has q already added to it!
    call pshpr(iprint()-30)
    call gvlst2(alat,plat,q,n1,n2,n3,0d0,gmax,[0],000,0,ng,ixx,xx,ixx)
    allocate(rv_a_ogv(ng,3), igv(ng,3), iv_a_okv(ng*3))
    call gvlst2(alat,plat, q, n1, n2, n3, 0d0,gmax,[0],509, ng, ng, iv_a_okv, rv_a_ogv, igv)
    call poppr
    if(napw > 0) then
       allocate(ivp(napw))    
       do ig = 1, napw
          ivp(ig) = findloc([( sum(abs(igv(jg,:)-igapw(:,ig)))==0,jg=1,ng)],value=.true.,dim=1)
       enddo
       if(any(ivp==0)) call rx('bug in rsibl.  Cannot find ivp')
    endif
    call tbhsi(nspec,nermx,net,etab,ipet,nrt,rtab,iprt,ltop) ! --- Tables of energies, rsm, indices to them ---
    ! --- Allocate and occupy arrays for yl, energy factors, rsm factors ---
    nlmtop = (ltop+1)**2
    allocate(w_ogq(ng,3),yl(ng,nlmtop), w_og2(ng), he(ng,net), hr(ng,nrt))
    ! H_L(G)= \frac{-4 pi}{e-G^2} {cal Y}_L(-iG) exp(gamma(e-G^2))
    ! hsibl1 calculaets he=1/(e-G^2) and hr=exp(-gamma G^2). The other parts are calculated in rsibl5.
    q0=0d0
    if(nlmto>0) call hsibl1 ( net,etab,nrt,rtab,ltop,alat,q0,ng,rv_a_ogv,w_ogq,w_og2, yl,he,hr )
    deallocate(w_og2)
    nblk = nevec
    allocate(psi(ng,nspc,nblk),vpsi(ng,nspc,nblk),psi0(ng,nspc,nblk,nbas),psir(k1,k2,k3))
    call rsibl1(q,nbas,ng,w_ogq,igv,n1,n2,n3,qlat,yl,he,hr, psi0,vol,iprt,ipet,etab,rtab,ndimh,nlmto,nspc,ewgt,nevec,evec)
    psi(:,:,:) = sum(psi0(:,:,:,1:nbas),dim=4)
    if(napw>0) psi(ivp(:),:,1:nevec) = psi(ivp(:),:,1:nevec) + evec(nlmto+1:nlmto+napw,:,1:nevec)/vol**.5 !add PW(G) to psi
    ! psi= H(G) + PW(G) 
    rsibl2block: block  !   ... Add to real-space mesh, optionally make smpot*psi for forces
      use m_sugcut,only:ngcut
      use m_lattic,only:rv_a_opos
      use m_lmfinit,only: ispec
      complex(8):: phase(ng),img=(0d0,1d0),psix(ng,nspc,nevec)
      integer:: i,ispc,is,ib,kb
      real(8):: wgt1
      real(8):: xx(ng),p(3),f0(3)
      do  ispc = 1, nspc !nspc=2 for SO=1, nspc=1 otherwise. nspx=nspc/nps
         do  i = 1, nevec
            call gvputf(ng,1,iv_a_okv,k1,k2,k3,psi(1,ispc,i),psir)
            call fftz3(psir,n1,n2,n3,k1,k2,k3,1,0,1)
            wgt1 = ewgt(i)
            smrho(:,:,:,isp+ispc-1)=smrho(:,:,:,isp+ispc-1)+ wgt1*dconjg(psir(:,:,:))*psir(:,:,:) !realspace density
            if (lfrce /= 0) then
               psir(:,:,:) = psir(:,:,:)*smpot(:,:,:,isp+ispc-1)
               call fftz3(psir,n1,n2,n3,k1,k2,k3,1,0,-1)
               call gvgetf(ng,1,iv_a_okv,k1,k2,k3,psir,vpsi(1,ispc,i))
            endif
         enddo
      enddo
      AddForce: if (lfrce /= 0) then
         do ib = 1, nbas
            is=ispec(ib) 
            p=rv_a_opos(:,ib) 
            phase = exp(-img*tpi*sum(p*q)) * exp(-img*tpi*matmul(p, matmul(qlat, transpose(igv))))
            do i = 1, nevec
               xx = sum(dimag(vpsi(:,:,i))*dreal(psi0(:,:,i,ib)) - dreal(vpsi(:,:,i))*dimag(psi0(:,:,i,ib)),dim=2)
               f0(:) = 2d0*vol*matmul(xx,w_ogq(:,:))
               f(:,ib) = f(:,ib)   + ewgt(i)*f0(:) !Add 2*Re( (v psi+) grad(psi) ) to f
               do kb = 1, nbas !!             This shouldn't be necessary?
                  f(:,kb) = f(:,kb) - ewgt(i)*f0(:)/nbas
               enddo
            enddo
         enddo
      endif AddForce
    endblock rsibl2block
    call tcx('rsibl')
  end subroutine rsibl
  subroutine rsibl1(q,nbas,ng,gq,iv,n1,n2,n3,qlat,yl,he,hr,psi0,vol,iprt,ipet,etab,rtab,ndimh,nlmto,nspc,ewgt,nevec,evec) ! Make wave function for a block of evecs, or add contr. to forces
    use m_uspecb,only:uspecb
    use m_struc_def 
    use m_orbl,only: Orblib,ktab,ltab,offl,norb
    use m_sugcut,only:ngcut
    use m_lattic,only: pos=>rv_a_opos
    use m_lmfinit,only: ispec
    !i Inputs
    !i   q     :Bloch wave number
    !i   nbas  :size of basis
    !i   ng    :number of G-vectors
    !i   gq    :2*pi/alat * (q+G) for all G-vectors
    !i   iv    :g-vectors as integer multiples of qlat (suphs0)
    !i   n1..3 :size uniform mesh for smooth density and potential
    !i   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
    !i   yl    :spherical harmonics for ng vectors
    !i   he    :table of energy factors
    !i   hr    :table of smoothing radius factors
    !o   psi0  : psi sans phase factors
    !i   vol   :cell volume
    !o   iprt  :index to which entry in rt a given orbital belongs
    !i   ipet  :index to which entry in etab a given orbital belongs
    !i   etab  :table of all inequivalent energies
    !i   rtab  :table of all inequivalent smoothing radii
    !i   ndimh :dimensions evec
    !i   nspc  :2 for coupled spins; otherwise 1
    !i   ewgt  :weights for each of the trial fermi levels
    !i   nevec  :number of eigenstates to generate
    !i   evec  :eigenevectors
    !i   vspi  :potential * wave function, needed only for mode=1
    !o Outputs
    !o   psi   :wave function (mode=0); work area (mode=1)
    !o   f     :term added to forces (mode=1)
    implicit none
    real(8):: q(3)
    integer :: nbas,ng,ndimh,nlmto,nspc,nevec,iv(ng,3), n1,n2,n3,n0,nkap0
    parameter (n0=10,nkap0=3)
    integer :: iprt(n0,nkap0,*),ipet(n0,nkap0,*)
    real(8) :: vol,yl(ng,*),he(ng,*),hr(ng,*), &
         etab(*),rtab(*),gq(ng,3),f(3,nbas),ewgt(nevec),qlat(3,3)
    complex(8):: psi0(ng,nspc,nevec,nbas), evec(ndimh,nspc,nevec),vpsi(ng,nspc,nevec)!,psix(ng,nspc,nevec)
    integer:: blks(n0*nkap0),ntab(n0*nkap0),ncut(n0,nkap0),lh(nkap0),nkapi
    double precision :: e,rsm,eh(n0,nkap0),rsmh(n0,nkap0),f0(3)
    double precision :: xx(n0),wt
    integer :: ib,is,io,jo,l2,kp,ie,ir,ioff,nlm1,nlm2,iq,kb,lt,i,ig, ncutt
    complex(8):: phase(ng),img=(0d0,1d0)
    real(8),parameter:: pi = 4d0*datan(1d0),tpi = 2d0*pi
    real(8):: fac
    integer:: ilm,l
    psi0=0d0
    do ib = 1, nbas
       is=ispec(ib) 
       ncut=ngcut(:,:,is)
       phase = [(exp(-img*tpi*sum(pos(:,ib)*(q+matmul(qlat,iv(ig,:))))),ig=1,ng)]
       call orblib(ib) !Return norb,ltab,ktab,offl
       call uspecb(is,rsmh,eh)
       call gtbsl1(1,norb,ltab,ktab,rsmh,eh,ntab,blks)
       do io = 1, norb
          if (blks(io) == 0) cycle
          jo = ntab(io)
          l2 = ltab(io)
          lt = ltab(jo)
          kp = ktab(io)
          ie = ipet(l2+1,kp,is)
          ir = iprt(l2+1,kp,is)
          ioff = offl(io)
          nlm1 = l2**2+1
          nlm2 = nlm1 + blks(io)-1
          rsm = rtab(ir)
          e   = etab(ie)
          ncutt=ncut(lt+1,kp) 
          fac = 4d0*pi*dexp(e*rsm*rsm*0.25d0)/vol
          do  ilm = nlm1, nlm2 ! ... Make vector evec*phase ! ... Combine G-dependent energy, rsm and YL factors
             l=ll(ilm)
             do i = 1, min(ng,ncutt)
                psi0(i,1:nspc,1:nevec,ib) = psi0(i,1:nspc,1:nevec,ib)&
                     + he(i,ie)*hr(i,ir)* yl(i,ilm) *(0d0,-1d0)**(l+2)* fac*phase(i) *evec(ilm-nlm1+ioff+1,1:nspc,1:nevec) 
             enddo
          enddo
       enddo
    enddo
  end subroutine rsibl1
end module m_rsibl
