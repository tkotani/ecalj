      program lmf2gw
c- Files, gwa.* gwb.* gw1.* gw2.* gw3.*, generated by ng0
c  are converted to DATA4GW
c ---------
c Input files
c   gwa.* : atomic data
c   gwb.* : band data
c   gw1.* : <psi|H|psi>
c   gw2.* : <psi|H(without Vxc)|psi>
c   Not used now ---> gw3.* : <psi|H(where Vxc(nval))|psi> !used only for NoCore case  
c
c   Q0P  ; q points near q=0 instead of q=0
c   GWIN0; required inputs for GW only read its nband.
c   CLASS:  CLASS information.
c
c Output files
c  DATA4GW_V2 :
Cu Updates
Cu             Uses CLASS rather than EFCLASSin
c------------------------------------------------------------------
C     implicit none
C     implicit real*8 (a-h,o-z)
      integer icor1,icorex,nphimx,i,i1,i2,ibas,ibasx,ibx,ic,icore,
     .ifichkv,ifigw0,ifigwa,ifigwb,ifigwx1,ifigwx2,ifigwx3,isp,ispx,
     .ispxx,ix,kkk,kkkdummy,l,ldummy,lmxa,lxx,n1q,n2q,n3q,nclassx,m,n,
     .ncore,ndimh,ngp,nnc,nq0i,nqbz,nspdummy,IKP,NR_A !takao feb2012 ngc,ngcmx,
      real(8) qlat(3,3),ovv(20),ef0,qpgcut_phi,qpgcut_cou,z,
     .a_a,b_a,rofi_anr
      character*120  ext0*256, ext*256
      real(8):: qqq(3),plat(3,3)
      integer:: ifi,ifefclass,fopnx,fopna,fext,icors(2)
      complex(8),allocatable:: zegf(:,:) ,geig(:,:)
      complex(8),allocatable:: cphi(:,:),cphi_d(:,:,:,:)
      real(8),allocatable:: evl(:), vvv1(:),vvv2(:),vvv3(:),rofi_A(:)
     &,gcore_A(:,:), ec_A(:), bas(:,:)
      integer,allocatable:: konf(:,:),lmxaa(:),nncx(:,:),ngvecp(:,:)
      real(8),allocatable :: qbze(:,:)
      real(8),parameter ::  rydberg=13.6058d0
      logical :: nocore  ! Flag file NoCore exist or not.
      ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
      ! If nocore exist. you have to supply
      !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
      ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
      real(8),allocatable :: wt(:),q0i(:,:)
c----------------------------------------------
      integer ::
     &nsp,      ! =1 or 2, corresponding to para or ferro.
     &nbas,     ! Number of atom in the primitive cell
     &nclass,   ! Number of atomic class (or type) for in the primitive cell
     &nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
     &ncoremx,  ! = maxval(ncore(1:nclass))
c
     &lmxamx,   ! = maxval(lmxa(1:nclass))
     &ngpmx,    ! Maximum number of G vector.
     &nband,    ! Number of bands given by GWIN0
     &ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
     &ldim2,    ! = total number of augmentation functions nRlm
     &nphi,     ! = total number of augmentation functions nRl
     &nqbze     ! = nqbz*(1+nq0i). Number of q points given by qg4gw
      real(8) ::
     &alat,    ! Lattice constant in a.u.
     &efermi = 1d99   ! This is dummy now .
      integer,allocatable::
     &iclass(:),
     &lmxa_d  (:),
     &nr(:),
     &konf_d(:,:),
     &ncore_d(:)
      real(8),allocatable ::
     &zz(:),
     &aa(:),bb(:),
     &ec_d (:,:,:),
     &evl_d(:,:,:),
     &vxclda (:,:,:),
     &gx_d(:,:,:,:,:),
     &gcore_d(:,:,:,:)
      complex(8),allocatable::
     &geig_d(:,:,:,:)
      integer,allocatable:: nindx(:),lindx(:),ibasindx(:)
      integer:: ificg
      integer:: procid,nrank,ifigwb_,ifigwx1_,ifigwx2_
      character*256:: extn,aaa
      character*256,allocatable:: extp(:)
      integer,parameter :: nsize= 1 000 000
      integer:: ifiproc,nqixx,nspxx,numprocxx,ixxx
      integer,allocatable:: iprocq(:,:),iantiferro(:)
      character(8),allocatable:: spid(:)
!!
      call show_programinfo(6)

!! === readin lmfgw_kdivider, and get extensions === apr2013
      ifiproc = fopnx('lmfgw_kdivider',2,1,-1)
      read(ifiproc,*) ext  !extension is read here
      ifi = fext(trim(ext))
      read(ifiproc,*) nqixx, nspxx, nrank
      allocate(iprocq(nqixx,nspxx))
      do isp=1,nspxx
      do iqq=1,nqixx
        read(ifiproc,*) iqqxx, ispxx, ixxx
        if(iqqxx/=iqq) stop 'iqqxx/=iqq'
        if(ispxx/=isp) stop 'ispxx/=isp'
        iprocq(iqq,isp) = ixxx
        write(6,"('iqq isp irank=',i8,i2,i6)") iqq,isp, iprocq(iqq,isp)
      enddo
      enddo
      call fclose(ifiproc)
!! for mpi files.
      allocate(extp(0:nrank-1))
      extp(0) = trim(ext)
      write(6,"('  0 ext= ',a,a)") trim(extp(0)),' ----------'
      do procid=1,nrank-1
        write(extn,"(i10)") procid
        extp(procid)=trim(adjustl(ext))//'_'//trim(adjustl(extn))
        write(6,"(i3,' ext= ',a,a)") procid,trim(extp(procid)),' ----------'
      enddo
!! --------------------------------------

      nocore=.false.
      ifichkv = 8485
      call setpr(30)
      ifigwa = fopna('gwa',-1,4)
      ifigwb = fopna('gwb',-1,4)
      ifigwx1 = fopna('gw1',-1,4)
      ifigwx2 = fopna('gw2',-1,4)
      open(ifichkv,file='VXCFP.chk')
      write(ifichkv,"(a)") '### LDA exchange correlation ###'
      write(ifichkv,"(a)")'#   qvec                 ikp iband    eigen VXC(ntotal)     VXC(nvalence)'
      read (ifigwb) nbas,nsp,ldim2,ndimh,alat,qlat,ef0,nqbz,plat(1:3,1:3),nqbze, nqirr !feb2012takao
      nqbze=nqirr    !nqbze means number of calculated bands (irreducible only)         feb2012takao
      allocate(lmxaa(1:nbas), bas(1:3,1:nbas))
      read (ifigwb) lmxaa(1:nbas), bas(1:3,1:nbas)
      read (ifigwb) ngpmx !, ngcmx
      lmxamx = maxval(lmxaa(1:nbas))
      allocate( iclass(nbas) )

!! readin CLASS
      ifefclass = 321
      open(ifefclass,file='CLASS')
      nclass=0
      do ibas = 1,nbas
        read(ifefclass,*)  ibasx,  nclassx
        if(nclassx>nclass) nclass= nclassx
      enddo

      write(6,'('' File CLASS:  nclass ='',i4)') nclass
      allocate( qbze(3,nqbze), lmxa_d(nclass), nr(nclass),
     &  ncore_d(nclass), konf_d(0:lmxamx,nclass), zz(nclass),
     &  aa(nclass), bb(nclass) )
!!
      ificg=421
      open(ificg,file='CphiGeig',form='unformatted')
      rewind ifefclass
      do ibas=1,nbas
        read(ifefclass,*) ix,iclass(ibas)
        lmxa_d(iclass(ibas)) =lmxaa(ibas)
      enddo
      close(321)

!! Band Part
      nbandmx = ndimh
      write(6,'(" nqbze nqpz ndimh(max)=",3i5)') nqbze,nqbz,ndimh
      allocate( evl_d (nbandmx, nqbze, nsp),vxclda(nbandmx, nqbze, nsp),
     &  vvv1(nbandmx),vvv2(nbandmx),vvv3(nbandmx),cphi(ldim2, nbandmx), evl(nbandmx) )
      evl_d=1d20
      vxclda=1d20
      iqq=0
      do ikp = 1,nqbze
        iqq=iqq+1
        do isp = 1, nsp
          ifigwb_= fopnx('gwb'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          read (ifigwb_) qbze(:,ikp),nband,iq
          write(6,"(a,3i6,3x,3f11.6,$)") 'ikp isp nband q=',ikp,isp,nband, qbze(:,ikp)
          evl =1d20
          cphi=1d20
          read (ifigwb_) evl(1:nband), cphi(:,1:nband)
          write(ificg) cphi(1:ldim2,1:nbandmx)
          evl_d (1:nband, ikp,isp) = evl (1:nband)

!! Plane wave part
          read (ifigwb_) ngp !,ngc
          allocate( geig(ngp, nbandmx),
     &    ngvecp(3,ngp) )!takao feb2012 ,ngvecc(3,ngc) )
          geig=1d20
          read(ifigwb_) ngvecp,geig(:,1:nband)
          write(ificg) ngp
          write(ificg) geig(1:ngp,1:nbandmx)
          write(6,'("  geig sumcheck= ",2d13.6)') sum(geig(1:ngp,1:nband))
          deallocate( geig,ngvecp)!takao feb2012 ,ngvecc )

!! --- VXCFP
          ifigwx1_= fopnx('gw1'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          ifigwx2_= fopnx('gw2'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          read (ifigwx1_ ) qqq, (vvv1(i),i=1,nband)
          read (ifigwx2_ ) qqq, (vvv2(i),i=1,nband)
          vxclda (1:nband, ikp,isp)= vvv1(1:nband)-vvv2(1:nband)
          vvv3=vvv2
          do ibx =1,nband
             write(ifichkv,"(3f8.4,2i3,6f16.8)") qqq,ikp,ibx,
     &            vvv1(ibx),vvv1(ibx)-vvv2(ibx),vvv3(ibx)-vvv2(ibx),
     &            rydberg*vvv1(ibx),rydberg*(vvv1(ibx)-vvv2(ibx)),
     &            rydberg*(vvv3(ibx)-vvv2(ibx))
          enddo
 888      continue
       enddo
      enddo
      close(ificg)
      deallocate( cphi,evl, vvv1,vvv2,vvv3)

!! GET nrxx and ncoremx ----------------------
      nrmx    = 0
      ncoremx = 0
      allocate(nncx(0:lmxamx,nbas),konf(lmxamx+1,nbas),spid(nbas))
      do  ibas = 1, nbas
        read(ifigwa) z, nr_A, a_A, b_A, rofi_Anr
     &  ,lmxa,nspdummy,ncore,spid(ibas)
        allocate(rofi_A(nr_A),ec_A(ncore))
        read(ifigwa) konf(1:lmxa+1,ibas)
        read(ifigwa) rofi_A(1:nr_A)
        do  l = 0, lmxa
          do  isp = 1, nsp
            read(ifigwa) lxx,ispx  !!!ibas==ic,l,n=1
            read(ifigwa)
            read(ifigwa)
            if (konf(l+1,ibas) .ge. 10) read(ifigwa)
          enddo
        enddo
        do  l = 0, lmxa
          do  isp = 1, nsp
            nncx(l,ibas) = mod(konf(l+1,ibas),10)-1 -(l+1) +1
            nnc          = max(nnc,nncx(l,ibas))
            do  kkk = l+1, mod(konf(l+1,ibas),10)-1
              icore = icore+1
              read(ifigwa) icore,ldummy,ispx,kkkdummy,ec_A(icore)
              read(ifigwa)
            enddo
          enddo
        enddo
        deallocate(rofi_A,ec_A)
        if(nr_A   >nrmx   ) nrmx    = nr_A
        if(ncore  >ncoremx) ncoremx = ncore
      enddo

!! == ATOMIC PART ic = ibas scheme ==
!! ... augmentation indexing information
      ifi = fopnx('NLAindx',2,1,-1)
      rewind ifi
      allocate(nindx(ldim2),lindx(ldim2),ibasindx(ldim2))
      call rdibasindx2(ldim2,nphi,nphimx,nindx,lindx,ibasindx,ifi)
      ncoremx = ncoremx/nsp
      allocate(ec_d(ncoremx, nclass, nsp),gx_d (nrmx, 0:lmxamx, nphimx,  nclass,nsp),
     & gcore_d(nrmx, ncoremx, nclass,nsp)  )
      gx_d = 0
      rewind ifigwa
      nnc =0
      konf =0
      write(6,'(/'' File gwa: reading atom data'')')
      do 3001 ibas = 1, nbas
        read(ifigwa) z, nr_A, a_A, b_A, rofi_Anr,lmxa,nspdummy,ncore
        allocate(rofi_A(nr_A),
     &  gcore_A(nr_A,ncore),ec_A(ncore))
        read(ifigwa) konf(1:lmxa+1,ibas)
        read(ifigwa) rofi_A(1:nr_A)
        write(6,369) ibas,z,rofi_A(nr_A),lmxa,konf(1:lmxa+1,ibas)
  369   format(' site',i3,'  z=',f5.1,'  rmax=',f8.5,'  lmax=',i1,'  konf=',10i1)
!!       A bit rough treatment
        ic    = iclass(ibas)
        zz(ic)= z
        aa(ic)= a_A
        bb(ic)= b_A
        nr(ic)= nr_A
        ncore_d(ic) = ncore/nsp
        konf_d(0:lmxa,ic) = konf(1:lmxa+1,ibas)
        write(6,371)
  371   format('  l    g(rmax)    gp(rmax)',4x,'<g g>',9x,'<gp gp>',9x,'<g gp>')
!! --- PHIU
        do  l = 0, lmxa
          do  isp = 1, nsp
            read(ifigwa) lxx,ispxx  !!!ibas==ic,l,n=1
            if(lxx /= l .or. isp /=ispxx) stop 'hhbecfp:lxx or isp wrong'
            read(ifigwa) gx_d(1:nr_A,l,1,ic,isp)
            read(ifigwa) gx_d(1:nr_A,l,2,ic,isp)
            if (konf_d(l,ic) .ge. 10) read(ifigwa) gx_d(1:nr_A,l,3,ic,isp)

            m = 2
            if (konf_d(l,ic) .ge. 10) m = 3
            n = 0
            do  i1 = 1, m
              do  i2 = 1, i1
                n = n+1
                call gintxx(gx_d(1:nr_A,l,i1,ic,isp),
     .          gx_d(1:nr_A,l,i2,ic,isp),a_A,b_A,nr_A,ovv(n))
              enddo
            enddo
            write(6,'(i3,2f11.5,2f15.10,f12.6)')
     .      l,gx_d(nr_A,l,1,ic,isp),gx_d(nr_A,l,2,ic,isp),
     .      ovv(1),ovv(3),ovv(2)
            if (m .eq. 3) write(6,321) gx_d(nr_A,l,3,ic,isp),
     .      ovv(6),ovv(4),ovv(5)
  321       format('  gz(rmax); <gz gz> <gz g> <gz gp> = ',f8.5,
     .      f15.10,2f12.7)

          enddo
        enddo
!! --- ECORE PHICU
        if (ncore .ne. 0)
     .  write(6,'(''  l  k isp       ecore      gc(rmax)     <gc gc>'')')
        icore = 0
        icors = 0
        do isp = 1, nsp
          do l = 0, lmxa
            nncx(l,ibas) = mod(konf(l+1,ibas),10)-1 -(l+1) +1
            nnc          = max(nnc,nncx(l,ibas))
            do  kkk = l+1, mod(konf(l+1,ibas),10)-1
              icore = icore+1
              icors(isp) = icors(isp) +1
              icor1=icors(isp)
              read(ifigwa) icorex,ldummy,ispx,kkkdummy,ec_A(icore)
              if(icore/=icorex)  stop 'lmf2gw:icore/=icorex'
              read(ifigwa) gcore_A(1:nr_A,icore)
              ec_d(icor1, ic, isp) = ec_A(icore)
              gcore_d(1:nr_A,icor1,ic,isp)  = gcore_A(1:nr_A,icore)
              call gintxx(gcore_A(1,icore),gcore_A(1,icore), a_A,b_A,nr_A,ovv(1))
              write(6,'(3i3,f15.6,f12.6,f15.10,3i3)')
     &        l,kkk,isp,ec_A(icore),gcore_A(nr_A,icore),ovv(1),icore,icor1
            enddo
          enddo
        enddo
        deallocate(rofi_A,gcore_A,ec_A)
 3001 continue
      allocate(iantiferro(nbas))
      read(ifigwa)iantiferro(1:nbas)      !iantiferro may2015

      ifi=501
      open (ifi,file='DATA4GW_V2',form='unformatted')
      call gwinput_v2x(-ifi,
     & nsp,   nbas,   nclass, nrmx,   ncoremx,
     & lmxamx, ngpmx,  nbandmx,  ldim2,   nqbze ,
     & nphi,nphimx, nindx, lindx, ibasindx,
     & iclass,lmxa_d,nr,konf_d,ncore_d,
     & zz,aa,bb,bas,alat,plat,
     & qbze,efermi,ec_d,evl_d,vxclda,gx_d,gcore_d,cphi_d,geig_d,nocore)
      write(ifi) iantiferro(1:nbas) !may2015
      write(ifi) spid(1:nbas) !nov2015
      close(ifi)
      write(6,"(a,100i4)") ' antiferro index=',iantiferro(1:nbas)
      do ibas=1,nbas
        write(6,"(a,i4,a)") ' i spid=',ibas,' '//trim(spid(ibas))
      enddo

c      stop ' OK! lmf2gw: end --- DATA4GW_V2 is written '
      call rx0( ' OK! lmf2gw: end --- DATA4GW_V2 is written ')
      end program lmf2gw

      subroutine rx0(string)
c  write extra information before error exit in standard format
      character*(*) string
      write(6,892) string
  892 format(/' ---- ',a,a)
      call exit(0)
      end
!!--------------------------------------------------------------------------------


      subroutine strip(str,i1,i2)
C!  strip(str,i1,i2) -- Returns i1,i2 so that str(i1:i2) stripped.
      character*(*) str
      i1=0
      do 1 i=1,len(str)
        if(str(i:i).ne.' ') then
          i1=i
          goto 2
        endif
  1   continue
      i1=1
      i2=0
      return
  2   i2=len(str)+1
      do 3 i=len(str),1,-1
        if(str(i:i).ne.' ') then
          i2=i
          goto 4
        endif
  3   continue
  4   continue
      end

      subroutine words(str,nw)
C- Count blank-delimited words in str
C ----------------------------------------------------------------------
Ci Inputs
Ci   str   :string
Co Outputs
Co   nw    :number of blank-delimited words in str
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      character*(*) str
      integer nw
C ... Local parameters
      integer i1,i2,i0,i

      nw = 0
      i1 = 0
      i2 = 0
      i0 = 1
   99 do  10  i = i0, len(str)
        if(str(i:i) .ne. ' ') then
          i1 = i
          goto 90
        endif
   10 continue
      return
   90 nw = nw+1
      do  20  i = i1,len(str)
        if(str(i:i) .eq. ' ') then
          i2 = i
          goto 91
        endif
   20 continue
      return
   91 i0 = i2
      goto 99
      end
      subroutine word(str,iw,j1,j2)
C- Returns j1,j2 so that str(j1:j2) is the iw-th word from beginning
C ----------------------------------------------------------------------
Ci Inputs
Ci   str   :string
Ci   iw    :find iw-th word
Co Outputs
Co   j1    :str(j1:j2) is iw-th word
Co   j2    :-//-
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      character*(*) str
      integer iw,j1,j2
C ... External calls
      external nword
      j1 = 1
      call nword(str,iw,j1,j2)
      end

      subroutine nword(str,iw,j1,j2)
C- Returns j1,j2 so that str(j1:j2) is the iw-th word from current pos
C ----------------------------------------------------------------------
Ci Inputs
Ci   str   :string
Ci   iw    :find iw-th word
Ci   j1    :start search from str(j1:)
Co Outputs
Co   j1    :str(j1:j2) is iw-th word
Co   j2    :-//-
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer iw,j1,j2
      character*(*) str
C ... Local parameters
      integer nw,i1,i2,i0,i
      nw = 0
      i1 = 0
      i2 = 0
      i0 = j1
      j2 = -1
  99  do  10  i = i0, len(str)
C   ... skip until nonblank char
        if(str(i:i) .ne. ' ') then
          i1 = i
          goto 90
        endif
  10  continue
      return
C   ... skip until a blank char
  90  nw = nw+1
      if (nw .eq. iw) j1 = i1
      do  20  i = i1, len(str)
        if(str(i:i) .eq. ' ') then
          i2 = i
          goto 91
        endif
   20 continue
C ... We have reached the end of the string
      if (nw .eq. iw) j2 = len(str)
      return
C ... cleanup: exit if word sought, else try again
   91 i0 = i2
      if (nw .eq. iw) then
        j2 = i2-1
        return
      endif
      goto 99
      end


      SUBROUTINE GINTxx(G1,G2,A,B,NR,SUM)
C- Integrate product of two wave functions, Simpson rule
C ----------------------------------------------------------------
c takao \sum_i g(i)*g(i) drdi
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      double precision G1(NR),G2(NR),a,b
      EA2 = DEXP(A + A)
      SUM = 0D0
      DRDI = (A*B)*DEXP(A)
      DO  10  IR = 2, NR-1, 2
        SUM = SUM + G1(IR)*G2(IR)*DRDI
        DRDI = DRDI*EA2
  10  CONTINUE
      SUM = SUM + SUM
      DRDI = (A*B)*EA2
      DO  11  IR = 3, NR-2, 2
        SUM = SUM + G1(IR)*G2(IR)*DRDI
        DRDI = DRDI*EA2
  11  CONTINUE
      RMPB = B*DEXP(A*(NR-1))
      SUM = (2*SUM+ G1(1)*G2(1)*(A*B) + G1(NR)*G2(NR)*(A*RMPB))/3d0
      END

      integer function fopna(fnam,lunit,ista)
C- File opening
C ----------------------------------------------------------------
Ci Inputs
Ci    fnam:  file name
Ci   lunit:  file logical lunit.  If passed lunit is -1, program finds
Ci           the next available logical unit; see Remarks.
Ci   ista:   status switches governing mode of file opening; see Remarks
Co Outputs
Co   fopna returns logical lunit number for file name
Cr Remarks
Cr   fopnx, below, is an all-purpose file-handling routine that
Cr   keeps an internal table that maintains an association of filenames
Cr   with their logical unit and status.  It is intended
Cr   to facilitate reference to files without carrying around
Cr   the logical unit number or file status.  Several 'front end'
Cr   routines listed here call fopnx with special arguments.
Cr
Cr   fopng(fnam,lunit,ista):
Cr     opens file 'fnam' with attributes set by 'ista',
Cr     assigns logical unit 'lunit', and returns the logical unit.
Cr     If lunit<0, fopnx will assign the logical unit
Cr     If fopnx has no record of this file name or logical unit in its
Cr     internal table, the file name and lunit are added to the table.
Cr     If fopnx does has a record of the logical unit, that unit and
Cr     the corresponding filename are used for file handling.  Else:
Cr     If fopnx does has a record of the file name, that name and
Cr     corresponding lunit are used for file handling.
Cr
Cr      Ista is a composite of integers a, b, c, d, stored as digits
Cr      abcd, base 2.
Cr      Bits 01: 0, open the file as 'UNKNOWN'
Cr               1, open the file as 'OLD'
Cr               2, open the file as 'NEW'
Cr      Bit 2:   1, open file as unformatted.
Cr      Bit 3:   1, do not add this file to the file table
Cr      Thus ista=5 opens file unformatted, status='old'
Cr
Cr   fopna(fnam,lunit,ista):
Cr     is identical to fopng, except that 'fnam' a path is prepended
Cr     to, and extension is appended to 'fnam'.  'path' and 'ext'
Cr     are set and recovered with:
Cr
Cr   fext(ext)     sets extension
Cr   fpath(path)   sets path
Cr   fextg(ext)    recovers extension
Cr   fpathg(ext)   recovers path
Cr
Cr   fadd(fnam,lunit,ista) adds 'fnam' to the internal table.
Cr
Cr   fopn(fnam)  is equivalent to fopna(fnam,0,-1)
Cr
Cr   fopnn(fnam)   same as fopn, but open with status='NEW'
Cr   fopno(fnam)   same as fopn, but open with status='OLD'.
Cr
Cr   fxst(fnam)    inquires as to whether file exists
Cr
Cr   ffnam(fnam,fnam) returns full file name
Cr
Cr   fhndl(fnam) returns with logical lunit associated with name,
Cr     and -1 if none exists.
Cr
Cr   fclr(fnam,unit) clears the file name from the internal table,
Cr     and closes the file if open.
Cr
Cr   ftflsh(unit) flushes output buffer of logical unit.
Cr     This routine is nonstandard, and works only some some machines.
Cr     unit = stdout calls a C-language routine that flushes stdout
Cr     unit < 0 calls a C-language routine that flushes all buffers
Cr
Cr   fshow lists the internal table
C ----------------------------------------------------------------
C     implicit none
C Passed parameters
      character*(*) fnam
      integer ista,lunit
C Local parameters
      integer fext,fextg,fopn,fopno,fopnn,fhndl,
     .fadd,fxst,fpath,fpathg,fopng,fopnx
      integer mode
C#ifndef AIX
      mode = 100 + 70*mod(ista/8,2)
      fopna = fopnx(fnam,mode,mod(ista,8),lunit)
      return

      entry fopng(fnam,lunit,ista)
      mode =   2 + 70*mod(ista/8,2)
      fopng = fopnx(fnam,mode,mod(ista,8),lunit)
      return

      entry fadd(fnam,lunit,ista)
      mode = 114 + 70*mod(ista/8,2)
      if (lunit .lt. 0) mode = mode-4
      fadd = fopnx(fnam,mode,mod(ista,8),lunit)
      return

      entry fopn(fnam)
      fopn = fopnx(fnam,100,0,-1)
      return

      entry fopno(fnam)
      fopno = fopnx(fnam,100,8+1,-1)
      return

      entry fopnn(fnam)
      fopnn = fopnx(fnam,100,8+2,-1)
      return

      entry fxst(fnam)
      fxst = fopnx(fnam,170,-1,-1)
      return

      entry fhndl(fnam)
      fhndl = fopnx(fnam,184,-1,-1)
      return

      entry fext(fnam)
      fext = fopnx(fnam,120,0,-1)
      return

      entry fpath(fnam)
      fpath = fopnx(fnam,140,0,-1)
      return

      entry fextg(fnam)
      fextg = fopnx(fnam,130,0,-1)
      return

      entry fpathg(fnam)
      fpathg = fopnx(fnam,150,0,-1)
      return
      end

      subroutine fclr(fnam,lunit)
C     implicit none
C Passed parameters
      character*(*) fnam
      integer lunit,fopnx,i

      i = fopnx(fnam,111,0,lunit)
      return

      entry fshow()
      i = fopnx(' ',190,0,-1)
      end
      subroutine ffnam(fnam,filnam)
C- Appends extension to fnam
C     implicit none
      character*(*) fnam,filnam
      integer i,fopnx
      filnam = fnam
      i = fopnx(filnam,160,0,-1)
      end

      integer function fopnx(pnam,mode,ista,lunit)
C- Kernel called by fopna, etc to open files
C  THIS IS A STRIPPED DOWN VERSION OF slatsm/fopna.f.
C  IT DOES NOT PRINT ANYTHING OUT; CONVERSION TO LOWER CASE SUPPRESSED.
C ----------------------------------------------------------------
Ci Inputs
Ci   pnam:   file name, or portion of file name, depending on mode
Ci   mode:   1s digit (for 10s digit 0)
Ci           0  Find lunit, ista from name.
Ci              pnam is name sans path, extension
Ci              If name does not exist, add to table, assign lunit.
Ci              Subsequent file handling depends on ista.
Ci           1  Remove name from internal table.  Close file if open.
Ci              Error if name is missing from table.
Ci          ... Add 2 if pnam is already full name
Ci          ... Add 4 to require lunit match internal table
Ci                    returns -1 if lgunit<0 and pnam missing from table
Ci          10s digit:
Ci           ... 1..6,8,9 suppress file handling
Ci           ... 1..9 suppresses messing with tables.
Ci           1  Suppress any file handling
Ci           2  copy pnam to extension
Ci           3  copy extension into pnam
Ci           4  copy pnam to path
Ci           5  copy path into pnam
Ci           6  copy full file name into pnam.
Ci         7,8  Do not alter internal tables
Ci           8  Suppress any file handling
Ci           9  Show internal tables
Ci          100s digit
Ci           1  convert pnam to lower case
Ci   ista:  -1  return 1 if file exists, 0 otherwise
Ci         >=0  sets flags file file status on opening.  This status
Ci              is kept and used along with the file table.  Internal
Ci              values are used except when missing or preempted:
Ci           ...The following bits work as independent switches:
Ci           ...bits 0,1:
Ci           0  open the file as 'UNKNOWN', if not open already
Ci           1  open the file as 'OLD'
Ci           2  open the file as 'NEW'
Ci           ...bit 2:
Ci           4  open the file as 'UNFORMATTED'
Ci           ...bit 3:
Ci           8  Override internal ista for bits 0,1
Ci          16  Override internal ista for bit 2
Ci   lunit:  (lunit>0) if in table, uses lunit to match instead of name
Ci              UNLESS mode, 10s digit set.
Cr Remarks
Cr   mxnam is maximum number of files that may be open at one time.
Cr   All file closings should be made through entry fclose
Cr   17 June 97 internal ista bits 0,1 ALWAYS 0,
Cr              making default file opening 'unknown'
C ----------------------------------------------------------------
C     implicit none
C Passed Parameters
      integer ista,lunit,mode
      character*(*) pnam
      character*11 ftnfmt
C Local variables
      logical bittst,isopen,ldum,mod100
      integer bit,bitand,getdig,i,i1,i2,iprint,locuni,lsta,matchn,
     .matchu,mode1,mode10,n,IDBG,isw
      character ftnsta*7, outs*80
C Parameters concerning limits to string size in filenames:
C plen: path length; extlen: ext length; maxsiz: name (including ext)
      integer maxsiz,extlen,plen
      parameter (extlen=20, plen=80, maxsiz=100)
      parameter (IDBG=110)
      integer mxnam
      parameter (mxnam=3000)
      character*(maxsiz) tabnam(mxnam),pfnam,fnam
      character*(extlen) ext
      character*(plen) path
      integer tabsw(mxnam), tabuni(mxnam),nnam,lgunit
      save tabnam, tabsw, tabuni, nnam, ext, path
      data nnam /0/
C#ifdef FEXTENS
      data ext /'.dat'/
C#elseC
C      data ext /' '/
C#endif
      data path /' '/

      bittst(n,bit) = (mod(n,bit+bit) - mod(n,bit) .eq. bit)

      mode1   = getdig(mode,0,10)
      mode10  = getdig(mode,1,10)
      mod100 = getdig(mode,2,10) .ne. 0

C --- Cases handling partial file names ---
      fopnx = 0
C ... Change extension
      if (mode10 .eq. 2) then
        call namcat(ext,pnam,' ',mod100)
C        if (iprint() .ge. IDBG) call awrit0(
C     .    ' FOPNX: set ext to "'//ext//'%a"',' ',80,lgunit(1))
        return
C ... Copy extension into pnam
      elseif (mode10 .eq. 3) then
        call namcat(pnam,ext,' ',.false.)
        return
C ... Change path
      elseif (mode10 .eq. 4) then
        call word(pnam,1,i1,i2)
        if (i2 .le. 0) then
          path = ' '
C        elseif (pnam(i2:i2) .eq. '/') then
C          call namcat(path,pnam,' ',mod100)
C        else
C          call namcat(path,pnam,'/',mod100)
        else
          call namcat(path,pnam,' ',mod100)
        endif
C        if (iprint() .ge. IDBG) call awrit0(
C     .    ' FOPNX: set path to "'//path//'%a"',' ',80,lgunit(1))
        return
C ... Copy path into pnam
      elseif (mode10 .eq. 5) then
        call namcat(pnam,path,' ',.false.)
        return
C ... Show internal table
      elseif (mode10 .eq. 9) then
C        call awrit3('%N fopen:  %i files in table.'//
C     .    '%?;n;  path='''//path//'%a'';;'//
C     .    '%?;n;  ext='''//ext//'%a'';;',' ',-80,lgunit(1),nnam,
C     .    isw(path.ne.' '),isw(ext.ne.' '))
C        n = 0
C        do  10  i = 1, nnam
C          call word(tabnam(i),1,i1,i2)
C          n = max(n,i2)
C   10   continue
C        n = n+2
C        call awrit1(' file%npunit   mode  open',' ',80,lgunit(1),n)
C        call pshpr(0)
C        do  11  i = 1, nnam
C          call awrit4(' '//tabnam(i)//
C     .      '%np%,2i    %?;n==0;  fmt;unfmt;   %l',' ',80,lgunit(1),n,
C     .      tabuni(i),bitand(tabsw(i),4),isopen(tabuni(i),.false.))
C   11   continue
C        call poppr
C        print *, ' '
        return

      endif

C --- Make full file name ---
      if (bittst(mode1,2)) then
        call namcat(pfnam,pnam,' ',mod100)
      else
        call namcat(pfnam,pnam,' ',mod100)
        call namcat(fnam,pfnam,ext,.false.)
        call namcat(pfnam,path,fnam,.false.)
      endif

C ... Return full file name in pnam
      if (mode10 .eq. 6) then
        call namcat(pnam,pfnam,' ',.false.)
        return
      endif

C --- Match lunit with table.  matchu=-1 unless a match exists ---
      matchu = -1
      if (lunit .gt. 0) then
        do  110  i = 1, nnam
          matchu = i
          if (tabuni(i) .eq. lunit) goto 111
  110   continue
        matchu = -1
  111   continue
      endif

C --- If no match, get next available unit number => locuni ---
      locuni = lunit
      if (matchu .eq. -1 .and. lunit .lt. 0) then
        locuni = 7
   12   locuni = locuni+1
        if (isopen(locuni,.false.)) goto 12
        do  14  i = 1, nnam
          if (tabuni(i) .eq. locuni) goto 12
   14   continue
      endif

C --- Match pfnam with table, unless not needed ---
      matchn = matchu
      if (matchu .le. 0 .or. bittst(mode1,4)) then
        do  30  i = 1, nnam
          matchn = i
          if (tabnam(i) .eq. pfnam) goto 31
   30   continue
        matchn = -1
   31   continue
      endif
      if (lunit .lt. 0 .and. matchn .gt. 0) then
        matchu = matchn
        locuni = tabuni(matchn)
      elseif (lunit .lt. 0 .and. bittst(mode1,4)) then
C        call rxs('fopnx: no unit or name specified, file ',pnam)
        fopnx = -1
        return
      endif

      fopnx = locuni

C ... Force match between name and unit, or error
C      call awrit1('%xFOPNX: file '//pfnam//'%a, unit %i, '//
C     .  'conflicts with prior use',outs,80,0,locuni)
      if (matchu .ne. matchn .and. bittst(mode1,4)) then
C        if (matchu .gt. 0)
C     .    call awrit0('%a%10b file '//tabnam(matchu),outs,80,0)
        call rx(outs)
      endif

C --- Add a file to internal table ---
      if (matchu .lt. 0 .and. mode10 .le. 6) then
        if (mod(mode1,2) .eq. 1) then
          if (lunit .gt. 0)
     .    call rxi('FOPNX: attempt to remove nonexistent unit',lunit)
          call rx('FOPNX: attempt to remove nonexistent name ')
        endif
        nnam = nnam+1
        if (nnam .gt. mxnam) call
     .  rxi('FOPNX: too many file names.  max=',mxnam)
        tabnam(nnam) = pfnam
        tabuni(nnam) = locuni
        tabsw(nnam)  = mod(ista,8) - mod(ista,4)
        matchu = nnam
C --- Remove a file entry from the internal table ---
      elseif (mod(mode1,2) .eq. 1 .and. mode10 .le. 7) then
        i = tabuni(matchu)
        if (isopen(i,.false.)) call fclose(i)
        do  130  i = matchu+1, nnam
          tabnam(i-1) = tabnam(i)
          tabuni(i-1) = tabuni(i)
          tabsw(i-1)  = tabsw(i)
  130   continue
        nnam = nnam-1
        return
      endif

C#ifdefC DEBUG
C      if (iprint() .ge. IDBG) then
C        call pshpr(0)
C        call awrit3(' FOPEN: file '//pfnam//'%a unit %i  status %i'//
C     .  ' open=%l',' ',80,lgunit(1),locuni,ista,isopen(locuni,.false.))
C        call poppr
C      endif
C#endif

C --- Cases ista=-2,-1 ---
      if (ista .eq. -2 .or. mode10 .ne. 0 .and. mode10 .ne. 7) return
      if (ista .eq. -1) then
C#ifdefC PRECONNECTED_UNITS | IBM_VM
C        INQUIRE(UNIT=lunit,EXIST=ldum)
C#else
        INQUIRE(FILE=pfnam,EXIST=ldum)
C#endif
        fopnx = 0
        if (ldum) fopnx = 1
        return
      else
      endif

C ... Format status
      lsta = ista
      if (matchu .gt. 0) then
C        lsta = tabsw(matchu)
C        if (bittst(ista,8))  lsta = bitand(lsta,1023-3) + bitand(ista,3)
C        if (bittst(ista,16)) lsta = bitand(lsta,1023-4) + bitand(ista,4)
C        tabsw(matchu) = lsta - mod(lsta,4)
        lsta = bitand(lsta,1023-4) + bitand(tabsw(matchu),4)
        if (bittst(ista,16)) then
          lsta = bitand(lsta,1023-4) + bitand(ista,4)
          tabsw(matchu) = bitand(tabsw(matchu),1023-4) + bitand(ista,4)
        endif
      endif
      ftnfmt = 'FORMATTED'
      if (bittst(lsta,4)) ftnfmt = 'UNFORMATTED'

C ... Handle fortran status (slow, but apparently stable)
      ftnsta = 'UNKNOWN'
      if (mod(lsta,4) .eq. 1) ftnsta = 'OLD'
      if (mod(lsta,4) .eq. 2) then
        ftnsta = 'NEW'
        call fclose(locuni)
C#ifdefC PRECONNECTED_UNITS | IBM_VM
C        open(locuni,FORM=ftnfmt,STATUS='UNKNOWN')
C#else
        open(locuni,FILE=pfnam,FORM=ftnfmt,STATUS='UNKNOWN')
C#endif
        close(unit=locuni,status='DELETE')
      endif

c      print *, 'dbg: fopn',pfnam,locuni,lsta,ftnfmt,ftnsta

      if (.not. isopen(locuni,.true.)) then
        call word(pfnam,1,i1,i2)
        call chrpos(pfnam,' ',plen+maxsiz,i)
        if (iprint() .ge. IDBG) print *, 'FOPEN: opening ',ftnfmt,
     .  ' file ''',pfnam(1:i2),''', status=',ftnsta,', unit=',locuni
C#ifdefC PRECONNECTED_UNITS | IBM_VM
C        open(locuni,FORM=ftnfmt,STATUS=ftnsta)
C#else
        open(locuni,FILE=pfnam(i1:i2),FORM=ftnfmt,STATUS=ftnsta)
        rewind locuni
C#endif
      endif

      end
      logical function isopen(unit,sw)
C- Returns whether unit aleady open; optionally adds unit to list if not
C ----------------------------------------------------------------
Ci Inputs
Ci   unit: if unit not among list of open files, add to list
Ci   sw:   if false, return isopen but do not add to list
Co Outputs
Co   isopen
Cr Remarks
Cr   maxfil is maximum number of files that may be open at one time
Cr   All file closings should be made through entry fclose
C ----------------------------------------------------------------
C     implicit none
      integer unit
      logical sw
      integer i,iprint
      integer maxfil
      parameter (maxfil=3000)
      integer unitab(0:maxfil-1),nopen
      common /funits/ unitab,nopen

      if (iprint() .gt. 110) print 20, unit, (unitab(i), i=0, nopen-1)
   20 format(/' ISOPEN: check logical unit',i3,
     .' among open units: ',15i3)

      isopen = .true.
      do  10  i = nopen-1, 0, -1
        if (unitab(i) .eq. unit) return
   10 continue

      isopen = .false.
      if (.not. sw) return
      unitab(nopen) = unit
      nopen = nopen+1
      if (nopen .gt. maxfil) call rx('ISOPEN: too many files')
      end
      subroutine fclose(unit)
C- Closes an open file, removing unit from the stack
C ----------------------------------------------------------------
Ci Inputs
Ci   unit
Co Outputs
Co   none
Cr Remarks
Cr   use in conjunction with isopen
C ----------------------------------------------------------------
C     implicit none
      integer unit
      integer i,iprint
      character*6 clstat
      integer maxfil
      parameter (maxfil=3000)
      integer unitab(0:maxfil-1),nopen
      common /funits/ unitab,nopen

      clstat = 'KEEP'
      goto 10

   10 continue
      if (iprint() .ge. 100) print 20, unit
   20 format(' FCLOSE: closing',i3)

      do  30  i = nopen-1, 0, -1
        if (unitab(i) .eq. unit) unitab(i) = 999
   30 continue
      call ishell(nopen,unitab)
      if (nopen .eq. 0 .or. unitab(max(nopen-1,0)) .ne. 999) then
        if (iprint() .ge. 100)
     .  print *, 'FCLOSE: attempt to close unopened file'
      else
        close(unit=unit,status=clstat)
        nopen = nopen-1
      endif
      return

      entry dfclos(unit)
      clstat = 'DELETE'
      goto 10

C --- Close all open files ---
      entry closea()
      do  50  i = 0, nopen-1
        if (iprint() .ge. 100) print *,'CLOSEA: closing file ',unitab(i)
        close(unit=unitab(i),status='KEEP')
        unitab(i) = 999
   50 continue
      nopen = 0
      return
      end
      integer function lgunit(i)
C- Returns stdout for i=1, log for i=2
C     implicit none
      integer i, fopn, i1mach, fhndl
C     lgunit = i1mach(2)
      lgunit = 6
      if (i .eq. 1) return
      lgunit = -1
      if (fhndl('LOG') .lt. 0) return
      lgunit = fopn('LOG')
      end
      subroutine namcat(dest,fnam1,fnam2,lcase)
C- Concatenates two names, optionally lowering the case
C     implicit none
      logical lcase
      character*(*) fnam1,fnam2,dest
      integer iprint,i1,i2,j1,j2

      call word(fnam1,1,i1,i2)
      call word(fnam2,1,j1,j2)
      i2 = max(i1-1,i2)
      j2 = max(j1,j2)
      dest = fnam2(j1:j2)
      if (i2 .ge. i1) dest = fnam1(i1:i2)//fnam2(j1:j2)
      if (i2-i1+j2-j1+2 .gt. len(dest) .and. iprint() .gt. 0) then
        print *, 'namcat: string "',fnam1(i1:i2),fnam2(j1:j2),
     .  '" was truncated to "',dest,'"'
      endif

C#ifdef unix
C     if (lcase) call locase(dest)
C#endif

      end
      subroutine ftflsh(ifi)
C- Flushes output buffer for file ifi
C  NB: this routine is nonstandard, and machine-dependent.
C     implicit none
      integer ifi
      character fname*101,fmt*33
      integer i1mach,j1,j2
      logical open

C      if (ifi .eq. i1mach(2)) then
C        call flushs(1)
C      elseif (ifi .lt. 0) then
C        call flushs(-1)
CC#ifdefC AIX
CC      else
CC        inquire (UNIT=ifi,OPENED=open,NAME=fname,FORM=fmt)
CC        call word(fname,1,j1,j2)
CCC        write (6,220) ifi,open,fname(j1:j2),fmt
CCC  220   format(' unit',i3,' open=',l1,'  name=',a,'  fmt=',a)
CC        if (open) then
CC          close(ifi)
CC          open(ifi, file=fname, form=fmt, status='old')
CC        endif
CC#endif
C      endif
      end
      subroutine rx(string)
c  routine for error exit
      character*(*) string
      write(6,892) string
      write(6,890)
  890 format(' ---- Error exit')
  892 format(/' ---- ',a)
      stop
      end
      subroutine rxi(string,i)
c  error exit with printout of one integer
      character*(*) string
      write(6,892) string,i
      write(6,890)
  892 format(/' ---- ',a,i8)
  890 format(' ---- Error exit')
      stop
      end

      integer function getdig(n,i,base)
C- Extracts one digit from an integer
C ----------------------------------------------------------------
Ci Inputs
Ci   n,i,base
Co Outputs
Co   getdig = ith digit from n, base "base"; eg 4=getdig(12345,1,10)
C ----------------------------------------------------------------
C     implicit none
      integer n,i,base
      getdig = mod(n/base**i,base)
      end

      integer function bitand(a,b)
C- Returns the bitwise AND of two integers
C     implicit none
      integer a,b
      integer TF(64),i,n,i1,i2
      if (a .lt. 0) then
        bitand = b
      elseif (b .lt. 0) then
        bitand = a
      else
        i1 = a
        i2 = b
        n = 0
        do  10  i = 1, 64
          if (i1 .eq. 0 .or. i2 .eq. 0) goto 12
          TF(i) = (mod(i1,2)+mod(i2,2))/2
          i1 = i1/2
          i2 = i2/2
          n = n+1
   10   continue
   12   continue
        bitand = 0
        do  20  i = n, 1, -1
          bitand = bitand*2 + tf(i)
   20   continue
      endif
      end

      subroutine chrpos(s,ch,maxch,ich)
C- Finds position of character in string
C ----------------------------------------------------------------
Ci Inputs
Ci   s:   string (declared as s(0:*)
Ci   ch:  character sought
Ci   ich: start search at s(ich)
ci   maxch: see ich
Co Outputs
Co   ich: position of character ch, not to exceed maxch
Cr Remarks
Cr    seeks match at string(i0), string(i0+1) until ch is found or until
Cr    ich = maxch.
C ----------------------------------------------------------------
C     implicit none
      integer ich,maxch
      character*1 ch,s(0:*)

   10 if (ich .eq. maxch  .or.  s(ich) .eq. ch) return
      ich = ich+1
      goto 10
      end

C --- Verbosity stack functions ---
C Functions are:
C iprint(): return value from top of stack
C pshprt(vb): push value onto top of stack
C popprt:     pop verbosity stack
C togprt:     exhanges position of top two values on stack
C setpr(vb):  replace top of stack with vb
C getpr(vb):  set vb to value at top of stack
C iprt(istk): return verbosity istk levels down
C sprt(istk,vb): sets verbosity istk levels down
C --- iprint, iprt ---
      integer function iprint()
C- get last integer off print priority stack
C     implicit none
      integer nstack,istk,iprt
      parameter (nstack=6)
      integer vstack(0:nstack-1),stackp
      common /iprnt/ vstack,stackp
      iprint = vstack(stackp)
      return

      entry iprt(istk)
      iprt = vstack(mod(stackp+istk,nstack))
c      print*, istk,iprt,stackp,vstack
      end
C --- pshprt, pshpr, setpr, getpr, popprt, poppr --
      subroutine pshprt(vb)
C     implicit none
      entry pshpr(vb)
      integer vb,istk,j
      integer nstack
      parameter (nstack=6)
      integer vstack(0:nstack-1),stackp
      common /iprnt/ vstack,stackp
      stackp = mod(stackp+(nstack-1),nstack)

      entry setpr(vb)
      vstack(stackp) = vb
      return

      entry getpr(vb)
      vb = vstack(stackp)
      return

      entry popprt()
      entry poppr()
      stackp = mod(stackp+1,nstack)
      return

      entry sprt(istk,vb)
      vstack(mod(stackp+istk,nstack)) = vb
      return

      entry shopr()
      print 333, (vstack(mod(stackp+j,nstack)), j=0,nstack-1)
  333 format(' vb stack',10i4)
      end

C --- togprt ---
      subroutine togprt
C     implicit none
      integer nstack
      parameter (nstack=6)
      integer vstack(0:nstack-1),stackp
      common /iprnt/ vstack,stackp
      integer itmp,jtmp

      entry togpr()
      itmp = vstack(stackp)
      call popprt
      jtmp = vstack(stackp)
      call popprt
      call pshprt(itmp)
      call pshprt(jtmp)
      end
C --- Defaults ---
      block data iprntb
C     implicit none
      integer nstack
      parameter (nstack=6)
      integer vstack(0:nstack-1),stackp
      common /iprnt/ vstack,stackp
      data vstack /30,30,30,30,30,30/, stackp /0/
      end

c$$$      subroutine gwinput(ifi,
c$$$     &  nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$     &  lmxamx,ngpmx,  nband,  ldim,   nqbze ,
c$$$c
c$$$     &  iclass,lmxa,nr,konf,ncore,
c$$$     &  zz,aa,bb,bas,alat,plat,
c$$$     &  qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore )
c$$$c- Read and Write the informations required for GW calculations.
c$$$c
c$$$cr When you write these data, you first have to open a file DATA4GW with the file handle ifi>0.
c$$$cr ,e.g,  open(ifi ,file='DATA4GW',form='unformatted')
c$$$cr
c$$$cr Radial mesh is specified from, nr, aa, and bb; mesh is r(i) = bb*(exp(aa*(i-1)) -1) ,i=1,nr
c$$$cr
c$$$cr When you read these data, you first need to read the sizes by the subbroutine gwinput0
c$$$cr in order to allocate required arrays.
c$$$cr
c$$$c----------------------------------------------------------------------------------------------
c$$$C     implicit none
c$$$      integer :: ifi, !File handle. Write for ifi<0. Read for ifi>0.
c$$$     &  nsp,      ! =1 or 2, corresponding to para or ferro.
c$$$     &  nbas,     ! Number of atom in the primitive cell
c$$$     &  nclass,   ! Number of atomic class (or type) for in the primitive cell
c$$$     &  nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
c$$$     &  ncoremx,  ! = maxval(ncore(1:nclass))
c$$$c
c$$$     &  lmxamx,   ! = maxval(lmxa(1:nclass))
c$$$     &  ngpmx,    ! Maximum number of G vector.
c$$$     &  nband,    ! Number of bands given by GWIN0
c$$$     &  ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
c$$$     &  nqbze,    ! = nqbz*(1+nq0i). Number of q points given by qg4gw
c$$$c----
c$$$     &  iclass(nbas),   ! class is starting from 1.
c$$$     &  lmxa  (nclass), ! Maximum l number for each atom for argumentation.
c$$$     &  nr(nclass),     ! Size of radial mesh.
c$$$     &  konf(0:lmxamx,nclass),! Principle quantum numbers of valence electron.
c$$$                              ! For example, 4s4p3d means konf(0)=4, konf(1)=4, konf(2)=3.
c$$$                              ! Core orbitals are specified by
c$$$                              !   1, 2,... konf(0)-1 for s
c$$$                              !   2, 3,... konf(1)-1 for p
c$$$                              !   3, 4,... konf(2)-1 for d, and so on.
c$$$                              ! The 10s digit is used as a separate
c$$$                              ! number to mark whether this channel
c$$$                              ! contains a local orbital:
c$$$                              ! 10s digit
c$$$                              ! 0 -> no local orbital in this channel
c$$$                              ! 1 -> local orbital with energy below valence
c$$$                              ! 2 -> local orbital with energy above valence
c$$$     &  ncore(nclass)   ! ncore = \sum_l  (konf(l)-1) - l
c$$$                        ! Number of different core orbitals for each atom.
c$$$      real(8) ::
c$$$     &  zz(nclass),     ! Atomic number.
c$$$     &  aa(nclass),bb(nclass),! Radial mesh are specified by these parameters with nr.
c$$$     &  bas(3,nbas),    ! Atomic posion in the Cartesian coordinate (alat unit),.
c$$$     &  alat,           ! Lattice constant in a.u.
c$$$     &  plat(3,3),      ! Primitive translation vector in the unit of alat. plat(1:3,1) is 1st vector, ans so on.
c$$$     &  qbze(3,nqbze),  ! q points given by qg4gw
c$$$     &  efermi,         ! Fermi energy. It should be calculated for n1 n2 n3 given by GIWN0.
c$$$c----
c$$$     &  ec(ncoremx, nclass, nsp),   ! Eigenvalues for core
c$$$     &  evl    (nband, nqbze, nsp), ! Eigenvalues
c$$$     &  vxclda (nband, nqbze, nsp), ! Lda XC potential <psi|Vxc(n_total)  |psi>
c$$$                                    !  or   <psi|Vxc(n_valence)|psi>. See nocore.
c$$$     &  gx (nrmx, 0:lmxamx, 2,  nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
c$$$                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
c$$$     &  gcore(nrmx, ncoremx, nclass,nsp)  ! Core radial function.
c$$$c
c$$$c     These radial functions are only the major part given by the scalar relativistic calculations.
c$$$c     gx and gcore = r \phi(r) = u(r), where \phi is the major part of the true radial functions.
c$$$c     gx is normalized as 1 = \int dr gx**2
c$$$c     gcore is the major part of the true radial functions.
c$$$c
c$$$      complex(8)::
c$$$     &  cphi(ldim, 2, nband, nqbze,nsp),! Coefficients of eigenfunction
c$$$                                        ! for phi    = cphi(ldim, 1, nband, nqbze), and
c$$$                                        ! for phidot = cphi(ldim, 2, nband, nqbze).
c$$$     &  geig(ngpmx,   nband, nqbze,nsp) ! Coefficients of eigenfunction for IPW.
c$$$      logical ::
c$$$     &   nocore  ! Flag file NoCore exist or not.
c$$$                 ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
c$$$                 ! If nocore exist. you have to supply
c$$$                 !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
c$$$                 ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
c$$$c----
c$$$      if(ifi>0) then
c$$$        read(ifi)
c$$$     &              iclass,lmxa,nr,konf,ncore,
c$$$     &              zz,aa,bb,bas,alat,plat,
c$$$     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
c$$$      elseif(ifi<0) then
c$$$        write(-ifi)
c$$$     &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$     &              lmxamx,ngpmx,  nband,  ldim,   nqbze
c$$$c
c$$$        write(6,*)
c$$$        write(6,*)' *** DATA4GW size=', nsp,  nbas, nclass, nrmx,ncoremx
c$$$        write(6,*)'                 =', lmxamx,ngpmx, nband, ldim, nqbze
c$$$
c$$$        write(-ifi)
c$$$     &              iclass,lmxa,nr,konf,ncore,
c$$$     &              zz,aa,bb,bas,alat,plat,
c$$$     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
c$$$      else
c$$$        stop 'gwinput: wrong ifi'
c$$$      endif
c$$$      end
c----------------------------------------------------------------------
C       subroutine gwinput0(ifi,
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze    )
C c  Read dimensions only.
C C     implicit none
C       integer::  ifi,
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze
C       read(ifi)
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze
C c    write(6,*)' 0 DATA4GW size=', nsp,   nbas, nclass, nrmx,ncoremx
C c    write(6,*)'                 =', lmxamx,ngpmx,  nband,  ldim, nqbze
C       end
      subroutine ishell(n,iarray)
      integer n
      integer iarray(1)
      integer lognb2,i,j,k,l,m,nn,it

      if (n .le. 1) return
      lognb2 = int(log(float(n+1))*1.4426950)
      m = n
      do  12  nn = 1, lognb2
        m = m/2
        k = n - m
        do  11  j = 1, k
          i = j
    3     continue
          l = i + m
          if (iarray(l) .lt. iarray(i)) then
            it = iarray(i)
            iarray(i) = iarray(l)
            iarray(l) = it
            i = i - m
            if (i .ge. 1) goto 3
          endif
   11   continue
   12 continue
      return
      end
c----------------------------------------------------------------------

      subroutine gwinput_v2x(ifi,
     &nsp,   nbas,   nclass, nrmx,   ncoremx,
     &lmxamx,ngpmx,  nband,  ldim2,   nqbze ,
     &nphi,nphimx,nindx,lindx,ibasindx,
     &iclass,lmxa,nr,konf,ncore,
     &zz,aa,bb,bas,alat,plat,
     &qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore)
c
c     &  ifomit ) !If ifomit=T, omit to store cphi and geig
c- Read and Write the informations required for GW calculations.
c
cr When you write these data, you first have to open a file DATA4GW with the file handle ifi>0.
cr ,e.g,  open(ifi ,file='DATA4GW',form='unformatted')
cr
cr Radial mesh is specified from, nr, aa, and bb; mesh is r(i) = bb*(exp(aa*(i-1)) -1) ,i=1,nr
cr
cr When you read these data, you first need to read the sizes by the subbroutine gwinput0
cr in order to allocate required arrays.
cr
cr NLAindx file should be written by echo 0|lmfgw -------
cr   It should be
cr----NLAindx start---------------
cr     ldim2
cr     n l ibas for each line --- Repeat this line for the number of ldim2.
cr                            --- nphimx=maximum value of n.
cr
c----------------------------------------------------------------------------------------------
C     implicit none
      integer :: ifi, !File handle. Write for ifi<0. Read for ifi>0.
     &nsp,      ! =1 or 2, corresponding to para or ferro.
     &nbas,     ! Number of atom in the primitive cell
     &nclass,   ! Number of atomic class (or type) for in the primitive cell
     &nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
     &ncoremx,  ! = maxval(ncore(1:nclass))
c
     &lmxamx,   ! = maxval(lmxa(1:nclass))
     &ngpmx,    ! Maximum number of G vector.
     &nband,    ! Number of bands given by GWIN0
cv2     &  ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
     &nqbze,    ! = nqbz*(1+nq0i). Number of q points given by qg4gw
c----
     &iclass(nbas),   ! class is starting from 1.
     &lmxa  (nclass), ! Maximum l number for each atom for augmentation.
     &nr(nclass),     ! Size of radial mesh.
     &konf(0:lmxamx,nclass),! Principle quantum numbers of valence electron.
c                              ! For example, 4s4p3d means konf(0)=4, konf(1)=4, konf(2)=3.
c                              ! Core orbitals are specified by
c                              !   1, 2,... konf(0)-1 for s
c                              !   2, 3,... konf(1)-1 for p
c                              !   3, 4,... konf(2)-1 for d, and so on.
c                              !
     &ncore(nclass)   ! ncore = \sum_l  (konf(l)-1) - l
c                        ! Number of different core orbitals for each atom.
c
cv2
      integer:: nphi,          ! number of augmentation nRl channels, as distinct from:
     &ldim2,         ! number of nRLm channels = 2*ldim for phi+phidot case.
     &nphimx,        ! Maxmum number of phi for all l ---  2 for phi+phidot case.
     &nindx(ldim2),  ! n    index
     &lindx(ldim2),  ! l    index
     &ibasindx(ldim2)! ibas index
c
      real(8) ::
     &zz(nclass),     ! Atomic number.
     &aa(nclass),bb(nclass),! Radial mesh are specified by these parameters with nr.
     &bas(3,nbas),    ! Atomic posion in the Cartesian coordinate (alat unit),.
     &alat,           ! Lattice constant in a.u.
     &plat(3,3),      ! Primitive translation vector in the unit of alat. plat(1:3,1) is 1st vector, ans so on.
     &qbze(3,nqbze),  ! q points given by qg4gw
     &efermi,         ! Fermi energy. It should be calculated for n1 n2 n3 given by GIWN0.
c----
     &ec(ncoremx, nclass, nsp),   ! Eigenvalues for core
     &evl    (nband, nqbze, nsp), ! Eigenvalues
     &vxclda (nband, nqbze, nsp), ! Lda XC potential <psi|Vxc(n_total)  |psi>
c                                    !  or   <psi|Vxc(n_valence)|psi>. See nocore.
c
cv2     &  gx (nrmx, 0:lmxamx, 2,  nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
cv2                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
     &gx (nrmx, 0:lmxamx, nphimx, nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
c                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
     &gcore(nrmx, ncoremx, nclass,nsp)  ! Core radial function.
c
c     These radial functions are only the major part given by the scalar relativistic calculations.
c     gx and gcore = r \phi(r) = u(r), where \phi is the major part of the true radial functions.
c     gx is normalized as 1 = \int dr gx**2
c     gcore is the major part of the true radial functions.
c

      complex(8)::
cv2     &  cphi(ldim, 2, nband, nqbze,nsp), ! Coefficients of eigenfunction
cv2                                         ! for phi    = cphi(ldim, 1, nband, nqbze), and
cv2                                         ! for phidot = cphi(ldim, 2, nband, nqbze).
     &cphi(ldim2,  nband, nqbze,nsp),     ! Coefficients of eigenfunction
c
     &geig(ngpmx,  nband, nqbze,nsp)  ! Coefficients of eigenfunction for IPW.


      logical ::
     &nocore  ! Flag file NoCore exist or not.
      ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
      ! If nocore exist. you have to supply
      !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
      ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
c      logical :: ifomit
c----
      if(ifi>0) then
c        if(ifomit) then
        read(ifi)
     &  iclass,lmxa,nr,konf,ncore,
     &  zz,aa,bb,bas,alat,plat,
     &  qbze,efermi,ec,evl,vxclda,gx,gcore,nocore !omit cphi and geig
cv2
     &  ,nindx,lindx,ibasindx
c        else
c          read(ifi)
c     &              iclass,lmxa,nr,konf,ncore,
c     &              zz,aa,bb,bas,alat,plat,
c     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
ccv2
c     &              ,nindx,lindx,ibasindx
c        endif
ccccccccccccccccc
        write(6,*)'gwinput_v2x: DATA4GW_V2 readin size=',
     &  nsp,nbas, nclass, nrmx,ncoremx
        write(6,*)'                 =', lmxamx,ngpmx,nband,ldim2, nqbze
        write(6,*)'ncoremx=',ncoremx
        write(6,*)'ecup=',ec(1:ncoremx, 1, 1)
        if(nsp==2) write(6,*)'ecdn=',ec(1:ncoremx, 1, 2)
ccccccccccccccccc

ccccccccccccccccccccccc
c--- This is a swap test ---
c      call swapc(cphi(5:9,    1:nband,1:nqbze,1:nsp)
c     &          ,cphi(201:205,1:nband,1:nqbze,1:nsp),5*nband*nqbze*nsp)
c      call swapr(gx(1:nrmx,2,1,1,1:nsp),gx(1:nrmx,2,3,1,1:nsp),nrmx*nsp)
c      print *,' ----swap test------'
ccccccccccccccccccccccc


ccccccccccccccccccccccc
c       cphi(201:205,1:nband,1:nqbze,1:nsp) = 0d0
c       print *,' --- skip 4d test ---'
ccccccccccccccccccccccc


c---------------------------
      elseif(ifi<0) then
        write(-ifi)
     &  nsp,   nbas,   nclass, nrmx,   ncoremx,
     &  lmxamx,ngpmx,  nband,  ldim2,   nqbze,
cv2
     &  nphi,nphimx
c
        write(6,*)
        write(6,*)' *** DATA4GW_V2 size=', nsp,nbas,nclass,nrmx,ncoremx
        write(6,*)'                 =', lmxamx,ngpmx, nband,ldim2, nqbze
        write(6,*)'                 =', nphi, nphimx

c        if(ifomit) then
        write(-ifi)
     &  iclass,lmxa,nr,konf,ncore,
     &  zz,aa,bb,bas,alat,plat,
     &  qbze,efermi,ec,evl,vxclda,gx,gcore,nocore !omit cphi and geig
cv2
     &  ,nindx,lindx,ibasindx
c        else
c          write(-ifi)
c     &              iclass,lmxa,nr,konf,ncore,
c     &              zz,aa,bb,bas,alat,plat,
c     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
ccv2
c     &              ,nindx,lindx,ibasindx
c        endif
      else
        stop 'gwinput: wrong ifi'
      endif
      end
c----------------------------------------------------------------------
C       subroutine gwinput0_v2(ifi,
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze,
C      &              nphi, nphimx)
C c  Read dimensions only.
C C     implicit none
C       integer::  ifi,
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze ,
C      &              nphi, nphimx
C       read(ifi)
C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze,
C      &              nphi, nphimx
C       end
c--------------------

      subroutine rdibasindx2(ldim2,nphi,nphimx,nindx,lindx,ibasindx,ifi)
C- Reads indexing data for augmentation functions
C ----------------------------------------------------------------------
Ci Inputs
Ci   ldim2 :number of augmentation functions nRlm in unit cell
Ci         :(used here as a sanity check)
Ci   ifi   :file handle ifi>0 for file read
Co Outputs
Co   nphi  :number of augmentation functions nRl  in unit cell
Co   nphimx:maximum number of aug. functions in a single Rl channel
Co   nindx :nindx(i) type of augm. function for the ith Rl channel
Co         :e.g. nindx=1 : phi, nindx=2 : phidot,  nindx=3 : loc. orb
Co   lindx :l quantum number for the ith Rl channel
Co ibasindx:site index for the ith Rl channel
Cr Remarks
Cu Updates
Cu   05 Mar 02 First created
C ----------------------------------------------------------------------
C     implicit none
      integer ldim2,nphi,nphimx,ifi,
     .nindx(ldim2),           ! n    index
     .lindx(ldim2),           ! l    index
     .ibasindx(ldim2)         ! ibas index

      character*80 outs
      integer i,ipqn,l,ib,ii,nn,m

C --- File read ---
      if (ifi .gt. 0) then
        rewind ifi
        read(ifi,'(a)') outs
        read(ifi,*) i
C       If passed ldim2>0, check that it matches file value
        if (ldim2 .gt. 0 .and. i .ne. ldim2)
     .  call rx('rdibasindx: file mismatch ldim2')
        ldim2 = i
        nphimx = 0
c        do  i = 1, ldim2
        nn = 0
        do
          read(ifi,'(a)',err=101,end=101) outs
          read(outs,*) ipqn,l,ib,ii
          do m=1,2*l+1
            nn = nn+1
            nindx   (nn) = ipqn
            lindx   (nn) = l
            ibasindx(nn) = ib
          enddo
          nphimx = max(nphimx,ipqn)
          nphi = i
        enddo
  101   continue

C --- File read ---
      else
        call rx('ioaindx: file write not implemented')
      endif

      end

      subroutine readin000(ifi,i0,e1)
c! readin i0,i1,e1,e2; defaults value are 0.
      character(len=100):: recxxx=' '
      character(len=108):: recxxx2
      real(8)::d0e1
      integer::i1
      i0=999999
      e1=99999
      read (ifi,"(a100)",err=1001,end=1001) recxxx
 1001 continue
      recxxx2 = recxxx//' 0 0'
      read(recxxx2,*,err=1002,end=1002) i0
 1002 continue
      read(recxxx2,*,err=1003,end=1003) i0 ,e1
 1003 continue
      end

      subroutine zprm(strn,icast,s,ns,nr,nc)
      implicit none
      integer icast,nr,nc,ns,ifi
      double precision s(2,ns,nc)
      character*(10) fmt, outs*80, strn*(*)
      integer i,j,fopna,i1mach
      fmt = '(9f15.10)'
      fmt = '(9f18.11)'
C     fmt = '(5f20.15)'
      outs = ' '
      if (icast .eq. 1)  outs = ' real'
      if (icast .eq. 11) outs = ' symm'
      if (icast .eq. 2)  outs = ' complex'
      if (icast .eq. 12) outs = ' herm'
      ifi = fopna('out',29,0)
      rewind ifi
C#ifdef NOAWRITE
      write(ifi,'(''% rows'',i5,'' cols'',i5,a)') nr,nc,outs(1:10)
C#elseC
C      call awrit2('%% rows %i cols %i'//outs,' ',80,ifi,nr,nc)
C#endif
      do  10  i = 1, nr
        write(ifi,fmt) (s(1,i,j), j=1,nc)
   10 continue
      if (mod(icast,10) .gt. 1) then
        write(ifi,*)
        do  20  i = 1, nr
          write(ifi,fmt) (s(2,i,j), j=1,nc)
   20   continue
      endif
      call fclose(ifi)
C#ifdef NOAWRITE
      outs = ' prm: wrote '//strn//' continue?'
      print *, outs
C#elseC
C      outs = ' zprm: wrote '//strn
C      call awrit0('%a.  Continue?',outs,-80,-i1mach(2))
C#endif
      read(*,'(a80)') outs

C#ifdef NOAWRITE
      if (outs .eq. 'q') stop 'quit in zprm'
C#elseC
C      if (outs .eq. 'q') call rx0('quit in zprm')
C#endif
      end
      subroutine prmx(strn,s,ns,nr,nc)
C- writes matrix into out file (for debugging)
      implicit none
      integer nr,nc,ns,ifi
      double precision s(ns,nc,2)
      character*(14) fmt, fmt0, strn*(*), outs*80
      integer i,j,fopna,i1mach
      save fmt
      data fmt /'(9f20.15)'/
C      fmt = '(1p9e20.10)'
      ifi = fopna('out',29,0)
      rewind ifi
C#ifdef NOAWRITE
      write(ifi,'(''% rows'',i5,'' cols'',i5,a)') nr,nc
C#elseC
C      call awrit2('%% rows %i cols %i real',' ',80,ifi,nr,nc)
C#endif
      do  10  i = 1, nr
        write(ifi,fmt) (s(i,j,1), j=1,nc)
   10 continue
      write(ifi,*)
C      do  12  i = 1, nr
C   12 write(ifi,fmt) (s(i,j,2), j=1,nc)
      call fclose(ifi)

C#ifdef NOAWRITE
      outs = ' prm: wrote '//strn//' continue?'
      print *, outs
C#elseC
C      outs = ' prm: wrote '//strn
C      call awrit0('%a.  Continue?',outs,-80,-i1mach(2))
C#endif
      read(*,'(a80)') outs

C#ifdef NOAWRITE
      if (outs .eq. 'q') stop 'quit in prm'
C#elseC
C      if (outs .eq. 'q') call rx0('quit in prm')
C#endif
      return

      entry prmx0(fmt0)
      fmt = fmt0
      end
