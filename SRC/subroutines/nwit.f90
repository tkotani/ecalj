subroutine nwit(nvario,iter,maxit,lhf,lhk,etol,qtol, &
     qdiff,amom,etot,sev,lsc)
  use m_lmfinit,only: nsp
  use m_lgunit,only:stdo,stdl
  !- Add to save file, determine whether to continue execution
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   nvario:number of variables in variables table to i/o
  !i   iter  :current iteration number
  !i   maxit :maximum number of iterations
  !i   lhf   :T if result is generated by overlapped free atoms
  !i         :(only affects key character in save file)
  !i   lhk   :1, if HK energy is available
  !i         :Add 10 to use HK energy for convergence, if available
  !i   etol  :energy tolerance for convergence.  If 0, criterion not used
  !i         :Energy change from prior iteration is compared to etol.
  !i   qtol  :charge tolerance for convergence.  If 0, criterion not used
  !i   qdiff :change in charge
  !i   amom  :magnetic moment
  !i   etot  :etot(1) = HF energy; etot(2) = KS energy
  !o Outputs
  !o   lsc   :0 self-consistency achieved (diffe<=etol, qdiff<=qtol)
  !o         :1 if not self-consistent, but encountered max. no. iter.
  !o         :2 Harris energy from overlap of free atoms (iter=1 and lhf=t)
  !o         :3 otherwise
  !u Updates
  !   svflg :string of characters.  svflg(lsc+1) is written as the
  !         :first character in the save file
  !u   14 Jan 05 Eliminate sctrl from argument list
  !u   11 Jan 05 Add 10's digit option to lhk
  !u   10 Mar 03 Split off nwitsv to make separately callable
  !u   07 Jun 01 Revised and split off from lmfp.
  ! ----------------------------------------------------------------------
  !     implicit none
  ! ... Passed parameters
  logical :: lhf
  character(4):: svflg='cxhi'
  integer :: iter,maxit,lhk,lsc,nvario
  double precision :: etol,qtol,qdiff,amom,etot(2)
  ! ... Local parameters
  integer :: lbl
  logical :: more,letol,lqtol
  double precision :: ehf1,ehk1,diffe,sev
  character flg*1
  save ehf1,ehk1
  character*255:: formatc(903:904),lbll
  call tcn('nwit')
  lsc = 3
  more = .true.
  if (iter >= maxit) then
     lsc = 1
     more = .false.
  endif
  if (lhf) lsc = 2
  ! --- Decide whether to iterate on ---
  !  903 format(/  ' it',i4,'  of',i4,'    ehf=',f15.6:'   ehk=',f15.6)
  !  904 format(/'   it',i3,'  of',i3,'    ehf=',f15.6:'   ehk=',f15.6)
  formatc(903)="(/  ' it',i4,'  of',i4,'    ehf=',f15.6:'   ehk=',f15.6)"
  formatc(904)="(/'   it',i3,'  of',i3,'    ehf=',f15.6:'   ehk=',f15.6)"
  lbl=904 !assign 904 to lbl
  if (maxit > 999 .OR. iter > 999) lbl=903 !assign 903 to lbl
  lbll=formatc(lbl)
  if (mod(lhk,10) == 1) write(stdo,trim(lbll)) iter,maxit,etot(1),etot(2)
  if (mod(lhk,10) == 0) write(stdo,trim(lbll)) iter,maxit,etot(1)
  if (iter > 1 .OR. etol == 0) then
     diffe = etot(1)-ehf1
     if (lhk == 11) diffe = etot(2)-ehk1
     letol = dabs(diffe) .le. etol .or. etol .le. 0
     lqtol = dabs(qdiff) .le. qtol .or. qtol .le. 0
     if (letol .AND. lqtol) then
        more = .false.
        lsc = 0
     endif
     !       if (lmove .gt. 0) more = .true.
     if (iter > 1) then
        if (mod(lhk,10) == 1) write(stdo,905) ehf1,ehk1,diffe,qdiff, &
             etol,qtol,more
        if (mod(lhk,10) == 0) write(stdo,906) ehf1,diffe,qdiff, &
             etol,qtol,more
     else
        write(stdo,907) qdiff,qtol,more
     endif
     !       write(lgunit(2),907) diffe,qdiff,etol,qtol
905  format(' From last iter',4x,'ehf=',f15.6,'   ehk=',f15.6, &
          /' diffe(q)=',f10.6,' (',f8.6,')', &
          '    tol=',f9.6,' (',f8.6,')','   more=',l1)
906  format(' From last iter',4x,'ehf=',f15.6, &
          /' diffe(q)=',f10.6,' (',f8.6,')', &
          '    tol=',f9.6,' (',f8.6,')','   more=',l1)
907  format(16x,'rms dq=',f10.6,8x,'tol=',f9.6,'   more=',l1)
  endif

  ! ... Save for future iterations
  ehk1 = etot(2)
  ehf1 = etot(1)

  ! --- Write out to save file --
  flg = svflg(lsc+1:lsc+1) !// '67'
  call nwitsv(nvario,flg,nsp,amom,etot,sev)
  call tcx('nwit')
end subroutine nwit

subroutine nwitsv(nvario,flg,nsp,amom,etot,sev)
  use m_ext,only:      sname
  use m_ldau,only:  eorb
  use m_lgunit,only:stdo,stdl
  !- Write to save file
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   iflst :specifies which files to output
  !i         :1s bit => write to 'save'
  !i         :2s bit => write to stdo
  !i         :4s bit => write to stdl
  !i   nvario:number of variables in variables table to i/o
  !i   flg   :label; see iosave for meaning
  !i   nsp   :2 for spin-polarized case, otherwise 1
  !i   amom  :system magnetic moment for spin-pol case
  !i   etot  :etot(1) = HF energy; etot(2) = KS energy
  !o Outputs
  !o   energy data is written to ...
  !r Remarks
  !r
  !u Updates
  !u   10 Mar 03 Cut out from nwit to make separately callable
  ! ----------------------------------------------------------------------
  implicit none
  ! ... Passed parameters
  integer :: iflst,nvario,nsp
  character flg*(*)
  double precision :: amom,etot(2)
  ! ... Local parameters
  integer :: ifi,i,ifile_handle
  double precision :: xv(4),sev,rydberg
  character(180) :: sout
  i = 0
  sout = ' '
  if (nsp == 2) then
     i = i+1
     xv(i) = amom
     sout=trim(sout)//',mmom '
  endif
  if(eorb==0) then
     if (etot(1) /= 0d0) then
        i = i+1
        xv(i) = etot(1)*rydberg()
        sout=trim(sout)//',ehf(eV) '
     endif
  endif
  if (etot(2) /= 0d0) then
     i = i+1
     xv(i) = etot(2)*rydberg()
     sout=trim(sout)//',ehk(eV) '
  endif
  if (sev /= 0) then
     i = i+1
     xv(i) = sev*rydberg()
     sout=trim(sout)//',sev(eV) '
  endif

  ifi=ifile_handle()
  open(ifi,file='save.'//trim(sname),position='append')
  call iosave(flg,sout(2:),xv,-ifi,nvario)
  close(ifi)
  call iosave(flg,sout(2:),xv,-stdo,nvario)
  !      call iosave(flg,sout(2:),xv,-stdl,nvario)
  close(ifi)
end subroutine nwitsv
