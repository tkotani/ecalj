      real(8) function epsnevec()
      epsnevec=1d-8 !it was 1d-6
      end
      logical function mixrealsmooth()
      mixrealsmooth=.true.
! Takao think mixrho should give a correct guess from informations
! of |rho_in - f(rho_in)|**2
! In our procedure now, takao think the weight from smooth part is rather small.
! Thus our mixing procedure is mainly controlled by atoic part.
! This works OK but may be not best...
!   How to choose wgtsmooth? or it will be better to take correct weighting for
!   mixing.
      print *,'mixrealsmooth=',mixrealsmooth
      end

      logical function noelind()
      noelind=.false. !in mixrho.F. If T, ELIND procedure is not.
! Does elind really works fine? It works for LiC2 case.
! Probably, we first have to modify mixrho.
      end

      logical function enforce_positive_smrho()
!      enforce smrho to positive in mkpot.F
      enforce_positive_smrho=.true.
      end

c-----------
Cr   To get old result, Use 1. below.
Cr   1. newsigmasw=F and pmtsig=F : gives old result   (backword compatibility mode)
Cr
Cr   2. newsigmasw=F and pmtsig=T : new result               (test mode)
Cr   3. newsigmasw=T (then pmtsig is irrelevant): new result (run mode)
Cr
Cr Note: you also need to use sigswitch=0 if you want to reproduce old results.

      logical function newsigmasw()
! newsigmasw: in this case, we only use emax_sigm in hqpe.sc.m.F when we construct sigma.
!!       T: newsigma rotation, and interpolation. !this is still problematic
c        O: old version
c      newsigmasw=.true.
!! in future, I like to modify the interpolation scheme, but not yet.
c      newsigmasw=.true.
      newsigmasw=.false.
      end

      logical function pmtsig()
Cr This switch is effective only when newsigmasw=F.
Cr This is used in hambls.F.
c      pmtsig=.true. !new interpolation mode.
      pmtsig=.false. !old result
      end
c-----------
      integer function debugmode()
      debugmode=0
      end

c
      integer function sigswitch()
c sigma interpolation
Cr This switch is effective only when newsigmasw=F.
Cr This is used in hambls.F.
c
c sigswitch=0: old version
c sigswitch=1: new version of sigma interpolation. (asig bsig are unused). 
c              Readin constant shift given in ESEAVR, generated by hqpe.
c              new interpolation mode for self-energy: Neglect asig and bsig
c      sigswitch=0
      sigswitch=1
      end

      logical function fullmesh()
c      fullmesh=.true. !including all G vector to expand charge density. I think this did not work well.
      fullmesh=.false.
      end

c      logical function nomshsiz()
c      nomshsiz=.true.
c      end

      logical function noshorbz()
!! shorbz is confusing (pull back k vector to 1st BZ). Especially, in the case of PMT, where we use exp(i (q+G)r).
!! It is better to use different algolism in future if required.
      noshorbz=.true. !.false. before aug2012
      end

      integer function matmul_pwhovl()
c switch used in gwd/pwmat.F
c  matmul_pwhovl=1 uses matmul,
c  matmul_pwhovl=2 and matmul_pwhovl=3 uses BLAS. In cases, it fails in centos(gfortran and so) in core-i7.
      matmul_pwhovl=2
      end

      logical function oncewrite(id)
      integer:: idx(1:100)=1
      if(id<1. or. id >100 ) call rx("oncewrite index out of range")
      oncewrite=.false.
      if( idx(id) ==1)  then
        oncewrite=.true.
        idx(id)=0
      endif
      end
