! PMT --1ststep--> MTP --2ndstep--> MLO. This is for 2ndstep
program lmfham2 ! Get the Hamiltonian on the MTO-based-Localized orbitals |MLO> from MTP
  ! that of the MTO-projected basis |MTP>. Conversion from MTP(hmmr1,ommr1,nband) to MLO(hmmr2,ommr2,nMLO).
  ! In advance, run lmfham1 to get |MTP> (MTPare given by a projection from MTOs to PMT space.
  ! That is, |MTP_i> = M |PMT_i>, where M is a mapping from MTP to the space of PMT.
  !  
  ! We use a modified procedure of this method of  [2]I.Souza, N.Marzari and D.Vanderbilt, PRB65,035109(2002) 
  !
  ! Main part of lmfham2 is Step1loop. 
  ! Among the space spanned by |MTonly>, we extract minimum basis space.
  ! For example, we have 25+25 MTOonlys for Si;then we extract 9+9 space spanned by |MLO>.
  !
  ! We use diffent idea of connectivity from [2]. Roughly speaking, we define connectivitiy of eigenfunctions between k and k+b,
  ! not by the overlap of periodic part of eigenfunctions, but by the coefficients on |MLO>.
  !
  use m_ftox
  use m_lgunit,only: stdo,m_lgunit_init
  use m_zhev,only:zhev_tk4
  use m_MPItk,only:    m_MPItk_init, m_MPItk_finalize, nsize, master_mpi !  use m_ext,only:      m_ext_init,sname
  use m_keyvalue,only: getkeyvalue
  use m_lmfinit,only:  m_lmfinit_init,oveps
  use m_ext,only: m_ext_init
  use m_cmdpath,only: Setcmdpath
  use m_readqplist,only: eferm,qplistsy,ndat,xdat, Readqplistsy !qplist.dat is generated by job_band
  use m_HamPMT,only: ReadHamPMTInfo, nspin=>nsp, natom=>nbas,plat,alat,npair,nlat,nqwgt, ldim, nqbz=>nkp,qbz=>qplist,&
       n1=>nkk1,n2=>nkk2,n3=>nkk3,pos,npairmx,nspx !,ib_table,l_table,k_table
  use m_read_Worb,only:s_read_Worb,nclass_mlwf,cbas_mlwf,norb=>nbasclass_mlwf,classname_mlwf ! iclassin,iphi,iphidot,nphi,nphix
  use m_HamRsMTP,only: ReadHamRsMTP,hmmr1=>hammr,ommr1=>ovlmr,nband=>ndimMTO,ib_tableM,l_tableM,k_tableM !Real-space Hamiltonian on the basis |MTo>.
  !      Main output of lmfham2 is  hmmr2,       ommr2,       nMLO,         ib_tableM(idmto(1:nwf)),... for |MLO>
  implicit none
  integer:: i,iq,is,ix,j,ifbb,ifoc,nbb,isc,ifq0p, nox,iko_ix,iko_fx,nsc1,ndz,nin,nout,nsc2,ibb
  integer:: inii,if102,iwf2,ib,itmp,itmp2,nqbz2,nspin2,ib1,ib2,iqb,iqbz,it,jsp,nmx,nev,isyml!,nqbz!,n1,n2,n3
  integer:: nMLO,ikx,ikxx,iadd,i1q,i2q,i1,i2,imp,inp,inx,imx,ibas,ibold,ibx,iorb
  integer,parameter:: nlinex=100
  integer::nline,np(nlinex), iwf,ldim2,ixx,npin,ifuumat,job
  real(8),parameter:: pi = 4d0*datan(1d0)
  real(8) :: tpia,vol,voltot,rs,alpha, rydberg,hartree,qlat(3,3),tripl,wbbsum,bb(3,12),eimax ,wbbs,WTbandqsum,WTouterqsum,&
       evalssold,qi(3,nlinex),qf(3,nlinex), omgi,omgiold,conv1,alpha1,zesumold,zesi,emm,eouterL,eouterH,eouterLeV,eouterHeV,&
       emin,evalss,sss,qiin(3),qfin(3),qold(3),enwfmax,qxx(3),eeee,enwfmaxi,ginv(3,3),einner,WTouter,ecenter,&
       eee,etest,egap,WTband,hardeinnerLev,hardeinnerHev
  character(8) :: xt
  real(8),allocatable    :: q(:,:)
  real(8),allocatable:: ku(:,:),kbu(:,:,:),eunk(:,:),eval(:), eks(:),wbb(:)
  integer,allocatable:: ikbidx(:,:),iko_i(:),iko_f(:)
  real(8),allocatable:: omgik(:),zesum(:),evals(:),WTbandq(:),WTouterq(:)
  real(8),allocatable:: xq(:),eval1(:,:),eval2(:,:),eval3(:,:),eval_w(:,:,:)
  integer,allocatable:: m_indx(:),n_indx(:),l_indx(:),ibas_indx(:),ibasiwf(:),idmto(:),idmto_(:)
  real(8),allocatable:: evl(:,:),ovl(:), bbv(:,:),wbz(:),proj(:)
  complex(8),allocatable:: upu(:,:,:,:), zmn(:,:),zmn0(:,:),WTbandii(:),WTouterii(:)
  complex(8),parameter:: img=(0d0,1d0)
  complex(8),allocatable::ovlm(:,:),ovlmx(:,:),hamm(:,:),ovec(:,:)!,emat(:,:)
  complex(8),allocatable:: uumat(:,:,:,:),evecc(:,:), amnk(:,:,:),cnk(:,:,:),umnk(:,:,:),evecc1(:,:,:),evecc2(:,:,:)
  complex(8),allocatable:: hmmr2(:,:,:,:),ommr2(:,:,:,:),wmat(:,:),wmat2(:,:)
  character(256):: fband,fband1
  logical:: cmdopt2,noinner
  real(8):: WTseed,eoffset
  character:: outs*20
  character(256):: aaa='',bbb=''
  integer:: nband_,nqbz_,iko_ix_,iko_fx_,nMLO_,ilowest
  call setcmdpath() !Set self-command path (this is for call system at m_lmfinit)
  call m_ext_init()         ! Get sname, e.g. trim(sname)=si of ctrl.si
  call m_MPItk_init('lmfham2') ! mpi initialization
  call m_lgunit_init() !set stdo,stdl
  call m_lmfinit_init('LMF')! Read ctrlp into module m_lmfinit.
  job=-1
  if(cmdopt2('--job=',outs)) read(outs,*) job
  if(job/=0.and.job/=1) call rx0(' Set --job=0 or 1')
  write(stdo,ftox)'=== Start lmfham2 --job=',job
  call mpibc1_int(job,1,'lmfham2_job') !set job of --job=job in arguments of lmf-MPIK.
  hartree=2d0*rydberg()
  call ReadHamPMTInfo()! Read infomation for Hamiltonian (lattice structures and index of basis).
  call ReadHamRsMTP()  ! Read Real-space |MTo>-basis Hamiltonian and overlap.
!  nqbz=nkp!  call minv33tp(plat,qlat)!  voltot = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))
  call pshpr(30)
  tpia = 2d0*pi/alat
  ginv   = transpose(plat)
  call readqplistsy()
  ReadInfoFromGWinput: block
    call s_read_Worb() ! Input orbital index for MLO, stored into idmto (s,p,d=1,2,3,4,5,6,7,8,9)
    nMLO=sum(norb(1:nclass_mlwf)) !number of MLO
    allocate(idmto(nMLO)) 
    ibx=0
    ibold=-999
    iorb=0
    SETidmto:do i = 1,nband !for example, allocate(idmto,source=[(i,i=1,9),(i+25,i=1,9)]) for Si
       if(ibold/=ib_tableM(i)) ibx=0
       ibas=ib_tableM(i)
       ibx=ibx+1
       if(findloc([(ibx==cbas_mlwf(ix,ibas),ix=1,norb(ibas))],dim=1,value=.true.)/=0) then
          iorb=iorb+1
          idmto(iorb)=i
       endif       !write(stdo,"('MHAM: i ib(atom) l m k(EH,EH2,PZ)=',5i3)") i,ib_table(i),ibx
       ibold=ib_tableM(i)
    enddo SETidmto
    write(stdo,ftox)' idmto=',idmto
    call getkeyvalue("GWinput","mlo_maxit",nsc1,default=10)
    call getkeyvalue("GWinput","mlo_conv",conv1,default=1d-4)
    call getkeyvalue("GWinput","mlo_mix",alpha1,default=.5d0) 
    call getkeyvalue("GWinput",'mlo_WTseed',WTseed,default=0d0)       ! Weight for seed. Rarely used now.
    call getkeyvalue("GWinput","mlo_WTband"  ,WTband,default=16d0)    ! Weight to minimize band energies
    call getkeyvalue("GWinput","mlo_WTouter", WTouter,default=2048d0) ! inner energy window WeighTing
!    call getkeyvalue("GWinput","mlo_EWinner", ewid, default=.1d0)     ! inner energy window softing eV
    call getkeyvalue("GWinput","mlo_ELouter", eouterLeV,default=-1d8) ! outer energy windowL eV relative to VBM
    call getkeyvalue("GWinput","mlo_EUouter", eouterHeV,default= 1d8) ! outer energy windowU eV relative to VBM
    call getkeyvalue("GWinput","mlo_ELinner",hardeinnerLev,default=999999d0) !Hard inner
    call getkeyvalue("GWinput","mlo_EUinner",hardeinnerHev,default=-999999d0)   
    if(master_mpi) then
       write(stdo,ftox)' Reading: mlo_ maxit conv mix=',nsc1,ftof(conv1),ftof(alpha1)
       write(stdo,ftox)' Reading: mlo_WTseed =',ftof(WTseed,2)
       write(stdo,ftox)' Reading: mlo_WTband =',ftof(WTband,2)
       write(stdo,ftox)' Reading: mlo_WTouter=',ftof(WTouter,2)  
       write(stdo,ftox)' Reading: mlo_ ELinner EUinner(eV)=',ftof(hardeinnerLeV,2),ftof(hardeinnerHeV,2)
! --- Our test show WTband,WTouter=4,1024 is good for Si666(spd model); =32,256 is for Si888 ---'
       write(stdo,ftox)' Rule of thumb: Too large WTband and WTouter may destroy smoothness of bands'
       write(stdo,ftox)'    mlo_WTband:  Fill bands from bottom. Search range is 1,2,4,...,256'
       write(stdo,ftox)'    mlo_WTouter: Usually =2048 works well. '
    endif
!    ewid= ewid/rydberg() !in Ry.
  endblock ReadInfoFromGWinput
  bbvector: block !Get connecting vectors bb, bb connects k and k+bb, where both k and k+bb are on mesh points nqbz.
    allocate(wbb(12))
    call getbb(plat,alat,n1,n2,n3, nbb,wbb,wbbsum,bb) ! b vectors (connecting vectors).
    allocate (ku(3,nqbz),kbu(3,nbb,nqbz),ikbidx(nbb,nqbz))
    call kbbindx(qbz,ginv,bb, nqbz,nbb, ikbidx,ku,kbu) ! index for k and k+bb
    allocate(iko_i(nqbz),iko_f(nqbz)) !, ikbo_i(nbb,nqbz),ikbo_f(nbb,nqbz)) !, ikbi_i(nbb,nqbz),ikbi_f(nbb,nqbz))
    call writebb2(ifbb,wbb(1:nbb),bb(1:3,1:nbb), ikbidx,ku,kbu, nqbz,nbb)
    write(stdo,ftox)' nbb wbb(in unit of 2pi/alat)=',nbb,ftof(wbb(1:nbb),3)
    allocate(bbv,source=bb)
  endblock bbvector
  iko_i=1; iko_f=nband ! outer window nband is the number of MLO
  iko_ix=minval(iko_i)
  iko_fx=maxval(iko_f) !  nox = iko_fx - iko_ix + 1
  if(job==1) goto 1011 !Goto Souza's iteration job=1 mode
  
  GetCNmatFile: block  !job=0 mode to get CNmat file (connection matrix uumat and so on).
    real(8):: qp(3)
    complex(8):: emat(nband,nband),osq(1:nband,1:nband),o2al(1:nband,1:nband,nqbz),phase,ovlmm(nband,nMLO),&
         evec(nband,nband,nqbz),evecx(1:nband,1:nband), ovec(nband,nband),amnk(iko_ix:iko_fx,nMLO,nqbz),&
         ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband), hamm(1:nband,1:nband),uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz)
    allocate(evl(nband,nqbz),ovl(nband))!NOTE: 20230805. When I declear evl in this block, ifort18.05 gives strange results.
    write(stdo,ftox)'Going to get CNmat ... : nband for |MLO1>=',nband,'iko_i iko_f=',iko_ix,iko_fx
    open(newunit=ifuumat,file='CNmat',form='unformatted')
    uuispinloop: do 1010 is = 1,nspin
       write(stdo,ftox)'Generating connection matrix ispinloop: is =',is,'  out of',nspin
       emat=0d0
       forall(i=1:nband) emat(i,i)=1d0
       do iqbz=1,nqbz
          qp=qbz(:,iqbz)
          ovlm = 0d0
          hamm = 0d0
          do i=1,nband !Get MTP Hamiltonian at qp by FF from the real-space MTP Hamiltonian (lmfham1)
             do j=1,nband
                ib1 = ib_tableM(i) !atomic-site index in the primitive cell
                ib2 = ib_tableM(j)
                do it =1,npair(ib1,ib2) !real-space to H,O at qp
                   phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                   hamm(i,j)= hamm(i,j)+ hmmr1(i,j,it,is)*phase 
                   ovlm(i,j)= ovlm(i,j)+ ommr1(i,j,it,is)*phase
                enddo
             enddo
          enddo
          nmx=nband
          ovlmx=ovlm
          call zhev_tk4(nband,ovlm,emat,nmx,nev, ovl, ovec, oveps) !Diangonale overlap matrix. (ovlm - e ) ovec=0
          ovlm=ovlmx
          call zhev_tk4(nband,hamm,ovlm,nmx,nev, evl(:,iqbz), evec(:,:,iqbz), oveps) !Diangonale (hamm- evl ovlm) z=0
          do concurrent (i=1:nband,j=1:nband)
             osq(i,j)=sum(ovec(i,:)*ovl(:)**0.5d0*dconjg(ovec(j,:))) !O^(1/2)
          enddo
          o2al(:,:,iqbz) = matmul(osq, evec(:,:,iqbz)) !o2al(basis index, band index, iqbz index) O^(1/2)*evec
          forall(i=1:nband) ovlmm(i,:) = ovlmx(i,idmto(:))
          amnk(:,:,iqbz)= matmul(transpose(dconjg(evec(1:nband,iko_ix:iko_fx,iqbz))),ovlmm) !amnk= <Psi^MTP|MTO>
       enddo
       do iqbz=1,nqbz
          do ibb=1,nbb
             iqb = ikbidx(ibb,iqbz)             !q1(:) = qbz(:,iqbz)             !q2(:) = q1(:) + bbv(:,ibb)
             do concurrent(ib1=iko_ix:iko_fx, ib2=iko_ix:iko_fx) !ib1,ib2 band index of outer-inner window
                uumat(ib1,ib2,ibb,iqbz)= sum(dconjg(o2al(1:nband,ib1,iqbz))*o2al(1:nband,ib2,iqb)) ! define connection <q ib1| q+b ib2>
             enddo
          enddo
       enddo
       write(ifuumat) nband,nqbz,iko_ix,iko_fx,nMLO,idmto
       write(ifuumat) evl   !eigenvalue
       write(ifuumat) uumat !connection matrix
       write(ifuumat) amnk  !initial projection
1010 enddo uuispinloop
    close(ifuumat)
    if(job==0) call rx0('OK! end of lmhfam2 job=0 for generating CNmat')
  endblock GetCNmatFile

1011 continue !=== job==1 mode start ========================================
  open(newunit=ifuumat,file='CNmat',form='unformatted')
  allocate(hmmr2(nMLO,nMLO,npairmx,nspin),ommr2(nMLO,nMLO,npairmx,nspin),source=(0d0,0d0))
  allocate(ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband),hamm(1:nband,1:nband))
  allocate(evl(nband,nqbz), ovec(nband,nband),ovl(nband))
  allocate(amnk(iko_ix:iko_fx,nMLO,nqbz),idmto_(nMLO))
  allocate(wbz(nqbz),source=1d0/nqbz)
  allocate (uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz))
  ispinloop: do 1000 is = 1,nspin
     read(ifuumat) nband_,nqbz_,iko_ix_,iko_fx_,nMLO_,idmto_
     if(nMLO/=nMLO.or.sum(abs(idmto-idmto_))/=0) call rx0('lmfham2: idmto error: Repeat --job=1 with the same <Worb> in GWinput!')
     read(ifuumat) evl
     read(ifuumat) uumat
     read(ifuumat) amnk
     if(eouterLeV>-1d5) then
        eouterL= eouterLeV/rydberg()+eferm
        if(master_mpi) write(stdo,ftox)' eouterL from VBM=',ftof((eouterL-eferm)*rydberg(),3),' eV'
     else
        if(master_mpi) write(stdo,ftox)' eouterL automatic'
     endif   
     if(eouterHeV<1d5) then
        eouterH= eouterHeV/rydberg()+eferm
        if(master_mpi) write(stdo,ftox)' eouterH from VBM=',ftof((eouterH-eferm)*rydberg(),3),' eV'
     else
        if(master_mpi) write(stdo,ftox)' eouterH automatic'
     endif   
     if(master_mpi) &
          write(stdo,ftox)'isploop: is=',is,'out of',nspin,'ChooseSpace by cnk(init:iend,1:nMLO,1:nqbz)=',iko_ix,iko_fx,nMLO,nqbz
     allocate( upu(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz), cnk(iko_ix:iko_fx,nMLO,nqbz), omgik(nqbz),evals(nqbz))!,zesum(nqbz)) !cnk2(iko_ix:iko_fx,nMLO,nqbz)
     allocate( WTbandq(nqbz),WTouterq(nqbz),proj(iko_ix:iko_fx))
     call amnk2unk(amnk,iko_ix,iko_fx,iko_i,iko_f,nMLO,nqbz, cnk)
     !amnk=<Psi^MTP(it,iqbz)|MTO(1:nMLO) >.  Note that amnk was in Eq.22 in Ref.II. <psi|Gaussian>. We replace Gaussian with MTO.
     !cnk =<Psi^MTP(it,iqbz)|MTO_orth(1:nMLO)>.  |MTO_orth>= |MTO> O^{-1/2} 
     zesumold=1d10
     alpha = 1d0
     upu   = 0d0
     wbbs=sum(wbb(1:nbb)) !we assume iko_i(iq)=1. If not, use evl(iko_i(iq),iq)
     SouzaStep1loop: do isc = 1,nsc1 ! choose Hilbert space -- determine cnk
        iqloop: do iq = 1,nqbz
           AUTOeouterL:if(eouterLeV<=-1d5) then! Search bottom of MTP Hamiltonian for given MTOsets to generate MLO.
              proj = [ (sum(cnk(i,:,iq)*dconjg(cnk(i,:,iq))),i=iko_ix,iko_fx) ]
              eouterL = evl(findloc(proj>0.1d0,value=.true.,    dim=1),iq) - 1d-3
              if(isc==1.and.iq==1) write(stdo,ftox)'AUTO: isc iq eouterL=',isc,iq,ftof((eouterL-eferm)*rydberg(),3)
           endif AUTOeouterL
           AUTOeouterH:if(eouterHeV>=1d5) then! Search bottom of MTP Hamiltonian for given MTOsets to generate MLO.
              proj = [ (sum(cnk(i,:,iq)*dconjg(cnk(i,:,iq))),i=iko_ix,iko_fx) ]
              eouterH = evl(findloc(proj>0.1d0,value=.true.,back=.true.,dim=1),iq) + 1d-3
              if(isc==1.and.iq==1) write(stdo,ftox)'AUTO: isc iq eouterH=',isc,iq,ftof((eouterH-eferm)*rydberg(),3)
           endif AUTOeouterH
           nout = iko_f(iq) - iko_i(iq) + 1 !outer
           ndz  = nout 
           if(isc /= 1) alpha = alpha1
           allocate(wmat(iko_ix:iko_fx,iko_ix:iko_fx), wmat2(iko_ix:iko_fx,iko_ix:iko_fx))
           i1q=iko_i(iq)
           i2q=iko_f(iq)
           do ibb = 1,nbb
              iqb = ikbidx(ibb,iq)
              i1= iko_i(iqb)
              i2= iko_f(iqb)
              do concurrent(inp=i1:i2, imp=i1:i2) !wmat = cnk * cnk^{*} is projector to 'wannier space'.
                 wmat(inp,imp)= sum(dconjg(cnk(inp,1:nMLO,iqb))*cnk(imp,1:nMLO,iqb)) !BUG-> range of sum was nin+1,nMLO before 2023-6-8(miyake)
              enddo
              do concurrent(inx=i1q:i2q, imp=i1:i2)
                 wmat2(imp,inx)= sum( wmat(i1:i2,imp)*dconjg(uumat(inx,i1:i2,ibb,iq)) ) !wmat*uumat
              enddo
              do concurrent(imx=i1q:i2q, inx=i1q:i2q)!      upu=   uumat* wmat * uumat ! (1-2) <u_mk | P_k+b | u_nk>
                 upu(imx,inx,ibb,iq)= (1d0-alpha)*upu(imx,inx,ibb,iq) + alpha*sum(uumat(imx,i1:i2,ibb,iq)*wmat2(i1:i2,inx))
              enddo
           enddo
           deallocate(wmat,wmat2)
           
           ! Omega= 1/2 \sum_b,k Tr {|\nabla Pk|^2} + WTband*Tr{Pk H} - WTouter*Tr{Pk EinnerW} + WTseed * Tr {Pk <psi_m|seed_i><seed_i|psi_n|}
           ! zmn = \frac{\delta Omega}{\delta Pmn^k}
           allocate (zmn0(ndz,ndz),source=(0d0,0d0)) ! (1-3) Zmn(k) > phi,eval
           allocate (zmn(ndz,ndz), evecc(ndz,ndz),eval(ndz),WTbandii(ndz),WTouterii(ndz))
           do ibb = 1,nbb
              zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) - 2d0*wbb(ibb)*upu(iko_i(iq):iko_f(iq),iko_i(iq):iko_f(iq),ibb,iq)
           enddo
           zmn=zmn0
           WTbandBlock: do concurrent(i=iko_i(iq):iko_f(iq))
              WTbandii(i)= WTband*(evl(i,iq))   !band energy term
              zmn(i,i)=zmn0(i,i) + WTbandii(i)  
           enddo WTbandBlock
           WTouterBlock: do concurrent(i=iko_i(iq):iko_f(iq)) !Add penalty for compoment outside of inner window
!              WTouterii(i)= WTouter*max(fermidist(-(evl(i,iq)-eouterH)/ewid),merge(0d0,1d0,evl(i,iq)-eouterL>0d0))
              WTouterii(i)= WTouter*max(merge(1d0,0d0,evl(i,iq)-eouterH>0d0),merge(0d0,1d0,evl(i,iq)-eouterL>0d0))
              zmn(i,i)= zmn(i,i) + WTouterii(i) 
           enddo WTouterBlock
           WTseedBlock: if(WTseed/=0d0) then
              zmn=zmn-WTseed*matmul(amnk(iko_i(iq):iko_f(iq),1:nMLO,iq), & !projection to Seed functions
                   dconjg(transpose(amnk(iko_i(iq):iko_f(iq),1:nMLO,iq))))
           endif WTseedBlock
           HardInnerBlock: block !effective only when hardeinnerHeV > haredinnerLeV
             real(8),parameter:: zhard=-1d6
             do i=iko_i(iq),iko_f(iq) 
                if(evl(i,iq)<hardeinnerHeV/rydberg()+eferm.and.evl(i,iq)>hardeinnerLeV/rydberg()+eferm) then 
                   zmn(i,:)=0d0; zmn(:,i)= 0d0; zmn(i,i)= zhard
                endif
             enddo
           endblock HardInnerBlock
           call diag_hm(zmn,ndz,eval,evecc)
           ! eval(i)/wbbs is normalized. If all eval(i)/wbbs=1, P_k=P_{k+b}.
           forall(iwf = 1:nMLO) cnk(iko_i(iq):iko_f(iq),iwf,iq) = evecc(1:ndz,iwf) !ndz+1-iwf)
           evals(iq)= sum(eval(1:nMLO)) 
           omgik(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*matmul(zmn0,evecc(1:ndz,i))),i=1,nMLO)])  
           WTbandq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTbandii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !2nd energy term
           WTouterq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTouterii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !
           !write(stdo,ftox)'iq=',iq,'eval=',ftof(eval)
           deallocate (zmn,evecc,eval,zmn0,WTbandii,WTouterii)
        enddo iqloop
        omgi  = sum(omgik(:)*wbz(:)) 
        WTbandqsum=sum(WTbandq(:)*wbz(:))
        WTouterqsum=sum(WTouterq(:)*wbz(:))
        evalss= sum(evals(:)*wbz(:))   
        ! \sum eval = \sum zmn0 term + WTbandq + WTouterq
        !    write(stdo,ftox)'#SC-loop, OmegaI_a Zsum=',isc,ftof(omgi),'=',ftof(zesi-evalss+WTbandqsum+WTouterqsum)
        if(WTouter/=0d0) aaa='Pout='//trim(ftof(-WTouterqsum/WTouter/nMLO))
        if(WTband/=0d0) bbb='Emean(eV)='//trim(ftof((WTbandqsum/WTband/nMLO-eferm)*rydberg()))
        write(stdo,ftox)'#SC-loop:isc=',isc,'Omega/nMLO=',ftof( (wbbs+omgi/2d0/nMLO)/tpia**2 + WTbandqsum/nMLO + WTouterqsum/nMLO),&
             'Nabla2/nMLO(a.u.**2)=',ftof((wbbs+omgi/2d0/nMLO)/tpia**2/2d0 ),&
             'MeanOverlap=',ftof(-omgi/2d0/nMLO/wbbs),trim(bbb),trim(aaa) !Omega corresponds to Omega_I in Eq.34 Mazari.
        !NOTE: nMLO \sim omgi=\sum_b wb \sum_{m=1}^N \sum_{n=1}^N |Mmn^{k,b}|^2 (See Eq.7 in Souza paper).
        !      But Mnm here is only for coefficienets parts of eigenfunctions.
        if(isc>=2 .and. dabs(evalssold-evalss)<conv1) then   ! (1-6) check self-consistency
           write(stdo,ftox) ' Step1: converged!'
           exit
        endif
        evalssold = evalss
        if(isc==nsc1) write(stdo,ftox)' Step1: not converged'
     enddo SouzaStep1loop
     deallocate(upu) 
     !! NOTE: cnk(iko_ix:iko_fx,nMLO,nqbz) is the final results of Step1loop, which minimize Omega_I (Wannier space)
     !!   cnk(iko_i(iq):iko_f(iq),nMLO,iq) gives nMLO-dimentional space.
     GetHamiltonianforMTObyProjection: block  !We do not use Marzari's unitary rotation
       real(8):: qq(3)
       integer:: il,im,in,ib1,ib2,jsp
       complex(8):: phase,proj(iko_ix:iko_fx,iko_ix:iko_fx),pa(iko_ix:iko_fx,nMLO),ham(nMLO,nMLO),ovlx(nMLO,nMLO)
       jsp=is
       do iqbz = 1,nqbz
          qq(:) = qbz(:,iqbz) !          write(6,*)' xxxx iq q=',iq,qq
          do concurrent(i=iko_ix:iko_fx, j=iko_ix:iko_fx)     !outer bandindex
             proj(i,j) = sum(cnk(i,:,iqbz)*dconjg(cnk(j,:,iqbz))) !sum for MLOindex
          enddo
          pa(iko_ix:iko_fx,1:nMLO) = matmul(proj,amnk(iko_ix:iko_fx,1:nMLO,iqbz))
!          write(6,*)'sumcheck ham=',iqbz,sum(abs(pa)),sum(abs(evl(iko_ix:iko_fx,iqbz))),sum(abs(amnk(iko_ix:iko_fx,1:nMLO,iqbz)))
          do concurrent(i=1:nMLO,j=1:nMLO)
             ham(i,j)  = sum(dconjg(pa(:,i))*evl(iko_ix:iko_fx,iqbz)*pa(:,j)) !sum(dconjg(pa(:,i))*pa(:,j))!
             ovlx(i,j) = sum(dconjg(pa(:,i))*pa(:,j))
          enddo
!          write(6,*)'sumcheck ham=',iqbz,sum(abs(ham))
          do concurrent(i=1:nMLO,j=1:nMLO) !Real space Hamiltonian. H(k)->H(T) FT to real space
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                phase = 1d0/dble(nqbz)* exp(img*2d0*pi* sum(qq*matmul(plat,nlat(:,it,ib1,ib2))))
                hmmr2(i,j,it,jsp)= hmmr2(i,j,it,jsp)+ ham(i,j)*phase
                ommr2(i,j,it,jsp)= ommr2(i,j,it,jsp)+ ovlx(i,j)*phase
             enddo
          enddo
       enddo
     endblock GetHamiltonianforMTObyProjection
     write(6,*)' get hmmr2. Goto band_lmfham2.dat ---------'
     bandplotMLO: block
       real(8):: qp(3),evlm(nMLO,ndat)
       complex(8):: phase,hamm(nMLO,nMLO),ovlm(nMLO,nMLO),evec(nMLO,nMLO)
       integer:: iband
       jsp=is
       fband='band_lmfham2_spin'//char(48+jsp)//'.dat'
       fband1='band_lmfham1_spin'//char(48+jsp)//'.dat'
       open(newunit=iband,file=trim(fband))
       do iq= 1,ndat
          qp=qplistsy(:,iq) 
          ovlm = 0d0
          hamm = 0d0
          do concurrent(i=1:nMLO,j=1:nMLO)
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)
                phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                hamm(i,j)= hamm(i,j)+ hmmr2(i,j,it,is)*phase
                ovlm(i,j)= ovlm(i,j)+ ommr2(i,j,it,is)*phase
             enddo
          enddo
          nmx =nMLO
          call zhev_tk4(nMLO,hamm,ovlm,nmx,nev, evlm(:,iq), evec, oveps)! Diangonale (hamm - evl ovlm ) evec=0
          if(iq<6)  write(stdo,"(' iq q=',i3,*(a))") iq,' ',ftof(qp,3),' e=',ftof(evlm(1:12,iq),3)
          if(iq==6) write(stdo,"(' iq q= ...')") 
          do i=1,nev
             write(iband,ftox)  ftof(xdat(iq)),ftof(evlm(i,iq)), is,i
          enddo
       enddo
       close(iband)
     endblock bandplotMLO
!     write(stdo,ftox)'eouter ewid (eV)=',ftof((eouter-eferm)*rydberg()),ftof(ewid*rydberg())
     Modifiedbandplotglt: block
       integer:: ifglt1,ifglt
       character(256):: aline,fname,fname2
       jsp = is
       fname2='bandplot.lmfham2.isp'//char(48+jsp)//'.glt'
       fname ='bandplot.isp'//char(48+jsp)//'.glt'
       open(newunit=ifglt,  file=trim(fname))
       open(newunit=ifglt1, file=trim(fname2))
       do 
          read(ifglt,"(a)",err=989,end=989)aline
          if(trim(aline)=="plot \") then !"
             write(ifglt1,ftox)"ef=",ftof(eferm)  
             write(ifglt1,ftox)trim(aline)
             write(ifglt1,ftox)'"'//trim(fband1)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "green",\'   !'  
             write(ifglt1,ftox)'"'//trim(fband)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'  
          else
             write(ifglt1,ftox)trim(aline)
          endif   
       enddo
989    continue
       close(ifglt)
       close(ifglt1)
       write(stdo,ftox)'OK! Run gnuplot -p '//trim(fname2)//'.Red points are by hmmr2 for Hamiltonian on {|MLO2>}'
    endblock Modifiedbandplotglt
    deallocate(cnk,omgik,evals,wtbandq,wtouterq,proj)
1000 enddo ispinloop
  call rx0('OK! end of lmfham2 -----------------')
! contains
!   pure real(8) function fermidist(x)
!     real(8),intent(in) :: x
!     if(x>100d0) then
!        fermidist=0d0
!     elseif(x<-100d0) then
!        fermidist=1d0
!     else
!        fermidist=1d0/(exp(x)+1)
!     endif
!   end function fermidist
END PROGRAM


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ! ! --- Readin nlam index
     ! open(newunit=ifoc,file ='@MNLA_CPHI')
     ! ldim2 = ldim !nlmto
     ! read(ifoc,*)
     ! if(allocated(m_indx)) deallocate(m_indx,n_indx,l_indx,ibas_indx,ibasiwf)
     ! allocate(m_indx(ldim2),n_indx(ldim2),l_indx(ldim2),ibas_indx(ldim2))
     ! do ix =1,ldim2
     !    read(ifoc,*)m_indx(ix),n_indx(ix),l_indx(ix),ibas_indx(ix),ixx
     !    if(ixx/=ix) call rx('failed to readin @MNLA_CPHI')
     ! enddo
     ! close(ifoc)
     ! allocate(ibasiwf(nwf))
     ! do iwf=1,nwf
     !    ibasiwf(iwf) = ibas_indx(iphi(1,iwf))
     ! enddo

     ! !! write HrotRS
     ! ifh=ifile_handle()
     ! if(is==1) open(ifh,file='HrotRS.up',form='unformatted')
     ! if(is==2) open(ifh,file='HrotRS.dn',form='unformatted')
     ! write(ifh)alat,plat,natom
     ! write(ifh)pos
     ! write(ifh)ef
     ! write(ifh)nwf,nrws,n1,n2,n3
     ! write(ifh) irws,rws,drws,hrotr, ibasiwf !drws added by okumura Aug28,2017
     ! close(ifh)

!     call write_hopping_output(is, hrotr, &
!          rws,irws,alat,plat,qlat,pos,natom, &
!          ibasiwf, nwf,nrws,spid , m_indx, l_indx, &
!          nphix, iphi, ldim2)
     !      close(ifh)

     !! TEST okumura: iq=1,nq, q->qbz?   (2017/06/10)
!!! qtt -> q, nqtt -> nqbz
     ! ! data list for wannier
     ! ifh=ifile_handle()
     ! open(ifh,file="wan4chi.d",form="unformatted")
     ! write(ifh) nwf,nspin,nqbz
     ! close(ifh)

     ! ! generate eigenvalue and eigenvector of Wannier Hamiltonian
     ! ! Index:: evecc_w (orbital,band,q-point,spin)
     ! write(6,*)
     ! if (is==1) allocate(eval_w(nwf,nqbz,nspin),evecc_w(nwf,nwf,nqbz,nspin))
     ! do iq = 1,nqbz
     !    if(iq<5 .OR. iq>nqbz-3)write(6,*)' got get_hrotkp_ws iq =',iq
     !    if(iq==5)write(6,*)' ...'
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,qbz(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval_w(1:nwf,iq,is)=eval
     !    evecc_w(1:nwf,1:nwf,iq,is)=evecc
     ! enddo

     ! if(is==2) then
     !    ifh=ifile_handle()
     !    open(ifh,file='EValue_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) eval_w(1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     !    ifh=ifile_handle()
     !    open(ifh,file='EVec_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) qbz(1:3,1:nqbz)
     !    write(ifh) evecc_w(1:nwf,1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     ! endif
     ! ! end okumura

     ! !! other k-points
     ! write(ifbnd,*)ef,' ef'
     ! write(iftb,*)ef,' ef'
     ! write(iffb,*)'#',ef,' ef'
     ! if (lsh) write(ifsh,*)ef,' ef'
     ! allocate(eval1(nwf,nq),eval3(nwf,nq),evecc1(nwf,nwf,nq))
     ! if(lsh) allocate(eval2(nwf,nq),evecc2(nwf,nwf,nq))
     ! do iq = 1,nq
     !    !     write(6,*)' got get_hrotkp_ws iq =',iq
     !    ! (3-3) Hrot_mn(k')
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,q(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    ! (3-4) diagonalize
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval1(1:nwf,iq)=eval
     !    evecc1(1:nwf,1:nwf,iq)=evecc
     !    !     (3-4) diagonalize  -- Small Hamiltonian --
     !    if (lsh) then
     !       hrotkps(1:nsh,1:nsh) = hrotkp(nsh1:nsh2,nsh1:nsh2)
     !       call diag_hm(hrotkps,nsh,evals,eveccs)
     !       write(ifsh,*)'iq =',iq
     !       write(ifsh,990)q(1:3,iq)
     !       eval2(1:nsh,iq)= evals(1:nsh)
     !       evecc2(1:nwf,1:nwf,iq)=eveccs
     !    endif                 ! lsh
     !    ! (3-3) Hrot_mn(k')  -- Tight-binding ---
     !    call get_hrotkp_tb_ws(rcut,plat,alat, &
     !         hrotr,rws,drws,irws,q(:,iq),  ibasiwf,pos,natom, &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    !     (3-4) diagonalize -- Tight-binding --
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval3(1:nwf,iq)=eval
     ! enddo
     ! do iband = 1,nwf
     !    do iq = 1,nq
     !       write(ifbnd,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       write(iftb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval3(iband,iq)-ef)*rydberg(),iband
     !       write(iffb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' ')",ADVANCE='NO') &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       do iwf=1,nwf
     !          write(iffb,"(f13.6)",ADVANCE='NO') (abs(evecc1(iwf,iband,iq)))**2
     !       enddo
     !       write(iffb,*)
     !    enddo
     !    write(ifbnd,*)
     !    write(iftb,*)
     !    write(iffb,*)
     !    write(iffb,*)
     ! enddo
!     deallocate(eval1,eval3,evecc1)
     ! if(lsh) then
     !    do iband = 1,nsh
     !       do iq = 1,nq
     !          write(ifsh,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !               iq,q(1:3,iq),  xq(iq),(eval2(iband,iq)-ef)*rydberg(),iband
     !       enddo
     !    enddo
     ! endif
!     call writeham(ifham,is,ef,alat,plat,pos,qbz,wbz,rws,irws,hrotk,nspin,natom,nwf,nqbz,nrws)
!     deallocate(cnk,umnk,eunk,hrotk,hrotr,hrotkp,evecc,eval,irws,rws,drws, &
!          ibasiwf,m_indx,n_indx,l_indx,ibas_indx)
!     if (lsh) deallocate(hrotkps,eveccs,evals,evecc2)
!     close(ifbnd)
!     close(iftb)
!     close(iffb)
!1000 enddo ispinloop
!950 format(a14,3f23.16)
!990 format(3f12.6)
!  call cputid(0)
!  call rx0s('lmfham2: ixc=2 ok')
!END PROGRAM lmfham2
