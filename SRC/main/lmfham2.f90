program lmfham2 ! Get |MLO2> from |MLO1>. Conversion from (hmmr1,ommr1,nwf1) to (hmmr2,ommr2,nwf2).
  ! In advance, run lmfham1 to get MLO1 (MLO1 are given by a mapping from MTOs to PMT space.
  ! That is, |MLO1_i> = M |MTO_i>, where M is a mapping from MTO to the space of PMT.
  !  
  ! We use a modified procedure of this method of  [2]I.Souza, N.Marzari and D.Vanderbilt, PRB65,035109(2002) 
  !
  ! Main part of lmfham2 is Step1loop. 
  ! Among the space spanned by |MLO1>, we extract minimum basis space.
  ! For example, we have 25+25 MTOs for Si;then we extract 9+9 space spanned by |MLO2>.
  !
  ! We use diffent idea of connectivity from [2]. Roughly speaking, we define connectivitiy of eigenfunctions between k and k+b,
  ! not by the overlap of periodic part of eigenfunctions, but by the coefficients on |MLO1>.
  !
  use m_ftox
  use m_lgunit,only: stdo
  use m_keyvalue,only: getkeyvalue
  use m_zhev,only:zhev_tk4
  use m_MPItk,only:    m_MPItk_init, m_MPItk_finalize, nsize, master_mpi !  use m_ext,only:      m_ext_init,sname
  use m_readqplist,only: eferm,qplistsy,ndat,xdat, Readqplistsy !qplist.dat is generated by job_band
  use m_HamPMT,only: ReadHamPMTInfo, nspin=>nsp, natom=>nbas,plat,alat,npair,nlat,nqwgt, ldim, nkp,qbz=>qplist,&
       n1=>nkk1,n2=>nkk2,n3=>nkk3,pos,npairmx,nspx !,ib_table,l_table,k_table
  use m_read_Worb,only:s_read_Worb,nclass_mlwf,cbas_mlwf,norb=>nbasclass_mlwf,classname_mlwf ! iclassin,iphi,iphidot,nphi,nphix
  use m_HamRsMTO,only: ReadHamRsMTO,hmmr1=>hammr,ommr1=>ovlmr,nwf1=>ndimMTO,ib_tableM,l_tableM,k_tableM !Real-space Hamiltonian on the basis |MLO1>.
  !      Main output of lmfham2 is  hmmr2,       ommr2,       nwf2,         ib_tableM(idmto(1:nwf)),... for |MLO2>
  implicit none
  integer:: i,iq,is,ix,j,ifbb,ifoc,nbb,isc,ifq0p, nox,iko_ix,iko_fx,nsc1,ndz,nin,nout,nsc2,ibb
  integer:: inii,if102,iwf2,ib,itmp,itmp2,nqbz2,nspin2,ib1,ib2,iqb,iqbz,it,jsp,nmx,nev,isyml,nband,nqbz!,n1,n2,n3
  integer:: nwf2,ikx,ikxx,iadd,ndzm,i1q,i2q,i1,i2,imp,inp,inx,imx,ibas,ibold,ibx,iorb
  integer,parameter:: nlinex=100
  integer::nline,np(nlinex), iwf,ldim2,ixx,npin,ifuumat,job
  real(8),parameter:: pi = 4d0*datan(1d0)
  real(8) :: tpia,vol,voltot,rs,alpha, rydberg,hartree,qlat(3,3),tripl,wbbsum,bb(3,12),eimax ,wbbs
  real(8):: qi(3,nlinex),qf(3,nlinex), omgi,omgiold,conv1,alpha1,zesumold,zesi,emm,einnerL,einnerH,einnerLeV,einnerHeV,emin
  real(8)::qiin(3),qfin(3),qold(3),enwfmax,qxx(3),eeee,enwfmaxi, epsovl=1d-8,ginv(3,3),einner,ewid,fac2,ecenter,eee,etest,egap,fac1
  character(8) :: xt
  real(8),allocatable    :: q(:,:)
  real(8),allocatable:: ku(:,:),kbu(:,:,:),eunk(:,:),eval(:),evals(:), eks(:),wbb(:)
  integer,allocatable:: ikbidx(:,:),iko_i(:),iko_f(:)
  real(8),allocatable:: omgik(:),zesum(:)
  real(8),allocatable:: xq(:),eval1(:,:),eval2(:,:),eval3(:,:),eval_w(:,:,:)
  integer,allocatable:: m_indx(:),n_indx(:),l_indx(:),ibas_indx(:),ibasiwf(:),idmto(:),idmto_(:)
  real(8),allocatable:: evl(:,:),ovl(:), bbv(:,:),wbz(:)
  complex(8),allocatable:: upu(:,:,:,:), zmn(:,:),zmn0(:,:)
  complex(8),parameter:: img=(0d0,1d0)
  complex(8),allocatable::ovlm(:,:),ovlmx(:,:),hamm(:,:),ovec(:,:)!,emat(:,:)
  complex(8),allocatable:: uumat(:,:,:,:),evecc(:,:), amnk(:,:,:),cnk(:,:,:),umnk(:,:,:),evecc1(:,:,:),evecc2(:,:,:)
  complex(8),allocatable:: hmmr2(:,:,:,:),ommr2(:,:,:,:),wmat(:,:),wmat2(:,:)
  character(256):: fband
  logical:: cmdopt2
  character:: outs*20
  integer:: nwf1_,nqbz_,iko_ix_,iko_fx_,nwf2_
  call m_MPItk_init('lmfham2') ! mpi initialization
  job=-1
  if(cmdopt2('--job=',outs)) read(outs,*) job
  if(job/=0.and.job/=1) call rx0(' Set --job=0 or 1')
  write(stdo,ftox)'=== Start lmfham2 --job=',job
  call mpibc1_int(job,1,'lmfham2_job')
  hartree=2d0*rydberg()
  call ReadHamPMTInfo()   ! Read infomation for Hamiltonian (lattice structures and index of basis).
  call ReadHamRsMTO()
  nqbz=nkp
  call pshpr(30)
  tpia = 2d0*pi/alat
  call minv33tp(plat,qlat)
  ginv   = transpose(plat)
  voltot = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))
  call readqplistsy()
  ReadInfoFromGWinput: block
    call s_read_Worb() ! Input orbital index for MLO, stored into idmto
    nwf2=sum(norb(1:nclass_mlwf)) !number of MLO2
    allocate(idmto(nwf2)) 
    ibx=0
    ibold=-999
    iorb=0
    SETidmto:do i = 1,nwf1 !for example, allocate(idmto,source=[(i,i=1,9),(i+25,i=1,9)]) for Si
       if(ibold/=ib_tableM(i)) ibx=0
       ibas=ib_tableM(i)
       ibx=ibx+1
       if(findloc([(ibx==cbas_mlwf(ix,ibas),ix=1,norb(ibas))],dim=1,value=.true.)/=0) then
          iorb=iorb+1
          idmto(iorb)=i
       endif       !write(stdo,"('MHAM: i ib(atom) l m k(EH,EH2,PZ)=',5i3)") i,ib_table(i),ibx
       ibold=ib_tableM(i)
    enddo SETidmto
    write(stdo,ftox)' idmto=',idmto
    call getkeyvalue("GWinput","mlo_maxit",nsc1,default=10)
    call getkeyvalue("GWinput","mlo_conv",conv1,default=1d-4)
    call getkeyvalue("GWinput","mlo_mix",alpha1,default=.5d0)
    call getkeyvalue("GWinput","mlo_WTlow"  ,fac1,default=0.05d0)     ! WeighT to emphasize lower energy bands
    call getkeyvalue("GWinput","mlo_WTinner",fac2,default=10d0)       ! inner energy window WeighTing
    call getkeyvalue("GWinput","mlo_EWinner", ewid, default=.1d0)     ! inner energy window softing eV
    call getkeyvalue("GWinput","mlo_ELinner", einnerLeV,default=-1d8) ! inner energy window lower eV relative to efermi (or VBM)
    call getkeyvalue("GWinput","mlo_EUinner", einnerHeV,default= 1d8) ! inner energy window upper eV relative to efermi
    write(stdo,ftox)' Reading: mlo_ ELinner EUinner EWinner relative to Ef (eV) =',ftof(einnerLeV),ftof(einnerHeV),ftof(ewid)
    write(stdo,ftox)' Reading: mlo_ maxit conv mix=',nsc1,ftof(conv1),ftof(alpha1)
    write(stdo,ftox)' Reading: mlo_ WTlow WTinner=',ftof(fac1),ftof(fac2)
    write(stdo,ftox)' --- Our test show Wlow=0.05 and Winner=10 is good for Si666(spd model); Wlow=0.20 Winner=10 for Si888 ---'
    write(stdo,ftox)'  Larger mlo_Wlow may give flatter bands at low energy (larger bandgap). Tested Range of Wlow 0.05 ~ 0.2'
    write(stdo,ftox)'  Larger mlo_Winner may pushe down bands to lower energy(smaller bandgap). Tested Range of Winner 1 ~ 10'
    write(stdo,ftox)'  So, (probably) Choose Wlow to fit band width, then Choose Winner to fit band gap.'
  endblock ReadInfoFromGWinput
  ewid= ewid/rydberg() !in Ry.
  bbvector: block !Get connecting vectors bb, bb connects k and k+bb, where both k and k+bb are on mesh points nqbz.
    allocate(wbb(12))
    call getbb(plat,alat,n1,n2,n3, nbb,wbb,wbbsum,bb) ! b vectors (connecting vectors).
    allocate (ku(3,nqbz),kbu(3,nbb,nqbz),ikbidx(nbb,nqbz))
    call kbbindx(qbz,ginv,bb, nqbz,nbb, ikbidx,ku,kbu) ! index for k and k+bb
    allocate(iko_i(nqbz),iko_f(nqbz)) !, ikbo_i(nbb,nqbz),ikbo_f(nbb,nqbz)) !, ikbi_i(nbb,nqbz),ikbi_f(nbb,nqbz))
    call writebb2(ifbb,wbb(1:nbb),bb(1:3,1:nbb), ikbidx,ku,kbu, nqbz,nbb)
    allocate(bbv,source=bb)
  endblock bbvector
  nband= nwf1     
  iko_i=1; iko_f=nwf1 ! outer window nwf1 is the number of MLO
  iko_ix=minval(iko_i)
  iko_fx=maxval(iko_f)
  nox = iko_fx - iko_ix + 1
  if(job==1) goto 1011 !Goto Souza's iteration job=1 mode
  GetCNmatFile: block  !job=0 mode to get CNmat file (connection matrix uumat and so on).
    real(8):: qp(3),evl(nwf1,nqbz),ovl(nwf1)
    complex(8):: emat(nwf1,nwf1),osq(1:nwf1,1:nwf1),o2al(1:nwf1,1:nwf1,nqbz),phase,ovlmm(nwf1,nwf2),&
         evec(nwf1,nwf1,nqbz),evecx(1:nwf1,1:nwf1), ovec(nwf1,nwf1),amnk(iko_ix:iko_fx,nwf2,nqbz),&
         ovlm(1:nwf1,1:nwf1),ovlmx(1:nwf1,1:nwf1), hamm(1:nwf1,1:nwf1),uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz)
    write(stdo,ftox)'Going to get CNmat ... : nwf1 for |MLO1>=',nwf1,'iko_i iko_f=',iko_ix,iko_fx
    open(newunit=ifuumat,file='CNmat',form='unformatted')
    uuispinloop: do 1010 is = 1,nspin
       write(stdo,ftox)'Generating connection matrix ispinloop: is =',is,'  out of',nspin
       emat=0d0
       forall(i=1:nwf1) emat(i,i)=1d0
       do iqbz=1,nqbz
          qp=qbz(:,iqbz)
          ovlm = 0d0
          hamm = 0d0
          do i=1,nwf1
             do j=1,nwf1
                ib1 = ib_tableM(i) !atomic-site index in the primitive cell
                ib2 = ib_tableM(j)
                do it =1,npair(ib1,ib2) !real-space to H,O at qp
                   phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                   hamm(i,j)= hamm(i,j)+ hmmr1(i,j,it,is)*phase 
                   ovlm(i,j)= ovlm(i,j)+ ommr1(i,j,it,is)*phase
                enddo
             enddo
          enddo
          nmx=nwf1
          ovlmx=ovlm
          call zhev_tk4(nwf1,ovlm,emat,nmx,nev, ovl, ovec, epsovl) !Diangonale overlap matrix. (ovlm - e ) ovec=0
          ovlm=ovlmx
          call zhev_tk4(nwf1,hamm,ovlm,nmx,nev, evl(:,iqbz), evec(:,:,iqbz), epsovl) !Diangonale (hamm- evl ovlm) z=0
          do concurrent (i=1:nwf1,j=1:nwf1)
             osq(i,j)=sum(ovec(i,:)*ovl(:)**0.5d0*dconjg(ovec(j,:))) !O^(1/2)
          enddo
          o2al(:,:,iqbz) = matmul(osq, evec(:,:,iqbz)) !o2al(basis index, band index, iqbz index) O^(1/2)*evec
          forall(i=1:nwf1) ovlmm(i,:) = ovlmx(i,idmto(:))
          amnk(:,:,iqbz)= matmul(transpose(dconjg(evec(1:nwf1,iko_ix:iko_fx,iqbz))),ovlmm) !amnk= <psi|MTO> minimum basis MTO =9+9
       enddo
       do iqbz=1,nqbz
          do ibb=1,nbb
             iqb = ikbidx(ibb,iqbz)             !q1(:) = qbz(:,iqbz)             !q2(:) = q1(:) + bbv(:,ibb)
             do concurrent(ib1=iko_ix:iko_fx, ib2=iko_ix:iko_fx) !ib1,ib2 band index of outer-inner window
                uumat(ib1,ib2,ibb,iqbz)= sum(dconjg(o2al(1:nwf1,ib1,iqbz))*o2al(1:nwf1,ib2,iqb)) ! define connection <q ib1| q+b ib2>
             enddo
          enddo
       enddo
       write(ifuumat) nwf1,nqbz,iko_ix,iko_fx,nwf2,idmto
       write(ifuumat) evl   !eigenvalue
       write(ifuumat) uumat !connection matrix
       write(ifuumat) amnk  !initial projection
1010 enddo uuispinloop
    close(ifuumat)
    if(job==0) call rx0('OK! end of lmhfam2 job=0 for generating CNmat')
  endblock GetCNmatFile

1011 continue !=== job==1 mode start ========================================
  open(newunit=ifuumat,file='CNmat',form='unformatted')
  allocate(hmmr2(nwf2,nwf2,npairmx,nspin),ommr2(nwf2,nwf2,npairmx,nspin),source=(0d0,0d0))
  allocate(ovlm(1:nwf1,1:nwf1),ovlmx(1:nwf1,1:nwf1),hamm(1:nwf1,1:nwf1))
  allocate(evl(nwf1,nqbz), ovec(nwf1,nwf1),ovl(nwf1))
  allocate(amnk(iko_ix:iko_fx,nwf2,nqbz),idmto_(nwf2))
  allocate(wbz(nqbz),source=1d0/nqbz)
  allocate (uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz))
  ispinloop: do 1000 is = 1,nspin
     write(stdo,ftox)'ispinloop: is =',is,'  out of',nspin
     read(ifuumat) nwf1_,nqbz_,iko_ix_,iko_fx_,nwf2_,idmto_
     if(nwf2/=nwf2.or.sum(abs(idmto-idmto_))/=0) call rx0('lmfham2: idmto error: Repeat --job=1 with the same <Worb> in GWinput!')
!     if( sum(abs([nwf1_-nwf1, nqbz_-nqbz, iko_ix_-iko_ix, iko_fx_-iko_fx, nwf2_-nwf2]))/=0) &
!          call rx0('Repeat --job=1 with the same setting <Worb>.')
     read(ifuumat) evl
     read(ifuumat) uumat
     read(ifuumat) amnk
     emm=9999d0
     emin=9999d0
     do iqbz=1,nqbz ! Default einnerH is at lowest of nwf2/2 th band.
        emm = min(evl(nwf2/2,iqbz),emm) !>eferm+1d-2,dim=1,value=.true.),iqbz) !evl(cvm+1)
        emin= min(emin,evl(1,iqbz))
     enddo
     if(einnerHeV> 1d7) einnerHeV= (emm-eferm)*rydberg()       !default emax is around at center of bands.
     einnerH= einnerHeV/rydberg()+eferm
     einnerL= einnerLeV/rydberg()+eferm
     if(master_mpi) write(*,*)'Step1loop: Choose Hilbert space by cnk(iko_ix:iko_fx,1:nwf2,1:nqbz)=',iko_ix,iko_fx,nwf2,nqbz
     if(master_mpi) write(stdo,ftox)'einnerH from VBM=',ftof((einnerH-eferm)*rydberg()),' eV'
     if(master_mpi) write(stdo,ftox)'einnerL from VBM=',ftof((einnerL-eferm)*rydberg()),' eV'
     allocate ( upu(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz), cnk(iko_ix:iko_fx,nwf2,nqbz), omgik(nqbz), zesum(nqbz)) !cnk2(iko_ix:iko_fx,nwf2,nqbz)
     cnk  = 0d0
     call amnk2unk(amnk,iko_ix,iko_fx,iko_i,iko_f, nwf2,nqbz,  cnk)! amnk was in Eq.22 in Ref.II. <psi|Gaussian>. Now amnk=< psi(it,iqbz) | MTO(nwf2) >
     zesumold=1d10
     alpha = 1d0
     upu   = 0d0
     SouzaStep1loop: do isc = 1,nsc1 ! choose Hilbert space -- determine cnk
        iqloop: do iq = 1,nqbz 
           nout = iko_f(iq) - iko_i(iq) + 1 !outer
           ndz  = nout 
           if(isc /= 1) alpha = alpha1
           allocate(wmat(iko_ix:iko_fx,iko_ix:iko_fx), wmat2(iko_ix:iko_fx,iko_ix:iko_fx))
           i1q=iko_i(iq)
           i2q=iko_f(iq)
           do ibb = 1,nbb
              iqb = ikbidx(ibb,iq)
              i1= iko_i(iqb)
              i2= iko_f(iqb)
              do concurrent(inp=i1:i2, imp=i1:i2) !wmat = cnk * cnk^{*} is projector to 'wannier space'.
                 wmat(inp,imp)= sum(dconjg(cnk(inp,1:nwf2,iqb))*cnk(imp,1:nwf2,iqb)) !BUG-> range of sum was nin+1,nwf2 before 2023-6-8(miyake)
              enddo
              do concurrent(inx=i1q:i2q, imp=i1:i2)
                 wmat2(imp,inx)= sum( wmat(i1:i2,imp)*dconjg(uumat(inx,i1:i2,ibb,iq)) ) !wmat*uumat
              enddo
              do concurrent(imx=i1q:i2q, inx=i1q:i2q)!      upu=   uumat* wmat * uumat ! (1-2) <u_mk | P_k+b | u_nk>
                 upu(imx,inx,ibb,iq)= (1d0-alpha)*upu(imx,inx,ibb,iq) + alpha*sum(uumat(imx,i1:i2,ibb,iq)*wmat2(i1:i2,inx))
              enddo
           enddo
           deallocate(wmat,wmat2)
           
           allocate (zmn0(ndz,ndz),source=(0d0,0d0)) ! (1-3) Zmn(k) > phi,eval
           allocate (zmn(ndz,ndz), evecc(ndz,ndz),eval(ndz))
           do ibb = 1,nbb
              zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) + wbb(ibb)*upu(iko_i(iq):iko_f(iq),iko_i(iq):iko_f(iq),ibb,iq)
           enddo 
           zmn=zmn0
           wbbs=sum(wbb(1:nbb))
           forall(i=iko_i(iq):iko_f(iq)) !penalty part to emphasize innner window
              zmn(i,i)=zmn0(i,i)&
                   + fac1*wbbs*(-evl(i,iq)) & !lower eigenvalue for higher energy
                   + fac2*wbbs* 1d0/(exp((evl(i,iq)-einnerH)/ewid)+1d0) * 1d0/(exp(-(evl(i,iq)-einnerL)/ewid)+1d0) !inner window enhancement
           end forall
           ! do i=iko_i(iq),iko_f(iq) !Hard inner window
           !    if(evl(i,iq)<einnerH.and.evl(i,iq)>einnerL) then
           !       zmn(i,i)       = 9999d0
           !       zmn(i,1:i-1   )= 0d0
           !       zmn(i,i+1:ndz )= 0d0
           !       zmn(1:i-1, i  )= 0d0
           !       zmn(i+1:ndz,i )= 0d0
           !    endif   
           ! enddo
           call diag_hm(zmn,ndz,eval,evecc)
           ndzm=ndz-nwf2+1
           zesum(iq)=sum(eval(ndzm:ndz))
           forall(iwf = 1:nwf2) cnk(iko_i(iq):iko_f(iq),iwf,iq) = evecc(1:ndz,ndz+1-iwf)
           omgik(iq)= nwf2*sum(wbb(1:nbb)) -sum(matmul(transpose(dconjg(evecc(1:ndz,ndzm:ndz))),matmul(zmn0,evecc(1:ndz,ndzm:ndz))))
           deallocate (zmn,evecc,eval,zmn0)
        enddo iqloop
        omgi = sum(omgik(:)*wbz(:)) ! (1-5) w_I(k) > Omaga_I  eq.(11)
        zesi = sum(zesum(:)*wbz(:))
        write(stdo,ftox)'#SC-loop, Omega_I Zsum=',isc,ftof(omgi),ftof(zesi)
        if(isc>=2 .and. dabs(zesumold-zesi)<conv1) then   ! (1-6) check self-consistency
           write(*,*) 'step1: converged!'
           exit
        endif
        zesumold = zesi
        if(isc==nsc1) write(*,*)'step1: not converged'
     enddo SouzaStep1loop
     deallocate(upu) 
     !! NOTE: cnk(iko_ix:iko_fx,nwf2,nqbz) is the final results of Step1loop, which minimize Omega_I (Wannier space)
     !!   cnk(iko_i(iq):iko_f(iq),nwf2,iq) gives nwf2-dimentional space.
     GetHamiltonianforMTObyProjection: block  !We do not use Marzari's unitary rotation
       real(8):: qq(3)
       integer:: il,im,in,ib1,ib2,jsp
       complex(8):: ham(nwf2,nwf2),ovlx(nwf2,nwf2),phase,proj(iko_ix:iko_fx,iko_ix:iko_fx),pa(iko_ix:iko_fx,nwf2)
       jsp=is
       do iqbz = 1,nqbz
          qq(:) = qbz(:,iqbz) !          write(6,*)' xxxx iq q=',iq,qq
          do concurrent(i=iko_ix:iko_fx, j=iko_ix:iko_fx)     !outer bandindex
             proj(i,j) = sum(cnk(i,:,iqbz)*dconjg(cnk(j,:,iqbz))) !sum for MLOindex
          enddo
          pa(iko_ix:iko_fx,1:nwf2) = matmul(proj,amnk(iko_ix:iko_fx,1:nwf2,iqbz))
          do concurrent(i=1:nwf2,j=1:nwf2)
             ham(i,j)  = sum(dconjg(pa(:,i))*evl(:,iqbz)*pa(:,j)) !sum(dconjg(pa(:,i))*pa(:,j))!
             ovlx(i,j) = sum(dconjg(pa(:,i))*pa(:,j))
          enddo
          do concurrent(i=1:nwf2,j=1:nwf2) !Real space Hamiltonian. H(k)->H(T) FT to real space
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                phase = 1d0/dble(nkp)* exp(img*2d0*pi* sum(qq*matmul(plat,nlat(:,it,ib1,ib2))))
                hmmr2(i,j,it,jsp)= hmmr2(i,j,it,jsp)+ ham(i,j)*phase
                ommr2(i,j,it,jsp)= ommr2(i,j,it,jsp)+ ovlx(i,j)*phase
             enddo
          enddo
       enddo
     endblock GetHamiltonianforMTObyProjection
     write(6,*)' get hmmr2. Goto band_lmfham2.dat ---------'
     bandplotMLO: block
       real(8):: qp(3),evlm(nwf2,ndat)
       complex(8):: phase,hamm(nwf2,nwf2),ovlm(nwf2,nwf2),evec(nwf2,nwf2)
       integer:: iband
       jsp=is
       fband='band_lmfham2_spin'//char(48+jsp)//'.dat'
       open(newunit=iband,file=trim(fband))
       do iq= 1,ndat
          qp=qplistsy(:,iq)
          !qp = q(:,iq)
          ovlm = 0d0
          hamm = 0d0
          do concurrent(i=1:nwf2,j=1:nwf2)
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)
                phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                hamm(i,j)= hamm(i,j)+ hmmr2(i,j,it,is)*phase
                ovlm(i,j)= ovlm(i,j)+ ommr2(i,j,it,is)*phase
             enddo
          enddo
          nmx =nwf2
          call zhev_tk4(nwf2,hamm,ovlm,nmx,nev, evlm(:,iq), evec, epsovl)! Diangonale (hamm - evl ovlm ) evec=0
          if(iq<6)  write(stdo,"(' iq q=',i3,*(a))") iq,' ',ftof(qp,3),' e=',ftof(evlm(1:12,iq),3)
          if(iq==6) write(stdo,"(' iq q= ...')") 
          do i=1,nev
             write(iband,ftox)  ftof(xdat(iq)),ftof(evlm(i,iq)), is,i
          enddo
       enddo
       close(iband)
     endblock bandplotMLO
     write(stdo,ftox)'einner ewid (eV)=',ftof((einner-eferm)*rydberg()),ftof(ewid*rydberg())
     Modifiedbandplotglt: block
       integer:: ifglt1,ifglt
       character(256):: aline,fname,fname1
       jsp = is
       fname1='bandplot.lmfham2.isp'//char(48+jsp)//'.glt'
       fname ='bandplot.isp'//char(48+jsp)//'.glt'
       open(newunit=ifglt,  file=trim(fname))
       open(newunit=ifglt1, file=trim(fname1))
       do 
          read(ifglt,"(a)",err=989,end=989)aline
          if(trim(aline)=="plot \") then !"
             write(ifglt1,ftox)"ef=",ftof(eferm)  
             write(ifglt1,ftox)trim(aline)
             write(ifglt1,ftox)'"'//trim(fband)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'  
          else
             write(ifglt1,ftox)trim(aline)
          endif   
       enddo
989    continue
       close(ifglt)
       close(ifglt1)
       write(stdo,ftox)'OK! Run gnuplot -p '//trim(fname1)//'.Red points are by hmmr2 for Hamiltonian on {|MLO2>}'
    endblock Modifiedbandplotglt
1000 enddo ispinloop
  call rx0('OK! end of lmfham2 -----------------')
END PROGRAM lmfham2

     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ! ! --- Readin nlam index
     ! open(newunit=ifoc,file ='@MNLA_CPHI')
     ! ldim2 = ldim !nlmto
     ! read(ifoc,*)
     ! if(allocated(m_indx)) deallocate(m_indx,n_indx,l_indx,ibas_indx,ibasiwf)
     ! allocate(m_indx(ldim2),n_indx(ldim2),l_indx(ldim2),ibas_indx(ldim2))
     ! do ix =1,ldim2
     !    read(ifoc,*)m_indx(ix),n_indx(ix),l_indx(ix),ibas_indx(ix),ixx
     !    if(ixx/=ix) call rx('failed to readin @MNLA_CPHI')
     ! enddo
     ! close(ifoc)
     ! allocate(ibasiwf(nwf))
     ! do iwf=1,nwf
     !    ibasiwf(iwf) = ibas_indx(iphi(1,iwf))
     ! enddo

     ! !! write HrotRS
     ! ifh=ifile_handle()
     ! if(is==1) open(ifh,file='HrotRS.up',form='unformatted')
     ! if(is==2) open(ifh,file='HrotRS.dn',form='unformatted')
     ! write(ifh)alat,plat,natom
     ! write(ifh)pos
     ! write(ifh)ef
     ! write(ifh)nwf,nrws,n1,n2,n3
     ! write(ifh) irws,rws,drws,hrotr, ibasiwf !drws added by okumura Aug28,2017
     ! close(ifh)

!     call write_hopping_output(is, hrotr, &
!          rws,irws,alat,plat,qlat,pos,natom, &
!          ibasiwf, nwf,nrws,spid , m_indx, l_indx, &
!          nphix, iphi, ldim2)
     !      close(ifh)

     !! TEST okumura: iq=1,nq, q->qbz?   (2017/06/10)
!!! qtt -> q, nqtt -> nqbz
     ! ! data list for wannier
     ! ifh=ifile_handle()
     ! open(ifh,file="wan4chi.d",form="unformatted")
     ! write(ifh) nwf,nspin,nqbz
     ! close(ifh)

     ! ! generate eigenvalue and eigenvector of Wannier Hamiltonian
     ! ! Index:: evecc_w (orbital,band,q-point,spin)
     ! write(6,*)
     ! if (is==1) allocate(eval_w(nwf,nqbz,nspin),evecc_w(nwf,nwf,nqbz,nspin))
     ! do iq = 1,nqbz
     !    if(iq<5 .OR. iq>nqbz-3)write(6,*)' got get_hrotkp_ws iq =',iq
     !    if(iq==5)write(6,*)' ...'
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,qbz(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval_w(1:nwf,iq,is)=eval
     !    evecc_w(1:nwf,1:nwf,iq,is)=evecc
     ! enddo

     ! if(is==2) then
     !    ifh=ifile_handle()
     !    open(ifh,file='EValue_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) eval_w(1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     !    ifh=ifile_handle()
     !    open(ifh,file='EVec_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) qbz(1:3,1:nqbz)
     !    write(ifh) evecc_w(1:nwf,1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     ! endif
     ! ! end okumura

     ! !! other k-points
     ! write(ifbnd,*)ef,' ef'
     ! write(iftb,*)ef,' ef'
     ! write(iffb,*)'#',ef,' ef'
     ! if (lsh) write(ifsh,*)ef,' ef'
     ! allocate(eval1(nwf,nq),eval3(nwf,nq),evecc1(nwf,nwf,nq))
     ! if(lsh) allocate(eval2(nwf,nq),evecc2(nwf,nwf,nq))
     ! do iq = 1,nq
     !    !     write(6,*)' got get_hrotkp_ws iq =',iq
     !    ! (3-3) Hrot_mn(k')
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,q(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    ! (3-4) diagonalize
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval1(1:nwf,iq)=eval
     !    evecc1(1:nwf,1:nwf,iq)=evecc
     !    !     (3-4) diagonalize  -- Small Hamiltonian --
     !    if (lsh) then
     !       hrotkps(1:nsh,1:nsh) = hrotkp(nsh1:nsh2,nsh1:nsh2)
     !       call diag_hm(hrotkps,nsh,evals,eveccs)
     !       write(ifsh,*)'iq =',iq
     !       write(ifsh,990)q(1:3,iq)
     !       eval2(1:nsh,iq)= evals(1:nsh)
     !       evecc2(1:nwf,1:nwf,iq)=eveccs
     !    endif                 ! lsh
     !    ! (3-3) Hrot_mn(k')  -- Tight-binding ---
     !    call get_hrotkp_tb_ws(rcut,plat,alat, &
     !         hrotr,rws,drws,irws,q(:,iq),  ibasiwf,pos,natom, &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    !     (3-4) diagonalize -- Tight-binding --
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval3(1:nwf,iq)=eval
     ! enddo
     ! do iband = 1,nwf
     !    do iq = 1,nq
     !       write(ifbnd,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       write(iftb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval3(iband,iq)-ef)*rydberg(),iband
     !       write(iffb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' ')",ADVANCE='NO') &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       do iwf=1,nwf
     !          write(iffb,"(f13.6)",ADVANCE='NO') (abs(evecc1(iwf,iband,iq)))**2
     !       enddo
     !       write(iffb,*)
     !    enddo
     !    write(ifbnd,*)
     !    write(iftb,*)
     !    write(iffb,*)
     !    write(iffb,*)
     ! enddo
!     deallocate(eval1,eval3,evecc1)
     ! if(lsh) then
     !    do iband = 1,nsh
     !       do iq = 1,nq
     !          write(ifsh,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !               iq,q(1:3,iq),  xq(iq),(eval2(iband,iq)-ef)*rydberg(),iband
     !       enddo
     !    enddo
     ! endif
!     call writeham(ifham,is,ef,alat,plat,pos,qbz,wbz,rws,irws,hrotk,nspin,natom,nwf,nqbz,nrws)
!     deallocate(cnk,umnk,eunk,hrotk,hrotr,hrotkp,evecc,eval,irws,rws,drws, &
!          ibasiwf,m_indx,n_indx,l_indx,ibas_indx)
!     if (lsh) deallocate(hrotkps,eveccs,evals,evecc2)
!     close(ifbnd)
!     close(iftb)
!     close(iffb)
!1000 enddo ispinloop
!950 format(a14,3f23.16)
!990 format(3f12.6)
!  call cputid(0)
!  call rx0s('lmfham2: ixc=2 ok')
!END PROGRAM lmfham2
