! PMT --1ststep--> MTP --2ndstep--> MLO. This is for 2ndstep
program lmfham2 ! Get the Hamiltonian on the MTO-based-Localized orbitals |MLO> from MTP
  ! that of the MTO-projected basis |MTP>. Conversion from MTP(hmmr1,ommr1,nband) to MLO(hmmr2,ommr2,nMLO).
  ! In advance, run lmfham1 to get |MTP> (MTPare given by a projection from MTOs to PMT space.
  ! That is, |MTP_i> = M |PMT_i>, where M is a mapping from MTP to the space of PMT.
  !  
  ! We use a modified procedure of this method of  [2]I.Souza, N.Marzari and D.Vanderbilt, PRB65,035109(2002) 
  !
  ! Main part of lmfham2 is Step1loop. 
  ! Among the space spanned by |MTonly>, we extract minimum basis space.
  ! For example, we have 25+25 MTOonlys for Si;then we extract 9+9 space spanned by |MLO>.
  !
  ! We use diffent idea of connectivity from [2]. Roughly speaking, we define connectivitiy of eigenfunctions between k and k+b,
  ! not by the overlap of periodic part of eigenfunctions, but by the coefficients on |MLO>.
  !
  use m_ftox
  use m_lgunit,only: stdo,m_lgunit_init
  use m_zhev,only:zhev_tk4
  use m_MPItk,only:    m_MPItk_init, m_MPItk_finalize, nsize, master_mpi !  use m_ext,only:      m_ext_init,sname
  use m_keyvalue,only: getkeyvalue
  use m_lmfinit,only:  m_lmfinit_init,oveps
  use m_ext,only: m_ext_init
  use m_cmdpath,only: Setcmdpath
  use m_readqplist,only: eferm,qplistsy,ndat,xdat, Readqplistsy !qplist.dat is generated by job_band
  use m_HamPMT,only: ReadHamPMTInfo, nspin=>nsp, natom=>nbas,plat,alat,npair,nlat,nqwgt, ldim, nqbz=>nkp,qbz=>qplist,&
       n1=>nkk1,n2=>nkk2,n3=>nkk3,pos,npairmx,nspx !,ib_table,l_table,k_table
  use m_read_Worb,only:s_read_Worb,nclass_mlwf,cbas_mlwf,norb=>nbasclass_mlwf,classname_mlwf ! iclassin,iphi,iphidot,nphi,nphix
  use m_HamRsMTP,only: ReadHamRsMTP,hmmr1=>hammr,ommr1=>ovlmr,nband=>ndimMTO,ib_tableM,l_tableM,k_tableM !Real-space Hamiltonian on the basis |MTo>.
  !      Main output of lmfham2 is  hmmr2,       ommr2,       nMLO,         ib_tableM(idmto(1:nwf)),... for |MLO>
  implicit none
  integer:: i,iq,is,ix,j,ifbb,ifoc,nbb,isc,ifq0p, nox,iki,ikf,nsc1,ndz,nin,nout,nsc2,ibb
  integer:: inii,if102,iwf2,ib,itmp,itmp2,nqbz2,nspin2,ib1,ib2,iqb,iqbz,it,jsp,nmx,nev,isyml!,nqbz!,n1,n2,n3
  integer:: nMLO,ikx,ikxx,iadd,i1q,i2q,i1,i2,imp,inp,inx,imx,ibas,ibold,ibx,iorb
  integer,parameter:: nlinex=100
  integer::nline,np(nlinex), iwf,ldim2,ixx,npin,ifuumat,job
  real(8),parameter:: pi = 4d0*datan(1d0)
  real(8) :: tpia,vol,voltot,rs,alpha, rydberg,hartree,qlat(3,3),tripl,wbbsum,bb(3,12),eimax ,wbbs,WTbandqsum,WTinnerqsum,&
       evalssold,qi(3,nlinex),qf(3,nlinex), omgi,omgiold,conv1,alpha1,zesumold,zesi,emm,eLinner,eUinner,eLinnereV,eUinnereV,&
       emin,evalss,sss,qiin(3),qfin(3),qold(3),enwfmax,qxx(3),eeee,enwfmaxi,ginv(3,3),WTinner,ecenter,eLhard,eLhardeV,&
       eee,etest,egap,WTband,eUhardeV
  character(8) :: xt
  real(8),allocatable    :: q(:,:)
  real(8),allocatable:: ku(:,:),kbu(:,:,:),eunk(:,:),eval(:), eks(:),wbb(:)
  integer,allocatable:: ikbidx(:,:),lindex(:)
  real(8),allocatable:: omgik(:),zesum(:),evals(:),WTbandq(:),WTinnerq(:)
  real(8),allocatable:: xq(:),eval1(:,:),eval2(:,:),eval3(:,:),eval_w(:,:,:)
  integer,allocatable:: m_indx(:),n_indx(:),l_indx(:),ibas_indx(:),ibasiwf(:),idmto(:),idmto_(:)
  real(8),allocatable:: evl(:,:),ovl(:), bbv(:,:),wbz(:),proj(:),projs(:),projss(:)
  complex(8),allocatable:: upu(:,:,:,:), zmn(:,:),zmn0(:,:),WTbandii(:),WTinnerii(:),zmns(:,:)
  complex(8),parameter:: img=(0d0,1d0)
  complex(8),allocatable::ovlm(:,:),ovlmx(:,:),hamm(:,:),ovec(:,:)!,emat(:,:)
  complex(8),allocatable:: uumat(:,:,:,:),evecc(:,:), amnk(:,:,:),cnk(:,:,:),umnk(:,:,:),evecc1(:,:,:),evecc2(:,:,:)
  complex(8),allocatable:: hmmr2(:,:,:,:),ommr2(:,:,:,:),wmat(:,:),wmat2(:,:),cnk0(:,:,:)
  character(256):: fband,fband1
  logical:: cmdopt2,noinner,eLinnerauto,ELhardauto,eUinnerauto,convn,eUouterauto,skipdfinner,EUautosp,debug=.false.
  real(8):: WTseed,eoffset, projcut,ewid,ewideV,eUinnercut,eouter,CUouter,WTouter,EUouter,CLhard,eUoutereV,CUinner,eLhardeVoffset
  character:: outs*20
  character(256):: aaa='',bbb=''
  integer:: nband_,nqbz_,iki_,ikf_,nMLO_,ilowest,ieLhard,iUinneradd
  call setcmdpath() !Set self-command path (this is for call system at m_lmfinit)
  call m_ext_init()         ! Get sname, e.g. trim(sname)=si of ctrl.si
  call m_MPItk_init('lmfham2') ! mpi initialization
  call m_lgunit_init() !set stdo,stdl
  call m_lmfinit_init('LMF')! Read ctrlp into module m_lmfinit.
  job=-1
  if(cmdopt2('--job=',outs)) read(outs,*) job
  if(job/=0.and.job/=1) call rx0(' Set --job=0 or 1')
  write(stdo,ftox)'=== Start lmfham2 --job=',job
  call mpibc1_int(job,1,'lmfham2_job') !set job of --job=job in arguments of lmf-MPIK.
  hartree=2d0*rydberg()
  call ReadHamPMTInfo()! Read infomation for Hamiltonian (lattice structures and index of basis).
  call ReadHamRsMTP()  ! Read Real-space |MTo>-basis Hamiltonian and overlap.
!  nqbz=nkp
  call pshpr(30)
  tpia = 2d0*pi/alat
  ginv   = transpose(plat)
  call readqplistsy()
  ReadInfoFromGWinput: block
    call s_read_Worb() ! Input orbital index for MLO, stored into idmto (s,p,d=1,2,3,4,5,6,7,8,9)
    nMLO=sum(norb(1:nclass_mlwf)) !number of MLO
    allocate(idmto(nMLO),lindex(nMLO))
    ibx=0
    ibold=-999
    iorb=0
    SETidmto:do i = 1,nband !for example, allocate(idmto,source=[(i,i=1,9),(i+25,i=1,9)]) for Si
       if(ibold/=ib_tableM(i)) ibx=0
       ibas=ib_tableM(i)
       ibx=ibx+1
       if(findloc([(ibx==cbas_mlwf(ix,ibas),ix=1,norb(ibas))],dim=1,value=.true.)/=0) then
          iorb=iorb+1
          idmto(iorb)=i
          lindex(iorb)=l_tableM(i)
       endif
       !write(stdo,"('MHAM: i ib(atom) l m k(EH,EH2,PZ)=',5i3)") i,ib_table(i),ibx
       ibold=ib_tableM(i)
    enddo SETidmto
      
    write(stdo,ftox)' idmto=',idmto
    call getkeyvalue("GWinput","mlo_maxit",nsc1,default=20)
    call getkeyvalue("GWinput","mlo_conv",conv1,default=1d-4)
    call getkeyvalue("GWinput","mlo_mix",alpha1,default=.5d0) 
    call getkeyvalue("GWinput","mlo_EUinner", eUinnereV,default= 1d8) ! inner energy windowU eV relative to VBM
    call getkeyvalue("GWinput","mlo_CUouter", CUouter,default=0.1d0)
    call getkeyvalue("GWinput","mlo_CUinner", CUinner,default=0.5d0)
    
    call getkeyvalue("GWinput","mlo_CLhard",CLhard,default=0.33d0)
    call getkeyvalue("GWinput","mlo_ewid",    ewideV, default=1d0)       ! inner energy window softing eV
    call getkeyvalue("GWinput","mlo_WTband" , WTband,default=32d0)    ! Weight to minimize band energies
    call getkeyvalue("GWinput",'mlo_WTseed' , WTseed,default=64d0)    ! Weight for seed.
    call getkeyvalue("GWinput","mlo_ELinner", eLinnereV,default=-1d8) ! inner energy windowL eV relative to VBM
    call getkeyvalue("GWinput","mlo_WTinner", WTinner,default=2048d0) ! inner energy window WeighTing
    call getkeyvalue("GWinput","mlo_WTouter", WTouter,default=2048d0*16d0) ! inner energy window WeighTing
    call getkeyvalue("GWinput","mlo_ELhard",ELhardeV,default=-1d8)

!    call getkeyvalue("GWinput","mlo_Skipdfinner",Skipdfinner,default=.false.)
    call getkeyvalue("GWinput","mlo_EUinnerAUTOsp",EUautosp,default=.false.)
    
    ELhardauto=.true.
    if(ELhardeV>-1d7) ELhardauto=.false.

    if(master_mpi) then
       write(stdo,ftox)' Reading: mlo_maxit=',nsc1
       write(stdo,ftox)'        : mlo_conv =',ftof(conv1)
       write(stdo,ftox)'        : mlo_mix  =',ftof(alpha1,2)
       write(stdo,ftox)'        : mlo_WTseed   =',ftof(WTseed,2)
       write(stdo,ftox)'        : mlo_WTband   =',ftof(WTband,2)
       write(stdo,ftox)'        : mlo_WTinner  =',ftof(WTinner,2)
       if(eUinnereV>1d5) then
!           write(stdo,ftox)'        :  mlo_EUinner = by mlo_CUinner'
           write(stdo,ftox)'        :  mlo_CUinner =',ftof(CUinner,2)
       endif   
       if(eUinnereV<=1d5) write(stdo,ftox)'        :  mlo_EUinner(eV)=',ftof(eUinnereV,2)
       if(eLinnereV>-1d5)write(stdo,ftox)'        :  mlo_ELinner(eV)=',ftof(eLinnereV,2)
       write(stdo,ftox)'        :  mlo_ewid(eV)=',ftof(ewideV,2)
       write(stdo,ftox)'        : mlo_WTouter  =',ftof(WTouter,2)  
       write(stdo,ftox)'        :  mlo_CUouter =',ftof(CUouter,2)
!       if(CUouter>0 )      write(stdo,ftox)'        :  mlo_CUouter =',ftof(CUouter,2)
!       if(CUouter<=0)      write(stdo,ftox)'        :  mlo_EUouter(eV) =',ftof(EUoutereV,2)
       if(.not.ELhardauto) write(stdo,ftox)'        : mlo_ELhard(eV)=',ftof(ELhardeV,2)
       if(ELhardauto)      write(stdo,ftox)'        : mlo_ELhard(eV) = by mlo_CLhard'
       if(ELhardauto)      write(stdo,ftox)'        :  mlo_CLhard =',ftof(CLhard,2)
!       if(ELhardauto)      write(stdo,ftox)'        :  mlo_ELhardoffset(eV) =',ftof(ELhardeVoffset,3)
!       write(stdo,ftox)' Reading: mlo_ ELinner EUinner(eV)=',ftof(hardinnerLeV,2),ftof(eHhardeV,2)
    endif
    eLinner= eLinnereV/rydberg()+eferm
    eUinner= eUinnereV/rydberg()+eferm
!    eUouter= eUoutereV/rydberg()+eferm
    eUouterauto=.true. !merge(.true.,.false.,eUouter>1d5)
    eUinnerauto=merge(.true.,.false.,eUinner>1d5)
    ewid= ewideV/rydberg() !in Ry.
  endblock ReadInfoFromGWinput
  bbvector: block !Get connecting vectors bb, bb connects k and k+bb, where both k and k+bb are on mesh points nqbz.
    allocate(wbb(12))
    call getbb(plat,alat,n1,n2,n3, nbb,wbb,wbbsum,bb) ! b vectors (connecting vectors). See appendix of Marzari.1997
    allocate (ku(3,nqbz),kbu(3,nbb,nqbz),ikbidx(nbb,nqbz))
    call kbbindx(qbz,ginv,bb, nqbz,nbb, ikbidx,ku,kbu) ! index for k and k+bb
    call writebb2(ifbb,wbb(1:nbb),bb(1:3,1:nbb), ikbidx,ku,kbu, nqbz,nbb)
    write(stdo,ftox)' nbb wbb(in unit of 2pi/alat)=',nbb,ftof(wbb(1:nbb),3)
    allocate(bbv,source=bb)
  endblock bbvector
  !iko_i=1; iko_f=nband 
  iki=1     !minval(iko_i)
  ikf=nband !maxval(iko_f) !  nox = ikf - iki + 1. nband is for MTP Hamiltonian
  if(job==1) goto 1011 !Goto Souza's iteration job=1 mode
  
  GetCNmatFile_job0: block  !job=0 mode to get CNmat file (connection matrix uumat and so on).
    real(8):: qp(3)
    complex(8):: emat(nband,nband),osq(1:nband,1:nband),o2al(1:nband,1:nband,nqbz),phase,ovlmm(nband,nMLO),&
         evec(nband,nband,nqbz),evecx(1:nband,1:nband), ovec(nband,nband),amnk(iki:ikf,nMLO,nqbz),&
         ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband), hamm(1:nband,1:nband),uumat(iki:ikf,iki:ikf,nbb,nqbz)
    allocate(evl(nband,nqbz),ovl(nband))!NOTE: 20230805. When I declear evl in this block, ifort18.05 gives wrong results.
    write(stdo,ftox)'Going to get CNmat ... : nband for |MLO1>=',nband,'iki ikf=',iki,ikf
    open(newunit=ifuumat,file='CNmat',form='unformatted')
    uuispinloop: do 1010 is = 1,nspin
       write(stdo,ftox)'Generating connection matrix ispinloop: is =',is,'  out of',nspin
       emat=0d0
       forall(i=1:nband) emat(i,i)=1d0
       do iqbz=1,nqbz
          qp=qbz(:,iqbz)
          ovlm = 0d0
          hamm = 0d0
          do i=1,nband !Get MTP Hamiltonian at qp by FF from the real-space MTP Hamiltonian (lmfham1)
             do j=1,nband
                ib1 = ib_tableM(i) !atomic-site index in the primitive cell
                ib2 = ib_tableM(j)
                do it =1,npair(ib1,ib2) !real-space to H,O at qp
                   phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                   hamm(i,j)= hamm(i,j)+ hmmr1(i,j,it,is)*phase 
                   ovlm(i,j)= ovlm(i,j)+ ommr1(i,j,it,is)*phase
                enddo
             enddo
          enddo
          nmx=nband
          ovlmx=ovlm
          call zhev_tk4(nband,ovlm,emat,nmx,nev, ovl, ovec, oveps) !Diangonale overlap matrix. (ovlm - e ) ovec=0
          ovlm=ovlmx
          call zhev_tk4(nband,hamm,ovlm,nmx,nev, evl(:,iqbz), evec(:,:,iqbz), oveps) !Diangonale (hamm- evl ovlm) z=0
          do concurrent (i=1:nband,j=1:nband)
             osq(i,j)=sum(ovec(i,:)*ovl(:)**0.5d0*dconjg(ovec(j,:))) !O^(1/2)
          enddo
          o2al(:,:,iqbz) = matmul(osq, evec(:,:,iqbz)) !o2al(basis index, band index, iqbz index) O^(1/2)*evec
          forall(i=1:nband) ovlmm(i,:) = ovlmx(i,idmto(:))
          amnk(:,:,iqbz)= matmul(transpose(dconjg(evec(1:nband,iki:ikf,iqbz))),ovlmm) !amnk= <Psi^MTP|MTO>
       enddo
       do iqbz=1,nqbz
          do ibb=1,nbb
             iqb = ikbidx(ibb,iqbz)             !q1(:) = qbz(:,iqbz)             !q2(:) = q1(:) + bbv(:,ibb)
             do concurrent(ib1=iki:ikf, ib2=iki:ikf) !ib1,ib2 band index of inner-inner window
                uumat(ib1,ib2,ibb,iqbz)= sum(dconjg(o2al(1:nband,ib1,iqbz))*o2al(1:nband,ib2,iqb)) ! define connection <q ib1| q+b ib2>
             enddo
          enddo
       enddo
       write(ifuumat) nband,nqbz,iki,ikf,nMLO,idmto
       write(ifuumat) evl   !eigenvalue
       write(ifuumat) uumat !connection matrix
       write(ifuumat) amnk  !initial projection
1010 enddo uuispinloop
    close(ifuumat)
    if(job==0) call rx0('OK! end of lmhfam2 job=0 for generating CNmat')
  endblock GetCNmatFile_Job0

1011 continue !=== job==1 mode start ========================================
  open(newunit=ifuumat,file='CNmat',form='unformatted')
  allocate(hmmr2(nMLO,nMLO,npairmx,nspin),ommr2(nMLO,nMLO,npairmx,nspin),source=(0d0,0d0))
  allocate(ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband),hamm(1:nband,1:nband))
  allocate(evl(nband,nqbz), ovec(nband,nband),ovl(nband))
  allocate(amnk(iki:ikf,nMLO,nqbz),idmto_(nMLO))
  allocate(wbz(nqbz),source=1d0/nqbz)
  allocate (uumat(iki:ikf,iki:ikf,nbb,nqbz))
  ispinloop: do 1000 is = 1,nspin
     read(ifuumat) nband_,nqbz_,iki_,ikf_,nMLO_,idmto_
     if(nMLO/=nMLO.or.sum(abs(idmto-idmto_))/=0) call rx0('lmfham2: idmto error: Repeat --job=1 with the same <Worb> in GWinput!')
     read(ifuumat) evl
     read(ifuumat) uumat
     read(ifuumat) amnk
     if(master_mpi) &
          write(stdo,ftox)'isploop: is=',is,'out of',nspin,'ChooseSpace by cnk(init:iend,1:nMLO,1:nqbz)=',iki,ikf,nMLO,nqbz
     allocate(upu(iki:ikf,iki:ikf,nbb,nqbz), cnk(iki:ikf,nMLO,nqbz), omgik(nqbz),evals(nqbz))!,zesum(nqbz)) !cnk2(iki:ikf,nMLO,nqbz)
     allocate(WTbandq(nqbz),WTinnerq(nqbz),proj(iki:ikf),projs(iki:ikf),projss(iki:ikf))
     callamnk2unk: block
       integer:: iko_i(nqbz),iko_f(nqbz)
       iko_i=iki
       iko_f=ikf
       call amnk2unk(amnk,iki,ikf,iko_i,iko_f,nMLO,nqbz, cnk)
       if(allocated(cnk0)) deallocate(cnk0)
       allocate(cnk0(iki:ikf,nMLO,nqbz),source=cnk)
     endblock callamnk2unk
     !amnk=<Psi^MTP(it,iqbz)|MTO(1:nMLO) >.  Note that amnk was in Eq.22 in Ref.II. <psi|Gaussian>. We replace Gaussian with MTO.
     !cnk =<Psi^MTP(it,iqbz)|MTO_orth(1:nMLO)>.  |MTO_orth>= |MTO> O^{-1/2} !initial condition
     zesumold=1d10
     alpha = 1d0
     upu   = 0d0
     wbbs=sum(wbb(1:nbb)) !we assume iko_i(iq)=1. If not, use evl(iko_i(iq),iq)
     convn=.false.
     SouzaStep1loop: do isc = 1,nsc1 ! choose Hilbert space -- determine cnk
        AUTOeLhard:block
          if(eLhardauto) then! Search bottom of MTP Hamiltonian for given MTOsets to generate MLO.
             ieLhard=9999
             do iq = 1,nqbz
                proj = [ (sum(cnk(i,:,iq)*dconjg(cnk(i,:,iq))),i=iki,ikf) ]
                !if(iq==1) then;do i=1,nband; write(stdo,ftox)i,ftof((evl(i,iq)-eferm)*rydberg()),ftof(proj(i)); enddo;endif
                ieLhard = min(findloc(proj>CLhard,value=.true.,dim=1),ieLhard) !lowest band index
             enddo
             eLhard = minval(evl(ieLhard,:))- 1d-3 !eLhardeVoffset/rydberg()
          else
             eLhard= eLhardeV/rydberg()+eferm
          endif
          if(isc==1.or.convn.or.isc==nsc1) write(stdo,ftox)' isc eLhard =',isc,ftof((eLhard-eferm)*rydberg(),3),'eV'
        endblock AUTOeLhard
        AUTOeUblock:block
          integer::ikff,imlo,ik,ibandx,ibandxx,iUinneri,n
          real(8):: zmnsa(iki:ikf),nnc(iki:ikf,nMLO),ppp
          character(5):: aaax
          character(8):: xn
          integer:: nlow,iUinner,iUouter
          if(eUinnerauto) eUinner=-9999d0/rydberg()+eferm
          if(eUouterauto) eUouter=-9999d0/rydberg()+eferm
          iUinner=nband
          do iq=1,nqbz
             proj   = [(sum(cnk(i,:,iq)*dconjg(cnk(i,:,iq))),i=iki,ikf) ]
             projs  = [(sum(proj(i:ikf)),i=iki,ikf)]
             if(eUouterauto) then
                iUouter = findloc(projs>CUouter,value=.true.,back=.true.,dim=1) +1
                if(iUouter==0.or.iUouter>nband) iUouter=nband
                eUouter = max(evl(iUouter,iq),eUouter)
             endif
             if(debug) then!.true.) then !
                do imlo=1,nMLO
                   !proj = [(sum(cnk(iki:ik,imlo,iq)*dconjg(cnk(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                   proj = [(sum(cnk0(iki:ik,imlo,iq)*dconjg(cnk0(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                   write(stdo,ftox)'imlo=',imlo,' weight=',ftof(proj(iki:25),2),' total=',ftof(proj(ikf),3)
                enddo
             endif
             if(eUinnerauto) then !default
                iUinner=-999
                do imlo=1,nMLO
!                   proj = [(sum(cnk0(iki:ik,imlo,iq)*dconjg(cnk0(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                   proj = [(sum(cnk(iki:ik,imlo,iq)*dconjg(cnk(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                   !                   iUinner=max(findloc(proj>.5d0,value=.true.,dim=1),iUinner)
                   if(EUautosp.and.lindex(imlo)>=2) cycle
                   iUinner=max(findloc(proj>CUinner,value=.true.,dim=1),iUinner)
                   !write(stdo,ftox)'imlo=',imlo,' weight=',ftof(proj(iki:25),2),' total=',ftof(proj(ikf),3)
                enddo
                if(iUinner==-1) iUinner=nband
                eUinner = max(evl(iUinner,iq),eUinner)  !maximum value
             endif
             ! if(eUinnerauto) then !default
             !    projss = [(sum(proj(iki:i)),i=iki,ikf)] 
             !    iUinner= findloc(projss>nMLO-1d-3,value=.true.,dim=1) 
             !    if(iUinner==0)  iUinner=nband
             !    eUinner = max(evl(iUinner,iq),eUinner)  !maximum value
             ! endif
          enddo
          if((isc==1.or.convn.or.isc==nsc1)) then !.and.iq==1)then
             aaa=merge('auto.given by CUouter='//ftof(CUouter),repeat(' ',256), eUouterauto)
             write(stdo,ftox)' isc eUouter=',isc,ftof((eUouter-eferm)*rydberg(),3),'eV',trim(aaa)
             aaa=''
             if(eUinnerauto) aaa='auto.default'//' EUinner by proj>CUinner='//ftof(CUinner) 
             if(eUautosp)    aaa=trim(aaa)//' EUinnerAUTOsp on.'
             write(stdo,ftox)' isc eUinner=',isc,ftof((eUinner-eferm)*rydberg(),3),'eV',trim(aaa)
          endif
        endblock AUTOeUblock
        iqloop: do iq = 1,nqbz
!            eU2block:block
!              character(5):: aaax
! !             integer:: nlow,iUinner
!              proj   = [ (sum(cnk(i,:,iq)*dconjg(cnk(i,:,iq))),i=iki,ikf) ]
!              projss = [(sum(nint(proj(iki:i))),i=iki,ikf)] !nint sum 
!              projs  = [(sum(proj(i:ikf)),i=iki,ikf)]
!              nlow = max(findloc(evl(:,iq)>eLhard,value=.true.,dim=1)-1,0)   !  print *,'nlow=',nlow,nlow+nband,nlow+nMLO
!              if(eUouterauto) eUouter = evl(findloc(projs>CUouter,value=.true.,back=.true.,dim=1),iq) + 1d-3
! !             iUinner=max(findloc(projss>nMLO-1d-3,value=.true.,dim=1),nMLO) ! +iUinneradd,nMLO)
! !             if(eUinnerauto) eUinner = evl(iUinner,iq) + 1d-3
!              if((isc==1.or.convn.or.isc==nsc1).and.iq==1)then
!                 aaa=merge('given by CUouter='//ftof(CUouter),repeat(' ',256), eUouterauto)
! !                write(stdo,ftox)' isc iq eUouter=',isc,iq,ftof((eUouter-eferm)*rydberg(),3),'eV',trim(aaa)
! !                aaa=merge('given by CUinner='//ftof(CUinner),repeat(' ',256), eUinnerauto)
! !                write(stdo,ftox)' isc iq eUinner=',isc,iq,ftof((eUinner-eferm)*rydberg(),3),'eV',trim(aaa)
! !             endif
! !             if(iq==1.and.(convn.or.isc==nsc1)) then
! !                write(stdo,ftox)'---Monitor eigenvalue and nint(proj) at q=0'
! !                do i=1,min(nband,IUinner)
! !                   aaax=merge('inner','     ',i<=iUinner.and.i>nlow)
! !                   write(stdo,ftox)i,ftof((evl(i,iq)-eferm)*rydberg(),3),ftof(projss(i),3),trim(aaax)
! !                enddo
! !                write(stdo,ftox)'...'
! !             endif
!            endblock eU2block
           
           nout = ikf - iki + 1 
           ndz  = nout 
           if(isc /= 1) alpha = alpha1
           allocate(wmat(iki:ikf,iki:ikf), wmat2(iki:ikf,iki:ikf))
           i1q=iki!iko_i(iq)
           i2q=ikf!iko_f(iq)
           do ibb = 1,nbb
              iqb = ikbidx(ibb,iq)
              i1= iki!iko_i(iqb)
              i2= ikf!iko_f(iqb)
              do concurrent(inp=i1:i2, imp=i1:i2) !wmat = cnk * cnk^{*} is projector to 'wannier space'.
                 wmat(inp,imp)= sum(dconjg(cnk(inp,1:nMLO,iqb))*cnk(imp,1:nMLO,iqb)) !BUG-> sum was for nin+1:nMLO before 2023-6-8(miyake)
              enddo
              do concurrent(inx=i1q:i2q, imp=i1:i2)
                 wmat2(imp,inx)= sum( wmat(i1:i2,imp)*dconjg(uumat(inx,i1:i2,ibb,iq)) ) !wmat*uumat
              enddo
              do concurrent(imx=i1q:i2q, inx=i1q:i2q)!      upu=   uumat* wmat * uumat ! (1-2) <u_mk | P_k+b | u_nk>
                 upu(imx,inx,ibb,iq)= (1d0-alpha)*upu(imx,inx,ibb,iq) + alpha*sum(uumat(imx,i1:i2,ibb,iq)*wmat2(i1:i2,inx))
              enddo
           enddo
           deallocate(wmat,wmat2)
           ! Omega= 1/2 \sum_b,k Tr {|\nabla Pk|^2} + WTband*Tr{Pk H} - WTinner*Tr{Pk EinnerW} + WTseed * Tr {Pk <psi_m|seed_i><seed_i|psi_n|}
           ! zmn = \frac{\delta Omega}{\delta Pmn^k}
           allocate (zmn0(ndz,ndz),source=(0d0,0d0)) ! (1-3) Zmn(k) > phi,eval
           allocate (zmn(ndz,ndz),zmns(ndz,ndz), evecc(ndz,ndz),eval(ndz),WTbandii(ndz),WTinnerii(ndz))
           do ibb = 1,nbb
!             zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) - 2d0*wbb(ibb)*upu(iko_i(iq):iko_f(iq),iko_i(iq):iko_f(iq),ibb,iq)
              zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) - 2d0*wbb(ibb)*upu(iki:ikf,iki:ikf,ibb,iq)
           enddo
           zmn=zmn0
           
           WTbandBlock: do concurrent(i=iki:ikf)
              WTbandii(i)= WTband*evl(i,iq) !+ WTband*evl(i,iq)*(1d0-filter2((evl(i,iq)-eferm-1d0)/ewid))
              zmn(i,i)=zmn0(i,i) + WTbandii(i)  
           enddo WTbandBlock
           WTseedBlock: block
             if(WTseed/=0d0) then !projection to Seed functions
                !  zmns = matmul(amnk(iki:ikf,1:nMLO,iq),dconjg(transpose(amnk(iki:ikf,1:nMLO,iq))))
                zmns = matmul(cnk0(iki:ikf,1:nMLO,iq),dconjg(transpose(cnk0(iki:ikf,1:nMLO,iq)))) !NOTE: this did not work for Si666 at least
                zmn(iki:ikf,iki:ikf)= zmn(iki:ikf,iki:ikf) - WTseed*zmns
             endif
!                zmnsa=[(sum([(abs(zmns(i,i)),i=iki,ikff)]),ikff=iki,ikf)]
!                do i=iki,ikf
!                   write(stdo,ftox)'zmnss=',i,ftof((evl(i,iq)-eferm)*rydberg()),ftof(zmnsa(i))
!                enddo
!                eUinner= evl(findloc(zmnsa>0.8, value=.true., back=.true.,dim=1),iq)
!                write(stdo,ftox)'--- zsum=',ftof(sum([(zmns(i,i),i=iki,ikf)])),'eUinner=',ftof((eUinner-eferm)*rydberg())

                !              zmn(iki:ikf/2,iki:ikf/2)= zmn(iki:ikf,iki:ikf/2) &
                !              - WTseed*matmul(amnk(iki:ikf/2,1:nMLO,iq),dconjg(transpose(amnk(iki:ikf/2,1:nMLO,iq)))) 
                !!              zmn=zmn-WTseed*matmul(cnk0(iki:ikf,1:nMLO,iq), & !projection to Seed functions
                !!                   dconjg(transpose(cnk0(iki:ikf,1:nMLO,iq)))) !NOTE: this did not work for Si666 at least
           endblock WTseedBlock
           WTinnerBlock: do concurrent(i=iki:ikf) !Add penalty for compoment outside of inner window
              WTinnerii(i) = WTinner*filter2((evl(i,iq)-eUinner)/ewid) + WTinner*filter2((eLinner-evl(i,iq))/ewid)!inner window
!              WTinnerii(i) = WTinner*merge(1d0,0d0,evl(i,iq)-eferm>5d0/13.605d0) 
!              WTinnerii(i) = WTinnerii(i)*merge(abs(evl(i,iq)-eferm)**6,0d0,evl(i,iq)-eferm>0)
              zmn(i,i)= zmn(i,i) + WTinnerii(i)
              zmn(i,i)= zmn(i,i) + WTouter*filter2((evl(i,iq)-eUouter)/ewid)  !outer window
           enddo WTinnerBlock
           HardInnerBlock: block ! hard innerwindow
             real(8),parameter:: zhard=-1d8, zavoid=1d8
             do i=iki,ikf 
                if(evl(i,iq)<eLhard) then !avoided
                   zmn(i,:)=0d0; zmn(:,i)= 0d0; zmn(i,i)= zavoid 
!                elseif(evl(i,iq)<eUhardeV/rydberg()+eferm) then !included
!                   zmn(i,:)=0d0; zmn(:,i)= 0d0; zmn(i,i)= zhard  
                endif
             enddo
           endblock HardInnerBlock
           
           call diag_hm(zmn,ndz,eval,evecc)
           ! eval(i)/wbbs is normalized. If all eval(i)/wbbs=1, P_k=P_{k+b}.
           forall(iwf = 1:nMLO) cnk(iki:ikf,iwf,iq) = evecc(1:ndz,iwf) 
           evals(iq)= sum(eval(1:nMLO)) 
           omgik(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*matmul(zmn0,evecc(1:ndz,i))),i=1,nMLO)])  
           WTbandq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTbandii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !2nd energy term
           WTinnerq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTinnerii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !
           !write(stdo,ftox)'iq=',iq,'eval=',ftof(eval)
           deallocate (zmn,evecc,eval,zmn0,WTbandii,WTinnerii,zmns)
        enddo iqloop
        omgi  = sum(omgik(:)*wbz(:)) 
        WTbandqsum=sum(WTbandq(:)*wbz(:))
        WTinnerqsum=sum(WTinnerq(:)*wbz(:))
        evalss= sum(evals(:)*wbz(:))   
        ! \sum eval = \sum zmn0 term + WTbandq + WTinnerq
        !    write(stdo,ftox)'#SC-loop, OmegaI_a Zsum=',isc,ftof(omgi),'=',ftof(zesi-evalss+WTbandqsum+WTinnerqsum)
        if(WTinner/=0d0) aaa='Pin='//trim(ftof(1d0-WTinnerqsum/WTinner/nMLO))
        if(WTband/=0d0) bbb='Emean(eV)='//trim(ftof((WTbandqsum/WTband/nMLO-eferm)*rydberg()))
        write(stdo,ftox)'#SC:isc=',isc,'Omega/nMLO=',ftof( (wbbs+omgi/2d0/nMLO)/tpia**2 + WTbandqsum/nMLO + WTinnerqsum/nMLO),&
             'Nabla2/nMLO(a.u.**2)=',ftof((wbbs+omgi/2d0/nMLO)/tpia**2/2d0 ),&
             'MeanOverlap=',ftof(-omgi/2d0/nMLO/wbbs),trim(bbb),trim(aaa) !Omega corresponds to Omega_I in Eq.34 Mazari.
        !NOTE: nMLO \sim omgi=\sum_b wb \sum_{m=1}^N \sum_{n=1}^N |Mmn^{k,b}|^2 (See Eq.7 in Souza paper).
        !      But Mnm here is only for coefficienets parts of eigenfunctions.
        if(convn) then
           write(stdo,ftox)' Step1: converged!'
           exit
        endif
        if(isc>=2 .and. dabs(evalssold-evalss)<conv1) convn=.true. 
        evalssold = evalss
        if(isc==nsc1) write(stdo,ftox)' Step1: not converged'
     enddo SouzaStep1loop
     deallocate(upu) 
     !! NOTE: cnk(iki:ikf,nMLO,nqbz) is the final results of Step1loop, which minimize Omega_I (Wannier space)
     !!   cnk(iko_i(iq):iko_f(iq),nMLO,iq) gives nMLO-dimentional space.
     GetHamiltonianforMTObyProjection: block  !We do not use Marzari's unitary rotation
       real(8):: qq(3)
       integer:: il,im,in,ib1,ib2,jsp
       complex(8):: phase,proj(iki:ikf,iki:ikf),pa(iki:ikf,nMLO),ham(nMLO,nMLO),ovlx(nMLO,nMLO)
       jsp=is
       do iqbz = 1,nqbz
          qq(:) = qbz(:,iqbz) !          write(6,*)' xxxx iq q=',iq,qq
          do concurrent(i=iki:ikf, j=iki:ikf)     !inner bandindex
             proj(i,j) = sum(cnk(i,:,iqbz)*dconjg(cnk(j,:,iqbz))) !sum for MLOindex
          enddo
          pa(iki:ikf,1:nMLO) = matmul(proj,amnk(iki:ikf,1:nMLO,iqbz))
!          write(6,*)'sumcheck ham=',iqbz,sum(abs(pa)),sum(abs(evl(iki:ikf,iqbz))),sum(abs(amnk(iki:ikf,1:nMLO,iqbz)))
          do concurrent(i=1:nMLO,j=1:nMLO)
             ham(i,j)  = sum(dconjg(pa(:,i))*evl(iki:ikf,iqbz)*pa(:,j)) !sum(dconjg(pa(:,i))*pa(:,j))!
             ovlx(i,j) = sum(dconjg(pa(:,i))*pa(:,j))
          enddo
!          write(6,*)'sumcheck ham=',iqbz,sum(abs(ham))
          do concurrent(i=1:nMLO,j=1:nMLO) !Real space Hamiltonian. H(k)->H(T) FT to real space
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                phase = 1d0/dble(nqbz)* exp(img*2d0*pi* sum(qq*matmul(plat,nlat(:,it,ib1,ib2))))
                hmmr2(i,j,it,jsp)= hmmr2(i,j,it,jsp)+ ham(i,j)*phase
                ommr2(i,j,it,jsp)= ommr2(i,j,it,jsp)+ ovlx(i,j)*phase
             enddo
          enddo
       enddo
     endblock GetHamiltonianforMTObyProjection
     write(6,*)' get hmmr2. Goto band_lmfham2.dat ---------'
     bandplotMLO: block
       real(8):: qp(3),evlm(nMLO,ndat)
       complex(8):: phase,hamm(nMLO,nMLO),ovlm(nMLO,nMLO),evec(nMLO,nMLO)
       integer:: iband
       jsp=is
       fband='band_lmfham2_spin'//char(48+jsp)//'.dat'
       fband1='band_lmfham1_spin'//char(48+jsp)//'.dat'
       open(newunit=iband,file=trim(fband))
       do iq= 1,ndat
          qp=qplistsy(:,iq) 
          ovlm = 0d0
          hamm = 0d0
          do concurrent(i=1:nMLO,j=1:nMLO)
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)
                phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                hamm(i,j)= hamm(i,j)+ hmmr2(i,j,it,is)*phase
                ovlm(i,j)= ovlm(i,j)+ ommr2(i,j,it,is)*phase
             enddo
          enddo
          nmx =nMLO
          call zhev_tk4(nMLO,hamm,ovlm,nmx,nev, evlm(:,iq), evec, oveps)! Diangonale (hamm - evl ovlm ) evec=0
          if(iq<6)  write(stdo,"(' iq q=',i3,*(a))") iq,' ',ftof(qp,3),' e=',ftof(evlm(1:12,iq),3)
          if(iq==6) write(stdo,"(' iq q= ...')") 
          do i=1,nev
             write(iband,ftox)  ftof(xdat(iq)),ftof(evlm(i,iq)), is,i
          enddo
       enddo
       close(iband)
     endblock bandplotMLO
     Modifiedbandplotglt: block
       integer:: ifglt1,ifglt
       character(256):: aline,fname,fname2
       jsp = is
       fname2='bandplot.lmfham2.isp'//char(48+jsp)//'.glt'
       fname ='bandplot.isp'//char(48+jsp)//'.glt'
       open(newunit=ifglt,  file=trim(fname))
       open(newunit=ifglt1, file=trim(fname2))
       do 
          read(ifglt,"(a)",err=989,end=989)aline
          if(trim(aline)=="plot \") then !"
             write(ifglt1,ftox)"ef=",ftof(eferm)  
             write(ifglt1,ftox)trim(aline)
             write(ifglt1,ftox)'"'//trim(fband1)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "green",\'   !'  
             write(ifglt1,ftox)'"'//trim(fband)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'  
          else
             write(ifglt1,ftox)trim(aline)
          endif   
       enddo
989    continue
       close(ifglt)
       close(ifglt1)
       write(stdo,ftox)'OK! Run gnuplot -p '//trim(fname2)//'.Red points are by hmmr2 for Hamiltonian on {|MLO2>}'
    endblock Modifiedbandplotglt
    deallocate(cnk,omgik,evals,wtbandq,wtinnerq,proj,projs,projss)
1000 enddo ispinloop
  call rx0('OK! end of lmfham2 -----------------')
contains
  pure real(8) function filter2(x) !step like function
    real(8),intent(in) :: x
    if(x<0d0) then
       filter2=0d0
    elseif(x>30d0) then
       filter2=1d0
    else
       filter2= 1d0-2d0/(exp(x)+1d0)
    endif
  end function filter2
END PROGRAM


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ! ! --- Readin nlam index
     ! open(newunit=ifoc,file ='@MNLA_CPHI')
     ! ldim2 = ldim !nlmto
     ! read(ifoc,*)
     ! if(allocated(m_indx)) deallocate(m_indx,n_indx,l_indx,ibas_indx,ibasiwf)
     ! allocate(m_indx(ldim2),n_indx(ldim2),l_indx(ldim2),ibas_indx(ldim2))
     ! do ix =1,ldim2
     !    read(ifoc,*)m_indx(ix),n_indx(ix),l_indx(ix),ibas_indx(ix),ixx
     !    if(ixx/=ix) call rx('failed to readin @MNLA_CPHI')
     ! enddo
     ! close(ifoc)
     ! allocate(ibasiwf(nwf))
     ! do iwf=1,nwf
     !    ibasiwf(iwf) = ibas_indx(iphi(1,iwf))
     ! enddo

     ! !! write HrotRS
     ! ifh=ifile_handle()
     ! if(is==1) open(ifh,file='HrotRS.up',form='unformatted')
     ! if(is==2) open(ifh,file='HrotRS.dn',form='unformatted')
     ! write(ifh)alat,plat,natom
     ! write(ifh)pos
     ! write(ifh)ef
     ! write(ifh)nwf,nrws,n1,n2,n3
     ! write(ifh) irws,rws,drws,hrotr, ibasiwf !drws added by okumura Aug28,2017
     ! close(ifh)

!     call write_hopping_output(is, hrotr, &
!          rws,irws,alat,plat,qlat,pos,natom, &
!          ibasiwf, nwf,nrws,spid , m_indx, l_indx, &
!          nphix, iphi, ldim2)
     !      close(ifh)

     !! TEST okumura: iq=1,nq, q->qbz?   (2017/06/10)
!!! qtt -> q, nqtt -> nqbz
     ! ! data list for wannier
     ! ifh=ifile_handle()
     ! open(ifh,file="wan4chi.d",form="unformatted")
     ! write(ifh) nwf,nspin,nqbz
     ! close(ifh)

     ! ! generate eigenvalue and eigenvector of Wannier Hamiltonian
     ! ! Index:: evecc_w (orbital,band,q-point,spin)
     ! write(6,*)
     ! if (is==1) allocate(eval_w(nwf,nqbz,nspin),evecc_w(nwf,nwf,nqbz,nspin))
     ! do iq = 1,nqbz
     !    if(iq<5 .OR. iq>nqbz-3)write(6,*)' got get_hrotkp_ws iq =',iq
     !    if(iq==5)write(6,*)' ...'
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,qbz(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval_w(1:nwf,iq,is)=eval
     !    evecc_w(1:nwf,1:nwf,iq,is)=evecc
     ! enddo

     ! if(is==2) then
     !    ifh=ifile_handle()
     !    open(ifh,file='EValue_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) eval_w(1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     !    ifh=ifile_handle()
     !    open(ifh,file='EVec_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) qbz(1:3,1:nqbz)
     !    write(ifh) evecc_w(1:nwf,1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     ! endif
     ! ! end okumura

     ! !! other k-points
     ! write(ifbnd,*)ef,' ef'
     ! write(iftb,*)ef,' ef'
     ! write(iffb,*)'#',ef,' ef'
     ! if (lsh) write(ifsh,*)ef,' ef'
     ! allocate(eval1(nwf,nq),eval3(nwf,nq),evecc1(nwf,nwf,nq))
     ! if(lsh) allocate(eval2(nwf,nq),evecc2(nwf,nwf,nq))
     ! do iq = 1,nq
     !    !     write(6,*)' got get_hrotkp_ws iq =',iq
     !    ! (3-3) Hrot_mn(k')
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,q(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    ! (3-4) diagonalize
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval1(1:nwf,iq)=eval
     !    evecc1(1:nwf,1:nwf,iq)=evecc
     !    !     (3-4) diagonalize  -- Small Hamiltonian --
     !    if (lsh) then
     !       hrotkps(1:nsh,1:nsh) = hrotkp(nsh1:nsh2,nsh1:nsh2)
     !       call diag_hm(hrotkps,nsh,evals,eveccs)
     !       write(ifsh,*)'iq =',iq
     !       write(ifsh,990)q(1:3,iq)
     !       eval2(1:nsh,iq)= evals(1:nsh)
     !       evecc2(1:nwf,1:nwf,iq)=eveccs
     !    endif                 ! lsh
     !    ! (3-3) Hrot_mn(k')  -- Tight-binding ---
     !    call get_hrotkp_tb_ws(rcut,plat,alat, &
     !         hrotr,rws,drws,irws,q(:,iq),  ibasiwf,pos,natom, &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    !     (3-4) diagonalize -- Tight-binding --
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval3(1:nwf,iq)=eval
     ! enddo
     ! do iband = 1,nwf
     !    do iq = 1,nq
     !       write(ifbnd,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       write(iftb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval3(iband,iq)-ef)*rydberg(),iband
     !       write(iffb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' ')",ADVANCE='NO') &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       do iwf=1,nwf
     !          write(iffb,"(f13.6)",ADVANCE='NO') (abs(evecc1(iwf,iband,iq)))**2
     !       enddo
     !       write(iffb,*)
     !    enddo
     !    write(ifbnd,*)
     !    write(iftb,*)
     !    write(iffb,*)
     !    write(iffb,*)
     ! enddo
!     deallocate(eval1,eval3,evecc1)
     ! if(lsh) then
     !    do iband = 1,nsh
     !       do iq = 1,nq
     !          write(ifsh,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !               iq,q(1:3,iq),  xq(iq),(eval2(iband,iq)-ef)*rydberg(),iband
     !       enddo
     !    enddo
     ! endif
!     call writeham(ifham,is,ef,alat,plat,pos,qbz,wbz,rws,irws,hrotk,nspin,natom,nwf,nqbz,nrws)
!     deallocate(cnk,umnk,eunk,hrotk,hrotr,hrotkp,evecc,eval,irws,rws,drws, &
!          ibasiwf,m_indx,n_indx,l_indx,ibas_indx)
!     if (lsh) deallocate(hrotkps,eveccs,evals,evecc2)
!     close(ifbnd)
!     close(iftb)
!     close(iffb)
!1000 enddo ispinloop
!950 format(a14,3f23.16)
!990 format(3f12.6)
!  call cputid(0)
!  call rx0s('lmfham2: ixc=2 ok')
!END PROGRAM lmfham2
