      program hwmatK_MPI
!!== Calculates the bare/screened interaction W ===
!!
!! W(w) = <phi(n1,dR) phi(n2,0) |W(w)| phi(n3,R') phi(n4,R'+dR')>
!! phi(n,R): maximally localized Wannier orbital
!!    n : band index
!!    R : site
!!
!! We included a cRPA method by juelich's group.
!!
!! This routine requirs an input from standard IO.
!! In scripts, you can do it like, prompt>echo mode|../exec/hwmat >lwmat,
!! where mode is 1 or 2, or 10011.
!!
!!  mode= 1: bare Coulomb mode, V, <phi phi | V  | phi phi>
!!  mode= 2: screening mode, Wc,   <phi phi | Wc | phi phi>
!!  mode=11: <phi phi | V(omega=0)  | phi phi>
!!  mode=12: <phi phi | Wc(omega=0) | phi phi>
!!  mode=10011: cRPA mode
!!
!!  nwf: total number of wannier within the primitive cell.
!!  nrws1: index for phi1(n1,dR) phi(n2,0), where range of dR is by dR < rcut1
!!  nrws2: index for phi(n3,R'), where range of R' is            by R' < rcut2
!!         This is also for R'+dR'.
!!  nrws = nrws1*nrws2*nrws2 : total spatial index for W.
!!  Thus irws=1,nrws where specifies a set (dR,R',dR').
!!
cccccccccccccccc old history ----
cx  mode= 3: effective U mode,   <phi phi | U | phi phi>
cx  mode= 4: similar to mode=1, but phi is atomic orbital+gaussian tail
cx  mode= 5: similar to mode=2, but phi is atomic orbital+gaussian tail
cx  mode= 6: similar to mode=3, but phi is atomic orbital+gaussian tail
c
c Mar 2008 Takashi Miyake, MPI version (parallelized along the outer q only)
c May 2007 Takashi Miyake, full matrix elements
c May 2006 Takashi Miyake, updated for new fpgw
c Sep 2004 Takashi Miyake, off-site W
c Jul 2004 Takashi Miyake. from hsfp0.m.f
c May 2002 Takashi Miyake. Total energy calc.
c Apr 2002 takao kotani. multiple argumentation wave per l. 
c This hsfp0 is build from hsec10.f by F.Aryasetiawan.
c------------------------------------------------------------
      use m_readqg,only: Readngmx2,ngcmx,ngpmx,Readqg0,Readqg
      use m_hamindex,only:   Readhamindex,symgg=>symops,ngrp,invg=>invgx
      use m_read_bzdata,only: Read_bzdata,qibz,irk,ginv,n1,n2,n3,nqbz,nqibz,nstar,nstbz,qbas,qbz,wibz,wbz
      use m_readeigen,only: onoff_write_pkm4crpa,init_readeigen,init_readeigen2,
     &     init_readeigen_mlw_noeval,init_readeigen_phi_noeval,  nwf
      use m_genallcf_v3,niwg=>niw
      use m_keyvalue,only: getkeyvalue
      use m_readhbe,only: Readhbe, nprecb,mrecb,mrece,nlmtot,nqbzt,nband,mrecg
      use m_zmel,only: ppbafp_v2
      use m_hamindex0,only: readhamindex0,iclasst
c RS: MPI module
      use rsmpi
      use rsmpi_rotkindex
      implicit none
      real(8),parameter :: 
     &  ua    = 1d0    ! constant in w(0)exp(-ua^2*w'^2) to take care of peak around w'=0 
c------------------------------------
      real(8)    :: esmr2,shtw
c      integer(4) :: mxclass,ngnmax,mbytes,mwords,iwksize,
c     &   natom,nclass,ipos,igrp,
c     &   iqibz,
c     &   iqbz,
c     &   iinvg,
c     o   nspin,nl,nn,nnv,nnc,
c     o   inindx,inindxv,inindxc,iiclass,
c     d   nlmto,nlnx,nlnxv,nlnxc,nlnmx,nlnmxv,nlnmxc,
c     o   iz, 
c     o   iil,iin,iim,iilnm,i_mnl,
c     o   iilv,iinv,iimv,iilnmv,i_mnlv,
c     o   iilc,iinc,iimc,iilnmc,i_mnlc,
c     o   incwf,iecore,ikonf,iicore,incore,nctot,
c     o   imagw,niw,nw,ifreq,  
      integer(4)::
     &   ixc,iopen, !ifhbed, nprecb,mrecb,mrece,nlmtot,nqbzt, nband,
     &   ibas,ibasx,nxx,nbloch,ifqpnt,ifwd,ifmloc,
     &   nprecx,mrecl,nblochpmx2,nwp,niwt, nqnum,mdimx,nblochpmx,
     &   ifrcw,ifrcwi,  noccxv,maxocc2,noccx,ifvcfpout,iqall,iaf,ntq,
     &   i,k,nspinmx, nq,is,ip,iq,idxk,ifoutsex,iclose,nq0i,ig,
     &   mxkp,nqibzxx,ntet,nene,iqi, ix,iw,
     &   nlnx4,niwx,irot,invr,invrot,ivsum, ifoutsec,ntqx,!nwf,
c
c     &   ifrb(2),ifcb(2),ifrhb(2),ifchb(2)
c     &    ifev(2),
     &    ifwmat(2) !,ifcphi
     &   ,ifxc(2),ifsex(2), ifphiv(2),ifphic(2),ifec,ifexsp(2),
     &   ifsecomg(2),ifexx,ndble=8
c
c      real(8) :: alat,ef,diw,dw,delta,pi,tpia,vol,voltot,rs,alpha,
      real(8) :: pi,tpia,vol,voltot,rs,alpha,
     & qfermi,efx,valn,efnew,edummy,efz,qm,xsex,egex,
     & zfac1,zfac2,dscdw1,dscdw2,dscdw,zfac,ef2=1d99,exx,exxq,exxelgas
c
c     &   lowesteval !defined in readeigen
ccc   qbas(3,3),ginv(3,3) plat(3,3),
      logical lqall,laf
c      character*120 symgrp

c class parameters
c      parameter (mxclass=100)
c      character*6 clabl(mxclass)
c symmetry group
c      parameter (ngnmax=10)
c      real(8) :: gen(9,ngnmax)
c
      integer(4),allocatable :: itq(:)
      real(8),allocatable    :: q(:,:)

c takao
      integer(4),allocatable :: ngvecpB(:,:,:),!ngveccB(:,:,:),
     &  ngvecp(:,:), ngvecc(:,:),iqib(:), !,ngpn(:)ngcni(:)
     &  kount(:), nx(:,:),nblocha(:),lx(:) !ngveccBr(:,:,:)
      real(8),allocatable:: vxcfp(:,:,:),
     &  wqt(:), wgt0(:,:),q0i(:,:),
     &  ppbrd (:,:,:,:,:,:,:),cgr(:,:,:,:),eqt(:),
     &  ppbrdx(:,:,:,:,:,:,:),aaa(:,:), !symope(:,:,:)=symgg, ! qibz(:,:),
     &  ppb(:), eq(:), !,pdb(:),dpb(:),ddb(:)
     &  eqx(:,:,:),eqx0(:,:,:),ekc(:),coh(:,:)
     &         , rw_w(:,:,:,:,:,:),cw_w(:,:,:,:,:,:),
     &           rw_iw(:,:,:,:,:,:),cw_iw(:,:,:,:,:,:)
      complex(8),allocatable:: geigB(:,:,:,:)
c 
      logical :: screen, exchange, cohtest, legas, tote, lueff 
      logical :: lcrpa
      real(8) ::  rydberg,hartree 
      real(8):: qreal(3), ntot,nocctotg2,tripl,xxx(3,3)
      logical ::nocore

c space group infermation 
      integer(4),allocatable :: invgx(:), miat(:,:)
      real(8),allocatable    :: tiat(:,:,:),shtvg(:,:)

c tetra 
      real(8),allocatable :: qz(:,:),qbzxx(:),wbzxx(:),wtet(:,:,:,:),
     &     eband(:,:,:), ene(:) !,ecore(:,:)
      integer(4),allocatable ::idtetx(:,:),idtet(:,:),ipq(:)
     &      ,iene(:,:,:),ibzx(:) ! ,nstar(:)
c      real(8) :: qbasmc(3,3)

c worksize in megabytes (1 word = 4 bytes)
c      integer(4) :: mbytes,mwords,iwksize
c      parameter (mbytes=60)
c      parameter (mwords=mbytes/4)
c      parameter (iwksize=mwords * 1000 *1000)
c      integer w
c      common /w/ w(iwksize)

      integer(4) ::ib,iqx,igp,iii,ivsumxxx,isx,iflegas, iqpntnum
c
      real(8),allocatable   :: eex1(:,:,:),exsp1(:,:,:),qqex1(:,:,:,:)
      integer(4),allocatable:: nspex(:,:),ieord(:),itex1(:,:,:)
      real(8)    :: qqex(1:3), eex,exsp,eee, exwgt,deltax0
      integer(4) :: itmx,ipex,itpex,itex,nspexmx,nnex,isig,iex,ifexspx
     & ,ifexspxx ,ifefsm, nq0ix,ifemesh,nz
      character(3)  :: charnum3,sss
      character(12) :: filenameex
      logical :: exspwrite=.false.
      character*8 xt

      integer(4) :: iwini,iwend
      real(8),allocatable:: omega(:,:)
      real(8) ::  omegamax,dwplot,omegamaxin
c      logical :: sergeys

      integer(4)::nqbze,ini,nq0it,idummy
      real(8),allocatable:: qbze(:,:)

      real(8)   :: ebmx(2)
      integer(4):: nbmx(2)
      
      real(8):: volwgt

      integer(4)::nwin, incwfin
      real(8)::efin,ddw,dwdummy
      integer(4),allocatable::imdim(:)
      real(8),allocatable::freqx(:),freqw(:),wwx(:),expa(:)

      logical:: GaussSmear !readgwinput, 
      integer(4)::ret
      character*(150):: ddd


      integer(4)::  ngpn1,verbose,ngcn1,nwxx !bzcase, mrecg,
      real(8)   :: wgtq0p,quu(3)

      real(8),allocatable:: freq_r(:)

      logical ::smbasis
      integer(4):: ifpomat,nkpo,nnmx,nomx,ikpo,nn_,no,nss(2)
      real(8):: q_r(3)
      real(8),allocatable:: qrr(:,:)
      integer(4),allocatable:: nnr(:),nor(:)
      complex(8),allocatable:: pomatr(:,:,:),pomat(:,:)

      real(8)::sumimg
      logical allq0i                                             !S.F.Jan06

      integer(4):: nw_i,ifile_handle,if102,if3111,if101

      logical:: latomic,lfull,lstatic,lwssc
      logical:: l1d,lll
      real(8):: rsite(3),rcut1,rcut2
      real(8),allocatable :: rws(:,:),drws(:),rws1(:,:),rws2(:,:)
      integer(4):: nrws,nrws1,nrws2,ir1,ir2,ir3,ir,nrw
      integer(4),allocatable:: irws(:),irws1(:),irws2(:)

c RS: variables for MPI
      integer(4) :: input3(3),irot_local,ip_local,iq_local, nq0ixxx
      integer,allocatable :: nq_local(:),iqx_index(:,:)
      real(8),allocatable:: 
     &  rw_w_sum(:,:,:,:,:,:),rw_iw_sum(:,:,:,:,:,:),
     &  cw_w_sum(:,:,:,:,:,:),cw_iw_sum(:,:,:,:,:,:)

      integer :: iwf1, iwf2, iwf3, iwf4, ia
      integer :: ifcou, ifscr
      real(8),allocatable:: 
     &           rv_w(:,:,:,:,:),cv_w(:,:,:,:,:),
     &           rv_iw(:,:,:,:,:),cv_iw(:,:,:,:,:)
      real(8)::ef
c For hmagnon (only omega=0 is used)
      integer::nw,nctot0,niw
      logical:: lomega0
c---------------------------------------
c RS: program begins here
      call RSMPI_Init()

      hartree=2d0*rydberg()

      iii=verbose()
      if (Is_IO_Root_RSMPI())write(6,*)' verbose=',iii

c mode switch. --------------
      if (Is_IO_Root_RSMPI()) then
      write(6,*) ' --- Choose omodes below ----------------'
      write(6,*) '  V (1) or W (2) or U(3)' 
      write(6,*) '  V_omega=0 (11) or W_omega=0 (12)' 
      write(6,*) '  [option --- (+ QPNT.{number} ?)] '
      write(6,*) ' --- Put number above ! -----------------'
      call readin5(ixc,nz,idummy)

      input3(1) = ixc
      input3(2) = nz
      input3(3) = idummy
      write(6,*) ' ixc nz=',ixc, nz
      if(ixc==0) stop ' --- ixc=0 --- Choose computational mode!'
      endif

      call MPI_Bcast(input3,3,MPI_INTEGER,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Bcast(input3)",ierror_rsmpi)
      ixc=input3(1)
      nz=input3(2)
      idummy=input3(3)

      lomega0=.false.
      if (ixc==11) then
         ixc=1
         lomega0=.true.
      elseif(ixc==12) then
         ixc=2
         lomega0=.true.
      endif

c---  readin BZDATA. See gwsrc/rwbzdata.f
c--------readin data set when you call read_BZDATA ---------------
c       integer(4)::ngrp,nqbz,nqibz,nqbzw,nteti,ntetf
ccccc    ! &   ,n_index_qbz  
c       integer(4):: n1,n2,n3
c       real(8):: qbas(3,3),ginv(3,3),qbasmc(3,3)
c       real(8),allocatable:: qbz(:,:),wbz(:),qibz(:,:)
c     &    ,wibz(:),qbzw(:,:)
c       integer(4),allocatable:: idtetf(:,:),ib1bz(:),idteti(:,:)
c     &    ,nstar(:),irk(:,:),nstbz(:)          !,index_qbz(:,:,:)
c-----------------------------------------------------------------
      call read_BZDATA()
c      write(6,"(a,9f9.4)")'hwmatK_MPI:ginv=',ginv

      if (Is_IO_Root_RSMPI()) then
      write(6,*)' nqbz  =',nqbz
c      write(6,*)  qbz 
      write(6,*)' nqibz ngrp=',nqibz,ngrp
c      write(6,*)' irk=',irk
c      write(6,*)' #### idtetf: ####'
c      write(6,*) idtetf
      endif

c set up work array
c      call wkinit (iwksize)
      call pshprt(60)

C--- readin GWIN and LMTO, then allocate and set datas.
c      nwin =-999    !not readin NW file
c      efin =-999d0  !not readin EFERMI
      incwfin= -1  !use 7th colmn for core at the end section of GWIN
      call genallcf_v3(incwfin) !in module m_genallcf_v3
      niw=niwg
      ef=1d99
c      if(ngrp/= ngrp2)
c     &  call RSMPI_Stop( 'ngrp inconsistent: BZDATA and LMTO GWIN_V2')
c---  These are allocated and setted.
c      integer(4)::  nclass,natom,nspin,nl,nn,nnv,nnc, ngrp,
c     o  nlmto,nlnx,nlnxv,nlnxc,nlnmx,nlnmxv,nlnmxc, nctot,niw, !not readin nw
c      real(8) :: alat,ef, diw,dw,delta,deltaw,esmr   
c      character(120):: symgrp
c      character(6),allocatable :: clabl(:)
c      integer(4),allocatable:: iclass(:)
c     &  ,nindxv(:,:),nindxc(:,:),ncwf(:,:,:) ,
c     o    invg(:), il(:,:), in(:,:), im(:,:),   ilnm(:),  nlnm(:),
c     o    ilv(:),inv(:),imv(:),  ilnmv(:), nlnmv(:),
c     o    ilc(:),inc(:),imc(:),  ilnmc(:), nlnmc(:),
c     o    nindx(:,:),konf(:,:),icore(:,:),ncore(:),
c     &    occv(:,:,:),unoccv(:,:,:)   
c     &   ,occc(:,:,:),unoccc(:,:,:),
c     o    nocc(:,:,:),nunocc(:,:,:)
c      real(8), allocatable:: 
c     o  plat(:,:),pos(:,:),z(:),  ecore(:,:),  symgg(:,:,:) ! symgg=w(igrp),freq(:)
c-----------------------------------------------------------------------

c--- Get maximums takao 18June03
c      call getnemx(nbmx,ebmx,8,.true.) !8+1 th line of GWIN0
c      call getnemx8(nbmx,ebmx)
c      if (Is_IO_Root_RSMPI())
c     &  write(6,"('  nbmx ebmx from GWinput=',2i8,2d13.5)") nbmx,ebmx

c-------------------------------------------------------------------
c      if (nclass > mxclass) stop ' hsfp0: increase mxclass'
c!!!! WE ASSUME iclass(iatom)= iatom !!!!!!!!!!!!!!!!!!!!!!!!!
      if (nclass /= natom ) call RSMPI_Stop( ' hsfp0: nclass /= natom ') ! We assume nclass = natom.
      if (Is_IO_Root_RSMPI()) write(6,*)' hsfp0: end of genallcf2'
c
      call pshprt(30)
      pi   = 4d0*datan(1d0)
      tpia = 2d0*pi/alat

      shtw = 0d0
      if(esmr<1d-5) shtw=0.01d0 ! Ferdi's shift to avoid resonance effect(maybe)
c
c      call dinv33(plat,1,xxx,vol)
c      voltot = dabs(vol)*(alat**3)
      voltot = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))

      legas = .false.
      latomic = .false.
      l1d = .false.
      inquire(file='UU1dU',exist=l1d)

      if (ixc==1) then
        if (Is_IO_Root_RSMPI())
     &   write(6,*)' --- bare Coulomb mode --- '
        exchange =.true.
        lueff = .false.
        if (Is_IO_Root_RSMPI()) then
          ifwmat(1) = iopen('VMATU',1,-1,0)
          if (nspin == 2) ifwmat(2) = iopen('VMATD',1,-1,0)
        endif  
      elseif (ixc ==2) then
        if (Is_IO_Root_RSMPI())
     &   write(6,*)' --- screening (Wc) mode --- '
        exchange =.false.
        lueff = .false.
        lcrpa = .false.
        print *, "lcrpa =", lcrpa
        print *, "lueff=", lueff
        if (Is_IO_Root_RSMPI()) then
          ifwmat(1) = iopen('WcMATU',1,-1,0)
          if (nspin == 2) ifwmat(2) = iopen('WcMATD',1,-1,0)
        endif  
      elseif (ixc == 100) then
        if (Is_IO_Root_RSMPI())
     &   write(6,*)' --- screening_crpa (Wc) mode --- '
        exchange =.false.
        lueff = .false.
        lueff = .false.
        lcrpa = .true.
        ixc = 2
        if (Is_IO_Root_RSMPI()) then
          ifwmat(1) = iopen('WcMATU',1,-1,0)
          if (nspin == 2) ifwmat(2) = iopen('WcMATD',1,-1,0)
        endif  
c$$$      elseif (ixc ==3) then
c$$$        if (Is_IO_Root_RSMPI())
c$$$     &   write(6,*)' --- Ueff mode --- '
c$$$        exchange =.false.
c$$$        lueff = .true.
c$$$        if (Is_IO_Root_RSMPI()) then
c$$$          ifwmat(1) = iopen('UMATU',1,-1,0)
c$$$          if (nspin == 2) ifwmat(2) = iopen('UMATD',1,-1,0)
c$$$        endif  
c$$$      elseif (ixc==4) then
c$$$        if (Is_IO_Root_RSMPI())
c$$$     &   write(6,*)' --- bare Coulomb mode --- '
c$$$        exchange =.true.
c$$$        lueff = .false.
c$$$        latomic = .true.
c$$$        ixc=1
c$$$        if (Is_IO_Root_RSMPI()) then
c$$$          ifwmat(1) = iopen('VMATaU',1,-1,0)
c$$$          if (nspin == 2) ifwmat(2) = iopen('VMATaD',1,-1,0)
c$$$        endif
c$$$      elseif (ixc ==5) then
c$$$        if (Is_IO_Root_RSMPI())
c$$$     &   write(6,*)' --- screening (Wc) mode --- '
c$$$        exchange =.false.
c$$$        lueff = .false.
c$$$        latomic = .true.
c$$$        ixc=2
c$$$        if (Is_IO_Root_RSMPI()) then
c$$$          ifwmat(1) = iopen('WcMATaU',1,-1,0)
c$$$          if (nspin == 2) ifwmat(2) = iopen('WcMATaD',1,-1,0)
c$$$        endif
c$$$      elseif (ixc ==6) then
c$$$        if (Is_IO_Root_RSMPI())
c$$$     &   write(6,*)' --- Ueff mode --- '
c$$$        exchange =.false.
c$$$        lueff = .true.
c$$$        latomic = .true.
c$$$        ixc=3
c$$$        if (Is_IO_Root_RSMPI()) then
c$$$          ifwmat(1) = iopen('UMATaU',1,-1,0)
c$$$          if (nspin == 2) ifwmat(2) = iopen('UMATaD',1,-1,0)
c$$$        endif  
      elseif(ixc==10011) then
        write(6,*) 'ixc=10011 pkm4crpa mode'
        exchange =.false.
        lueff = .false.
      else   
         call RSMPI_Stop( 'ixc error')
      endif  

c---
      if (Is_IO_Root_RSMPI()) then
      write(6, *) ' --- computational conditions --- '
      write(6,'("    deltaw  =",f13.6)') deltaw 
      write(6,'("    ua      =",f13.6)') ua
      write(6,'("    esmr    =",f13.6)') esmr
      write(6,'("    alat voltot =",2f13.6)') alat, voltot
c      write(6,'("    niw nw dw   =",2i5,f13.6)') niw,nw,dw
      endif

c>> read dimensions of wc,b,hb
c      ifhbed     = iopen('hbe.d',1,0,0)
c      read (ifhbed,*) nprecb,mrecb,mrece,nlmtot,nqbzt, nband,mrecg
c      if (nprecb == 4)
c     & call RSMPI_Stop( 'hsfp0: b,hb in single precision')
      call Readhbe()
      call Readhamindex()
      call init_readeigen()!nband,mrece) !initialization of readEigen

c --- get space group information ---------------------------------
c true class information in order to determine the space group -----------
c     because the class in the generated GW file is dummy.(iclass(ibas)=ibas should be kept).
c      if102=ifile_handle()
c      open (if102,file='CLASS')
      allocate(invgx(ngrp)
     &         ,miat(natom,ngrp),tiat(3,natom,ngrp),shtvg(3,ngrp))
c      if (Is_IO_Root_RSMPI())
c     & write(6,*)'  --- Readingin CLASS info ---'
c      do ibas = 1,natom
c        read(if102,*) ibasx, iclasst(ibas)
c        if (Is_IO_Root_RSMPI())
c     &   write(6, "(2i10)") ibasx, iclasst(ibas)
c      enddo
c      close(if102)
      call readhamindex0()

c Get space-group transformation information. See header of mptaouof.
      call mptauof(symgg,ngrp,plat,natom,pos,iclasst
     o              ,miat,tiat,invgx,shtvg )
c        write (*,*)  'tiat=', tiat(1:3,1:natom,invr),invr
      
c Get array size to call rdpp
c      call getsrdpp( nclass,nl,  
c     o               ngpmx,ngcmx,nxx )
      call getsrdpp2( nclass,nl,nxx)
      call readngmx2()
c      call readngmx('QGpsi',ngpmx)
c      call readngmx('QGcou',ngcmx)
      if (Is_IO_Root_RSMPI())
     & write(6,*)' ngcmx ngpmx=',ngcmx,ngpmx
      allocate( nx(0:2*(nl-1),nclass), nblocha(nclass) ,lx(nclass),
     &   ppbrd ( 0:nl-1, nn, 0:nl-1,nn, 0:2*(nl-1),nxx, nspin*nclass),
     &   cgr(nl**2,nl**2,(2*nl-1)**2,ngrp))

c- readin plane wave parts, and Radial integrals ppbrd.
! ppbrd = radial integrals
! cgr   = rotated cg coeffecients.
! geigB = eigenfunction's coefficiens for planewave.
! ngvecpB (in 1stBZ) contains G vector for eigen function.
! ngveccB (in IBZ)   contains G vector for Coulomb matrix.
c      call rdpp_v2( ngpmx,ngcmx,nxx,  qibz,nqibz, qbz,nqbz,
c     i      nband, nl,ngrp, nn,  nclass, nspin, symgg,    qbas, 
c     o      nblocha, lx, nx, ppbrd ,
c     o      mdimx, nbloch, cgr, 
c     o      nblochpmx, ngpn,geigB,ngvecpB,  ngcni,ngveccB )
      call rdpp_v3(nxx, nl, ngrp, nn, nclass, nspin, symgg,!qbas,
     o      nblocha, lx, nx,  ppbrd , mdimx, nbloch, cgr)
c      nblochpmx = nbloch + ngcmx

c      allocate(ngcni(nqibz)) !, ngveccB(3,ngcmx,nqibz)) !, ngveccBr(3,ngcmx,nqibz))
c   geigB(ngpmx,nband,nqbz,nspin),ngpn(nqbz),ngvecpB(3,ngpmx,nqbz),  
c     &   )  ! in IBZ 
c
c      call rdpp_pln(ngpmx,ngcmx, qibz,nqibz, qbz,nqbz,nband,nspin,
c     o      ngpn,geigB,ngvecpB,ngcni,ngveccB)
c
c      do iq = 1,nqibz
c        call readqg('QGcou',qibz(1:3,iq),ginv,  quu,ngcni(iq), ngveccB(1,1,iq))
c        write(6,"('--From QGcou  qibz quu ngc=',3f9.4,'  ',3f9.4,i5)")
c     &       qibz(1:3,iq),quu,ngcni(iq)
c      enddo
c for info
      allocate(ngvecp(3,ngpmx),ngvecc(3,ngcmx))
      call readqg('QGpsi',qibz(1:3,1), quu,ngpn1, ngvecp)
      call readqg('QGcou',qibz(1:3,1), quu,ngcn1, ngvecc)
      deallocate(ngvecp,ngvecc)

      if (Is_IO_Root_RSMPI()) write(6,*) ' end of read QGcou' 

cccccccccccccccccccccccccccccccccccccccccccccccccccc
c      iqx=1
c      do ib=1,nband
c        write(6,'("  iband iqx sumgeigB=",2i3,12d12.3)') 
c     &   ib,iqx, sum(geigB(1:ngpn(1),ib,iqx))
c      enddo
ccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      ib =1
c      iqx=1
c      do igp =1,nbloch + ngpn(iqx)
c         write(6,'("  igb ib iqx geigB=",3i3,1x,3i2,12d12.3)') 
c     &   igp,ib,iqx, ngvecpB(1:3,igp,iqx), geigB(igp,ib,iqx)
c      enddo
c      stop "xxxxxx zzz"      
cccccccccccccccccccccccccccccccccccccccccccccccccccc
c----------------------------------------------
      call pshprt(60)

      if(ixc==10011) goto 1018

C--- Readin WV.d
      if (.not.exchange) then
       if (lueff) then 
         call RSMPI_Stop('Ueff mode not implimented in the MPI version')
          ifwd      = iopen('WV.d.maxloc',1,-1,0)
       else
          ifwd      = iopen('WV.d',1,-1,0)
       endif
       read (ifwd,*) nprecx,mrecl,nblochpmx,nwp,niwt,nqnum,nw_i
c nblochpmx from WV.d oct2005
       if (Is_IO_Root_RSMPI()) write(6,"(' Readin WV.d =', 10i5)") 
     &  nprecx, mrecl, nblochpmx, nwp, niwt, nqnum, nw_i 
       call checkeq(nprecx,ndble)
c       call checkeq(nblochpmx,nblochpmx2)
c       if (nwt /= nw)   stop 'hwmatK: wrong nw'
c       nw = nwt
       nw=nwp-1
       if (niwt /= niw) call RSMPI_Stop( 'hwmatK: wrong niw')
ctm 050518
       niw = 0
       niwt = 0
       if (lueff) then
          ifrcw     = iopen('WVR.maxloc',0,-1,mrecl)
c          ifrcwi = iopen('WVI.maxloc',0,-1,mrecl)
       else
          ifrcw     = iopen('WVR',0,-1,mrecl)
c          ifrcwi = iopen('WVI',0,-1,mrecl)
       endif
C... reading general energy mesh from file 'freq_r'
c        open(UNIT=3111,file='freq_r') !this is in a.u.
c        read(3111,*)nwxx             !number of energy points
c        if(nwxx/=nw) stop ' freq_r nw /=nw'
c        allocate(freq_r(nw))       !freq_r(1)=0d0
c        read(3111,*)freq_r
c     close(3111)
        if3111=ifile_handle()
        open(if3111,file='freq_r') !this is in a.u.
        read(if3111,*)nwxx             !number of energy points
        if(nwxx/= nw+1) stop ' freq_r nw /=nw'
        allocate(freq_r(nw_i:nw))       !freq_r(1)=0d0
        do iw = nw_i,nw
        read(if3111,*)freq_r(iw)
        enddo
        close(if3111)

      else 
       ifvcfpout = iopen('VCCFP',0,-1,0) 
       allocate(freq_r(1)); freq_r=1d99
c       nw = 1
       nw = 0
      endif
c 
      nrw = nw
      if (Is_IO_Root_RSMPI())
     & call getkeyvalue("GWinput","wmat_static",lstatic,default=.false.)
      call MPI_Bcast(lstatic,1,MPI_LOGICAL,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Bcast(lstatic)",ierror_rsmpi)
      if (lstatic) nrw = 0

c... Readin eigen functions
c      ifev(1)   = iopen('EVU', 0,0,mrece)
c     if (nspin==2) ifev(2) = iopen('EVD', 0,0,mrece)

c$$$c     --- determine Fermi energy ef for given valn (legas case) or corresponding charge given by z and konf.
c$$$!     When esmr is negative, esmr is geven automatically by efsimplef.
c$$$      call efsimplef2a_RSMPI(nspin,wibz,qibz,ginv, 
c$$$     i     nband,nqibz
c$$$     i     ,konf,z,nl,natom,iclass,nclass
c$$$     i     ,valn, legas, esmr,  !!! valn is input for legas=T, output otherwise. 
c$$$c     
c$$$     i     qbz,nqbz             !index_qbz, n_index_qbz,
c$$$     o     ,efnew)
c$$$c     
c$$$c     write(6,*)' end of efsimple'
c$$$c     ef = efnew
c$$$c     - check total ele number -------
c$$$      ntot  = nocctotg2(nspin, ef,esmr, qbz,wbz, nband,nqbz) !wbz
c$$$      write(6,*)' ef    =',ef
c$$$      write(6,*)' esmr  =',esmr
c$$$      write(6,*)' valn  =',valn
c$$$      write(6,*)' ntot  =',ntot

c      ifcphi  = iopen('CPHI',0,0,mrecb)
 1018 continue
      call init_readeigen2()!mrecb,nlmto,mrecg) !initialize m_readeigen
      write(*,*)'nband =',nband
!! jan2015
      lll=.false.
      if(ixc==10011.and.Is_IO_Root_RSMPI()) lll=.true.
      call onoff_write_pkm4crpa(lll) 
      !this is for writing pkm4crpa in init_readeigen_mlw_noeval.

      if (latomic) then
         call init_readeigen_phi_noeval()!nwf,nband,mrecb,mrecg)
      else   
!         if (l1d) then
!           call init_readeigen_mlw_noeval1D(nwf,nband,mrecb,mrecg)
!         else
           call init_readeigen_mlw_noeval()!nwf,nband,mrecb,mrecg)
!         endif
      endif
      if (Is_IO_Root_RSMPI()) then
      write(*,*)'Caution! evals are zero hereafter.'
      write(*,*)'nwf =',nwf
c      write(*,*)'nband =',nband
c      write(*,*)'mrecb =',mrecb
c      write(*,*)'mrecg =',mrecg
      write(*,*)'init_readeigen_mlw: done'
      endif

!! pkm4crpa mode. generated by init_readeigen_mlw_noeval
      if(ixc==10011) then
        call RSMPI_Finalize()
        if (Is_IO_Root_RSMPI()) call rx0s(' OK! hwmatK_MPI ixc=10011')
        stop 
      endif

c QPNT data
      if(nz==0) then
c        if(readgwinput()) then
         call getkeyvalue("GWinput","<QPNT>",unit=ifqpnt,status=ret) 
c        else
c         ifqpnt = iopen('QPNT',1,0,0)
c        endif
      else
        ifqpnt  = iopen('QPNT'//xt(nz),1,0,0)
      endif
      if (Is_IO_Root_RSMPI()) write(6,*)' ifqpnt ret=',ifqpnt,ret

c read q-points and states
c ---
! read QPNT
      lqall      = .true.
      laf        = .false.
      call readx   (ifqpnt,10)
      read (ifqpnt,*) iqall,iaf
      if (iaf   == 1)   laf = .true.
      call readx   (ifqpnt,100)
      read (ifqpnt,*) ntq
      allocate (itq(ntq))
      read (ifqpnt,*) (itq(i),i=1,ntq)
      deallocate(itq)
      nq         = nqibz
      allocate(q(3,nq))
      call dcopy   (3*nqibz,qibz,1,q,1)
c
      nspinmx = nspin
      if (laf) nspinmx =1

      close(ifqpnt)

ctm, 070521
      if (Is_IO_Root_RSMPI())
     & call getkeyvalue("GWinput","wmat_all",lfull,default=.false.)
      call MPI_Bcast(lfull,1,MPI_LOGICAL,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Bcast(lfull)",ierror_rsmpi)

      print *, "Here!!!!!!!!!!!!!", lfull, lwssc, nrws

      if (lfull) then
         if (Is_IO_Root_RSMPI()) then
         call getkeyvalue("GWinput","wmat_rcut1",rcut1, default=0.01d0 )  
         call getkeyvalue("GWinput","wmat_rcut2",rcut2, default=0.01d0 )  
ctm, 070814
         call getkeyvalue("GWinput","wmat_WSsuper",lwssc,default=.true.)
         endif ! Is_IO_Root_RSMPI
         call MPI_Bcast(rcut1,1,MPI_DOUBLE_PRECISION,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
         call RSMPI_Check("MPI_Bcast(rcut1)",ierror_rsmpi)
         call MPI_Bcast(rcut2,1,MPI_DOUBLE_PRECISION,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
         call RSMPI_Check("MPI_Bcast(rcut2)",ierror_rsmpi)
         call MPI_Bcast(lwssc,1,MPI_LOGICAL,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
         call RSMPI_Check("MPI_Bcast(lwssc)",ierror_rsmpi)
         if (lwssc) then
           allocate(irws(n1*n2*n3*8),rws(3,n1*n2*n3*8),drws(n1*n2*n3*8))
           call wigner_seitz(alat,plat,n1,n2,n3,nrws,rws,irws,drws)
           if (Is_IO_Root_RSMPI()) then
           write(*,*)'*** Wigner-Seitz Super cell'
           do i=1,nrws
              write(*,"(i5,4f12.6,i5)")i,rws(1,i),rws(2,i),rws(3,i),
     &                                 drws(i),irws(i)
           enddo   
           endif
         else
           allocate(irws(n1*n2*n3),rws(3,n1*n2*n3),drws(n1*n2*n3))
           call super_cell(alat,plat,n1,n2,n3,nrws,rws,irws,drws)
           if (Is_IO_Root_RSMPI()) then
           write(*,*)'*** Super cell (Not Wigner-Seitz super cell)'
           do i=1,nrws
              write(*,"(i5,4f12.6,i5)")i,rws(1,i),rws(2,i),rws(3,i),
     &                                 drws(i),irws(i)
           enddo   
           endif
         endif   
         nrws1 = 1
         do i=1,nrws
            if (drws(i).le.rcut1) nrws1=i
         enddo
         nrws2 = 1
         do i=1,nrws
            if (drws(i).le.rcut2) nrws2=i
         enddo
         allocate(rws1(3,nrws1),rws2(3,nrws2),irws1(nrws1),irws2(nrws2))
         rws1(:,1:nrws1) = rws(:,1:nrws1)
         rws2(:,1:nrws2) = rws(:,1:nrws2)
         irws1(1:nrws1) = irws(1:nrws1)
         irws2(1:nrws2) = irws(1:nrws2)
         nrws = nrws1*nrws2*nrws2
         deallocate(irws,rws,drws)
      else
         if (Is_IO_Root_RSMPI())
     &    call getkeyvalue("GWinput","wmat_rsite", rsite,3, 
     &     default=(/0.0d0,0.0d0,0.0d0/),status=ret)
          call MPI_Bcast(rsite,3,MPI_DOUBLE_PRECISION,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
          call RSMPI_Check("MPI_Bcast(rsite)",ierror_rsmpi)
         rcut1 = 0.0d0
         rcut2 = 0.0d0
         nrws1 = 1
         nrws2 = 1
         allocate(rws1(3,nrws1),rws2(3,nrws2),irws1(nrws1),irws2(nrws2))
         rws1(:,1) = rsite(:)
         rws2 = 0d0
         irws1(1) = 1
         irws2(1) = 1
         nrws = nrws1*nrws2*nrws2
      endif
      print *, "Here!!!!!!!!!!!!!", lfull, lwssc, nrws
      if (Is_IO_Root_RSMPI()) then
      write(*,'(a14,i5,f12.6)')'nrws1, rcut1 =',nrws1,rcut1
      write(*,'(a14,i5,f12.6)')'nrws2, rcut2 =',nrws2,rcut2
      write(*,'(a7,i7)')'nrws  =',nrws
      endif

c ---  q near zero
      write(6,*) 'reading QOP'
      if101=ifile_handle()
      open (if101,file='Q0P')
      read (if101,"(i5)") nq0i
      if(.not.exchange) call checkeq(nqibz+nq0i-1, nqnum)
      if (Is_IO_Root_RSMPI())
     & write(6,*) ' *** nqibz nq0i_total=', nqibz,nq0i
      nq0it = nq0i
      allocate( wqt(1:nq0i),q0i(1:3,1:nq0i) )
c      read (101,"(d24.16,3x, 3d24.16)" )( wqt(i),q0i(1:3,i),i=1,nq0i)
      nq0ix = nq0i
      do i=1,nq0i
      read (if101,* ) wqt(i),q0i(1:3,i)
      if(wqt(i)==0d0 ) nq0ix = i-1
      enddo
      nq0i = nq0ix ! New nq0i July 2001
      if (Is_IO_Root_RSMPI()) then
      write(6,*) ' Used k number in Q0P =', nq0i
      write(6,"(i3,f14.6,2x, 3f14.6)" )(i, wqt(i),q0i(1:3,i),i=1,nq0i)
      endif
      close(if101)
      allocate( wgt0(nq0i,ngrp) )
C Sergey's 1stFeb2005
c      call q0iwgt2(symgg,ngrp,wqt,q0i,nq0i, 
c     o            wgt0)
      if (Is_IO_Root_RSMPI())
     & call getkeyvalue("GWinput","allq0i",allq0i,default=.false.)!S.F.Jan06
      call MPI_Bcast(allq0i,1,MPI_LOGICAL,io_root_rsmpi,
     &     MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Bcast(allq0i)",ierror_rsmpi)
      call q0iwgt3(allq0i,symgg,ngrp,wqt,q0i,nq0i,               !S.F.Jan06
     o            wgt0)                   ! added allq0i argument
C--------------------------
      if (Is_IO_Root_RSMPI()) then
      if(nq0i/=0) write(6,*) ' *** tot num of q near 0   =', 1/wgt0(1,1)      
      write(6,"('  sum(wgt0) from Q0P=',d14.6)")sum(wgt0)
      endif
c$$$      if(bzcase()==2) then
c$$$        wgt0= wgt0*wgtq0p()/dble(nqbz)
c$$$        if (Is_IO_Root_RSMPI())
c$$$     &   write(6,"('bzcase=2:  sum(wgt0_modified )=',d14.6)")sum(wgt0)
c$$$      endif

c --- qbze(3,nqibze)
      nqbze  = nqbz *(1 + nq0it)
      allocate( qbze(3, nqbze) )
      call dcopy(3*nqbz, qbz, 1, qbze,1)
      do i = 1,nq0it
        ini = nqbz*(1 + i -1)
        do ix=1,nqbz
          qbze (:,ini+ix)   = q0i(:,i) + qbze(:,ix)
        enddo
      enddo

c --- read LDA eigenvalues
c     ntp0=ntq
c      allocate(eqx(ntq,nq,nspin),eqx0(ntq,nq,nspin),eqt(nband))
c      do      is = 1,nspin
c      do      ip = 1,nq
cc        iq       = idxk (q(1,ip),qbze,nqbze)
cc        call rwdd1   (ifev(is), iq, nband, eqt) !direct access read b,hb and e(q,t)
c        call readeval(q(1,ip),is,eqt)
cc        write(6,*)' eqt=',eqt
c        eqx0(1:ntq,ip,is) = eqt(itq(1:ntq))
c        eqx (1:ntq,ip,is) = rydberg()*(eqt(itq(1:ntq))- ef)
c      enddo
c      enddo
c      deallocate(eqt)


c --- info
      if (Is_IO_Root_RSMPI())
     & call winfo(6,nspin,nq,ntq,nspin,nbloch
     &    ,ngpn1,ngcn1,nqbz,nqibz,ef,deltaw,alat,esmr)

c pointer to optimal product basis
      allocate(imdim(natom)) !bugfix 12may2015
c      call indxmdm (nblocha,nclass,
c     i              iclass,natom,
c     o              imdim )
      do ia = 1,natom
        imdim(ia)  = sum(nblocha(iclass(1:ia-1)))+1
      enddo
      if(niw/=0) then ! generate gaussian frequencies x between (0,1) and w=(1-x)/x
        allocate(freqx(niw),freqw(niw),wwx(niw))!,expa(niw))
        call freq01x  (niw, !ua,
     o                freqx,freqw,wwx) !, expa)
      endif
ccc ------ write energy mesh ----------
ccc      if(.not.sergeys) then
cc      ifemesh = iopen('emesh.hwmat'//xt(nz),1,-1,0)
cc      deltax0 = 0d0
cc      call writeemesh(ifemesh,freqw,niw,freq_r,nwp,deltax0)
ccc
      iii=ivsumxxx(irk,nqibz*ngrp)
      if (Is_IO_Root_RSMPI())
     & write(6,*) " sum of nonzero iirk=",iii, nqbz

C... Read pomatr
      if(smbasis()) then
        call RSMPI_Stop('hwmatK_MPI: smbasis notimplemented!')
        write(6,*)' smooth mixed basis : augmented zmel'
        call getngbpomat(nqibz+nq0i,
     o  nnmx,nomx)
        nkpo = nqibz+nq0i
        ifpomat = iopen('POmat',0,-1,0) !oct2005
        allocate( pomatr(nnmx,nomx,nkpo),qrr(3,nkpo),nor(nkpo),nnr(nkpo) )
        do ikpo=1,nkpo
         read(ifpomat) qrr(:,ikpo),nn_,no,iqx !readin reduction matrix pomat
c         write(6,"('smbasis: ikp q no nn=',i5,3f8.4,4i5)") ikp,qrr(:,ikpo),no,nn_
         nnr(ikpo)=nn_
         nor(ikpo)=no
         read(ifpomat) pomatr(1:nn_,1:no,ikpo)
        enddo
        isx = iclose("POmat")
        write(6,*)"Read end of POmat ---"
      else !dummy
        nkpo = 1
        nnmx =1
        nomx =1 
        allocate( pomatr(nnmx,nomx,nkpo), qrr(3,nkpo),nor(nkpo),nnr(nkpo) )
      endif

c-----------------------------------------------------------
c calculate the correlated part of the self-energy SEc(qt,w)
c-----------------------------------------------------------
c arrays for sxcf.f
      nlnx4    = nlnx**4
      niwx     = max0 (nw,niw)
      allocate( ppb(nlnmx*nlnmx*mdimx*nclass),  eq(nband), 
     & kount(nqibz), 
     &       rw_w(nwf,nwf,nwf,nwf,nrws,0:nrw),
     &       cw_w(nwf,nwf,nwf,nwf,nrws,0:nrw),
     &       rw_iw(nwf,nwf,nwf,nwf,nrws,niw),
     &       cw_iw(nwf,nwf,nwf,nwf,nrws,niw),
     &       rv_w(nwf,nwf,nwf,nwf,nrws),
     &       cv_w(nwf,nwf,nwf,nwf,nrws))

c RS: set MPI parameters
c RS: see gwsrc/RSMPI_rotkindex_mod.F
      call MPI_Barrier(MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Barrier",ierror_rsmpi)
!      call setup_rotkindex(ngrp,irk,wgt0,bzcase(),nqibz,nq0i,nq)
      nq0ixxx=0
c      call setup_rotkindex(ngrp,irk,wgt0,bzcase(),nqibz,nq0ixxx,1) ! nq=1
      call setup_rotkindex(ngrp,irk,wgt0,1,nqibz,nq0ixxx,1) ! nq=1

      if (Is_IO_Root_RSMPI()) then ! debug
        if(nq0i/=0) then
          write(6,*) 'RS: total number of k-points should be',
     &         nqbz +  1/wgt0(1,1)   - 2 + 1 !bzcase()
        else
          write(6,*) 'RS: total number of k-points should be',
     &         nqbz  - 2 + 1 !bzcase()
        endif
      endif
      call MPI_Barrier(MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Barrier",ierror_rsmpi)
c RS: openlogfile for each process
      if (ixc .eq. 1) then
        ifile_rsmpi = iopen ('lwt_v.MPI'//myrank_id_rsmpi,1,3,0)
      else if (ixc .eq. 2) then
        ifile_rsmpi = iopen ('lwt_wc.MPI'//myrank_id_rsmpi,1,3,0)
      else if (ixc .eq. 3) then
        ifile_rsmpi = iopen ('lwt_u.MPI'//myrank_id_rsmpi,1,3,0)
      else if (ixc .eq. 4) then
        ifile_rsmpi = iopen ('lwt_v_phi.MPI'//myrank_id_rsmpi,1,3,0)
      else if (ixc .eq. 5) then
        ifile_rsmpi = iopen ('lwt_wc_phi.MPI'//myrank_id_rsmpi,1,3,0)
      else if (ixc .eq. 6) then
        ifile_rsmpi = iopen ('lwt_u_phi.MPI'//myrank_id_rsmpi,1,3,0)
      elseif( ixc==10011) then
      else
        call RSMPI_Stop("unknown ixc")
      endif
c RS: print how symmetry operations and k-points are devided ..
      write(ifile_rsmpi,*) "rank : ", myrank_id_rsmpi
      write(ifile_rsmpi,*) "nrotk_local:",nk_local_qkgroup
      write(ifile_rsmpi,*) "nrot_local :",nrot_local_rotk
      if (nrot_local_rotk .gt. 0) then
        write(ifile_rsmpi,*)
     &        "irot_index :",irot_index_rotk(1:nrot_local_rotk)
      endif
      write(ifile_rsmpi,*) "nk_local(1:ngrp) :"
      write(ifile_rsmpi,*) nk_local_rotk(:)
      do irot=1,ngrp
        if (nk_local_rotk(irot).gt.0) then
          write(ifile_rsmpi,*) "> irot,nk_local(irot) = ",
     &         irot, nk_local_rotk(irot)
          write(ifile_rsmpi,*) "   ik_index : ",
     &         ik_index_rotk(irot,1:nk_local_rotk(irot))
        endif
      enddo
ccccccccccccccc
      call MPI_Barrier(MPI_COMM_WORLD,ierror_rsmpi)
      call RSMPI_Check("MPI_Barrier",ierror_rsmpi)

      if (Is_IO_Root_RSMPI()) then
        write(6,*) "RS: loop over spin --"
      endif


c loop over spin ----------------------------------------------------
      do 2000 is = 1,nspinmx

c initialise secq and kount
      kount = 0
      rw_w = 0d0
      cw_w = 0d0
      rw_iw = 0d0
      cw_iw = 0d0
 

c loop over rotations -------------------------------
ctm
      call chkrot() !ngrp)
      do 1000 irot_local = 1,nrot_local_rotk
        irot = irot_index_rotk(irot_local)
	if( sum(abs( irk(:,irot) )) ==0 .and.
     &      sum(abs( wgt0(:,irot))) == 0d0 ) then
c RS: this should not happen... see gwsrc/RSMPI_rotindex_mod.F
          call RSMPI_Stop("hwmatK_RSMPI, cylce occurs in do 1000 -loop!")
	   cycle
	endif
        write (6,"(i3,'  out of ',i3,'  rotations ',$)") irot,ngrp
        call cputid (0)

c rotate atomic positions invrot*R = R' + T
c        invr       = invrot (irot,invg,ngrp)
        invr     = invg(irot)
c -- ppb= <Phi(SLn,r) Phi(SL'n',r) B(S,i,Rr)> 
        call ppbafp_v2 (irot,ngrp,is,nspin,
     i              il,in,im, nlnm,
     d                 nl,nn,nclass,nlnmx,
     i                 mdimx,lx,nx,nxx,  !Bloch wave    
     i                 cgr, nl-1,        !rotated CG
     i                 ppbrd,            !radial integrals
     o              ppb)

cc -- Rotated gvecc
c        call rotgvec(symgg(:,:,irot), nqibz, 
c     i    ngcmx,ngcni,qbas,ngveccB, 
c     o    ngveccBr)

c------------------------------------------------------
c calculate the correlated part of the self-energy within GW
c        ntqx = 0
c        if(tetra.and.(.not.exchange)) then
c        ntqx =3*ntq
c        endif
c loop over q
c        do ip = 1,nq   !;write (*,*) ip,'  out of ',nq,'  k-points ' ! call cputid  (0)
c          iq  = idxk (q(1,ip),qbz,nqbz)
c          call rwdd1 (ifev(is),iq, nband,eq)
c          call readeval(q(1,ip),is,eq)

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c nctot=0 in this version
      nctot0=0
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         write(*,*) 'wmatq in',irot_local,nrot_local_rotk

         call wmatqk_MPI (kount, irot,ef,ef2,esmr,esmr2,
ctm, 070501
c     i              tiat(1:3,1:natom,invr),miat( 1:natom,invr), rsite,
     i              tiat(1:3,1:natom,invr),miat( 1:natom,invr), 
c     i              rws,irws,nrws,
     i              rws1,rws2,nrws1,nrws2,nrws,
cv2
     i              nspin,is, !ifcphi,ifrb(is),ifcb(is),ifrhb(is),ifchb(is),
     i              ifrcw,ifrcwi,
     i              qbas,ginv,qibz,qbz,wbz,nstbz, wibz, !iindxk,
     i              nstar,irk,     !kount,
c
c     i        iiclass,nblocha,i_mnlv,i_mnlc,iicore,incore,iimdim,
     i        iclass,nblocha,nlnmv, nlnmc,   !w(i_mnlv),w(i_mnlc)
     i        icore,ncore, imdim,
     i              ppb, ! pdb,dpb,ddb,
     i              freq_r,freqx, wwx, expa,
     i              ua,dwdummy,  !deltaw,
     i              ecore(:,is), 
c
     d        nlmto,nqibz,nqbz,nctot0,
c     i        index_qbz, n_index_qbz,
     d              nl,nnc,nclass,natom,
     d              nlnmx,mdimx,nbloch,ngrp,nw_i,nw,nrw,niw,niwx,nq,
c
c     i     nblochpmx, ngpn,ngcni,ngpmx,ngcmx,
     i     nblochpmx,ngpmx,ngcmx,
c     i     geigB(1,1,1,is), ngvecpB,ngveccBr,
c     i     ngveccBr,
     i     wgt0,wqt,nq0i,q0i, symgg(:,:,irot),alat,
     i     matmul(symgg(:,:,irot),shtvg(:,invr)),nband,
     i     ifvcfpout,
c     i     shtw, 
     i     exchange, !tote, screen, cohtest, ifexsp(is),
c     i        omega, iwini,iwend,
c     i     nbmx(2),ebmx(2), !takao 18June2003 
     i   pomatr, qrr,nnr,nor,nnmx,nomx,nkpo,          !oct2005 for pomat 
     i     nwf,
     o     rw_w,cw_w,rw_iw,cw_iw) ! acuumulation variable
         write(*,*) 'wmatq out',irot_local,nrot_local_rotk
cccccccccccccccccccccccccccccccccccccccccc
c        iii = ivsum(kount,nqibz*nq)
c        write(6,*)" sumkount 2=",nqibz,nq,iii
c        stop "--- kcount test end --- "
cccccccccccccccccccccccccccccccccccccccccc
c< end of q-loop
c        enddo

c< end of rotation-loop
c        enddo
 1000 continue !end of rotation-loop


      print *,'xxxxxxxxbbbbbbbbbbbbbbbbbbbb'
C RS: accumulate zw
      allocate( rw_w_sum(nwf,nwf,nwf,nwf,nrws,0:nrw),
     &          cw_w_sum(nwf,nwf,nwf,nwf,nrws,0:nrw),
     &          rw_iw_sum(nwf,nwf,nwf,nwf,nrws,niw),
     &          cw_iw_sum(nwf,nwf,nwf,nwf,nrws,niw))
        call MPI_AllReduce(rw_w,rw_w_sum,(nrw+1)*nwf**4*nrws,
     &         MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror_rsmpi)
        call RSMPI_Check("MPI_AllReduce,rw_w",ierror_rsmpi)
        rw_w = rw_w_sum
        call MPI_AllReduce(cw_w,cw_w_sum,(nrw+1)*nwf**4*nrws,
     &         MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror_rsmpi)
        call RSMPI_Check("MPI_AllReduce,cw_w",ierror_rsmpi)
        cw_w = cw_w_sum

        if (niw.gt.0) then
           call MPI_AllReduce(rw_iw,rw_iw_sum,niw*nwf**4*nrws,
     &          MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror_rsmpi)
           call RSMPI_Check("MPI_AllReduce,rw_iw",ierror_rsmpi)
           rw_iw = rw_iw_sum
           call MPI_AllReduce(cw_iw,cw_iw_sum,niw*nwf**4*nrws,
     &          MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror_rsmpi)
           call RSMPI_Check("MPI_AllReduce,cw_iw",ierror_rsmpi)
           cw_iw = cw_iw_sum
        endif                   ! niw
        deallocate(rw_w_sum,cw_w_sum,rw_iw_sum,cw_iw_sum) 

c      if (debug) write(*,*) 'do-rot out'

c check that all k { FBZ have been included
c      if (ivsum(kount,nqibz*nq) /= nqbz*nq) then
c        iii = ivsum(kount,nqibz*nq)
c        write(6,*)" ivsum=",iii, nqbz*nq 
c        stop 'hsfp0: missing k-pts'
c      endif

c---------------------------------

 2001 continue
c---------------------------------
      
c write <p p | W | p p>
      if (Is_IO_Root_RSMPI()) then
      if (exchange) then
        call       wvmat (is,ifwmat(is),nwf,
     i            rws1,rws2,irws1,irws2,nrws1,nrws2,nrws,
     i            alat,rcut1,rcut2,rw_w(:,:,:,:,:,0),cw_w(:,:,:,:,:,0), lcrpa, lomega0)
        rv_w = rw_w(:,:,:,:,:,0)
        cv_w = cw_w(:,:,:,:,:,0)
c        write(*,*) "This one!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1!"
c        write(*,*) rw_w
c        write(*,*) cw_w
c        write(*,*) rw_w(:,:,:,:,:,0)
c        write(*,*) cw_w(:,:,:,:,:,0)

      else
        call       wwmat (is,ifwmat(is),nw_i,nrw+1,nwf,
     i                    rws1,rws2,irws1,irws2,nrws1,nrws2,nrws,
     i                    alat,rcut1,rcut2,
     i                    freq_r(0:nrw),
     i                    rw_w,cw_w,rv_w,cv_w,
     i                    lcrpa, lomega0)
      endif
      endif
 2000 continue !end of spin-loop

c------------
c close files
c------------
      isx = iclose ('wc.d')
      isx = iclose ('wci.d')
      isx = iclose ('hbe.d')
      isx = iclose ('RBU')
      isx = iclose ('CBU')
      isx = iclose ('RHBU')
      isx = iclose ('CHBU')
      isx = iclose ('EVU')
      isx = iclose ('RBD')
      isx = iclose ('CBD')
      isx = iclose ('RHBD')
      isx = iclose ('CHBD')
      isx = iclose ('EVD')

c-----------------------------------------------------------------------
      call cputid(ifile_rsmpi)
      call cputid(0)
      call RSMPI_Finalize()
      if (Is_IO_Root_RSMPI()) call rx0s(' OK! hwmatK_MPI')
      end

c-----------------------------------------------------------------------
      subroutine wwmat (is,ifwmat,nw_i,nw,nwf,
     i                  rws1,rws2,irws1,irws2,nrws1,nrws2,nrws,
     i                  alat,rcut1,rcut2,
     i                  freq,
     i                  rw_w,cw_w,rv_w,cv_w,
     i                  lcrpa, lomega0)

      implicit real*8(a-h,o-z)
      implicit integer (i-n)
      integer(4) :: irws1(nrws1),irws2(nrws2)
      real(8) :: rws1(3,nrws1),rws2(3,nrws2)
      real(8) :: rydberg,hartree 
      real(8) :: freq(1:nw),freq2(1:nw)      ! iw is shifted by one
      real(8) :: rw_w(nwf,nwf,nwf,nwf,nrws,1:nw), ! iw is shifted by one
     &           cw_w(nwf,nwf,nwf,nwf,nrws,1:nw)  ! iw is shifted by one
c     &          ,rw_iw(nwf,nwf,nwf,nwf,nrws,niw),
c     &           cw_iw(nwf,nwf,nwf,nwf,nrws,niw) 
      integer:: iwf1, iwf2, iwf3, iwf4, ifreq2
      real(8) :: rv_w(nwf,nwf,nwf,nwf,nrws),cv_w(nwf,nwf,nwf,nwf,nrws)
      logical:: lcrpa, lomega0

      hartree=2d0*rydberg()
 
c      call cv      (hartree,freq,nw,freq2)
c      call cv      (hartree,rw_w,nwf*nwf*nwf*nwf*nrws*nw,rw_w)
c      call cv      (hartree,cw_w,nwf*nwf*nwf*nwf*nrws*nw,cw_w)
      freq2 = hartree*freq
      rw_w  = hartree*rw_w
      cw_w  = hartree*cw_w
      
      write(ifwmat,*)'*** nwf,nw,alat'
      write(ifwmat,*)nwf,nw,alat
      write(ifwmat,*)'*** rcut1,rcut2'
      write(ifwmat,*)rcut1,rcut2
      write(ifwmat,*)'*** nrws1,nrws2,nrws'
      write(ifwmat,*)nrws1,nrws2,nrws
      write(ifwmat,*)'*** w along the real-axis'
      write(ifwmat,*)freq2
c      write(ifwmat,*)'*** w along the imaginary-axis'
c      write(ifwmat,*)freqw
      write(ifwmat,*)'*** rws1,irws1'
      write(ifwmat,*)rws1,irws1
      write(ifwmat,*)'*** rws2,irws2'
      write(ifwmat,*)rws2,irws2
      write(ifwmat,*)'*** rw_w'
      write(ifwmat,*)rw_w
      write(ifwmat,*)'*** cw_w'
      write(ifwmat,*)cw_w
c      write(ifwmat,*)'*** rw_iw'
c      write(ifwmat,*)rw_iw
c      write(ifwmat,*)'*** cw_iw'
c      write(ifwmat,*)cw_iw


c        write(*,*) rw_w
c        write(*,*) cw_w
c        write(*,*) rw_w(:,:,:,:,:,0)
c        write(*,*) cw_w(:,:,:,:,:,0)

      write(*,*)'Writing Screened Couloumb interaction (W-v) : Real'
      ifscr = ifile_handle()

      if ((is==1) .and. (lcrpa .eqv. .false.)) then
        open(ifscr,file="Screening_W-v.UP")
      else if ((is==2) .and. (lcrpa .eqv. .false.)) then
        open(ifscr,file="Screening_W-v.DN")
      else if ((is==1) .and. (lcrpa .eqv. .true.)) then
        open(ifscr,file="Screening_W-v_crpa.UP")
      else if ((is==2) .and. (lcrpa .eqv. .true.)) then
        open(ifscr,file="Screening_W-v_crpa.DN")
      end if
      if (lomega0) then !only omega=0
         nrws1=1
         nw=1
      endif
      do ir1 = 1,nrws1
        do ifreq2 = 1,nw
          do iwf1 = 1,nwf
            do iwf2 = 1,nwf
              do iwf3 = 1, nwf
                do iwf4 = 1, nwf
                  write(ifscr,"(' Wannier ',2i5, 3f12.6, 5i5,4f12.6)")
     &                 ir1, irws1(ir1), rws1(:,ir1)
     &                ,is,iwf1,iwf2,iwf3,iwf4,freq(ifreq2), freq2(ifreq2)
     &                ,rw_w(iwf1,iwf2,iwf3,iwf4,ir1,ifreq2)
     &                ,cw_w(iwf1,iwf2,iwf3,iwf4,ir1,ifreq2)
                enddo
              enddo
            enddo
          enddo
!          write(ifscr,*)''
        enddo
      enddo
      close(ifscr)
      print *, "lcrpa, lomega0 =", lcrpa, lomega0
      print *, "lueff=", lueff
      if (lcrpa .eqv. .false.) then
        write(*,*) 'See "Screening_W-v.UP" and "Screening_W-v.DN" files'
      else if (lcrpa .eqv. .true.) then
        write(*,*) 'See "Screening_W-v_crpa.UP" and "Screening_W-v_crpa.DN" files'
      end if

      end
c-----------------------------------------------------------------------
      subroutine wvmat (is,ifwmat,nwf,
     i            rws1,rws2,irws1,irws2,nrws1,nrws2,nrws,
     i            alat,rcut1,rcut2,rw_w,cw_w,
     i            lcrpa, lomega0)

      implicit real*8(a-h,o-z)
      implicit integer (i-n)
      integer(4) :: irws1(nrws1),irws2(nrws2)
      real(8) :: rydberg,hartree 
      real(8) :: rws1(3,nrws1),rws2(3,nrws2)
      real(8) :: rw_w(nwf,nwf,nwf,nwf,nrws),cw_w(nwf,nwf,nwf,nwf,nrws)
      integer:: iwf1, iwf2, iwf3, iwf4,ir1
      logical:: lcrpa, lomega0
 
      hartree=2d0*rydberg()

c      call cv      (hartree,rw_w,nwf*nwf*nwf*nwf*nrws,rw_w)
c      call cv      (hartree,cw_w,nwf*nwf*nwf*nwf*nrws,cw_w)
      rw_w= hartree*rw_w
      cw_w= hartree*cw_w

      write(ifwmat,*)'*** nwf,alat'
      write(ifwmat,*)nwf,alat
      write(ifwmat,*)'*** rcut1,rcut2'
      write(ifwmat,*)rcut1,rcut2
      write(ifwmat,*)'*** nrws1,nrws2,nrws'
      write(ifwmat,*)nrws1,nrws2,nrws
      write(ifwmat,*)'*** rws1,irws1'
      write(ifwmat,*)rws1,irws1
      write(ifwmat,*)'*** rws2,irws2'
      write(ifwmat,*)rws2,irws2
      write(ifwmat,*)'*** vcoul: Re'
      write(ifwmat,*)rw_w
      write(ifwmat,*)'*** vcoul: Im'
      write(ifwmat,*)cw_w


      write(*,*)'Coulomb interaction (v) : '
      ifcou = ifile_handle()
      if (is==1) then
        open(ifcou,file="Coulomb_v.UP")
      else if (is==2) then
        open(ifcou,file="Coulomb_v.DN")
      end if
      if (lomega0) then !only omega=0
         nrws1=1
         nw=1
      endif
      do ir1 = 1,nrws1
        do iwf1 = 1,nwf
          do iwf2 = 1,nwf
            do iwf3 = 1, nwf
              do iwf4 = 1, nwf
                write(ifcou,"(' Wannier ',2i5, 3f12.6, 5i5,2f12.6)")
     &              ir1, irws1(ir1), rws1(:,ir1), is, iwf1, iwf2, iwf3, iwf4
     &              ,rw_w(iwf1,iwf2,iwf3,iwf4,ir1),cw_w(iwf1,iwf2,iwf3,iwf4,ir1)
              enddo
            enddo
          enddo
        enddo
        write(*,*)
      enddo
      close(ifcou)

      return
      end
c-----------------------------------------------------------------------
      subroutine chkrot ()
      use m_hamindex,only:   Readhamindex, symops, ngrp
      implicit integer (i-n)
      implicit real*8(a-h,o-z)
      integer:: ifile_handle
      parameter (eps = 1d-6)
      real(8) :: symope(3,3,ngrp)

c$$$      ifi = ifile_handle()
c$$$      open(ifi,file='SYMOPS')
c$$$      read(ifi,*)ngrp2
c$$$      if (ngrp .ne. ngrp2) stop 'chkrot: ngrp error'
c$$$
c$$$      do ig = 1,ngrp
c$$$         read(ifi,*)ig2
c$$$         do i = 1,3
c$$$            read(ifi,*)symope(i,1:3,ig)
c$$$         enddo
c$$$      enddo
c$$$
c$$$      close(ifi)
      symope=symops
      do i = 1,3
         symope(i,i,1) = symope(i,i,1) - 1d0
      enddo

      do i = 1,3
      do j = 1,3
         as = dabs(symope(i,j,1))
         if (as .gt. eps) stop 'chkrot: irot=1 error'
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
