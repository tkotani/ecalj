module m_mixrho !mixing routine of density given by smrho and orho
  use m_lmfinit,only: z_i=>z,nr_i=>nr,rmt_i=>rmt,lmxl_i=>lmxl,spec_a,rg_i=>rg,rsmv_i=>rsmv,nbas
  use m_ll,only:ll
  use m_lgunit,only:stdo,stml !  integer,parameter,public:: kmxv=15
  public:: mixrho
  private
  real(8),parameter::pi = 4d0*datan(1d0), srfpi = dsqrt(4d0*pi)
contains
  subroutine mixrho(iter, qval,  sv_p_orhnew, sv_p_orhold, smrnew, smrho,rmsdel)! Mix old and new charge densities =  Takao's version: real space mixing of smrho. It works OK. However, we may need to fix it so that this is well-defined chi=|rho-f(rho)|**2 minimization mixing.
    use m_struc_def
    use m_supot,only: iv_a_okv,rv_a_ogv,n1,n2,n3
    use m_lmfinit,only:alat=>lat_alat,nbas,stdl,ispec,nsp,broyinit,nmixinit,betainit,killj,wtinit,wc,bexist,mix_nsave
    use m_lattic,only: vol=>lat_vol
    use m_supot,only:  ng=>lat_ng,n1,n2,n3
    use m_ext,only:    sname
    use m_ftox
    implicit none
!    intent(in)::    iter,qval,   sv_p_orhnew 
!    intent(inout)::                           sv_p_orhold, smrnew, smrho,rmsdel
    !!     Warn. For Co case, I found broyden mixing works wrong.
    !!     ITER    NIT=30 MIX=B3,n=5,b=.7,w=1,0
    !!     However, as in copt, Broyden mixing is efficient.
    !! ----------------------------------------------------------------------
    ! i Inputs
    ! i iter
    ! i qval  :total valence charge, used to estimate Lindhard parameter
    ! i Read mixing parameter from m_lmfinit
    ! o   orhnew:On input, local parts of the density that generated the ham.
    ! o   orhold:Local parts of the density that the hamiltonian generated
    ! o         :On output, the mixed density
    ! o   smrho :On input, smooth density that generated the hamiltonian H
    ! o         :On output mixed smooth density
    ! o   smrnew:smooth density generated by the H(rhold,smrho) =>DESTROYED on output
    ! o Mixing parameters from m_lmfinit
    ! o         :(1)  broy  :mixing scheme: 0->Anderson 1->Broyden
    ! o         :(2)  beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
    ! o         :(3)  wc    :Broyden weights for prior iterations
    ! o         :(4,5) weights for n^+ + n^- and n^+ - n^- in spin pol cases
    ! o                Avg, diff weighted by wt(1) and wt(2) in the mixing.
    ! o                As special cases,
    ! o                wt(2)=0 freezes the moments and mixes the charge only
    ! o                wt(1)=0 freezes the charge and mixes the moments only
    ! o         :(6)  mxsav : maximum number of prior iter to save on disk
    ! o         :(7)  mmix  : maximum number of prior iter to mix
    ! o         :(8)  nkill : kill mixing file after multiples nkill
    ! o         :(9)  betv  : special potential mixing parameter
    ! o         :Outputs
    ! o         :(11) rmsdel : rms (output-input) density
    ! o         :(12) rmsl   : rms (output-input) local density
    ! o         :(13) nmix   : number of prior iter actually mixed
    ! o         :(14) broy   : actual mixing scheme used
    ! o         :(15) beta   : actual mixing beta used
    ! o         :(16-24) tj  : Anderson mixing coefficients
    ! o         :(25)        : (spin polarized case only)
    ! o                      : 1  if weight for n^+ + n^- is nonzero
    ! o                      : 10 if weight for n^+ - n^- is nonzero
    ! o                      : 11 if both nonzero

    !l Local variables
    !l   locmix=3 :2  Local densities are further mapped onto a G_kL expansion.
    !l          :   whose coefficients are included in the Anderson/Broyden
    !l          :   mixing schemes, including the nonspherical densities.
    !l          :   the residual (what is left of rho beyond the G_kL expansion)
    !l          :   is linearly mixed.
    !l              CAUTION: not tested in a long time
    !l          :3  Similar to locmix=2, but l=0 part is of the G_kL expansion
    !l          :   is projected out.
    !l          :
    !l   rms2   : <(rout-rin)**2>, where rin and rout are the input and
    !l          : screened output densities represented as a vector,
    !l          : including smoothed and local parts.  rmsdel changes with
    !l          : the choice of transformation of local densities;see locmix
    !l          : above.
    !l   rmsdel : (linked to dmxp(11)).
    !l          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
    !l          : On output, rmsdel is overwritten by rms2.
    !l   rmsuns : RMS difference in output-input sm. density, unscreened
    !l   rms    : RMS difference in output-input sm. density, screened
    !lxxx   kmxs   : k-cutoff for G_kL expansion of screening charge projected
    !lxxx          : into local densities; see Remarks
    !l   kmxr   : k-cutoff for G_kL expansion used to smooth local densities
    !l          : for mixing
    !l   ng0    : condensed number of G vectors. That rho(G) is hermitian
    !l          : is exploited to reduce ng to ng0
    !l   qcell  : cell charge

    !b Bugs
    !b   Mixing scheme needs some revision.  For now, uses locmix=3 and k9=10
    !b   Problem: G-kL expansion doesn't represent rim density well; not
    !b          : good for rho1+rho2.
    !b   Better:  1. Use simpler trans: (rho1+rho2)/100 or so, and (rho1-rho2)
    !b            2. For nonspherical parts, mix coefficient to multipole in
    !b               the Anderson/Broyden scheme; linearly mix the rest.
    !r Remarks
    !r   To estimate the self-consistent density a model (Lindhard) dielectric
    !r   function is used.  A smooth "total density" is assembled on a mesh
    !r   from the smooth density + local contributions; the latter are
    !r   smoothed into a G_kL expansion of rho1-rho2 and added to the mesh
    !r   density.  This "mesh total density" is assembled for the input and
    !r   output densities smrho and smrnew, and the screening charge
    !r   (eps^-1 - 1) (smrnew(tot) - smrho(tot)) is obtained using the
    !r   Lindhard approximation for eps^-1.  The screening charge is then:
    !r
    !r     (1)  added to smrnew
    !r
    !r     (2)  added back onto local densities as a G_kL expansion
    !r          to both the true and smooth local mixed densities.
    !r
    !r   Finally, the (screened) output density is mixed with the input density
    !r   using an Anderson or Broyden mixing scheme.  Both mesh part and local
    !r   parts are mixed, the latter consists of the true, smooth,
    !r   and core parts.
    !r   How the mixing proceeds depends on locmix; see Local variables above.
    !r
    !r   The steps in this routine follow this path (see numbers in comments)
    !r   1.   smooth rho+,rho-  ->  smrho, smmag
    !r   2.   FT smrnew(r)-smrho(r) -> cn = smrho(G)
    !r   3.   rho1-rho2 -> smoothed, FT; added to smrho(G)
    !r   4.   cn = screening (eps^-1 - 1) smrho(G)
    !r   5.   Add screening to smrnew; smrnew(G) -> smrnew(r)
    !r   6.   smrnew = sm. screened nout, smrho,smrnew -> smooth rho+,rho-
    !r        At this stage, smrho = input smooth rho+,rho-
    !r                       smrnew = screened output rho+,rho-
    !r   7.   Add screening to rho1, rho2; scale if locmix > 0
    !r   8.   smrho,smrnew(r) -> smrho,smrnew(G)
    !r   9.   Pack in,out densities into large matrix a;
    !r        Read prior iterations into a
    !r   10.  Linear mixing of local densities
    !r   11.  Make modified a when wt(1) or wt(2) restricts q or spin
    !r   12.  Mix input, output densities
    !r   13.  Inverse of step 11.
    !r   14.  Poke contents of a into smrho,orhold
    !r   15.  Undo scaling of local rho (step 7)
    !r
    !m MPI
    !m   master process handles the mix files and broadcasts. All processes then mix.
    type(s_rv1) :: sv_p_orhold(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    character sout*80,fnam*8
    character(20) :: ext
    character(26) :: datim
    character(120) :: strn
    logical::        mixrealsmooth, init=.true., initd=.true. !noelind,
    logical :: mlog!,cmdopt
    integer :: numprocs, ierr
    integer ::isp,nnnx,ng02,ng2, iprint
    integer::  iter,procid,master
    integer :: i,i1,i2,i3,ib,ipl,ipr,is,k0, lmxl,nlml,nr,nmixr,nda,ifi, &
         kkk,nnnew,nnmix,nx,nkill,isw,naa,kmxr,kmxs,locmix,offx,off2,nlmlx,ng0
    integer,save:: broy,nmix,mxsav
    real(8),save:: rmsdelsave,beta
    real(8),save:: wt(2)
    real(8):: smmin,sss,wgtsmooth,qval !elinl
    real(8) :: starttime, endtime
    real(8) :: a,beta0,dif,difx,difxu,fac,rms,rmt,summ,top,tpiba,dquns,rmsuns,ddot,q1,&
         qin(2),qout(2),qscr(2),qcell,rms2,rms2f,rsmv,qmx, rmsdel,xx
    real(8),allocatable :: rofi_rv(:),rwgt_rv(:), wn1_rv(:),wn2_rv(:),co_rv(:)
    real(8),allocatable:: w_oqkl(:), w_oa(:,:,:,:),w_oaa(:),cn_rv(:),rho1bk(:),rho2bk(:)
    complex(8):: smrnew(n1,n2,n3,nsp),smrho(n1,n2,n3,nsp)
    complex(8),allocatable :: cg1_zv(:), cg2_zv(:),fkl_zv(:)
    complex(8),allocatable:: smrnewbk(:,:,:,:),w_owk(:),cn_rvc(:),co_rvc(:)
    include "mpif.h"
    call tcn('mixrho')
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr )
    call getpr(ipr)
    master = 0
    mlog = .false. !cmdopt('--mlog',6,0,strn)
    ipl = 1
    kkk = n1*n2*n3 !    locmix = 3 !original lmv7 by mark. !    kmxs = 3
    kmxr = 8
    if(initd) then
       mxsav = mix_nsave !out 
       rmsdelsave=0d0
       beta=1d0
       initd=.false.
    endif
    rms2 = 0
    fnam = 'mixm' 
    nmix = nmixinit
    broy = broyinit
    if(bexist) beta=betainit
    nkill = max(killj,0) ! Periodic file deletion (nkill):   
    if (nkill>1 .and. mod(iter,nkill) == 0) nkill=-nkill
    if (nkill == 1) nkill=-nkill
    rmsdel = rmsdelsave
    if (nmix == 0) broy = 0
    wt(1:2)   = wtinit     
    if (nsp == 1) wt(2)=0d0
    if (sum(wt**2)==0d0) call rx('MIXRHO: bad mixing weights wt=0')
    wt= wt/sum(wt**2)**.5 !call dscal(2,1/dsqrt(wt(1)**2+wt(2)**2),wt,1)
    if (nmix < 0) nmix = mxsav
    call rhoqm(smrho, n1,n2,n3,nsp,vol,qin ) ! ... Initial charges
    call rhoqm(smrnew,n1,n2,n3,nsp,vol,qout)
    fac = vol/(n1*n2*n3)
    rms = sum((smrnew(:,:,:,:)-smrho(:,:,:,:))**2) ! RMS difference. Before 2023-10-8, it is sum of the differenc of charge (not spin density).
    rms = dsqrt(fac*rms/vol)
    !!== elind mode ==> removed
    nlmlx=maxval((lmxl_i+1)**2)
    nda=0
    do ib = 1, nbas
       is = ispec(ib) 
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       nr  =nr_i(is)
       nlml = (lmxl+1)**2
       allocate(rho1bk,source=sv_p_orhold(1,ib)%v)
       allocate(rho2bk,source=sv_p_orhold(2,ib)%v)
       sv_p_orhold(1,ib)%v=rho1bk+rho2bk
       sv_p_orhold(2,ib)%v=rho1bk-rho2bk
       !call pvmix9 ( 1,0,nr,nlml * nsp,0,0d0,rofi_rv,sv_p_orhold( 1,ib )%v     ,sv_p_orhold( 2,ib )%v )
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=rho1bk+rho2bk
       sv_p_orhnew(2,ib)%v=rho1bk-rho2bk
       !call pvmix9 ( 1,0,nr,nlml * nsp,0,0d0,rofi_rv,sv_p_orhnew( 1,ib )%v     ,sv_p_orhnew( 2,ib )%v )
       deallocate(rho1bk,rho2bk) !,rofi_rv)
       nda = nda + 2*(kmxr+1)*(lmxl+1)**2 + 2*nr_i(is) ! include spherical part of local densities and non-spherical part of rho1-rho2
    enddo      
    ! if(mixrealsmooth()) then
    ng02 = n1*n2*n3
    ng2 = ng02
    nda = nda + ng02
    allocate(cn_rv(ng02*nsp),co_rv(ng02*nsp))
    call dcopy(ng02*nsp,dreal(smrnew), 1, cn_rv,1)
    call dcopy(ng02*nsp,dreal(smrho),  1, co_rv,1)
    wgtsmooth=1d0/ng02**0.5d0 !try this relative weight. Not correct weight charge mixing.
    if(iprint()>10) print *,'wgtsmooth=',wgtsmooth
    cn_rv= cn_rv*wgtsmooth !
    co_rv= co_rv*wgtsmooth !
    allocate(w_oa(nda,nsp,(mxsav+2),2),source=0d0)
    allocate(w_oqkl(2*(kmxr+1)*nlmlx*nsp*4*nbas))
    w_oqkl=0d0
    ! --- 9. Read prior iterations from disk; update with current iter ---
    if (procid==master) open(newunit=ifi,file=trim(fnam)//'.'//trim(sname),form='unformatted')
    call pvmix5 ( nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx, nsp,sv_p_orhold &
        ,sv_p_orhnew,co_rv,cn_rv,ng2,ng02,nda,w_oa,w_oqkl,rms2,nmixr )
    rmsdel = rms2
    nmix = min(nmix,nmixr)
    WriteThisANDPriorIterationsONTOdisk:block
      integer:: j
      if (procid==master) then
         rewind(ifi)
         write(ifi) min(nmix+1,mxsav), nda*nsp
         do  j = 1, min(nmix+1,mxsav)
            write(ifi)w_oa(:,:,j,1)
            write(ifi)w_oa(:,:,j,2)
         enddo
      endif
    endblock WriteThisANDPriorIterationsONTOdisk
    if (nkill < 0) then
       if(ipr>=20) then
          sout = ' ...  deleting file '//fnam
          write(stdo,"(a,i5)") trim(sout)//" nkill=",nkill
       endif
       if(procid==master) close(ifi,status='delete')
    else
       if(procid==master) close(ifi)
    endif
    call rhoqm(smrnew,n1,n2,n3,nsp,vol,qscr)
    if(ipr >45) then
       write(stdo,"(' charges:',7x,'old',11x,'new',9x,'screened',6x,'rms diff',7x,'lin mix'/' smooth ',5f14.6)")&
            qin(1),qout(1),qscr(1),rms,beta*qscr(1)+(1-beta)*qin(1)
       if(nsp == 2) write(stdo,"(' mmom   ',2f14.6,28x,f14.6)") qin(2),qout(2),beta*qscr(2)+(1-beta)*qin(2)
    endif
    ! --- 10. Linear mixing of local densities  ---
    call pvmix3 ( nbas,nsp,beta,wt ,kmxr,nlmlx,w_oqkl,sv_p_orhold,sv_p_orhnew,difx )
    difxu = difx
    !!== Main Mixing part ==
    !!=== 11. Spin polarized case: separate weighting for spin channels ===
    if (nsp == 2) then ! .OR. nx > 0) then
       naa = 0
       if (wt(1) /= 0) naa = naa+nda
       if (wt(2) /= 0) naa = naa+nda
       offx = 0                !offset to extra elements (none now)
       off2 = (nsp-1)*nda      !offset to spin down part of a
       allocate(w_oaa(naa*(mxsav+2)*2),source=0d0)
       call pqsclf(nda*nsp,nda,offx,off2,naa,mxsav,wt, w_oa,w_oaa,rms2f)
       if (wt(1)*wt(2) ==0d0 ) then
          write(stdo,ftox)' Constrained spin mixing wt =',ftof(wt),' Constrained rms DQ=',ftod(rms2f)
          rmsdel = rms2f
       endif
       !!=== 12. Mix the soup of densities ===
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oaa)
       !!=== 13. Restore matrix a to rho+, rho===
       call pqsclb(nda*nsp,nda,offx,off2,naa,mxsav,wt,w_oa,w_oaa)
        w_oa(:,:,1,1)=w_oa(:,:,1,2) 
       deallocate(w_oaa)
    else
       naa = nda
       !!=== 12. Mix the soup of densities ===
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oa)
    endif
    ! ... 14. Poke mixed smooth and local densities into smrho,rhoold
!    write(6,*) 'sssssssss111',sum(smrho)
    call pvmix7(nbas,nsp,nda,w_oa,n1,n2,n3,wt,kmxr,nlmlx,w_oqkl,ng,ng2, ng02,iv_a_okv,rv_a_ogv,co_rv,sv_p_orhold,smrho, wgtsmooth )
!    write(6,*) 'sssssssss222',sum(smrho)
    deallocate(w_oqkl,w_oa,co_rv,cn_rv)
    
    qmx=0d0
    do ib = 1, nbas ! ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-'
       is = ispec(ib)
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       allocate(rho1bk,source=sv_p_orhold(1,ib)%v)
       allocate(rho2bk,source=sv_p_orhold(2,ib)%v)
       sv_p_orhold(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orhold(2,ib)%v=.5d0*(rho1bk-rho2bk) !    call pvmix9 ( 1,- 1,nr,nlml * nsp,0,0d0,rofi_rv,     sv_p_orhold( 1,ib )%v,sv_p_orhold( 2,ib )%v )
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orhnew(2,ib)%v=.5d0*(rho1bk-rho2bk)  !    call pvmix9 ( 1,- 1,nr,nlml * nsp,0,0d0,rofi_rv,     sv_p_orhnew( 1,ib )%v,sv_p_orhnew( 2,ib )%v )
       deallocate(rho1bk,rho2bk)
       nlml = (lmxl+1)**2
       nr=nr_i(is)
       allocate(rwgt_rv(nr))
       call radwgt( rmt_i(is),spec_a(is),nr,rwgt_rv)
       do i = 1, nsp !  Net local site charge q1-q2
          off2 = 1 + nr*nlml*(i-1)
          associate(rho1s=> sv_p_orhold(1,ib)%v(off2:off2+nr-1),& 
               rho2s=> sv_p_orhold(2,ib)%v(off2:off2+nr-1)) 
            qmx = qmx+srfpi*sum((rho1s-rho2s)*rwgt_rv)
          endassociate
       enddo
       deallocate(rwgt_rv)
    enddo      
    summ = sum(smrho) ! ... Net interstitial charge and cell charge
    qcell= qval - summ*fac - qmx !     Net system charge
    xx = qcell/(vol*nsp)
    if(iprint()>10) write(6,"(a,4d13.5)")' mixrho: add corrections to qcell smrho =',qcell,xx,qmx,summ
    smrho=smrho+xx ! Add constant to smrho to force charge neutrality
    rmsdelsave = rmsdel
    if(ipr>=10 .AND. abs(qcell) > 1d-6) write(stdo,'('' add q='',f10.6,'' to preserve neutrality'')') qcell
    nnnx=count(dreal(smrho)<0d0)
    smmin=minval(dreal(smrho))
    if(nnnx>0 ) write(6,"(a,i8,d13.5)") ' mixrho: warning. negative smrho; isp number min=',nnnx,smmin
    if(nnnx<=0) write(6,"(a)") ' mixrho: all smrho are positive'
    ! ... old code call rhopos(smrho,n1,n2,n3,n1,n2,n3) to enforce density positive
    call tcx('mixrho')
  end subroutine mixrho




  
  subroutine pvmix3 ( nbas,nsp,beta,wt,kmxr,nlmlx,qkl,sv_p_orhold,sv_p_orhnew,difx  )
    use m_struc_def  
    use m_lmfinit,only: ispec
    !- Linearly mix local densities, possibly subtracting G_kL expansion
    !i   beta  :linear mixing parameter
    !l Local variables
    !l   locmix :governs linear transformation of local densities for mixing
    !l          :see description in Local variables, routine mixrho.
    !i   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
    !i   nlmlx   :second dimension of qkl
    !i   qkl    :(locmix>=2) G_kL expansion of local densities
    !i          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !i          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !i          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !i          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    ! o Inputs/Outputs
    ! o  orhold :On input, local densities generating hamiltonian
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhold).
    ! o         :On output, w(orhold) is overwritten by the linear
    ! o         :combination (1-beta)*w(orhold) + beta*w(orhnew)
    ! o  orhnew :On input, local densities gen. by ham. (maybe screened)
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhnew).
    !o Outputs
    !o   difx   :maximum rms difference in rhonew-rhoold
    implicit none
    integer :: nbas,nsp,kmxr,nlmlx,locmix
    type(s_rv1) :: sv_p_orhold(3,nbas)
    type(s_rv1) :: sv_p_orhnew(3,nbas)
    real(8):: difx,beta,wt(2),qkl(0:kmxr,nlmlx,nsp,4,nbas)
    integer :: ib,is,igetss,nr,nlml,m,lmxl,ir,mode4
    real(8) ,allocatable :: ri_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    real(8) :: a,rmt,rg,difa,rf
    real(8),allocatable:: w_orsm(:,:,:,:)
    difx  = 0
    do  ib = 1, nbas
       is = ispec(ib)
       lmxl = int(lmxl_i(is))
       if (lmxl == -1) cycle
       a=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       rg=rg_i(is)
       nlml = (lmxl+1)**2
       allocate(ri_rv(nr),rwgt_rv(nr),w_orsm(nr,nlml,nsp,4))
       call radmsh( rmt,a,nr,ri_rv)
       call radwgt( rmt,a,nr,rwgt_rv)
       rf = rmt/3
       do m=1,4
          call pkl2ro (mode4,rg,kmxr,nr,nlml,nsp,ri_rv,rwgt_rv,nlmlx,qkl(0,1,1,m,ib), w_orsm(:,:,:,m))
       enddo
!       call pvmix9( 0,-1,nr,nlml * nsp,0,rf,ri_rv      ,w_orsm(:,:,:,1),w_orsm(:,:,:,2))
!       call pvmix9( 0,-1,nr,nlml * nsp,0,rf,ri_rv      ,w_orsm(:,:,:,3),w_orsm(:,:,:,4))
       forall(ir=1:nr) w_orsm(ir,:,:,1)=w_orsm(ir,:,:,1)* exp((ri_rv(ir)/rf)**2) !scale up orsm
       forall(ir=1:nr) w_orsm(ir,:,:,3)=w_orsm(ir,:,:,3)* exp((ri_rv(ir)/rf)**2)
       associate( rhos1=>w_orsm(:,:,:,1),rhos2=>w_orsm(:,:,:,2),rhns1=>w_orsm(:,:,:,3),rhns2=>w_orsm(:,:,:,4),&
            rho1=>sv_p_orhold(1,ib)%v, rho2=>sv_p_orhold(2,ib)%v, rho3=>sv_p_orhold(3,ib)%v, &
            rhn1=>sv_p_orhnew(1,ib)%v, rhn2=>sv_p_orhnew(2,ib)%v, rhn3=>sv_p_orhnew(3,ib)%v)
         rho1=(1-beta)*rho1 +beta*rhn1 -reshape((1-beta)*rhos1+beta*rhns1 ,shape(rho1))
         rho2=(1-beta)*rho2 +beta*rhn2 -reshape((1-beta)*rhos2+beta*rhns2 ,shape(rho2))
         rho3=(1-beta)*rho3 +beta*rhn3
       endassociate
!       difx  = dmax1(difx,difa)
       deallocate(rwgt_rv,ri_rv,w_orsm)
    enddo
  end subroutine pvmix3
  subroutine pvmix5(nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx,nsp,sv_p_orhold & !- Copy rho into holding array, read prior iterations from disk
      ,sv_p_orhnew,co,cn,ng2,ng02,nda, a,qkl,rms2 ,nmixr )
    use m_lmfinit,only:ispec
    use m_struc_def
    use m_ftox
    !i   nmix  :number of prior iterations sought (for printout)
    !i   mxsav :max no. prior iteration to read, also dimensions a
    !i   fnam  :file name (for printout)
    !i   ifi  :file logical unit
    !i  rmsdel :Same as rms2 (see Outputs), from prior iteration.
    !i         :If no prior iteration, rsmdel=0.  For printout only.
    !i  locmix=3 :switch governing linear transformation of local densities
    !i          for mixing; see Local variables in subroutine mixrho.
    !i  nbas   :size of basis
    !i   nsp   :2 for spin-polarized case, otherwise 1
    !i   orhold:input local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   orhnew:output local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   co    :input smooth density this iteration, in FT form
    !i   cn    :output smooth density this iteration, in FT form
    !i   ng    :leading dimension of co,cn
    !i   ng0   :number of Fourier coefficients
    !xxxx    ng02=ng0*2 in the mixrealsmooth()=F (original case)
    !o Inputs/Outputs
    ! o  nmixr :(output for ifi>0) number of prior iter read from file
    ! o        :on output number of prior iterations read from file
    ! o  a,nda :work array a and leading dimension (nda must be >= na)
    ! o         a(*,i,1) holds f(xi) for iteration i-1
    ! o         a(*,i,2) holds   xi  for iteration i-1
    !o Outputs
    !o  qkl    :(locmix>=2) G_kL expansion of local densities
    !o         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !o         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !o         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !o         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    !o  rms2   :rms difference in f-x, where f=output density and x the
    !o          input density.  f and x include smoothed and local
    !o          contributions, with the latter depending on choice of
    !o          linear transformation; see locmix above.  Thus, there
    !o          is some arbitrariness in rms2.
    !r Remarks
    !r   Content of a(*) = a(*,isp,:,:):
    !r   Case locmix = 3
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
    !r     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
    !r                                             w/ l=0 part zeroed out
    !r     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
    implicit none
    include "mpif.h"
    integer :: procid, master, numprocs, ierr
    character(20) :: ext
    character(26) :: datim
    real(8) :: starttime, endtime
    character(120) :: strn
    logical :: mlog!,cmdopt
    logical :: readerror!,lddump
    integer :: ng2,ng02,nda,nmix,mxsav,ifi,nbas,nr,nsp,kmxr,nlmlx
    type(s_rv1) :: sv_p_orhold(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    real(8):: a(nda,nsp,mxsav+2,2),rms2,rmsdel
    real(8):: co(ng2,nsp),cn(ng2,nsp),qkl(0:kmxr,nlmlx,nsp,4,1)
    character fnam*8
    integer :: ib,na,i,j,k,m,np,iprint,nmixr,is,igetss, off,nlml,lmxl 
    real(8) ,allocatable :: rofi_rv(:)
    real(8) :: ddot,rmt,aat,rf
    character outs*80
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr)
    master = 0
    mlog=.false.
    a(1:ng02,1:nsp,1,2)=co(1:ng02,1:nsp)
    a(1:ng02,1:nsp,1,1)=cn(1:ng02,1:nsp)
    na = 1 + ng02
    do ib = 1, nbas !   ... Site densities, depending on locmix
       is = ispec(ib)
       lmxl=lmxl_i(is)
       if (lmxl == -1) cycle
       nr = nr_i(is)
       rmt=rmt_i(is)
       rf = rmt/3
       nlml = (lmxl+1)**2
       allocate(rofi_rv(nr))
       call radmsh ( rmt,spec_a(is),nr,rofi_rv)
       call pvmix9 ( 0,0,nr,nlml * nsp,0,rf,rofi_rv, sv_p_orhold( 1,ib )%v,sv_p_orhold( 2,ib )%v ) !   copy spherical part of local rho to a
       call pvmix9 ( 0,0,nr,nlml * nsp,0,rf,rofi_rv, sv_p_orhnew( 1,ib )%v,sv_p_orhnew( 2,ib )%v )
       do  i = 1, nsp
          off = 1+nr*nlml*(i-1)
          call dpscop ( sv_p_orhold( 1,ib )%v,a ( na + 00,i,1,2 ),nr,off,1,1d0 )
          call dpscop ( sv_p_orhold( 2,ib )%v,a ( na + nr,i,1,2 ),nr,off,1,1d0 )
          call dpscop ( sv_p_orhnew( 1,ib )%v,a ( na + 00,i,1,1 ),nr,off,1,1d0 )
          call dpscop ( sv_p_orhnew( 2,ib )%v,a ( na + nr,i,1,1 ),nr,off,1,1d0 )
       enddo
       do  i = 1, nsp
          call pshpr(iprint()-30)
          call rhogkl ( ib,i,2,sv_p_orhold,  kmxr,qkl ( 0,1,i,1,ib ) )
          call rhogkl ( ib,i,3,sv_p_orhold,  kmxr,qkl ( 0,1,i,2,ib ) )
          call rhogkl ( ib,i,2,sv_p_orhnew,  kmxr,qkl ( 0,1,i,3,ib ) )
          call rhogkl ( ib,i,3,sv_p_orhnew,  kmxr,qkl ( 0,1,i,4,ib ) )
          call poppr
          !           Convert qkl for 2nd spin channel into 2nd channel only, since rhogkl makes expansion combining channels 1+2
          if (i == 2) qkl(:,:,2,:,ib)= qkl(:,:,2,:,ib) - qkl(:,:,1,:,ib) 
          qkl(0:kmxr,1,i,1:4,ib)=0d0 !           locmix=3 : zero out spherical part of G_kL
          na = na + 2*nr
          np = (1+kmxr)*nlml
          call dpscop(qkl(0,1,i,1,ib),a(na+00,i,1,2),np,1,1,1d0)
          call dpscop(qkl(0,1,i,2,ib),a(na+np,i,1,2),np,1,1,1d0)
          call dpscop(qkl(0,1,i,3,ib),a(na+00,i,1,1),np,1,1,1d0)
          call dpscop(qkl(0,1,i,4,ib),a(na+np,i,1,1),np,1,1,1d0)
          if (i < nsp) na = na - 2*nr            !           locmix=3, : undo increment unless final spin
       enddo     
       call pvmix9 ( 0,- 1,nr,nlml * nsp,0,rf,rofi_rv,sv_p_orhold( 1,ib )%v,sv_p_orhold( 2,ib )%v )
       call pvmix9 ( 0,- 1,nr,nlml * nsp,0,rf,rofi_rv,sv_p_orhnew( 1,ib )%v,sv_p_orhnew( 2,ib )%v )
       na = na + 2*np
       if (allocated(rofi_rv)) deallocate(rofi_rv)
    enddo                     !Loop over sites
    na = na-1
    if(nda /= na) call rx('mixrho: bug in pvmix5')
    na = nda*nsp
!    rms2 = dsqrt(dabs(ddot(na,a,1,a,1)   - 2*ddot(na,a,1,a(1,1,1,2),1) + ddot(na,a(1,1,1,2),1,a(1,1,1,2),1))/(na-0))*nsp
    rms2 = (sum((a(:,:,1,1)-a(:,:,1,2))**2)/(nda*nsp))**.5*nsp ! *nsp is right?
    if (mxsav == 0) return
    nmixr = 0
    readerror = .true.
    if (procid == master) then
       readerror = .false.
       read (ifi,err=311,end=311) nmixr, na !   ... File I/O of previous iterations; nmixr is number actually read
       goto 312
311    continue
       readerror = .true.
312    continue
    endif
    call MPI_BCAST(readerror,1,MPI_LOGICAL,   master,MPI_COMM_WORLD,ierr)
    if(readerror) goto 9999
    call MPI_BCAST(na,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
!    if (nda*nsp /= na) then
!       if (procid == master) write(stdo,ftox)' mixrho:  expecting',nda*nsp,'elements but found',na,'discarding file'
!       goto 9999
!    endif
    if (procid == master) then
       readerror = .false.
       do  30  j = 1,  min(mxsav,nmixr)
          read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,1)
          read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,2)
          nmixr = j
          cycle
90        continue
          write(stdo,ftox) 'pvmix5: reading only nmixr=',nmixr
          exit
30     enddo
    endif
313 continue
    call MPI_BCAST(nmixr,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
    if(nmixr > 0) call MPI_BCAST(a,nda*nsp*(mxsav+2)*2,MPI_DOUBLE_PRECISION, master,MPI_COMM_WORLD,ierr)
31  continue
9999 continue
    if (iprint() >= 20) then !this is needed for test
       write(stdo,fmt=ftox, advance='no')' mixrho: sought',nmix,'iter from file '//trim(fnam)
       write(stdo,fmt='("; read ",g0," RMS DQ=",es8.2e1)',advance='no') nmixr, rms2
       if (rmsdel/= 0) write(stdo,"('  last it=',es8.2e1)",advance='no')rmsdel
       write(stdo,*)
    endif
  end subroutine pvmix5
  subroutine pvmix6(broy,nmix,mmix,mxsav,beta,wc,nda,a)!- Mixing of the total density
    use m_amix,only: amix
    !i  broy   : 0 for Anderson mixing
    !i         : 1 for Broyden mixing
    !i  nmix   : nmix: number of iter to try and mix
    !i  mmix   : number of iterates available to mix
    !i  mxsav  : second dimension of a
    ! o Inputs/Outputs
    ! o  a     :On input:
    ! o         (*,i,1)  output vector for prev. iteration i
    ! o         (*,i,2)  input  vector for prev. iteration i
    ! o        :On output:
    ! o         (*,0,1) and (*,0,2) estimated new vector
    ! o         (*,i,1), i>1 destroyed
    !r  Remarks
    !r    Broyden mixing adapted from Duane Johnson.  Notation:
    !r    x^(m): input vector for iteration m
    !r    F^(m): difference between output and input vector in iteration m
    ! ------------------------------------------------------------------
    !     implicit none
    integer :: nda,nmix,mmix,mxsav,broy
    real(8) :: beta,a(nda,0:mxsav+1,2)
    integer :: j,iprint!,amix
    real(8) :: tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
    parameter (tjmax = 5d0)
    ! ... This is the result of linear mixing, q=0 smooth rho      sqmix = a(1,0,1)*beta + a(1,0,2)*(1-beta)
    real(8),allocatable:: aaa(:)
    !$$$ccccccccccccccccccccccccccccccccccccccccc
    !$$$c takao simple mixing test
    !$$$      print *,' vvv: takao simple mixing test'
    !$$$      allocate(aaa(nda))
    !$$$c      aaa = .2d0*a(:,0,1)+.8d0*a(:,0,2)
    !$$$c      aaa = .40d0*a(:,0,1)+.6d0*a(:,0,2)
    !$$$c      aaa = .9d0*a(:,0,1)+.1d0*a(:,0,2)
    !$$$      aaa = 1.d0*a(:,0,1)+.0d0*a(:,0,2)
    !$$$c       aaa = .5d0*a(:,0,1)+.5d0*a(:,0,2)
    !$$$c      aaa = .8d0*a(:,0,1)+.2d0*a(:,0,2)
    !$$$      call dcopy(nda,aaa,1,a(1,0,1),1)
    !$$$      call dcopy(nda,aaa,1,a(1,0,2),1)
    !$$$      deallocate(aaa)
    !$$$      return
    !$$$cccccccccccccccccccccccccccccccccccccccccc
    if (nmix == 0 .OR. nmix == 1 .OR. broy == 0) then
       ! ... amix needs f-x for prior iterations
       do  j = 1, nmix
          call daxpy(nda,-1d0,a(1,j,2),1,a(1,j,1),1)
       enddo
       nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,a,tj,  rms2) ! --- Anderson mixing ---
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
    elseif (broy == 1) then 
       call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) ! --- Broyden mixing, Duane Johnson's approach ---
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
    else
       call rx('pvmix6: bad value for broy')
    endif
  end subroutine pvmix6
  subroutine pvmix7 ( nbas,nsp,nda,a,n1,n2,n3,wt,kmxr,nlmlx,qkl,ng,ng2, ng02,kv,gv,crho,sv_p_orhold,smrho,wgtsmooth)
    use m_lmfinit,only: ispec
    use m_struc_def 
    !i   nda   :leading dimension of a
    !i   a     :mixed density from pvmix6, smoothed + local densities
    !i         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
    !i         :locmix = 3, a contains spherical part on mesh a full rho, GkL expansion
    !i   n1..3 :FT mesh
    !i   n1..3 :dimensions smrho
    !i   ng    :number of FT G-vectors
    !i   ng0   :condensed number of G vector (excluding hermitian equiv)
    !i   kv    :indices for gather/scatter operations (gvlist.f)
    !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
    !i   crho  :FT coefficients of smrho(G)
    !i   wk    :complex work array of dimension (n1,n2,n3)
    !i   smrho :smooth density that generated the hamiltonian
    !i   orhold:local  density that generated the hamiltonian,
    !i         :a portion of which which has been linearly mixed (pvmix4)
    !i         :orhold(1) contains rho1+rho2;
    !i         :orhold(2) contains rho1-rho2; see pvmix9
    !o Outputs
    !o   smrho :overwritten by mixed smooth density
    !o   orhold:mixed local density is returned, in rho1+rho2,rho10rho2 form
    implicit none
    integer :: nsp,n1,n2,n3,ng,ng02,nda,na,nr,nbas, kv(ng,3),kmxr,nlmlx,ng2
    type(s_rv1) :: sv_p_orhold(3,1)
    real(8):: gv(ng,3),a(nda,nsp),qkl(0:kmxr,nlmlx,nsp,4,nbas),rf,wt(2), wgtsmooth
    complex(8):: smrho(n1,n2,n3,nsp),wk(n1,n2,n3)
    real(8):: crho(ng2,nsp)
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    integer :: ib,is,mode4,m,lmxl,nlml,off,np,orsm(2),i,ir
    real(8) :: aat,rmt,rg,xx
    real(8),allocatable:: w_orsm(:,:,:,:)
!    logical:: mixrealsmooth=T
    do  i = 1, nsp
       call dscal(ng02,-1d0/wgtsmooth,crho(1,i),1)
       call daxpy(ng02,1d0/wgtsmooth,a(1,i),1,crho(1,i),1)
       call daxpy(n1*n2*n3,1d0,crho(1,i),1,smrho(1,1,1,i),2)
    enddo
    na = 1 + ng02
    do  ib = 1, nbas
       is = ispec(ib)
       aat=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       lmxl=lmxl_i(is)
       if (lmxl == -1) cycle
       rf = rmt/3
       rg = rg_i(is)
       nlml = (lmxl+1)**2
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh ( rmt,aat,nr,rofi_rv)
       call radwgt ( rmt,aat,nr,rwgt_rv)
       
       !       Scale rho1+rho2 to match scaled spherical parts and sm parts
!       call pvmix9 ( 0,0,nr,nlml * nsp,0,rf,rofi_rv,       sv_p_orhold( 1,ib )%v,sv_p_orhold( 2,ib )%v ) !scale down
       
       !       Overwrite sph. rhold with scaled mixed rho; do not unscale
       do  i = 1, nsp
          off = 1+nr*nlml*(i-1)
          sv_p_orhold(1,ib)%v(off:off+nr-1)= a(na:   na+nr-1,  i )* exp((rofi_rv(:)/rf)**2) !scale up
          sv_p_orhold(2,ib)%v(off:off+nr-1)= a(na+nr:na+2*nr-1,i )!* exp((rofi_rv(:)/rf)**2)
!          call dpscop ( a( na + 00,i ), sv_p_orhold( 1,ib )%v,nr               ,1,off,1d0 ) !a is scale downed ???
!          call dpscop ( a( na + nr,i ), sv_p_orhold( 2,ib )%v,nr               ,1,off,1d0 )
       enddo
       na = na + 2*nr
       !   ... Mixing mode 2,3: add mixed sm density to existing rhold
       np = (1+kmxr)*nlml
       allocate(w_orsm(nr,nlml,nsp,2))
       do  m = 1, 2
          do  i = 1, nsp
             call dpscop(a(na+np*(m-1),i),qkl(0,1,i,m,ib),np,1,1,1d0)
          enddo
          call pkl2ro ( mode4,rg,kmxr,nr,nlml,nsp,rofi_rv,rwgt_rv,nlmlx,qkl ( 0,1,1,m,ib ),w_orsm(:,:,:,m))
          if(m==1) forall(ir=1:nr) w_orsm(ir,:,:,m)=w_orsm(ir,:,:,m)* exp((rofi_rv(ir)/rf)**2) !scale up
       enddo
       sv_p_orhold(1,ib)%v = sv_p_orhold(1,ib)%v + reshape(w_orsm(:,:,:,1),shape(sv_p_orhold(1,ib)%v)) 
       sv_p_orhold(2,ib)%v = sv_p_orhold(2,ib)%v + reshape(w_orsm(:,:,:,2),shape(sv_p_orhold(2,ib)%v))
!       call daxpy ( nr * nlml * nsp,1d0,w_orsm ( :,:,:,1 ),1,sv_p_orhold( 1,ib )%v ,1 )
!       call daxpy ( nr * nlml * nsp,1d0,w_orsm ( :,:,:,2 ),1,sv_p_orhold( 2,ib )%v ,1 )
       deallocate(w_orsm)
       na = na + 2*np
!       call pvmix9 ( 0,- 1,nr,nlml * nsp,0,rf,rofi_rv  ,sv_p_orhold( 1,ib )%v,sv_p_orhold( 2,ib )%v ) !scale up
       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(rofi_rv)) deallocate(rofi_rv)
    enddo                     !Loop over sites
    na = na-1
    if (nda /= na) call rx('mixrho: bug in pvmix7')
  end subroutine pvmix7
  subroutine pvmix9(mode,linv,nr,nlml,off,rf,rofi,rho1,rho2)    !- Transformation of local densities rho1,rho2 for mixing
    integer :: mode,nr,nlml,linv,off
    real(8) :: rho1(nr,nlml),rho2(nr,nlml),rofi(nr),rf,rho1old(nr,nlml),rho2old(nr,nlml)
    integer :: i,ilm,mode0,mode1
    if(linv== 0) forall(i = 1:nr) rho1(i+off,:) = rho1(i+off,:) * exp(-(rofi(i)/rf)**2)
    if(linv==-1) forall(i = 1:nr) rho1(i+off,:) = rho1(i+off,:) * exp((rofi(i)/rf)**2)
  end subroutine pvmix9
  subroutine pqsclf(nda,npq,offx,off2,na,mxsav,wt,a,a2,rms2)    !- Split into (a+ + a-) and (a+ - a-); include extra data
    !i Inputs
    !i   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
    !i   nda   :leading dimension of a
    !i   npq   :number of elements to spin-split with wt(1),wt(2)
    !i   offx  :(nx>0)offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimension of a2 and number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a     :(na,1:2,i,1) output vector for prev. iteration i
    !i         :(na,1:2,i,2) input  vector for prev. iteration i
    !o Outputs
    !o   a2    :(*,i,1) output charge and moments, scaled by weights
    !o         :(*,i,2) input  charge and moments, scaled by weights
    !o   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
    !r Remarks
    !r   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
    !r   If wt(1) or wt(2) is zero, a2 holds q or mom only.
    !r   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
    ! ------------------------------------------------------------------
    !     implicit none
    integer :: mode,nda,npq,mxsav,na,offx,off2
    real(8) :: wt(2),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2), rms2,ddot
    integer :: is,ia,ja
    ja = 0
    if (wt(1) == 0 .AND. wt(2) == 0) goto 11
    do  10  is = 0, mxsav+1
       ja = 0
       do  12  ia = 1, npq
          if (wt(1) /= 0) then
             ja = ja+1
             !           Given (rhnew+ + rhnew-)*wt(1), (rhold+ + rhold-)*wt(1)
             a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
             a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          elseif (wt(1) /= 0) then
             ja = ja+1
             a2(ja,is,1) = a(ia,is,1)*wt(1)
             a2(ja,is,2) = a(ia,is,2)*wt(1)
          endif
          if (wt(2) /= 0) then
             ja = ja+1
             !           Given (rhnew+ - rhnew-)*wt(2), (rhold+ - rhold-)*wt(2)
             a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
             a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          elseif (wt(2) /= 0) then
             ja = ja+1
             a2(ja,is,1) = a(ia+off2,is,1)*wt(2)
             a2(ja,is,2) = a(ia+off2,is,2)*wt(2)
          endif
12     enddo
10  enddo
11  continue
    rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1) - 2*ddot(na,a2,1,a2(1,0,2),1) + ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))
    if (ja /= na) call rx('pqsclf: element mismatch')
  end subroutine pqsclf
  subroutine pqsclb(nda,npq,offx,off2,na,mxsav,wt,a,a2)    !- Undo split into wt1*q and wt2*mom done by pqsclf
    !i   nda   :leading dimension of a
    !i   npq   :number of P,Q
    !i   offx  :offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimensions a2; number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
    !o Outputs
    !o   a     :a2 is unscaled and restored into a
    !     implicit none
    integer :: nda,na,npq,mxsav,offx,off2
    real(8) :: wt(2),a(nda,0:mxsav+1,2), &
         a2(na,0:mxsav+1,2),sum,diff
    integer :: is,ia,ja
    if (wt(1) == 0 .AND. wt(2) == 0) then
       ja = 0
    elseif (wt(1) /= 0 .AND. wt(2) /= 0) then
       do  is = 0, mxsav+1
          ja = 1
          do  ia = 1, npq
             a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
             a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2
             !         mixed  rhonew-,rhold-
             a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
             a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
             ja = ja+2
          enddo
       enddo
       ja = 2*npq
    elseif (wt(1) /= 0) then
       diff = 0
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+off2
             sum  = a2(ia,is,1)/wt(1)
             diff = (a(ia,is,1) - a(ja,is,1))
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             sum  = a2(ia,is,2)/wt(1)
             diff = (a(ia,is,2) - a(ja,is,2))
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    elseif (wt(2) /= 0) then
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+npq
             !         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
             sum  = (a(ia,is,1) + a(ja,is,1))
             diff = a2(ia,is,1)/wt(2)
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             !         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
             sum  = (a(ia,is,2) + a(ja,is,2))
             diff = a2(ia,is,2)/wt(2)
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    endif
  end subroutine pqsclb
  subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) !Broyden mixing of a vector, Duane Johnson's approach
    use m_ftox
    !i  mmix: number of iterates available to mix
    !i  a:    (*,i,1)  output values for prev. iteration i
    !i        (*,i,2)  input  values for prev. iteration i
    ! o nmix: nmix > 0: number of iter to try and mix    nmix < 0: use mmix instead of nmix.
    !o  nmix: (abs)  number of iter actually mixed.  (sign) <0, intended that caller update nmix for next call.
    !r  x^(m): input vector for iteration m
    !r  F^(m): difference between output and input vector in iteration m
    implicit none
    integer :: nda,nmix,mmix,mxsav,im,km,i,iprint,i1mach,imix,jmix
    real(8) :: beta,rms2,wctrue,a(nda,0:mxsav+1,2), ddot,dval,wc
    real(8) :: xmp1_rv(nda), f_rv(nda), ui_rv(nda), vti_rv(nda), xold_rv(nda), df_rv(nda), dx_rv(nda)
    real(8),allocatable:: wk_rv(:)
    imix = merge(mmix,nmix, nmix < 0) !imix is a local copy of nmix
    do while (im/=imix) ! --- Starting from iteration mmix, build the Jacobian matrix ---
       jmix = min(mmix,iabs(imix))
       do km = 1, jmix
          im = jmix-km+1
          call dcopy ( nda,a ( 1,im - 1,1 ),1,dx_rv,1 )
          call daxpy ( nda,- 1d0,a ( 1,im - 1,2 ),1,dx_rv  ,1 )
          rms2 = dsqrt ( ddot ( nda,dx_rv,1,dx_rv,1 ) / ( nda - 0 ) )
          ! ---   Determine wc_true if wc < 0 ---
          if (wc < 0) then
             wctrue = -wc/100/dsqrt(nda*rms2**2)
             wctrue = min(max(wctrue,1d0),1d4)
          else
             wctrue = wc
          endif
          if (km == 1) wctrue = .01d0
          i = iprint()
          if (km /= jmix) i = i-20
          allocate(wk_rv(nda*2*(jmix+2)))
          i = broyj ( nda,a(1,im-1,2),dx_rv,km, i,beta,0d0,0d0,0d0,wctrue,wk_rv,nda,xmp1_rv )
          deallocate(wk_rv)
       enddo
       ! --- Check for interactive change of nmix ---   ! NB negative sign signals request for permanent change in nmix
       im = imix
       if(iabs(imix) > mmix .AND. imix /= im) write(stdo,ftox)' (warning) only ',mmix,' iter available'
       !    if(im /= imix) goto 1
    enddo
    nmix = imix
    if(nmix == 0 ) return
    if(iprint() > 60 .OR. (iprint() >= 40 .AND. nda <= 100)) then
       write(stdo,"(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')") 
       do i = 1, nda
          if(dabs(a(i,0,1)-a(i,0,2))>= 5d-9 ) write(stdo,"(i5,4f14.6)")i,a( i,0,2 ),a( i,0,1 ),a(i,0,1)-a( i,0,2 ),xmp1_rv(i) 
       enddo
    endif
    call dcopy(nda,xmp1_rv,1,a ( 1,0,2 ),1 ) !Save x^(m+2) into a(*,0,2) and exit ---
  end subroutine pqmixb
  subroutine pkl2ro(mode4,rsm,kmax,nr,nlml,nsp,rofi,rwgt,nlmlx,fklr,rho1) !- Put PkL or GkL expansion of a function on a radial mesh for one site
    !i         add G_kL expansion of rho to rho1 (and possibly rho2)    !i         :    Here, fkl are coffs to G_kL expansion
    !i         add expansion to rho1 only; rho2 is not touched
    !i         coefficients fkl are real (uses fklr)
    !i         initialize rho1,rho2 before adding expansion
    !i         :mode4 10000s digit for spin polarized case
    !i         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
    !i         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
    !i   rsm   :smoothing radius for P_kL (or G_kL) expansion
    !i   kmax  :k-cutoff for P_kL (or G_kL) expansion
    !i   nr    :number of radial mesh points
    !i   nlml  :L-cutoff for rho1,rho2
    !i   nsp   :2 if fkl is spin-pol; 1 if not
    !i   rofi  :radial mesh points
    !i   rwgt  :radial mesh weights
    !i   nlmlx  :second dimension of fkl
    !i   fklc  :complex coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !i   fklr  :real coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !o Outputs
    !o  rho1  :fkL P_kL (or G_kL) added to local true density rho1
    !o  rho2  :fkL P_kL (or G_kL) added to local smoothed density rho2
    !i   qmx   :charge in rho1 after fkl PkL is added
    !r Remarks
    !u Updates
    !u   21 Nov 01 First created
    ! ----------------------------------------------------------------------
    implicit none
    integer :: mode,kmax,nlmlx,nr,nlml,nsp,i,ilm,isp,k,l,lmxl,mode4,np 
    real(8) :: qmx,rsm
    real(8) :: rofi(nr),rwgt(nr)
    real(8) :: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),nchg(nr,nlml),nspn(nr,nlml)
    real(8) :: fklr(0:kmax,nlmlx,nsp)
    real(8) :: add,r,rl,sum1
    real(8) :: rhoc(nr,nsp)
    lmxl = ll(nlml)
    mode4 = 0!mod(mode/10000,10)
    block
      real(8):: pkl(nr,0:kmax,0:lmxl)
      do i = 2, nr
         call radgkl(rofi(i),rsm,kmax,lmxl,kmax,pkl(i,:,:))
      enddo
      do ilm = 1, nlml
         l = ll(ilm)
         do  isp = 1, nsp
            rho1(1:nr,ilm,isp) = [0d0,(sum(fklr(:,ilm,isp)*pkl(i,:,l))*rofi(i)**(l+2),i=2,nr)]
         enddo
      enddo
    endblock
  end subroutine pkl2ro
  subroutine rhoqm(smrho,n1,n2,n3,nsp,vol, qsum)    !- Return charge, magnetic moment of smooth density
    !o Outputs
    !o   qsum  :qsum(1) = smrho(+) + smrho(-)
    !o         :qsum(2) = smrho(+) - smrho(-) (for nsp=2 only)
    implicit none
    integer ::  n1,n2,n3,nsp,i
    complex(8):: smrho(n1,n2,n3,nsp)
    real(8):: vol,qsum(2),sumi(2)
    sumi = [(sum(smrho(:,:,:,i)),i=1,nsp)]
    qsum(1) = vol/(n1*n2*n3)*sum(sumi)
    if(nsp==2) qsum(2) = vol/(n1*n2*n3)*(sumi(1)-sumi(2))
  end subroutine rhoqm
  integer function broyj(n,xin,gin,ir,ipr,beta,dxmx,xtol,gtol, wc,wk,ndw,xnew)   !- One Broyden step in finding gin = f[xin]-xin = 0
    !i Inputs
    !i   n:     number of variables
    !i   ir:    Number of iterations of x and g.
    !i          1 initiates a new sequence of mixing;
    !i          broyj uses linear mixing for this iteration.
    !i   isw    1s digit (not implemented)
    !i          0  find minimum
    !i          1  find maximum
    !i         10s digit not used
    !i        100s digit not used
    !i       1000s digit governs convergence criterion:
    !i          1 return when |grad| < gtol
    !i          2 return when max dx < xtol
    !i          3 return when either (1) or (2) satisfied
    !i          4 return when both (1) and (2) are satisfied
    !i   beta:  linear mixing parameter (ir=1 only)
    !i   xin:   input vector, this iteration
    !i   gin:   output-input vector, f[xin]-xin, this iteration
    !i   wc:    weighting for this iteration
    ! o  wk     workspace of 2*ndw*(ir+2), ndw>=n
    ! o         wk must be preserved between calls to broyj.
    ! o         (*,1,0) x of the prior iteration.
    ! o         (*,2,0) g of the prior iteration.
    ! o         (*,1..2,1..ir-1) u and vt of this and prior iterations
    ! o         (*,1,ir) g(this iter) - g (prior iter).
    !o Outputs
    !o   xnew   estimate of x
    !o   broyj
    !r Remarks
    !r   Adapted from Duane Johnson
    ! ----------------------------------------------------------------------
    implicit none
    integer :: isw,ir,n,ipr,ndw
    real(8) :: beta,dxmx,wc,xin(n),gin(n),xnew(n),xtol,gtol, wk(ndw,2,0:ir)
    ! Local variables
    integer :: i,ip,j,k,irm1,irm2,lm,ln,nn,i1mach,isw1,isw2,isw3 !dinv
    integer :: ierr
    real(8) :: aij,cmj,dfnorm,fac1,fac2,gmi,one,zero,ddot,w0
    parameter (zero=0d0,one=1d0,nn=20)
    real(8) :: a(nn,nn),cm(nn),w(nn),d(nn,nn)
    real(8) :: betx,diff,gmax,xmax
    save w,cm,a,w0
    isw1 = 0!mod(isw/10,10)
    isw2 = 0!mod(isw/100,10)
    isw3 = 0!mod(isw/1000,10)
    if (ir > nn) call rxi('broyj: increase nn, need',ir)
    ! --- First iteration: simple mixing ---
    if (ir == 1) then
       w0 = wc
       betx = beta
       gmax = 0
       do  k = 1, n
          gmax = max(gmax,abs(gin(k)))
       enddo
       If (dxmx > 0d0 .AND. gmax > dxmx) then
          betx = beta*dxmx/gmax
       endif
       do    k = 1, n
          xnew(k) = xin(k) + betx*gin(k)
       enddo
       ! --- Subsequent iterations: Broyden mixing ---
    else
       !   ... Make xold, gold
       do  20  k = 1, n
          wk(k,1,0) = xin(k) - wk(k,1,0)
          wk(k,1,ir) = gin(k) - wk(k,2,0)
20     enddo

       !   --- Coefficient matrices and the sum for corrections ---
       !   ... dfnorm = |g(i)-g(i-1)|, used for normalization
       dfnorm = dsqrt(ddot(n,wk(1,1,ir),1,wk(1,1,ir),1))
       fac2 = one/(dfnorm+1d-12)
       fac1 = beta*fac2
       !   ... Shuffle each prior u,vt to prior+1 iteration
       irm1 = ir-1
       irm2 = ir-2
       do  30  j = irm2, 1, -1
          call dcopy(n,wk(1,1,j),1,wk(1,1,j+1),1)
          call dcopy(n,wk(1,2,j),1,wk(1,2,j+1),1)
30     enddo
       !   ... Make u,vt for this iteration
       do    k = 1, n
          wk(k,1,1) = fac1*wk(k,1,ir) + fac2*wk(k,1,0)
          wk(k,2,1) = fac2*wk(k,1,ir)
       enddo

       !   --- Make  a and b = ( w0**2 I + a )^-1 (symmetric) ---
       do  42  j = 1, irm2
          aij = zero
          cmj = zero
          do    k = 1, n
             cmj = cmj + wk(k,2,ir-j)*gin(k)
             aij = aij + wk(k,2,ir-j)*wk(k,2,1)
          enddo
          a(irm1,j) = aij
          a(j,irm1) = aij
          cm(j) = cmj
42     enddo
       aij = zero
       cmj = zero
       do  k = 1, n
          cmj = cmj + wk(k,2,1)*gin(k)
          aij = aij + wk(k,2,1)*wk(k,2,1)
       enddo
       a(irm1,irm1) = aij
       cm(irm1) = cmj
       w(irm1) = wc

       !   ... Set up and calculate beta matrix
       do   lm = 1, irm1
          do  ln = 1, irm1
             d(ln,lm) = a(ln,lm)*w(ln)*w(lm)
          enddo
          d(lm,lm) = w0**2 + a(lm,lm)*w(lm)*w(lm)
       enddo
       !   --- Invert to make d ---
       call matinv2(irm1,d(1:irm1,1:irm1),ierr)
       !   --- xnew <- vector for the new iteration ---
       do   k = 1, n
          xnew(k) = xin(k) + beta*gin(k)
       enddo
       do  70  i = 1, irm1
          gmi = zero
          do  ip = 1, irm1
             gmi = gmi + cm(ip)*d(ip,i)*w(ip)
          enddo
          do  k = 1, n
             xnew(k) = xnew(k) - gmi*wk(k,1,ir-i)*w(i)
          enddo
70     enddo
       !   ... Cap to maximum allowed shift xnew-xin
       if (dxmx > 0d0) then
          diff = 0
          do  k = 1, n
             diff = max(diff,abs(xnew(k)-xin(k)))
          enddo
          if (diff > dxmx) then
             betx = dxmx/diff
             do   k = 1, n
                xnew(k) = xin(k) + betx*(xnew(k)-xin(k))
             enddo
          endif
       endif
    endif
    ! --- Cleanup, setup for next call ---
    xmax = 0
    gmax = 0
    diff = 0
    do  110  k = 1, n
       xmax = max(xmax,abs(xnew(k)-xin(k)))
       gmax = max(gmax,dabs(gin(k)))
       diff = diff + (xnew(k)-xin(k))**2
       wk(k,2,0) = gin(k)
       wk(k,1,0) = xin(k)
110 enddo
    diff = dsqrt(diff/n)
    j = ir+1
    if (isw3 /= 0 .AND. (gmax == 0 .OR. &
         gmax < gtol .AND. xmax < xtol .AND. isw3 == 4 .OR. &
         gmax < gtol .AND. (isw3 == 1 .OR. isw3 == 3)  .OR. &
         xmax < xtol .AND. (isw3 == 2 .OR. isw3 == 3)  .OR. &
         gmax < gtol .AND. (isw3 == 1 .OR. isw3 == 3))) j = 0
    broyj = j
  end function broyj
  subroutine rhogkl(ib,nsp,mode,sv_p_orhoat,kmax,qkl )!- G_kL expansion of valence sphere densities
    use m_lgunit,only:stdo
    use m_struc_def  
    use m_lmfinit,only: ispec
    use m_hansr,only:corprm
    use m_freeatom,only:sspec
    !i   mode  : 2 for rho1, 3 for rho2
    !i   kmax  : make expansion coffs to polynomial cutoff kmax
    !i   orhoat: vector of offsets containing site density
    !o   qkl  :Expansion coefficients, stored as a single long vector.
    !o        := integral pkl Y_L integrand where integrand is according to mode
    !r Remarks1
    !r   Q_kL = integral p_kl (rho1-rho2) + l=0 contr. from core spillout.  Ser rhomom
    !r   The core spillout term is:
    !r      qcore(rhoc)-z  - sm_qcore-sm_qnuc
    !r   pvrgkl makes this Q_kL when mode=131; partial contr for other modes
    !r   NB: p0l = a**l and scaling factor for k=0 is 4*pi/(a**l * (2l+1)!!)
    !r       => q0l = 4*pi/(2l+1)!! q_l, where q_l is the multipole moment
    ! ----------------------------------------------------------------------
    !r Remarks2
    !r   P_kL are polyonomials orthogonal in the following sense:
    !r                                          (4a^2)^k a^l k! (2l+1)!!
    !r    int P_kL G_k'L' = delta_kk'*delta_ll'  ----------------------
    !r                                                    4pi
    !r   See defined in J. Math. Phys. 39, 3393 (1988).
    !r   Combining eqns 12.7 and 5.19 in that paper, we obtain
    !r    p_kl = a**l / (2a**2)^(k+l) (2l+1)!! / (2k+2l+1)!! phi_kl
    !r    p_0l = a**l
    !r    p_1l = a**l (2*(ar)**2/(2l+3) - 1)
    !r    p_kl = [(2*(ar)**2 - (4k+2l-1))p_k-1,l - 2(k-1)p_k-2,l]  / (2k+2l+1)
    implicit none
    integer:: ib1,ib2,nsp,mode,kmax
    type(s_rv1) :: sv_p_orhoat(3,nbas)
    real(8):: qkl(0:kmax,*),z,qc,a,rmt,qcorg,qcorh,qsc,cofg,cofh,rg, ceh,rfoc,df(0:20)
    integer:: ipr,iprint, ib,is,lmxl,nr,nlml,ilm,j,lfoc,k,l,m
    real(8) ,allocatable :: rofi(:), rwgt(:)
    real(8),parameter:: fpi = 16d0*datan(1d0)
    ipr  = iprint()
    is = ispec(ib)
    lmxl=lmxl_i(is)
    if (lmxl == -1) return
    z=z_i(is)
    qc=sspec(is)%qc
    a=spec_a(is)
    nr=nr_i(is)
    rmt=rmt_i(is)
    rg=rg_i(is)
    call corprm(is,qcorg,qcorh,qsc,cofg,cofh,ceh,lfoc,rfoc,z)
    qc = qcorg+qcorh
    nlml = (lmxl+1)**2
    allocate(rofi(nr),rwgt(nr))
    call radmsh(rmt,a,nr,rofi )
    call radwgt(rmt,a,nr,rwgt )
    QKL_Pkl: block
      real(8),target :: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp)!, rhoc(nr,nsp)
      real(8):: dfactl(0:lmxl),kfact(0:kmax) ,pkl(nr,0:kmax,0:lmxl),a       !call vecpkl(rofi,rg,nr,kmax,lmxl,nr,kmax,pkl)
      real(8),pointer :: rho(:,:,:)
      real(8):: ag
      integer:: isp,kk,lx
      rho1=reshape(sv_p_orhoat(1,ib)%v,shape(rho1))
      rho2=reshape(sv_p_orhoat(2,ib)%v,shape(rho2))
      a = 1d0/rg
      do l = 0, lmxl
         pkl(:,0,l) = a**l *rofi**l !Scale by r^l 
         pkl(:,1,l) = a**l*(2*a*a*rofi**2/(2*l+3)-1d0) *rofi**l
         do  k = 2, kmax ! --- Recursion for higher k ---
            pkl(:,k,l) = 1d0/(2*k+2*l+1)*((2*a*a*rofi**2-(4*k+2*l-1))*pkl(:,k-1,l) - 2*(k-1)*pkl(:,k-2,l))
         enddo
      enddo
      if (mode == 2) rho=>rho1
      if (mode == 3) rho=>rho2
      if( .not.(mode==2.or.mode==3)) call rxi('rhogkl: bad mode=',mode)
      dfactl(0:lmxl)=[(product([(2*lx+1,lx=0,l)]),   l=0,lmxl)]
      kfact(0:kmax)= [(product([(max(1,kk),kk=0,k)]),k=0,kmax)]
      ag = 1/rg
      do  ilm=1,(lmxl+1)**2
         l=ll(ilm)
         do  k = 0, kmax
            qkl(k,ilm)=fpi*sum([(sum(rwgt(:)*pkl(:,k,l)*rho(:,ilm,isp)),isp=1,nsp)])/ ((4*ag**2)**k*ag**l*kfact(k)*dfactl(l))
         enddo
      enddo
    endblock QKL_Pkl
    checkrwrite: if(ipr >=40) then
       write(stdo,221)
       write(stdo,222) ib,0,1,(qkl(k,1), k=0,kmax)
       call stdfac(20,df)
       do  ilm=1,(lmxl+1)**2
          l=ll(ilm)
          if (dabs(qkl(0,ilm))*df(2*l+1) > 1d-6) write(stdo,220) 0,ilm,(qkl(k,ilm)*df(2*l+1),k=0,kmax)
       enddo
222    format(2x,'ib=',i3,i5,i6,10f12.6)
220    format(9x,i4,i6,f12.6,10f12.6)
221    format(/' rhogkl:    k   ilm      qkl (2l+1)!! ...')
    endif checkrwrite
  end subroutine rhogkl
  subroutine splrho(mode,nsp,nr,nlml,rho1,rho2,rhoc)  !- Overwrite spin pol local rho+,rho- with rho,rho+ - rho-, or reverse
    implicit none
    integer :: mode,nsp,nr,nlml
    real(8):: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rhoc(nr,nsp),rho1old(nr,nlml,nsp),rho2old(nr,nlml,nsp),rhocold(nr,nsp),fac
    if (nsp == 1) return
    fac = 1
    if (mod(mode,10) /= 0) fac = .5d0
    rho1old=rho1 !    call dsumdf(nr*nlml,fac,rho1,0,1,rho1(1,1,2),0,1)
    rho1(:,:,1)=fac*(rho1old(:,:,1)+rho1old(:,:,2)) 
    rho1(:,:,2)=fac*(rho1old(:,:,1)-rho1old(:,:,2)) 
    rho2old=rho2
    rho2(:,:,1)=fac*(rho2old(:,:,1)+rho2old(:,:,2)) 
    rho2(:,:,2)=fac*(rho2old(:,:,1)-rho2old(:,:,2)) 
    if(mode<10) then 
       rhocold=rhoc
       rhoc(:,1)=fac*(rhocold(:,1)+rhocold(:,2))
       rhoc(:,2)=fac*(rhocold(:,1)-rhocold(:,2))        !       call dsumdf(nr,     fac,rhoc,0,1,rhoc(1,2),0,1)
    endif  
  end subroutine splrho
end module m_mixrho
