module m_mksym_util !utities for m_mksym
  use m_lgunit,only:stdo
  use m_ftox
  public gensym,grpgen,symtbl, word,words,nword,splcls
  private
  real(8),parameter:: toll=1d-4,tiny=1d-4
contains
  subroutine gensym(slabl,gens,usegen,lcar,lfix,lsmall,nbas, nspec,ngmx,plat,platcv,bas,ips,nrspec,ng,g, &
       ag,ngen,gen,nwgens,nggen,isym,istab)  ! Generate the space group 
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   slabl: name of the different species.
    !i   gens:  a list of generators, in symbolic representation
    !i          NB: this list is not required; see Remarks.
    !i   usegen:0 Find any additional group operations for this basis.
    !i          1 Also, extra basis atoms are added as needed to guarantee
    !i            the group operations created from gens are valid.
    !i          2 Do neither 0 nor 1.
    !i   lcar:  (not used)
    !i          T express ag,positions in cartesian coordinates
    !i          F express in units of conventional unit cell
    !i   lfix:  T: do not rotate or shift lattice
    !i   nspec: number of classes, atoms in same class are symmetry-related
    !i   plat:  primitive lattice vectors (scaled by alat)
    !i   platcv:Used to scale translation part of generators,
    !i         :when translation part specified as a multiple of
    !i         :lattice vectors.  Can be same as plat but
    !i         :primitive lattice vectors of "conventional unit cell"
    !i         :are sometimes used to specify these translations, e.g.
    !i         :when generated from spacegroup data in some books.
    !i   ldist: lattice deformation matrix key; see lattdf
    !i   dist:  lattice deformation matrix; see lattdf
    ! o Inputs/Outputs (altered only if usegen=F)
    ! o  nbas:  On input, number of atoms in the basis
    ! o         On output nbas may be enlarged, depending symops and usegen
    ! o  bas:   basis vectors
    ! o         On output bas may be enlarged, depending symops and usegen
    ! o  ips:   the jth atom belongs to spec ips(j)
    ! o         On output ips may be enlarged, depending symops and usegen
    !o Outputs:
    !o   istab: site ib is transformed into istab(ib,ig) by operation ig
    !o   g:     symmetry operation matrix (assumed dimensioned >=ngmx)
    !o   ag:    symmetry operation vector (assumed dimensioned >=ngmx)
    !o   ... The following are generated if usegen=F
    !o   isym:  numbers characterizing the symmetry of lattice and crystal
    !o          isym(1) produces index for underlying lattice (see symlat)
    !o   lsmall:if T: a smaller unit cell can be found
    !o   nrspec:number of atoms in the ith class
    !o   ng:    number of group operations
    !o   ngen:  number of symmetry generators
    !o   gen:   generators in matrix form
    !o   nwgens:generators in ascii form
    !o   nggen :number of group ops generated by generators.
    !o         :Usually nggen=ng; however nggen can exceed ng if
    !o         :supercell is artificial -> extra translations; see groupg
    !l Local variables
    !l   modes: 0 -> sgroup compares point and space groups
    !l          1 -> sgroup compares point groups only
    !l          (set with 'points' keyword in gens)
    !r Remarks:
    !r   gensym generates the space group, using the following prescription:
    !r     1.  Any generators supplied from input gens
    !r         are checked for consistency with the underlying lattice.
    !r     2.  The space group is made from these generators.
    !r     3.  if usegen<2, missing basis atoms are added to make
    !r         the basis consistent with the supplied symmetry.
    !r     4.  nrspec is created
    !r     ... Unless usegen is 0, nothing more is done
    !r     5.  The point group of the underlying lattice without the
    !r         basis is generated.
    !r     6.  The full space group is generated from the point group
    !r     7.  A set of generators for this group is created
    !r   This program was adapted from the Stuttgart ASA version lmto-46.
    !b Bugs:
    !b   auto symmetry finder can fail with supercells, where extra
    !b   group operations include the same point group but inequivalent
    !b   translations.  Solution: have symcry call sgroup to see
    !b   if the space group is enlarged.  If so, space group should be
    !b   enlarged.
    !u Updates
    !u   04 Jan 06 Enabled keyword 'point' in ssymgr, returns if ng>ngmx
    !u   13 Dec 03 Uses platcv when scaling translation part of symgrp
    !u   05 Apr 03 Call sgroup looking only for point group ops;see bugs
    !u   03 Nov 01 Shortened argument list, eliminating duplicate bas,ips
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nbas,isym(*),istab(nbas,*),nspec,ngen,ngmx, ng,nrspec(nspec),usegen,ips(nbas),nggen 
    double precision :: plat(9),platcv(9),g(9,*),ag(3,*),bas(3,nbas)
    character(8) ::  slabl(*), gens*(*), nwgens*(*)
    logical :: lcar,lfix
    integer:: i , j , ibas , ic , iprint , ngnmx , igen , mxint , modes,ig
    real(8) ,allocatable :: wk_rv(:)
    double precision :: qlat(3,3),vol,platt(9)
    logical :: lsmall!,latvec
    parameter(ngnmx=10)
    double precision :: gen(9,ngnmx),agen(3,ngnmx)
    integer ::iwdummy,iwdummy1(1)
    character(8):: xt
    call rxx(.not. lcar, 'gensym not implemented lcar')
    call rxx(lfix,  'gensym not implemented lfix')
    call rxx(lsmall,'gensym not implemented lsmall')
    call dinv33(plat,1,qlat,vol) !Reciprocal lattice vectors ---
    ! Symmetry group as given by input generators ---
    nwgens = gens
    modes = 0
    call words(gens,ngen)
    if (ngen > 0) then
       call word(gens,ngen,i,j)
       if (gens(i:j) == 'point') then
          j = i-1
          modes = 1
       endif
       print *,'gggggg',ngen,gens(1:j)
!       print *,'platcv',platcv
       call psymop(gens(1:j),platcv,gen,agen,ngen)
       nwgens = gens(1:j)
    endif
    do  10  igen = 1, ngen
       call grpprd(gen(1,igen),plat,platt)
       if(.NOT.latvec(3,toll,qlat,platt))call rx('GENSYM: imcompatible with lattice generators. igen='//trim(xt(igen)))
10  enddo
    ! ... Set up space group (g,ag,ng) given point group generators gen
    call sgroup(10+modes,gen,agen,ngen,g,ag,nggen,ngmx,qlat)
    ng = min(nggen,ngmx)
    if (nggen > ngmx) return
    i = maxval(ips) !mxint(nbas,ips)
    if (i /= nspec .AND. iprint() > 0) &
         write(stdo,ftox)' GENSYM (warning)',nspec,'species supplied but only',i,'spec used ...'
    nspec = i
    nrspec=0 
    do  22  ibas = 1, nbas
       ic = ips(ibas)
       nrspec(ic) = nrspec(ic)+1
22  enddo
    ! --- Complete the space group ---
    if (usegen == 0) then
       !       call rotlat(alat,bas,csym,isym,lfix,nbas,plat,qlat)
       !   ... Symmetry of lattice without basis
       call symlat(plat,ng,g,isym(1))
       !   ... Symmetry of lattice with basis
       allocate(wk_rv(3*nbas))
       call symcry (bas , wk_rv , ips , nbas , nspec , nrspec &
            , ng , plat , qlat , g , ag , istab )
       if (allocated(wk_rv)) deallocate(wk_rv)
       if (ng > ngmx) return
       nwgens = ' '
       call groupg(0,ng,g,ag,plat,ngen,gen,agen,nwgens,nggen)
    else
       nggen = 0
       call symtbl ( 0 , nbas , iwdummy1 , bas , g , ag , ng , qlat , istab )
    endif
    ! --- Make istab2 ---
    !      do  i = 1, ng
    !        do  ibas = 1, nbas
    !          ic = istab(ibas,i)
    !          istab2(ic,i) = ibas
    !        enddo
    !      enddo
    if (iprint() >= 80 .AND. ng > 1) then
       write(stdo,*)'  ib  istab ...'
       do  i = 1, nbas
          write(stdo,"(i4,':',48i3)") i, (istab(i,ig), ig=1,ng)
       enddo
       write(stdo,*)' GENSYM: site permutation table for group operations ...'
    endif
  end subroutine gensym

  subroutine sgroup(mode,gen,agen,ngen,g,ag,ng,ngmx,qb)
    !      use m_lmfinit,only: stdo
    !- Sets up space group given generators (gen,agen).
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   mode  :a compound set of switches
    !i         :1s digit
    !i         :0 two groups compare to equal when both their point
    !i         :  and space parts compare equal
    !i         :1 two groups compare to equal when their point
    !i         :  group compares equal.  This eliminates
    !i         :  space groups that that have the same point group
    !i         :  but differing translational symmetry, which can
    !i         :  occur for artifically large supercells
    !i         :10s digit
    !i         :0 if ng>ngmx, abort with error message
    !i         :1 if ng>ngmx, return with ng=ngmx+1
    !i   gen   :rotation part of generators of the group
    !i   agen  :translation part of space group generator
    !i   ngen  :number of generators
    !i   ngmx  :maximum allowed number of group operations
    !i   qb    :vectors of a microcell in the Brillouin zone
    !o Outputs
    !o   g     :point group operations
    !o   ag    :translation part of space group
    !o   ng    :number of group operations
    !r Remarks
    !r   Operations are defined as (g,a)(v):=g*v+a
    !r   where g is a (3x3) matrix, a is a vector.
    !r   Always returns the identity operation as one group operation
    !u Updates
    !u   04 Jan 06 Added 10s digit mode
    !u   14 Mar 03 Added mode
    ! ----------------------------------------------------------------------
    implicit none
    integer:: mode,ngen,ng,ngmx
    integer:: ipr,igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,is,nnew,n,m,mode0,mode1
    real(8):: gen(9,ngen),g(9,ngmx),qb(3,3),agen(3,ngen),ag(3,ngmx), &
         h(9),hh(9),e(9),sig(9),asig(3),ah(3),ahh(3),ae(3)
    character:: sout*80,sg*35
    data e/1d0,0d0,0d0, 0d0,1d0,0d0, 0d0,0d0,1d0/, ae/0d0,0d0,0d0/
    call getpr(ipr)
    sout = ' '
    call spgcop(e,ae,g,ag)
    ng = 1
    mode0 = mod(mode,10)
    mode1 = mod(mode/10,10)
    ! --- For each generator, do ---
    do  80  igen = 1, ngen
       call spgcop(gen(1,igen),agen(1,igen),sig,asig)
       ! --- Extend the group by all products with sig ----
       do  9  ig = 1, ng
          if (spgeql(mode0,g(1,ig),ag(1,ig),sig,asig,qb)) then
             if (ipr > 30) write(stdo,ftox)' Generator ',igen,' already in group '// &
                  'as element ',ig
             !        write(stdo,650) igen,ig
             !  650   format(' generator',i3,'  is already in group as element',i3)
             goto 80
          endif
9      enddo
       ! ... Determine order (= power of sig that restores unit operation)
       call spgcop(sig,asig,h,ah)
       do  1  itry = 1, 100
          iord = itry
          if (spgeql(mode0,h,ah,e,ae,qb)) goto 2
          call spgprd(sig,asig,h,ah,h,ah)
1      enddo
       ! ... Products of type  g1 sig**p g2
2      nnow = ng
       if(ipr>=40) write(stdo,ftox)trim(sout),' ',igen,' is ',iord
       do  8  j = 1, ng
          call spgcop(g(1,j),ag(1,j),h,ah)
          do  10  ip = 1, iord-1
             call spgprd(sig,asig,h,ah,h,ah)
             do  11  i = 1, ng
                call spgprd(g(1,i),ag(1,i),h,ah,hh,ahh)
                do  12  k = 1, nnow
                   if ( spgeql(mode0,g(1,k),ag(1,k),hh,ahh,qb) ) goto 11
12              enddo
                !         call asymop(hh,ahh,' ',sg)
                !         write(stdo,'('' sgroup adding'',i3,2x,a)') nnow+1,sg
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call spgcop(hh,ahh,g(1,nnow),ag(1,nnow))
11           enddo
10        enddo
          if (j == 1) n2 = nnow
8      enddo
       ! ... Products with more than one sandwiched sigma-factor
       m1 = ng+1
       m2 = nnow
       do  20  is = 2, 50
          nnew = 0
          do 211 n = ng+1,n2
             do 21  m = m1, m2
                call spgprd(g(1,n),ag(1,n),g(1,m),ag(1,m),h,ah)
                do  22  k = 1, nnow
                   if (spgeql(mode0,g(1,k),ag(1,k),h,ah,qb)) goto 21
22              enddo
                nnew = nnew+1
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call spgcop(h,ah,g(1,nnow),ag(1,nnow))
21           enddo
211       enddo
          m1 = m2+1
          m2 = nnow
          if (nnew == 0) goto 25
20     enddo
25     continue
       ng = nnow
80  enddo
    ! --- Printout ---
    if (ipr >= 30) then
       if (sout /= ' ' .AND. ipr >= 60) write(stdo,ftox)' Order of generator'//trim(sout)
       write(stdo,ftox)'SGROUP: ',ng,'symmetry operations from',ngen
       if (ipr >= 60 .AND. ng > 1) then
          write(stdo,'('' ig group op'')')
          do  60  ig = 1, ng
             call asymop(g(1,ig),ag(1,ig),' ',sg)
             write(stdo,'(i4,2x,a)') ig,sg
60        enddo
       endif
    endif
    return
99  continue
    if(mode1 == 0)call rx1('SGROUP: ng greater than ngmx=%i: probably bad translation',ngmx)
    ng = ngmx+1
  end subroutine sgroup

  subroutine spgprd(g1,a1,g2,a2,g,a)
    !     implicit none
    double precision :: &
         g1(3,3),g2(3,3),g(3,3),sum,a1(3),a2(3),a(3),h(3,3),ah(3)
    integer :: i,j,k
    do 101 i=1,3
       do 10 j=1,3
          sum=0d0
          do 11 k=1,3
             sum=sum+g1(i,k)*g2(k,j)
11        enddo
          h(i,j)=sum
10     enddo
101 enddo
    do j=1,3
       do i=1,3
          g(i,j)=h(i,j)
       enddo
    enddo
    do  i=1,3
       ah(i)=a1(i)
       do  j=1,3
          ah(i)=ah(i)+g1(i,j)*a2(j)
       enddo
    enddo
    do 14 i=1,3
       a(i)=ah(i)
14  enddo
    return
  end subroutine spgprd

  subroutine spgcop(g,ag,h,ah)
    integer :: i
    double precision :: h(9),g(9),ag(3),ah(3)
    do 10 i=1,9
       h(i)=g(i)
       if (dabs(h(i)) < 1.d-10) h(i)=0d0
10  enddo
    do 11 i=1,3
       ah(i)=ag(i)
       if (dabs(ah(i)) < 1.d-10) ah(i)=0d0
11  enddo
  end subroutine spgcop

  subroutine gpfndx(g,ag,ia,ja,pos,nrc,rb,qb)
    !- Finds atom ja which is transformed into ia by group operation g,ag.
    !     implicit none
    integer :: ia,ja
    double precision :: g(3,3),ag(3),pos(3,1),d(3),rb(3,3),qb(3,3)
    integer :: ka,nrc,m,k
    real(8):: rfrac(3),epsr=1d-12
    !     integer mode(3)
    !      mode(1) = 2
    !      mode(2) = 2
    !      mode(3) = 2
    ja = 0
    do  11  ka = 1, nrc
       do  m = 1, 3
          d(m) = ag(m) - pos(m,ia)
          do  k = 1, 3
             d(m) = d(m) + g(m,k)*pos(k,ka)
          enddo
       enddo
       rfrac = matmul(d,qb)
       if(sum(abs(rfrac-nint(rfrac)))< toll) then
          ja = ka
          return
       endif
       !call shorbz(d,d,rb,qb)
       !if (abs(d(1))+abs(d(2))+abs(d(3)) < 1d-4) then
       !   ja = ka
       !   return
       !endif
11  enddo
  end subroutine gpfndx

  subroutine groupg(mode,ng,g,ag,plat,ngen,gen,agen,gens,ngout)
    use m_ftox
    use m_shortn3,only: shortn3_initialize,shortn3,nlatout
    !- Finds a set of generators for the symmetry group
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   mode  :0 two groups compare to equal when both their point
    !i         :  and space parts compare equal
    !i         :1 two groups compare to equal when their point
    !i         :  group compares equal.  This eliminates
    !i         :  space groups that that have the same point group
    !i         :  but differing translational symmetry, which can
    !i         :  occur for artifically large supercells.
    !i   plat  :primitive translation vectors in real space
    !i   qlat  :primitive translation vectors in reciprocal space
    !i   g:symmetry operation symbol
    !i   ng:number of symmetry operations as supplied by the generators
    !o Outputs:
    !o   gen,ngen:generators, and number needed to produce g
    !o   ngout :number of group ops generated by (gen,ngen)
    !o         :usually ngout=ng unless artificial translations
    !o   gens  :ascii representation of generators
    !r Remarks:
    !r   The smallest set of generators is sought.
    !r   This subroutine performs the inverse function of sgroup.
    !u Updates
    !u   09 Jul 08 Extra check to find new generators beyond
    !u             the given ones.
    !u   12 May 07 Always returns gens, independent of verbosity
    !u   04 Jan 06 Returns ngout
    ! ----------------------------------------------------------------------
    integer :: mode,ngen,ng,ngout
    double precision :: plat(3,3)
    double precision :: gen(3,3,*),agen(3,*),g(3,3,*),ag(3,*)
    character*(*) gens
    integer :: imax,isop,ngloc,ngmax,iprint,ngen0,ngmx
    integer :: i1,i2,j1,j2
    parameter (ngmx=48*64)
    character(100) :: sg,sg1,sout,sout2
    double precision :: gloc(3,3,ngmx),agloc(3,ngmx),qlat(3,3),xx,vec(3),vol
    real(8):: rfrac(3),epsr=1d-12
    call dinv33(plat,1,qlat,vol)
    call pshpr(1)
    ngen0 = ngen
    call sgroup(0,gen,agen,ngen,gloc,agloc,ngout,ngmx,qlat)
10  continue
    ! --- Do until enough generators added to make whole group ---
    if (ngout < ng) then
       imax = 0
       ngmax = 0
       do  isop = 1, ng!   ... Run through all symops, choosing whichever adds the most ops
          gen(:,:,ngen+1)= g(:,:,isop) 
          agen(:,ngen+1) = ag(:,isop)  
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
          if (ngloc > ngmax) then
             imax = isop
             ngmax = ngloc
             ngout = ngloc
          endif
       enddo
       ngen = ngen+1
       gen(:,:,ngen)= g(:,:,imax) 
       agen(: ,ngen)= ag(: ,imax) 
       goto 10
    endif
    if ( .TRUE. ) then
       !   ... Run through all symops, choosing whichever adds the most ops
       imax = 0
       ngmax = ngout
       do  isop = 1, ng
          gen(:,:,ngen+1)= g(:,:,isop)
          agen(:,ngen+1) = ag(:,isop) 
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
          if (ngloc > ngmax) then
             imax = isop
             ngmax = ngloc
             ngout = ngloc
          endif
       enddo
       if (ngout > ngmax) then
          ngen = ngen+1
          gen(:,:,ngen)= g(:,:,imax)
          agen(: ,ngen)= ag(: ,imax)
       endif
    endif
    call poppr
    if(iprint()>0.and. ngen0 == 0) then     ! --- Create gens, optionally printout ---
       write(stdo,ftox)'GROUPG: the following are sufficient to generate the space group:'
    elseif(iprint()>0) then
       write(stdo,ftox)'GROUPG:',ngen-ngen0,'generator(s) were added to complete the group:'
    endif
    sout = ' '
    sout2 = ' '
    call shortn3_initialize(plat)
    do  20  isop = 1, ngen
       call asymop(gen(1,1,isop),agen(1,isop),':',sg)
       sout(9:)=trim(sout(9:))//' '//trim(sg) 
       vec=agen(:,isop)
       call dgemm('N','N',1,3,3,1d0,agen(1,isop),1,qlat,3,0d0,vec,1)
       call asymop(gen(1,1,isop),vec,'::',sg1)
       call word(sg1,1,i1,i2)
       call shortn3(vec)
       vec=vec+matmul(plat,nlatout(:,1))
       call asymop(gen(1,1,isop),vec,'::',sg)
       call word(sg,1,j1,j2)
       if (i2-i1 < j2-j1) sg = sg1
       sout2(9:)=trim(sout2(9:))//' '//trim(sg) 
20  enddo
    if (ngen > ngen0 .AND. iprint() >= 20) then
       write(stdo,"(' Generators:trans(cart)  = ', a)")trim(adjustl(sout)) 
       write(stdo,"(' Generators::trans(frac) = ', a)")trim(adjustl(sout2))
    endif
    gens = sout2
    if(ngout>ng)write(stdo,ftox)'(warning)',ng,' ops supplied but generators create ',ngout,' ops'
  end subroutine groupg
  subroutine grpgen(gen,ngen,symops,ng,ngmx)
    use m_ftox
    !- Generate all point symmetry operations from the generation group
    ! ----------------------------------------------------------------
    !i Inputs
    !i   gen,ngen,ngmx
    !i   ng  (12 Sep 96): if>0 , add symops to the ng already in list.
    !o Outputs
    !o   symops,ng
    !r Remarks
    !r   This works for point groups only and is set up for integer
    !r   generators.
    ! ----------------------------------------------------------------
    !     implicit none
    integer :: ngen,ng,ngmx
    double precision :: gen(9,ngen),symops(9,ngmx)
    double precision :: h(9),hh(9),e(9),sig(9),ae(3)
    integer :: igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,n,m
    integer :: ipr
    !      logical grpeql
    character(80) :: sout
    data e /1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0/, ae/0d0,0d0,0d0/
    call getpr(ipr)
    sout = ' '
    call grpcop(e,symops)
    if (ng < 1) ng = 1
    do  80  igen = 1, ngen
       call grpcop(gen(1,igen),sig)
       ! ---   Extend the group by all products with sig ---
       do  9  ig = 1, ng
          if (grpeql(symops(1,ig),sig) .AND. ipr > 30) &
               write(stdo,ftox)' Generator ',igen,' already in group as element',ig
          if (grpeql(symops(1,ig),sig)) goto 80
9      enddo

       ! ---   Determine order ---
       call grpcop(sig,h)
       do  1  itry = 1, 100
          iord = itry
          if (grpeql(h,e)) goto 2
          call grpprd(sig,h,h)
1      enddo
       ! --- Products of type  g1 sig**p g2 ---
2      nnow = ng
       if(ipr >= 40) write(stdo,ftox)'%a  %i is %i,',trim(sout),' ',igen,' is',iord
       do  8  j = 1, ng
          call grpcop(symops(1,j),h)
          do  10  ip = 1, iord-1
             ! ... h = sig**ip
             call grpprd(sig,h,h)
             do  11  i = 1, ng
                ! ... hh = symops_i sig**ip
                call grpprd(symops(1,i),h,hh)
                do  12  k = 1, nnow
                   if ( grpeql(symops(1,k),hh) ) goto 11
12              enddo
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call grpcop(hh,symops(1,nnow))
                !              print 333, (symops(k,nnow), k=1,9), nnow
                !  333         format(9f12.6,i3)
11           enddo
10        enddo
          if (j == 1) n2 = nnow
8      enddo

       ! --- Products with more than one sandwiched sigma-factor ---
       m1 = ng+1
       m2 = nnow
       do  20  i = 2, 50
          do  121  n = ng+1, n2
             do  21  m = m1, m2
                call grpprd(symops(1,n),symops(1,m),h)
                do  22  k = 1, nnow
                   if (grpeql(symops(1,k),h)) goto 21
22              enddo
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call grpcop(h,symops(1,nnow))
21           enddo
121       enddo
          if (m2 == nnow) goto 25
          m1 = m2 + 1
          m2 = nnow
20     enddo
25     continue
       ng = nnow
80  enddo

    ! --- Printout ---
    if (ipr >= 30) then
       if (sout /= ' ' .AND. ipr >= 60) write(stdo,ftox)' Order of generator '//trim(sout)
       write(stdo,ftox)'GRPGEN:',ng,'symmetry operations from',ngen,'generator(s)'
    endif
    if (ipr >= 80 .AND. ng > 1) then
       write(stdo,'('' ig  group op'')')
       do  60  ig = 1, ng
          call asymop(symops(1,ig),ae,' ',sout)
          write(stdo,'(i4,2x,a)') ig,sout(1:35)
60     enddo
    endif

    !      if (ipr .ge. 110) then
    !        print *, 'group operations:'
    !        call ywrm(0,' ',1,i1mach(2),'(5f12.6)',symops,1,9,9,ng)
    !      endif
    return
99  continue
    do i=1,nnow
       write(stdo,ftox) ftof(symops(1:9,i),8)
    enddo   
    write(stdo,ftox) ftof(h,3)
    call rx('GRPGEN: too many elements')
  end subroutine grpgen
  subroutine grpcop(g,h)
    !- Copy matrix
    !     implicit none
    double precision :: h(9),g(9)
    integer :: i
    do  10  i = 1, 9
       h(i) = g(i)
10  enddo
  end subroutine grpcop

  subroutine grpprd(g1,g2,g1xg2)
    !- Returns the product of two point group operations
    !     implicit none
    double precision :: g1(3,3),g2(3,3),g1xg2(3,3),h(3,3),sum
    integer :: i,j,k
    do   i = 1, 3
       do    j = 1, 3
          sum = 0d0
          do  11  k = 1, 3
             sum = sum + g1(i,k)*g2(k,j)
11        enddo
          h(i,j) = sum
       enddo
    enddo
    do   j = 1, 3
       do   i = 1, 3
          g1xg2(i,j) = h(i,j)
       enddo
    enddo
  end subroutine grpprd
  !! -------------------------------------
  subroutine psymop(t,plat,g,ag,ng)    !- Parse symbolic representation of symmetry group operations
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   t,nt  string of symmetry operations, separated by spaces
    !i   plat  lattice vectors that scale translation part ag
    !i         (if needed, i.e. if translation specified by '::')
    !o Outputs:
    !o   g,ng  group op (3x3 matrix) for each input, and number
    !r Remarks:
    !r   Symbols have two parts, first the point group part, followed
    !r   By an optional translation.  The point group part has the form
    !r   O(nx,ny,nz) where O is one of M, I or Rj for mirror, inversion
    !r   and j-fold rotations, respectively, and nx,ny,nz are a triplet
    !r   of indices specifying the axis of operation.
    !r   (nx,ny,nz) is one of (1,0,0), (0,1,0), (0,0,1) and (1,1,1),
    !r   it can be abbreviated as x,X, y,Y, z,Z and d,D, respectively.
    !r   Also permissible are products, eg I*R4X.
    !r   The translation is also of the form (n1,n2,n3)
    !r   Example: the following input
    !r     R3D(0,0,0) Mx R2(1/2,sqrt(3)/2,0)(pi,0,0) my*i'
    !r   is nonsensical, but permissible and generates four group ops.
    !r   10 Jan 1997 now generates g=transpose of prior versions.
    ! ----------------------------------------------------------------------
    !     implicit none
    character(*):: t
    double precision :: plat(3,3),g(9,1),h(9),hh(9),ag(3,1),vec(3)
    integer :: nt,ng,i
    logical :: flgp
    character*1:: leftp='('
    ! --- Do until no more symbolic representation, do ---
    nt = len(t)
    write(6,*)'========== psymop  :'//trim(t)//'###'
    ng = 0
    i = 0
    do
       call skipbl(t,nt,i)
       i=i+1 !
       write(6,*)'  psymop:start###'//trim(t(i:)),' i=',i
       if (i >= nt) return
       ng = ng+1
       call parsop(t,i,g(1,ng))
       write(6,*)'  Endof parsop1 i=',i,trim(t(i:))
       if (t(i:i) == '*') then
          i = i+1
          write(6,*)'  psymop:ttttt222yyy###'//trim(t(i+1:)),'i=',i
          call parsop(t,i,h)
          call grpprd(g(1,ng),h,hh)
          call dcopy(9,hh,1,g(1,ng),1)
       endif
       ag(:,ng)=0d0 !call dpzero(ag(1,ng),3)
       !    ! ... Compatibility with old :T(x,y,z)
       !    if (t(i+1:i+2) == ':T' .OR. t(i+1:i+2) == ':t') i=i+2
       ! ... Compatibility with ::(x,y,z)
       flgp = .false.
       print *,'tttttttttt=',t(i:i+1) 
       if (t(i:i+1) == '::') then
          flgp = .true.
          i=i+2
       elseif (t(i:i) == ':') then
          i=i+1
       endif
       if (t(i:i) == leftp) then
          write(6,*)'psymop:ttttt111###'//trim(t)//'####',' flgp=',flgp,t(i:i)
          !i=i+1
          if ( .NOT. parsvc(-1,t,i,ag(1:3,ng))) call rxi('psymop: failed to parse translation ig=',ng)
          !i=i-1
          write(6,*)'aaaa000 ag=',ag(1:3,ng),t(i:)
          write(6,*) plat(1:3,1)
          write(6,*) plat(1:3,2)
          write(6,*) plat(1:3,3)
          if (flgp) then
             vec= ag(1:3,ng)
             call grpop(vec,ag(1,ng),plat,1)
          endif
          write(6,*)'aaaa111 ag=',ag(1:3,ng)
       endif
    enddo
    !    goto 90
  end subroutine psymop
  subroutine parsop(t,i,a)
    !- Parse string for a point group operator
    double precision :: v(3),sp,c,s,pi2,a(3,3),ddot
    character(*) :: t !(0:*)
    !      logical parsvc
    integer :: i,j,k,nrot,iii
!    i=i+1
    write(*,*)"parsopinput=@@@"//trim(t)//"@@@",i
    pi2 = 8*datan(1d0)
    if (t(i:i) == 'r' .OR. t(i:i) == 'R') then
       i = i+1
       read(t(i:i),'(i1)',err=99) nrot
       i = i+1
       if ( .NOT. parsvc(-1,t,i,v)) goto 99
       sp = ddot(3,v,1,v,1)
       sp = 1d0/dsqrt(sp)
       do  14  k = 1, 3
          v(k) = v(k)*sp
14     enddo
       c = dcos(pi2/nrot)
       s = dsin(pi2/nrot)
       do  16  k = 1, 3
          do  15  j = 1, 3
             a(k,j) = (1-c)*v(j)*v(k)
15        enddo
          a(k,k) = a(k,k) + c
16     enddo
       a(2,1) = a(2,1) + s*v(3)
       a(1,3) = a(1,3) + s*v(2)
       a(3,2) = a(3,2) + s*v(1)
       a(1,2) = a(1,2) - s*v(3)
       a(3,1) = a(3,1) - s*v(2)
       a(2,3) = a(2,3) - s*v(1)
    else if (t(i:i) == 'm' .OR. t(i:i) == 'M') then
       i = i+1
       if ( .NOT. parsvc(-1,t,i,v)) goto 99
       sp = ddot(3,v,1,v,1)
       do  11  j = 1, 3
          do  12  k = 1, 3
             a(j,k) = -2.d0*v(k)*v(j)/sp
12        enddo
          a(j,j) = a(j,j) + 1d0
11     enddo
    else if (t(i:i) == 'i' .OR. t(i:i) == 'I') then
       i = i+1
       !       call dvcpy(0d0,0,a,1,9)
       !       call dvcpy(-1d0,0,a,4,3)
       call dpzero(a,9)
       a(1,1) = -1
       a(2,2) = -1
       a(3,3) = -1
    else if (t(i:i) == 'e' .OR. t(i:i) == 'E') then
       i = i+1
       !       call dvcpy(0d0,0,a,1,9)
       !       call dvcpy(-1d0,0,a,4,3)
       call dpzero(a,9)
       a(1,1) = 1
       a(2,2) = 1
       a(3,3) = 1
    else
       goto 99
    endif
!    i=i-1
    return
99  continue
    write(stdo,*)'PARSOP: parse error at ',i,'t=',t(i:)
    call rx('PARSOP: parse error')
  end subroutine parsop
  ! ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
  subroutine symlat(platcp,ngrp,grp,isym)
    !- Generates the (point) symmetry operations of the lattice
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   platcp:lattice vectors of most compact primitive unit cell
    !o Outputs:
    !o   ngrp  :number of allowed symmetry operations
    !o   grp   :symmetry operation matrix
    !o   isym  :index to lattice type, calculated from ngrp:
    !o          ngrp   isym    name
    !o                  0     shouldn't happen
    !o            2     1     triclinic
    !o            4     2     monoclinic
    !o            8     3     orthorhombic
    !o           16     4     tetragonal
    !o           12     5     rhombohedral
    !o           24     6     hexagonal
    !o           48     7     cubic
    !r Remarks:
    !r   symlat analyzes the primitive translations of the bravais
    !r   lattice in order to supply the symmetry operations of the lattice.
    !r   It gives the number ngrp of allowed operations as well as
    !r   these operations themselves.
    ! ----------------------------------------------------------------------
    implicit none
    integer :: ngrp,isym
    double precision :: platcp(3,3),grp(9,*)
    integer :: i,iprint,ltmax,ll1,m,m1,m2,m3,mm,nrot(4)
    parameter(ltmax=3,ll1=ltmax*2+1)
    double precision :: platt(9),qlatcp(3,3),mat(9),vecg(3),vol
    logical :: lirr
    character(12) :: csym1(0:7)
    data nrot /2,3,4,6/
    data csym1 /'indefinite','triclinic','monoclinic','orthorhombic', &
         'tetragonal','rhombohedral','hexagonal','cubic'/
    mm(i,m) = ltmax-(mod(i,ll1**m)-mod(i,ll1**(m-1)))/ll1**(m-1)
    call dinv33(platcp,1,qlatcp,vol)
    ! --- Start out with E and I ---
    ngrp = 2
    call csymop(-1,grp(1,1),.false.,1,[0d0,0d0,0d0])
    call csymop(-1,grp(1,2), .true.,1,[0d0,0d0,0d0])
    ! --- Find all possible rotation axes ---
    do  10  i = 0, (ll1**3-1)/2-1
       m1 = mm(i,1)
       m2 = mm(i,2)
       m3 = mm(i,3)
       lirr = .true.
       do  12  m = 2, ll1
          lirr = lirr.and.(mod(m1,m).ne.0.or.mod(m2,m).ne.0.or. &
               mod(m3,m).ne.0)
12     enddo
       if (lirr) then
          do  14  m = 1, 3
             vecg(m) = m1*platcp(m,1) + m2*platcp(m,2) + m3*platcp(m,3)
14        enddo

          do  16  m = 1, 4
             !       ... Matrix for this symmetry operation
             call csymop(-1,mat,.false.,nrot(m),vecg)
             call grpprd(mat,platcp,platt)
             !       ... Add it and i*symop, if allowed
             if (latvec(3,toll,qlatcp,platt)) then
                call csymop(-1,grp(1,ngrp+1),.false.,nrot(m),vecg)
                call csymop(-1,grp(1,ngrp+2),.true. ,nrot(m),vecg)
                ngrp = ngrp+2
                if (m /= 1) then
                   call csymop(-1,grp(1,ngrp+1),.false.,-nrot(m),vecg)
                   call csymop(-1,grp(1,ngrp+2),.true. ,-nrot(m),vecg)
                   ngrp = ngrp+2
                endif
             endif
16        enddo
       endif
10  enddo
    isym = 0
    if (ngrp == 2) isym=1
    if (ngrp == 4) isym=2
    if (ngrp == 8) isym=3
    if (ngrp == 16) isym=4
    if (ngrp == 12) isym=5
    if (ngrp == 24) isym=6
    if (ngrp == 48) isym=7
    if (iprint() >= 30) write(stdo,ftox)' SYMLAT: Bravais system is ' &
         //csym1(isym)//'with',ngrp,'symmetry operations.'
  end subroutine symlat
  ! sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss!
  subroutine symcry(bas,bast,ipc,nbas,nclass,nrclas, &
       ng,plat,qlat,g,ag,istab)
    !- Generates the symmetry ops of the crystal from those of the lattice
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   tol:   tol for which atoms are considered to be at the same site
    !i          use 0 for symtbl to pick internal default
    !i   bas   :basis vectors (scaled by alat)
    !i   ipc   :the jth atom belongs to class ipc(j)
    !i   nbas  :number of atoms in the basis
    !i   nclass:number of classes, atoms in same class are symmetry-related
    !i   nrclas:number of atoms in the ith class
    !i   plat  :primitive lattice vectors (scaled by alat)
    !i   qlat  :primitive translation vectors in reciprocal space
    !i   bast  :work array of same dimension as bas
    ! o Inputs/Outputs:
    ! o  ng    :number of allowed symmetry operations (see Remarks)
    ! o         on input  number of symmetry operations of the lattice
    ! o         on output number of symmetry operations of the crystal
    ! o  g     :symmetry operation matrices
    !o Outputs:
    !o   ag    :symmetry operation vector
    !o   istab :site ib is transformed into istab(ib,ig) by operation ig
    !r Remarks:
    !r   symcry finds the subset of the allowed ng point operations of the
    !r   lattice without a basis (see symlat.f) that are valid for
    !r   the crystal.
    !r
    !r   This routine is based on ATFTMT written by Worlton and Warren,
    !r   CPC 3, 88 (1972).
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nbas,ng,ipc(nbas),nclass,istab(nbas,ng),nrclas(nclass)
    double precision :: plat(3,3),qlat(3,3),bas(3,nbas),bast(3,nbas), g(3,3,*),ag(3,*)
    integer :: ibas,ic,iclbsj,icmin,ig,ipr,jbas,kbas,kc, m,mbas,nj,nm,ng0
    double precision :: dbas(3),tol1
    character(135):: sg
    real(8):: rfrac(3),epsr=1d-12
    call getpr(ipr)
    tol1=toll
    ! --- Find the class with minimum number of atoms ---
    icmin = 1
    do  5  ic = 1, nclass
       if (nrclas(ic) < nrclas(icmin) .AND. nrclas(ic) > 0) icmin = ic
5   enddo
    ibas = iclbsj(icmin,ipc,nbas,1)
    ! --- For each group op, see whether it only shifts basis by some T ---
    ng0 = ng
    ng = 0
    do  30  ig = 1, ng0
       bast= matmul(g(:,:,ig),bas)!   ... Rotate the basis by g
       do  20  nj = 1, nrclas(icmin)
          jbas = iclbsj(icmin,ipc,nbas,nj)
          ag(:,ng+1) = bas(:,jbas)-bast(:,ibas) ! This is a candidate for translation ag
          rfrac = matmul(ag(:,ng+1)-epsr,qlat)
          ag(:,ng+1) = matmul(plat,rfrac -nint(rfrac)+epsr)
          do  10  kbas = 1, nbas
             kc = ipc(kbas)
             do  12  nm = 1, nrclas(kc)
                mbas = iclbsj(kc,ipc,nbas,nm)
                dbas(:) = bas(:,mbas)-bast(:,kbas)-ag(:,ng+1)
                if (latvec(1,tol1,qlat,dbas)) then
                   istab(kbas,ng+1) = mbas
                   goto 10
                endif
12           enddo
             !       ... Candidate not valid
             !if (ipr >= 90) then
             !   call asymop(g(:,:,ig),ag(1,ng+1),' ',sg)
             !   call awrit1(' symcry: excluded candidate ig=%,2i  '//sg &
             !        //'%a',' ',80,stdo,ig)
             !endif
             goto 20
10        enddo
          !     --- Valid ag found; add g to list ---
          ng = ng+1
          if (ig > ng) g(:,:,ng)=g(:,:,ig) 
          !if (ipr >= 70) then
          !   call asymop(g(:,:,ng),ag(1,ng),' ',sg)
          !   call awrit1(' symcry: accepted candidate ig=%,2i  '//sg &
          !        //'%a',' ',80,stdo,ig)
          !endif
          goto 30
20     enddo
30  enddo
    if (ipr >= 30) write(stdo,ftox)' SYMCRY: crystal invariant under ' &
         ,ng,'symmetry operations for tol=',ftof(tol1)
    if (ipr >= 60 .AND. ng > 1) then
       write(stdo,'(''-- ig group op'')')
       do  60  ig = 1, ng
          call asymop(g(:,:,ig),ag(1,ig),' ',sg)
          write(stdo,'(i4,2x,a)') ig,trim(sg)
60     enddo
    endif
  end subroutine symcry
  ! ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
  subroutine asymop(grp,ag,asep,sg)
    !- Generate the symbolic representation of a group operation
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i  grp,ag :  space group rotation + translation matrix
    !i  asep:     If first character is 'f', rot. and trans. vectors
    !i            are not converted into small algebraic expressions.
    !i            If first char. is 'f', The second-* character are
    !i            used for the separators.
    !o Outputs:
    !o  sg  :  symbolic representation of group op
    !b Bugs
    !b  No check is made on the length of sg
    ! ----------------------------------------------------------------------
    implicit none
    double precision :: grp(3,3),ag(3)
    character(*):: sg,asep
    double precision :: vecg(3),dasum
    integer :: nrot,ip,isw,i1,i2,fmtv
    logical :: li
    ! --- Get consitutents of grp ---
    call csymop(1,grp,li,nrot,vecg)
    ! --- Rotational part ---
    i1 = 1
    fmtv = 0
    if (asep(1:1) == 'f') then
       fmtv = 4
       i1 = 2
    endif
    sg = ' '
    if (nrot == 1) then
       sg = 'i*i'
       ip = 3
       if (li) sg = 'i'
       if (li) ip = 1
    else
       if (li .AND. nrot == 2) then
          sg = 'm'
          ip = 1
       else
          if(  li   ) sg='i*r'//char(48+nrot)
          if( .NOT. li) sg='r'//char(48+nrot)
          ip =len(trim(sg))
       endif
       ip=ip+1
       call rxx(.not. parsvc(2+fmtv,sg,ip,vecg),'bug in asymop')
    endif
!    write(6,*)'nrot=',nrot,trim(sg)
    ! --- Translational part ---
    if (dasum(3,ag,1) > tiny) then
       if (asep(i1:i1) /= ' ') then
          call nword(asep,1,i1,i2)
          sg(ip+1:) = asep(i1:i2)
          ip = ip+i2-i1+1
       endif
       ip=ip+1
       call rxx(.not. parsvc(1+fmtv,sg,ip,ag),'bug in asymop')
    endif
  end subroutine asymop
  ! ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
  subroutine csymop(iopt,grp,li,nrot,vecg) !Decomposes a group operation into its consitutents, or vice-versa
    use m_ftox
    !i Inputs:
    !i   iopt  := -1 to convert (nrot,vecg,li) to grp
    !i          =  1 to convert grp to to (nrot,vecg,li)
    !o Inputs/Outputs:
    ! o grp   :group operation matrix
    ! o li    :if T: inversion or rotoinversion
    ! o nrot  :rotation angle = 2*pi/nrot
    ! o vecg  :rotation axis
    !r Remarks
    !r   for nrot > 2 the matrix is non-symmetric and the rotation
    !r   axis can be calculated from the antisymmetric part.
    !r   For nrot = 2 this not possible.  However, the squared vector
    !r   components are given by:  mat(i,i) = 2 v_i * v_i - 1.
    !r   This is used for the largest component. The others are taken
    !r   from: mat(i,j) = 2 v_i * v_j for i ne j.  This way we also
    !r   get the right phases between the components.
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nrot,iopt
    double precision :: vecg(3),grp(3,3)
    logical :: li
    integer :: i,idamax,j,in
    double precision :: costbn,detop,ddet33,dnrm2,sinpb3,twopi,vfac, wk(9),sintbn,omcos,ddot
    character(8):: xt
    twopi = 8*datan(1d0)
    ! --- Make grp from (nrot,vecg,li) ---
    if (iopt == -1) then
       call dpzero(grp,9)
       in = iabs(nrot)
       if(in <= 0 .OR. in == 5 .OR. in > 6)call rx('CSYMOP: abs(nrot) must 1,2,3,4 or 6, but is '//trim(xt(in)))
       if(in == 1) then
          call dcopy(3,1d0,0,grp,4)
       else
          sintbn = dsin(twopi/nrot)
          costbn = dcos(twopi/nrot)
          omcos  = 1d0-costbn
          call rxx(dnrm2(3,vecg,1).lt.tiny, 'CSYMOP: zero rotation vector')
          call dscal(3,1/sqrt(ddot(3,vecg,1,vecg,1)),vecg,1)
          grp(1,1) = omcos*vecg(1)*vecg(1) + costbn
          grp(1,2) = omcos*vecg(1)*vecg(2) - sintbn*vecg(3)
          grp(1,3) = omcos*vecg(1)*vecg(3) + sintbn*vecg(2)
          grp(2,1) = omcos*vecg(2)*vecg(1) + sintbn*vecg(3)
          grp(2,2) = omcos*vecg(2)*vecg(2) + costbn
          grp(2,3) = omcos*vecg(2)*vecg(3) - sintbn*vecg(1)
          grp(3,1) = omcos*vecg(3)*vecg(1) - sintbn*vecg(2)
          grp(3,2) = omcos*vecg(3)*vecg(2) + sintbn*vecg(1)
          grp(3,3) = omcos*vecg(3)*vecg(3) + costbn
       endif
       if (li) call dscal(9,-1d0,grp(1,1),1)
       ! --- Make (nrot,vecg,li) from grp ---
    else if (iopt == 1) then
       ! ... Require |determinant=1|
       call dinv33(grp,0,wk,detop)
       if (dabs(dabs(detop)-1.0d0) > tiny) &
            call rx('Exit -1 ASYMOP: determinant of group op must be +/- 1, but is '//trim(ftof(detop)))
       detop = dsign(1.d0,detop)
       !   ... li is T if to multiply by inversion
       li = detop .lt. 0d0
       !   ... Multiply operation grp with detop to guarantee pure rotation
       call dscal(9,detop,grp(1,1),1)
       !   --- Calculate rotation angle from the normalization of v ---
       !       sum_i grp(i,i) = sum_i (1-cos) v_i*v_i + 3*cos = 1 + 2 * cos
       !       costbn = -0.5d0
       !       call daxpy(3,0.5d0,grp(1,1),4,costbn,0)
       costbn = 0.5d0*(-1 + grp(1,1) + grp(2,2) + grp(3,3))

       if (dabs(costbn-1d0) < tiny) then
          nrot = 1
          call dpzero(vecg,3)
       else
          nrot = idnint(twopi/dacos(dmax1(-1d0,costbn)))
          if (nrot == 2) then
             do  10  i = 1, 3
                vecg(i) = 0.5d0*(grp(i,i)+1.0d0)
10           enddo
             j = idamax(3,vecg,1)
             if(vecg(j) < 0d0)call rx('ASYMOP: bad operation j='//trim(xt(j))//'. Diagonal element is '//ftof(grp(j,j)))
             vecg(j) = dsqrt(vecg(j))
             vfac = 0.5d0/vecg(j)
             do  12  i = 1, 3
                if (i /= j) vecg(i) = vfac*grp(i,j)
12           enddo
          else
             vecg(1) = grp(3,2)-grp(2,3)
             vecg(2) = grp(1,3)-grp(3,1)
             vecg(3) = grp(2,1)-grp(1,2)
          endif
          !     --- Renormalize at least one component to 1 ---
          !         to allow for abbreviations as 'D', 'X', 'Y' or 'Z'
          sinpb3 = dsqrt(.75d0)
          if (dabs((sinpb3-dabs(vecg(1)))*(sinpb3-dabs(vecg(2)))* &
               (sinpb3-dabs(vecg(3)))) > tiny) then
             do  20  j = 3, 1,-1
                vfac = dabs(vecg(j))
                if(vfac > tiny) call dscal(3,1.d0/vfac,vecg,1)
20           enddo
          endif
       endif
       call dscal(9,detop,grp(1,1),1)
    endif
  end subroutine csymop
  subroutine symtbl(mode,nbas,ipc,pos,g,ag,ng,qlat,istab) ! Make symmetry transformation table for posis atoms; check classes
    !i Inputs
    !i   mode  :1st digit
    !i         :0  site ib is transformed into istab(ib,ig) by grp op ig
    !i         :1  site istab(i,ig) is transformed into site i by grp op ig
    !i         :   (NB: old routine gpfndx used this convention)
    !i         :10s digit
    !i         :1  check atom classes
    !i   tol   :tol for which atoms are considered to be at the same site
    !i         :use 0 for symtbl to pick internal default
    !i   nbas  :size of basis
    !i   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
    !i   pos   :pos(i,j) are Cartesian coordinates of jth atom in basis
    !i   g     :point group operations
    !i   ag    :translation part of space group
    !i   ng    :number of group operations
    !i   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
    !o Outputs
    !o   istab :table of site permutations for each group op; see mode
    implicit none
    integer :: nbas,ng,mode
    integer :: ipc(1),istab(nbas,1)
    double precision :: pos(3,1),g(9,1),ag(3,1),qlat(9)
    integer :: ib,ic,ig,jb,jc,mode1,mode10
    double precision :: tol1
    character(200)::aaa
    integer,allocatable:: w_oiwk(:)
    character(8):: xt
    if (ng == 0) return
    mode1 = mod(mode,10)
    mode10 = mod(mode/10,10)
    tol1=toll
    !     --- Make atom transformation table ---
    do  20  ig = 1, ng
       do  10  ib = 1, nbas
          call grpfnd(tol1,g,ag,ig,pos,nbas,qlat,ib,jb)
          if (jb == 0) then
             write(aaa,"('SYMTBL: no map for atom ib=',i0,' ig=',i0)") ib,ig
             call rx(aaa)
          endif
          if (mode10 /= 0) then
             ic = ipc(ib)
             jc = ipc(jb)
             if (ic /= jc) then
                write(aaa,"('SYMTBL: site ',i0,' not in same class as mapped site ',i0,', ig=',i0)")&
                     ib,jb,ig
                call rx(aaa)
             endif
          endif
          if (mode1 == 0) then
             istab(ib,ig) = jb
          else
             istab(jb,ig) = ib
          endif
10     enddo
20  enddo
    if (mode10 == 0) return
    allocate(w_oiwk(nbas))
    do  50  ib = 1, nbas ! --- Check atom classes ---
       ic = ipc(ib)
       w_oiwk=0
       do  30  ig = 1, ng
          w_oiwk(istab(ib,ig)) = 1
30     enddo
       do  40  jb = 1, nbas
          if(w_oiwk(jb) == 1) goto 40
          jc = ipc(jb)
          if(ic==jc) call rx('SYMTBL: site1 is inequivalent site2: sitesare'//trim(xt(ib))//trim(xt(jb)))
40     enddo
50  enddo
    deallocate(w_oiwk)
  end subroutine symtbl
  subroutine istbpm(istab,nbas,ng,istab2)  !- Makes inverse of istab
    integer :: nbas,ng
    integer :: istab(nbas,ng),istab2(nbas,ng)
    integer :: ib,ig,ibp
    do  ig = 1, ng
       do  ib = 1, nbas
          ibp = istab(ib,ig)
          istab2(ibp,ig) = ib
       enddo
    enddo
  end subroutine istbpm
  logical function parsvc(iopt,t,ip,v)  !- Parses string, converting to a vector, or vice-versa
    !i Inputs:
    !i   iopt   -1 to convert string t to vector,
    !i           1 to convert vector v to string t
    !i           2 same as 1, but use shorthand 'D', 'X', 'Y', 'Z'.
    !i   ip      position in t first char (0 for first char)
    !i Inputs/Outputs:
    ! o  t       string representation of vector (see Remarks)
    ! o  v       vector
    !o Outputs:
    !o   ip      position after last char: t(ip-1) is last char
    !o   parsvc  T if parse was successful; F if not.
    !r Remarks
    !r   The general string represntation has the form '(a,b,c)'
    !r   where a, b and c are expressions.
    !r   The following shorthand notations are allowed:
    !r   'D' for  (1,1,1)
    !r   'X', 'Y', 'Z' for (1,0,0), (0,1,0), (0,0,1).
    !b Bugs
    !b   no check is made on the length of t
    implicit none
    integer :: ip,tlen
    double precision :: v(3)
    character(*) :: t
    double precision :: x,y,z,d
    character rchr*9, sout*50, add*1,soutx*50
    integer :: itrm,ix(3),ich,iopt,m,i,iz,id,mx !,awrite !,a2vec
    logical :: lveq0(3),lveq1(3)!,a2bin
    data rchr /'(XxYyZzDd'/
    integer:: mmm
    !ip=ip+1
    ! --- Convert t to vec ---
    tlen=len(t)
!    write(6,*) 'Startparsvc:###'//t//'###xxxx',iopt
    if (iopt == -1) then
       v=0d0
       ich = 0
       call chrps2(t(ip:),rchr,len(rchr),ich,ich,itrm)
!       write(6,*) '###'//t(ip:ip+2)//'###itrm=',itrm
       !   ... First char not in rchr: not a recognizable vector
       parsvc = .false.
       if (itrm == 0) return
       if (itrm == 1) then !   '(' is found. We expect t(ip:)='(..., ..., ...)
          ip = ip+1
          mmm=index(t,')',back=.true.) !findloc([(t(ip+m)==')',m=1,size(t))],dim=1,value=.true.,back=.true.) !we have t(ip+mmm-1)=')'
          if(mmm<=0) call rx('cannot find right parensis for vector')
          write(*,*)'xxxx'//t(ip:mmm-1)//'xxxx'
          read(t(ip:mmm-1),*) v
          write(*,*)'vvvv=',v
!          stop 'vvvvvvvvv'
          !if ( .NOT. a2bin(t,v,4,0,',',ip,-1)) return
          !if ( .NOT. a2bin(t,v,4,1,',',ip,-1)) return
          !if ( .NOT. a2bin(t,v,4,2,')',ip,-1)) return
          ip=mmm
          parsvc = .true.
          return
       else
          if (itrm >= 8) then!         ... 'd'
             v(1:3) = 1
          else!         ... 'x' 'y' or 'z'
             v(itrm/2) = 1
          endif
          parsvc = .true.
          ip = ip+1 
       endif
       return
       ! --- Convert vec to t ---
    elseif (mod(iopt,4) == 1 .OR. mod(iopt,4) == 2) then
       parsvc = .true.
       do    i = 1, 3
          lveq0(i) = dabs(v(i)) .lt. tiny
          lveq1(i) = dabs(v(i)-1) .lt. tiny
       enddo
       !   ... Exclude shorthand
       if (mod(iopt,4) == 1) then
          lveq0(3) = .false.
          lveq1(3) = .false.
       endif
       if     (lveq1(1) .AND. lveq1(2) .AND. lveq1(3)) then
          t(ip:ip) = 'd'
       elseif (lveq1(1) .AND. lveq0(2) .AND. lveq0(3)) then
          t(ip:ip) = 'x'
       elseif (lveq0(1) .AND. lveq1(2) .AND. lveq0(3)) then
          t(ip:ip) = 'y'
       elseif (lveq0(1) .AND. lveq0(2) .AND. lveq1(3)) then
          t(ip:ip) = 'z'
       else
          t(ip:ip) = '('
          do  12  i = 1, 3
             write(sout,ftox)ftof(v(i))
             if(abs(nint(v(i))-v(i))<1d-6) write(sout,ftox) nint(v(i))
             x = v(i)
             y = v(i)*dsqrt(3d0)*4
             if (abs(x) > tiny .AND. dabs(dabs(x)-1) > tiny .AND. iopt <= 4) then
                if (abs(1/x-nint(1/x)) < tiny) then
                   write(sout,"('1/',g0)")  nint(abs(1/x))
                   if(x<0) sout='-'//adjustl(sout)
                elseif (abs(y-nint(y)) < tiny .AND.   abs(y) > .5d0) then
                   d = 12
                   iz = nint(abs(y))
                   id = 12
                   if (iz == 2) id = 6
                   if (iz == 4) id = 3
                   if (iz == 6) id = 2
                   if (iz == 12) id = 1
                   y = y/(12/id)
                   if(nint(y)==1) write(sout,"('sqrt(3)/',g0)") id
                   if(nint(y)/=1) write(sout,"(g0,'*sqrt(3)/',g0)") nint(y),id
                endif
             endif
             add=','
             if(i==3) add=')'
             sout=trim(adjustl(sout))//add
             m=len(trim(sout))
             call strncp(t(ip+1:ip+m),sout,1,1,m) !t(ip+1:ip+m)=trim(sout) !
!             ip = ip+m
12        enddo
       endif
!       ip = ip+1
    endif
  end function parsvc
  subroutine grpfnd(tol,g,ag,ig,pos,nbas,qlat,ia,ja) !- Find index to site ja site into which g,ag transforms site ia
    !i Inputs
    !i   tol   :tolerance in site positions
    !i   g     :rotation part of space group
    !i   ag    :translation part of space group
    !i   ig    :which group operation
    !i   pos   :basis vectors
    !i   nbas  :size of basis
    !i   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
    !i   ia    :site for which to find equivalent by group op (g,ag)
    !i         :If ia<0, absolute value of ia is used and additionally
    !i         :point group operation -g is used.
    !o Outputs
    !o   ja    :site that ia is transformed into by (g,ag)
    !o         :i.e. R(ja) = g(ig) R(ia) + ag(ig)
    !o         :if zero, no equivalent site was found.
    !u Updates
    !u   26 Jan 01  Add ability to operate with -g (ia<0)
    implicit none
    integer :: ia,ja,ig
    double precision :: g(3,3,ig),ag(3,ig),pos(3,1),qlat(3,3),tol
    double precision :: d(3),d2(3)
    integer :: ka,nbas,m,k
    ka = iabs(ia)
    do    m = 1, 3
       d(m) = ag(m,ig)
       do    k = 1, 3
          d(m) = d(m) + g(m,k,ig)*pos(k,ka)
       enddo
    enddo
    if (ia < 0) call dscal(3,-1d0,d,1)

    ja = 0
    do  10  ka = 1, nbas
       d2(1) = d(1) - pos(1,ka)
       d2(2) = d(2) - pos(2,ka)
       d2(3) = d(3) - pos(3,ka)
       if (latvec(1,tol,qlat,d2)) then
          ja = ka
          return
       endif
10  enddo
  end subroutine grpfnd
  logical function spgeql(mode,g1,a1,g2,a2,qb)
    !- Determines whether space group op g1 is equal to g2
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   mode  :0 -> space group is compared
    !i         :1 -> only point group is compared
    !i   g1,a1 :first space group
    !i   g2,a2 :second space group
    !i   qb    :reciprocal lattice vectors
    !u Updates
    ! ----------------------------------------------------------------------
    implicit none
    integer :: mode
    double precision :: g1(9),g2(9),a1(3),a2(3),qb(3,3)
    integer :: m,iq,iac
    double precision :: c,ca,dc
    spgeql=.true.
    do 10 m=1,9
       if (dabs(g1(m)-g2(m)) > toll) then
          spgeql=.false.
          return
       endif
10  enddo
    if (mode == 1) return
    do 20 iq=1,3
       c=(a1(1)-a2(1))*qb(1,iq)+(a1(2)-a2(2))*qb(2,iq) +(a1(3)-a2(3))*qb(3,iq)
       ca=dabs(c)
       iac=ca+0.5d0
       dc=ca-iac
       if (dabs(dc) > toll) then
          spgeql=.false.
          return
       endif
20  enddo
    return
  end function spgeql
  logical function grpeql(g1,g2)    !- Checks if G1 is equal to G2
         implicit none
    double precision :: g1(9),g2(9),dabs,x1,x2
    logical :: ddif
    integer :: i
    ddif(x1,x2) = dabs(x1-x2)> toll
    grpeql = .false.
    do  10  i = 1, 9
       if (ddif(g1(i),g2(i))) return
10  enddo
    grpeql = .true.
  end function grpeql
  SUBROUTINE GRPOP(V,V1,G,I)
    !     implicit none
    double precision :: G(3,3,*),V(3),V1(3)
    integer :: i
    V1(1) = G(1,1,I)*V(1) + G(1,2,I)*V(2) + G(1,3,I)*V(3)
    V1(2) = G(2,1,I)*V(1) + G(2,2,I)*V(2) + G(2,3,I)*V(3)
    V1(3) = G(3,1,I)*V(1) + G(3,2,I)*V(2) + G(3,3,I)*V(3)
    RETURN
  END SUBROUTINE GRPOP
  logical function latvec(n,tol,qlat,vec)
    !- Checks whether a set of vectors are lattice vectors
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   n     :number of vectors
    !i   tol   :tolerance
    !i   qlat  :primitive translation vectors in reciprocal space
    !i   vec   :double-precision vector
    !o Outputs:
    !o   latvec:T if all vectors are lattice vectors within spec'd tol
    ! ----------------------------------------------------------------------
    implicit none
    integer :: n,i,m
    double precision :: qlat(3,3),vec(3,n),tol, vdiff
    latvec = .false.
    do  10  i = 1, n
       do  20  m = 1, 3
          vdiff = vec(1,i)*qlat(1,m) + &
               vec(2,i)*qlat(2,m) + &
               vec(3,i)*qlat(3,m)
          if (dabs(vdiff-dnint(vdiff)) > tol) return
20     enddo
10  enddo
    latvec = .true.
  end function latvec
!=======================================  
  subroutine words(str,nw) !- Count blank-delimited words in str
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   str   :string
    !o Outputs
    !o   nw    :number of blank-delimited words in str
    !u Updates
    ! ----------------------------------------------------------------------
    character*(*) str
    integer :: nw
    integer :: i1,i2,i0,i
    nw = 0
    i1 = 0
    i2 = 0
    i0 = 1
99  do  10  i = i0, len(str)
       if(str(i:i) /= ' ') then
          i1 = i
          goto 90
       endif
10  enddo
    return
90  nw = nw+1
    do  20  i = i1,len(str)
       if(str(i:i) == ' ') then
          i2 = i
          goto 91
       endif
20  enddo
    return
91  i0 = i2
    goto 99
  end subroutine words
  subroutine word(str,iw,j1,j2) !- Returns j1,j2 so that str(j1:j2) is the iw-th word from beginning
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   str   :string
    !i   iw    :find iw-th word
    !o Outputs
    !o   j1    :str(j1:j2) is iw-th word
    !o   j2    :-//-
    !u Updates
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    character*(*) str
    integer :: iw,j1,j2
    ! ... External calls
    !external nword
    j1 = 1
    call nword(str,iw,j1,j2)
  end subroutine word
  subroutine nword(str,iw,j1,j2)    !- Returns j1,j2 so that str(j1:j2) is the iw-th word from current pos
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   str   :string
    !i   iw    :find iw-th word
    !i   j1    :start search from str(j1:)
    !o Outputs
    !o   j1    :str(j1:j2) is iw-th word
    !o   j2    :-//-
    !u Updates
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: iw,j1,j2
    character*(*) str
    ! ... Local parameters
    integer :: nw,i1,i2,i0,i
    nw = 0
    i1 = 0
    i2 = 0
    i0 = j1
    j2 = -1
99  do  10  i = i0, len(str)
       !   ... skip until nonblank char
       if(str(i:i) /= ' ') then
          i1 = i
          goto 90
       endif
10  enddo
    return
    !   ... skip until a blank char
90  nw = nw+1
    if (nw == iw) j1 = i1
    do  20  i = i1, len(str)
       if(str(i:i) == ' ') then
          i2 = i
          goto 91
       endif
20  enddo
    ! ... We have reached the end of the string
    if (nw == iw) j2 = len(str)
    return
    ! ... cleanup: exit if word soguht, else try again
91  i0 = i2
    if (nw == iw) then
       j2 = i2-1
       return
    endif
    goto 99
  end subroutine nword
  subroutine splcls(nosplt,bas,nbas,ng,istab,nspec,slabl,nclass,ipc, ics,nrclas)
    use m_lgunit,only:stdo
    !- Splits species into classes
    ! ----------------------------------------------------------------------
    !i Inputs:
    !i   nosplt:   T copy class and species
    !i   bas,nbas: dimensionless basis vectors, and number
    !i   nspec:    number of species
    !i   ipc:      on input, site j belongs to species ipc(j)
    !i   slabl:    on input, slabl is species label
    !i   ng:       number of group operations
    !i   istab:    site ib is transformed into istab(ib,ig) by grp op ig
    !o  Outputs:
    !o   slabl:    class labels
    !o   ipc:      on output, site j belongs to class ipc(j)
    !o   ics:      class i belongs to species ics(i)
    !o   nclass:   number of classes
    !o   nrclas:   number of classes per each species
    !u Updates
    !u   04 Apr 03 Search for equivalent classes more thorough
    ! ----------------------------------------------------------------------
    !     implicit none
    logical :: nosplt
    integer :: nbas,nspec,nclass,ng,istab(nbas,ng),ipc(nbas), ics(*),nrclas(nspec)
    double precision :: bas(3,*)
    character(8) :: slabl(*)
    integer :: ib,ic,icn,iclbsj,ig,jb,m,i,is,ipr,idx,ispec,j
    logical :: lyetno
    character(80) :: outs,clabl=''
    call getpr(ipr)
    call icopy(nspec,1,0,nrclas,1)
    !nrclas= 0
    nclass = nspec
    do  5  i = 1, nspec
       ics(i) = i
5   enddo
    if (nosplt) then
    else
       ! --- For each species, split to make equivalent classes ---
       ic = 1
10     if (ic <= nclass) then
          is = ics(ic)
          ib = iclbsj(ic,ipc,-nbas,1)
          !   ... No sites of this class ... skip
          if (ib < 0) goto 11
          lyetno = .true.
          !   ... For each basis atom in this class, do
          do  20  jb = 1, nbas
             !         print *, 'jb=',ib,jb,nclass
             if (ipc(jb) == ic) then
                !      ... If there is a g mapping ib->jb, sites are equivalent
                do  22  ig = 1, ng
                   if (istab(ib,ig) == jb) goto 20
22              enddo
                !      ... If there is a g mapping jb->ib, sites are equivalent
                do  23  ig = 1, ng
                   if (istab(jb,ig) == ib) goto 20
23              enddo
                ! 04 Apr 03 consider these other possibilities
                !      ... If there is a g mapping ib->kb,jb, sites are equivalent
                do  24  ig = 1, ng
                   if (istab(istab(ib,ig),ig) == jb) goto 20
24              enddo
                !      ... If there is a g mapping jb->kb,ib, sites are equivalent
                do  25  ig = 1, ng
                   if (istab(istab(jb,ig),ig) == ib) goto 20
25              enddo
                !      ... There wasn't one
                if (ipr >= 70) then
                   write(stdo,400) slabl(is),ib,(bas(m,ib),m = 1,3),jb,(bas(m,jb),m = 1,3)
                endif
                !      ... If the classes haven't been split yet, do so
                if (lyetno) then
                   nclass = nclass+1
                   icn  =  nclass
                   ics(icn) = is
                   nrclas(is) = nrclas(is)+1
                   lyetno = .false.
                endif
                if (nclass > nbas) then
                   call rx('splcls:  problem with istab')
                endif
                icn  =  nclass
                ipc(jb)=  icn
             endif
20        enddo
11        ic = ic + 1
          goto 10
       endif
    endif
    if(ipr>=30) then
       write(stdo,"(a)")'splcls:  ibas iclass ispec label(ispec)'
       do j=1,nbas
          ic   = ipc(j) !class
          ispec= ics(ic)!spec
          write(stdo,"(a,3i5,a)")"      ",j,ic,ispec,'     '//trim(slabl(ispec))
       enddo
    endif
    if (nclass == nspec .OR. ipr < 20) return
400 format(' SPLCLS: species: ',a,'has inequivalent positions:'/ &
         '  IB: ',i3,',  POS=',3f10.5/ &
         '  JB: ',i3,',  POS=',3f10.5)
  end subroutine splcls
  
end module m_mksym_util

