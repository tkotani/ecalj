      module m_mixrho
      use m_lgunit,only:stdo,stml
      public:: mixrho,parms0
      private
!  mixing routine of smrho, rh. T.kotani think this routine is too compicated to maintain.
!  It is better to rewrite all with keeping the functionality    
      contains
      subroutine mixrho(iter, qval, elind, sv_p_orhnew, sv_p_orhold, smrnew, smrho,rmsdel)
      use m_struc_def
      use m_supot,only: iv_a_okv,rv_a_ogv,k1,k2,k3
      use m_lmfinit,only:lat_alat,nbas,stdl, mixmod=>sstrnmix,ssite=>v_ssite,sspec=>v_sspec,nsp
      use m_lattic,only: lat_vol
      use m_supot,only: lat_nabc, lat_ng
      use m_lmfinit, only:   mix_b,mix_bv,mix_w,mix_wc,mix_nsave,mix_mmix
      use m_ext,only:      sname
!!= Mix old and new charge densities =
!!  Takao's version: real space mixing of smrho. It works OK. However,
!!  we may need to fix it so that this is well-defined chi=|rho-f(rho)|**2 minimization mixing.
!!     Warn. For Co case, I found broyden mixing works wrong.
!!     ITER    NIT=30 MIX=B3,n=5,b=.7,w=1,0
!!     However, as in copt, Broyden mixing is efficient.
!! ----------------------------------------------------------------------
!!i Inputs
!!i   ssite : maybe read only
!!i   sspec :
!!i   slat  :
!!i   nsp   :2 for spin-polarized case, otherwise 1
!!i   iter  :iteration number
!!i   mixmod:string containing iteration-dependent mixing (parmxp) What this mean???
!!i   k1,k2,k3 dimensions smrho
!!
!!i     qval  :total valence charge, used to estimate Lindhard parameter
!!i     elind :default Lindhard screening parameter
!!
!!--- below is Mark's original documents.
Cio Inputs/Outputs
Cio   dmxp  :Default and other values of mixing parameters.
Cio         :The input defaults may be overridden by the string mixmod.
Cio         :Inputs (defaults)
Cio         :(1)  broy  :mixing scheme: 0->Anderson 1->Broyden
Cio         :(2)  beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
Cio         :(3)  wc    :Broyden weights for prior iterations
Cio         :(4,5) weights for n^+ + n^- and n^+ - n^- in spin pol cases
Cio                Avg, diff weighted by wt(1) and wt(2) in the mixing.
Cio                As special cases,
Cio                wt(2)=0 freezes the moments and mixes the charge only
Cio                wt(1)=0 freezes the charge and mixes the moments only
Cio         :(6)  mxsav : maximum number of prior iter to save on disk
Cio         :(7)  mmix  : maximum number of prior iter to mix
Cio         :(8)  nkill : kill mixing file after multiples nkill
Cio         :(9)  betv  : special potential mixing parameter
Cio         :(10) rmscst: not used here
Cio         :Outputs
Cio         :(11) rmsdel : rms (output-input) density
Cio         :(12) rmsl   : rms (output-input) local density
Cio         :(13) nmix   : number of prior iter actually mixed
Cio         :(14) broy   : actual mixing scheme used
Cio         :(15) beta   : actual mixing beta used
Cio         :(16-24) tj  : Anderson mixing coefficients
Cio         :(25)        : (spin polarized case only)
Cio                      : 1  if weight for n^+ + n^- is nonzero
Cio                      : 10 if weight for n^+ - n^- is nonzero
Cio                      : 11 if both nonzero
C    dmxp for mixing.  Default parameters dmxp:
C    1(I) mixing scheme; 2 beta; 3 wc; 4,5 wgt; 6(I)nsave 7(I) mmix;
C    8(I) nkill; 9 betv; 10 rmscst.  11-20 are outputs:
C    11 rmsdel 12 rms2 13 nmix 14 actual broy 15 actual beta 16-24 tj
C    25 1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
C    27..29: hold parms for static parms block regular mixing
C    30..32: hold parms for static parms block Euler angle mixing
C    33 : Lindhard screening parameter
c
Cio   orhnew:On input, local parts of the density that generated the ham.
Cio   orhold:local parts of the density that the hamiltonian generated
Cio         :On output, the mixed density
Cio   smrho :On input, smooth density that generated the hamiltonian H
Cio         :On output mixed smooth density
Cio   smrnew:smooth density generated by the H(rhold,smrho)
Cio         :DESTROYED on output
Cl Local variables
Cl   locmix :governs linear transformation of local densities for mixing
Cl          :Note see Bugs, below
Cl          :0  This was the only mode in versions 6.11 and earlier.
Cl          :   The smooth part of the density and the spherical part of
Cl          :   the local densities are mixed in an Anderson or Broyden scheme.
Cl          :   In the remaining options,
Cl          :   local densities are rotated into
Cl          :     rho1,rho2 -> w(r)*(rho1+rho2), rho1-rho2
Cl          :   where w(r) is defined in pvmix9, mode controlled by k9.
Cl          :   For now, k9=10.
Cl          :   This has no effect for linear mixing, but affects the
Cl          :   Anderson or Broyden weights in the spherical part.
Cl          :1  Same as locmix=0, but for the transformation
Cl              CAUTION: not tested in a long time
Cl          :2  Local densities are further mapped onto a G_kL expansion.
Cl          :   whose coefficients are included in the Anderson/Broyden
Cl          :   mixing schemes, including the nonspherical densities.
Cl          :   the residual (what is left of rho beyond the G_kL expansion)
Cl          :   is linearly mixed.
Cl              CAUTION: not tested in a long time
Cl          :3  Similar to locmix=2, but l=0 part is of the G_kL expansion
Cl          :   is projected out.
Cl          :
Cl   rms2   : <(rout-rin)**2>, where rin and rout are the input and
Cl          : screened output densities represented as a vector,
Cl          : including smoothed and local parts.  rmsdel changes with
Cl          : the choice of transformation of local densities;see locmix
Cl          : above.
Cl   rmsdel : (linked to dmxp(11)).
Cl          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
Cl          : On output, rmsdel is overwritten by rms2.
Cl   rmsuns : RMS difference in output-input sm. density, unscreened
Cl   rms    : RMS difference in output-input sm. density, screened
Cl   sumo   : integral of smrho
Cl   sums   : integral of screened smoothed output rho
Cl   kmxs   : k-cutoff for G_kL expansion of screening charge projected
Cl          : into local densities; see Remarks
Cl   kmxr   : k-cutoff for G_kL expansion used to smooth local densities
Cl          : for mixing
Cl   ng0    : condensed number of G vectors. That rho(G) is hermitian
Cl          : is exploited to reduce ng to ng0
Cl   qcell  : cell charge
Cb Bugs
Cb   Mixing scheme needs some revision.  For now, uses locmix=3 and k9=10
Cb   Problem: G-kL expansion doesn't represent rim density well; not
Cb          : good for rho1+rho2.
Cb   Better:  1. Use simpler trans: (rho1+rho2)/100 or so, and (rho1-rho2)
Cb            2. For nonspherical parts, mix coefficient to multipole in
Cb               the Anderson/Broyden scheme; linearly mix the rest.
Cr Remarks
Cr   To estimate the self-consistent density a model (Lindhard) dielectric
Cr   function is used.  A smooth "total density" is assembled on a mesh
Cr   from the smooth density + local contributions; the latter are
Cr   smoothed into a G_kL expansion of rho1-rho2 and added to the mesh
Cr   density.  This "mesh total density" is assembled for the input and
Cr   output densities smrho and smrnew, and the screening charge
Cr   (eps^-1 - 1) (smrnew(tot) - smrho(tot)) is obtained using the
Cr   Lindhard approximation for eps^-1.  The screening charge is then:
Cr
Cr     (1)  added to smrnew
Cr
Cr     (2)  added back onto local densities as a G_kL expansion
Cr          to both the true and smooth local mixed densities.
Cr
Cr   Finally, the (screened) output density is mixed with the input density
Cr   using an Anderson or Broyden mixing scheme.  Both mesh part and local
Cr   parts are mixed, the latter consists of the true, smooth,
Cr   and core parts.
Cr   How the mixing proceeds depends on locmix; see Local variables above.
Cr
Cr   The steps in this routine follow this path (see numbers in comments)
Cr   1.   smooth rho+,rho-  ->  smrho, smmag
Cr   2.   FT smrnew(r)-smrho(r) -> cn = smrho(G)
Cr   3.   rho1-rho2 -> smoothed, FT; added to smrho(G)
Cr   4.   cn = screening (eps^-1 - 1) smrho(G)
Cr   5.   Add screening to smrnew; smrnew(G) -> smrnew(r)
Cr   6.   smrnew = sm. screened nout, smrho,smrnew -> smooth rho+,rho-
Cr        At this stage, smrho = input smooth rho+,rho-
Cr                       smrnew = screened output rho+,rho-
Cr   7.   Add screening to rho1, rho2; scale if locmix > 0
Cr   8.   smrho,smrnew(r) -> smrho,smrnew(G)
Cr   9.   Pack in,out densities into large matrix a;
Cr        Read prior iterations into a
Cr   10.  Linear mixing of local densities
Cr   11.  Make modified a when wt(1) or wt(2) restricts q or spin
Cr   12.  Mix input, output densities
Cr   13.  Inverse of step 11.
Cr   14.  Poke contents of a into smrho,orhold
Cr   15.  Undo scaling of local rho (step 7)
Cr
Cm MPI
Cm   master process handles the mix files and broadcasts. All processes
Cm   then mix.
Cu Updates
Cu   18 Dec 08 properly treats constrained cases w=1,0 and w=0,1
Cu   30 Jun 06 Bug fix (memory leak)
Cu   15 Feb 02 (ATP) Added MPI parallelization
Cu   21 Nov 01 Linear transformation of local densities for mixing.
Cu             New modes locmix.
Cu   23 Oct 01 Local densities used for screening charge are more
Cr             accurately represented in G_kL expansion, k=0..kmxs
Cu   19 Oct 01 correctly uses elind override from mixing string
Cu   22 Mar 01 Bug fix for case mixing string is empty
Cu   22 Jun 00 spin polarized
Cu   30 May 00 Adapted from nfp mix_rho
C ----------------------------------------------------------------------
      implicit none
      real(8),save::  dmxp(25)

#if MPI | MPIK
      include "mpif.h"
      integer numprocs, ierr, status(MPI_STATUS_SIZE)
      integer MAX_PROCS
      parameter (MAX_PROCS = 100)
      integer resultlen
      character*(MPI_MAX_PROCESSOR_NAME) name
      character*10 shortname(0:MAX_PROCS-1)
      character*20 ext
      character*26 datim
      integer namelen(0:MAX_PROCS-1)
      double precision starttime, endtime
      integer iunit
      character*120 strn
      logical mlog,cmdopt
#endif
      integer::  iter , procid , master
      type(s_rv1) :: sv_p_orhold(3,1)
      type(s_rv1) :: sv_p_orhnew(3,1)
c      character*(*) mixmod
c      type(s_site)::ssite(*)
c      type(s_spec)::sspec(*)
c      type(s_lat)::slat

      double precision qval,elind
      double complex smrnew(k1,k2,k3,nsp),smrho(k1,k2,k3,nsp)
C ... Local parameters
      integer i,i1,i2,i3,ib,ipl,ipr,is,k0,k9,kmxv,
     .lmxl,n1,n2,n3,ng,nglob,nlml,nr,nmixr,nmix,nda,mxsav,ifi,nlm0,
     .kkk,nnnew,nnmix,ngabc(3),igetss,broy,nx,
     .nkill,isw,naa,kmxr,kmxs,locmix,offx,off2
      integer:: ng0 !,  oa , oaa !, ocn ,owk , oqkl
      integer ,allocatable :: ips0_iv(:)
      real(8) ,allocatable :: co_rv(:)
      complex(8) ,allocatable :: cg1_zv(:)
      complex(8) ,allocatable :: cg2_zv(:)
      complex(8) ,allocatable :: fkl_zv(:)
      real(8) ,allocatable :: rofi_rv(:)
      real(8) ,allocatable :: rwgt_rv(:)
      real(8) ,allocatable :: wk1_rv(:)
      real(8) ,allocatable :: wk2_rv(:)

      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
      parameter (nlm0=49)
      double precision a,beta0,beta,dif,difx,difxu,fac,rms,rmt,
     .sumo,summ,sums,top,vol,alat,tpiba,pi,dquns,rmsuns,ddot,q1,
     .qin(2),qout(2),qscr(2),qmix(2),qcell,rms2,rms2f,wc,rsmv,qmx,
     .dgets,wt(3),rmsdel,elinl,srfpi,xx
      double complex xxc
c      logical parmxp
      character sout*80,fnam*8
      integer ::iwdummy ,isp,nnnx,ng02,ng2, iprint,ifile_handle
      real(8):: smmin,sss,wgtsmooth
      complex(8),allocatable:: smrnewbk(:,:,:,:),w_owk(:)
!      complex(8),allocatable:: w_oqkl(:)
      real(8),allocatable:: w_oqkl(:)
      real(8),allocatable:: w_oa(:),w_oaa(:),w_ocn(:)
      logical::       noelind
      logical:: mixrealsmooth
      logical:: init=.true., initd=.true.
      call tcn('mixrho')
      if (mixmod .eq. 'none') return
!  Initial setup for mixrho (charge mixing). This is used in mixrho-parmax.
      if(initd) then
         dmxp   = 0d0
         dmxp(2) = mix_b
         dmxp(3) = mix_wc
         dmxp(4:5)= mix_w(1:2)
         dmxp(6) = mix_nsave
         dmxp(7) = mix_mmix
         dmxp(9) = mix_bv
         call parms0(0,0,0d0,0) !reset mixing block
         initd=.false.
      endif

      nnnew=0
c      open(1898,file='test2vvv_smrho')
      do  i3 = 1, k3
        do  i2 = 1, k2
          do  i1 = 1, k1
            if (sum(dreal(smrho(i1,i2,i3,1:nsp))) .lt. 0) nnnew = nnnew+1
c        if( (i1==1.and.i2==1).or.
c     &      (i3==1.and.i2==1).or.
c     &      (i1==1.and.i3==1) ) then
c        write(1898,"(3i5,2d13.5)")i1,i2,i3,smrho(i1,i2,i3,1)
c        endif
          enddo
        enddo
      enddo
c      close(1898)
c      print *,'vvv'
c      print *,'mixrho: sum smrho  init =',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
c      write(6,"(a,3d13.6,i8)")' mixrho: sum smrho  init =',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
c---
      nnnew=0
c      open(1898,file='test2vvv_smrnew')
      do  i3 = 1, k3
        do  i2 = 1, k2
          do  i1 = 1, k1
            if (sum(dreal(smrnew(i1,i2,i3,1:nsp))) .lt. 0) nnnew = nnnew+1
c        if( (i1==1.and.i2==1).or.
c     &      (i3==1.and.i2==1).or.
c     &      (i1==1.and.i3==1) ) then
c          write(1898,"(3i5,2d13.5)")i1,i2,i3,smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1)
c        endif
          enddo
        enddo
      enddo
c      close(1898)
c      print *,'mixrho: sum smrnew new  =',sum(smrnew(:,:,:,1)),sum(abs(smrnew(:,:,:,1))),nnnew
c      write(6,"(a,3d13.6,i8)")' mixrho: sum smrnew new  =',sum(smrnew(:,:,:,1)),sum(abs(smrnew(:,:,:,1))),nnnew
ccccccccccccccccccccccccccccccccccccc


#if MPI | MPIK
      call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr )
      call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr )
      call MPI_GET_PROCESSOR_NAME(name, resultlen, ierr)
      call strcop(shortname(procid),name,10,'.',i)
      namelen(procid) = i-1
      master = 0
      mlog = cmdopt('--mlog',6,0,strn)
#else
      procid = 0
      master = 0
#endif

c      nbas = globalvariables%nbas
c      stdo = globalvariables%stdo
c      stdl = globalvariables%stdl
      call getpr(ipr)
      ipl = 1
      nx = 0
      kkk = k1*k2*k3
      pi = 4d0*datan(1d0)
      srfpi = dsqrt(4d0*pi)
      locmix = 3 !original lmv7 by mark.
      qmix(2) = 0
      ngabc=lat_nabc
      ng=lat_ng
      vol=lat_vol
      alat = lat_alat
      elinl = elind
      kmxs = 3
      kmxr = 8

C --- Iteration-dependent mixing parameters ---
      broy  = dmxp(1)
      beta  = dmxp(2)
      wc    = dmxp(3)
      wt(1) = dmxp(4)
      wt(2) = dmxp(5)
      wt(3) = dmxp(4)
C     Flags parmxp that there are no extra elements to mix
      if (nx .eq. 0) wt(3) = -9
      mxsav = nint(dmxp(6))
      nmix  = nint(dmxp(7))
      nkill = nint(dmxp(8))
      fnam  = 'mixm'
      rmsdel = dmxp(11)
      rms2 = 0
      if (ipr .ge. 20) write(stdo,*) ' '
      if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,elinl,
     .fnam,wc,nkill,dmxp(9),rms2)) call rx(
     .'MIXRHO: parse in parmxp failed')

C     In case parmxp doesn't touch wt, unset flag
      if (wt(3) .eq. -9) wt(3) = 0
      if (nmix .eq. 0) broy = 0
C ... Initial printout
C      call awrit7(' Mix density with beta=%;4d'//
C     .  '%?;n;, Lindhard E=%;3d;;'//
C     .  '%?;(n==1);, Broyden scheme using n=%,1i;%j;'//
C     .  '%?;(n==0);, Anderson scheme using n=%,1i;%j;',
C     .  ' ',80,stdo,beta,isw(elinl.ne.0),elinl,broy,nmix,
C     .  broy,nmix)
C      call rx('done')

C ... Interactively reset mix-parms block
      i1 = 0
      i2 = 0
c      call query('mix-parms-block',2,i1)
c      call query('block-iter',2,i2)
      if (i1 .gt. 0 .or. i2 .gt. 0) then
        if (i2 .le. 0) i2 = 1
        call parmx0(i1,i2,0d0)
        if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,
     .  elinl,fnam,wc,nkill,dmxp(9),rms2))call rx(
     .  'MIXRHO: parse in parmxp failed')
      endif

      if (nsp .eq. 1) wt(2) = 0
      if (wt(1)**2+wt(2)**2+wt(3)**2 .eq. 0)
     .call fexit(-1,111,' Exit -1 MIXRHO: '//
     .'bad mixing weights w =%3:1;6d',wt)
      call dscal(3,1/dsqrt(wt(1)**2+wt(2)**2+wt(3)**2),wt,1)

C      wt(1) = 1 ; wt(2) = 1; print * , '!! wt=', wt(1:2)

      if (nmix .lt. 0) nmix = mxsav
      if (elinl .lt. 0d0) elinl = -(3*pi**2*qval/vol)**.66666d0*elinl
      if (elinl .lt. .01d0) elinl = 0

C ... Initial charges
      call rhoqm(smrho,k1,k2,k3,n1,n2,n3,nsp,vol,qin)
      call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qout)


!!== difference in smooth part ==
c      write(6,"(a,3d13.5)") ' mixrho: dqsum rmsuns='
c     &  , dreal(sum((smrnew-smrho)/(n1*n2*n3)))
c     &  , sqrt( sum((smrnew-smrho)**2)/(n1*n2*n3) )
      fac = vol/(n1*n2*n3)

!!== RMS differences screened and input sm density; count neg points ==
      sumo = sum(dble(smrho))
      sums = sum(dble(smrnew))
      summ = 0d0
      top = 0d0
      rms = 0d0
      nnnew = 0
      nnmix = 0
      do  i3 = 1, n3
        do  i2 = 1, n2
          do  i1 = 1, n1
            dif = dble(sum(smrnew(i1,i2,i3,1:nsp))-sum(smrho(i1,i2,i3,1:nsp)))
            rms = rms + dif*dif
            top = dmax1(top,dabs(dif))
            xxc = beta*sum(smrnew(i1,i2,i3,1:nsp)) + (1d0-beta)*sum(smrho(i1,i2,i3,1:nsp))
            if( sum(dble(smrnew(i1,i2,i3,1:nsp))) < 0) nnnew = nnnew+1
            if( dble(xxc) .lt. 0) nnmix = nnmix+1
            summ = summ + dble(xxc)
          enddo
        enddo
      enddo
      rms = dsqrt(fac*rms/vol)
!!     Defer printout until after file read prior iterations; see '100' below


!!== elind mode ==
      if(noelind()) then
c        allocate(w_ocn(2*ng))
c        w_ocn=0d0
      else
C --- Screen sm output rho; distribute screening rho over local rho ---
C ... 1. Overwrite smrho+, smrho- with smrho, smrho+ - smrho-
        if (nsp .eq. 2) then
          call dsumdf(kkk*2,1d0,smrho,0,1,smrho(1,1,1,2),0,1)
          call dsumdf(kkk*2,1d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
        endif
C ... <smrout-smrhoin> and <(smrout-smrhoin)**2>, unscreened smrout
        dquns = 0
        rmsuns = 0
        do isp=1,nsp
          do   i3 = 1, n3
          do   i2 = 1, n2
          do   i1 = 1, n1
            dquns  = dquns  + dble(smrnew(i1,i2,i3,isp)-smrho(i1,i2,i3,isp))
            rmsuns = rmsuns + dble(smrnew(i1,i2,i3,isp)-smrho(i1,i2,i3,isp))**2
          enddo
          enddo
          enddo
        enddo
        rmsuns = dsqrt(rmsuns/(n1*n2*n3))
C ... 2. cn <- (smrnew - smrho)(G)
        allocate(w_ocn(2*ng),w_owk(kkk))
        call dcopy(kkk*2,smrnew,1,w_owk,1)
c        call dpadd(w_owk,smrho,1,kkk*2,-1d0)
        call daxpy(kkk*2,-1d0,smrho,1,w_owk,1)
        call fftz3(w_owk,n1,n2,n3,k1,k2,k3,1,0,-1)
        call gvgetf ( ng , 1 , iv_a_okv , k1 , k2 , k3 , w_owk , 
     . w_ocn )
        deallocate(w_owk)
C ... 3. Sum of local densities on Fourier mesh (up+down)
        allocate(cg1_zv(ng))
        allocate(cg2_zv(ng))
        cg1_zv=0d0
        cg2_zv=0d0
        call rhgcmp ( 131 , 1 , nbas , ssite , sspec ,  sv_p_orhold  !slat ,
     . , kmxs , ng , cg1_zv )
        call rhgcmp ( 131 , 1 , nbas , ssite , sspec ,  sv_p_orhnew !slat ,
     . , kmxs , ng , cg2_zv )
C     call gvputf(ng,1,w(okv),k1,k2,k3,w(ocg1),smrnew)
C     call fftz3(smrnew,n1,n2,n3,k1,k2,k3,1,0,1)
C     call zprm3('input local densities (r)',0,smrnew,k1,k2,k3)

C ... Add output-input difference in gaussian rho to make total rho
        call daxpy ( 2 * ng ,   1d0 , cg2_zv , 1 , w_ocn , 1 )
        call daxpy ( 2 * ng , - 1d0 , cg1_zv , 1 , w_ocn , 1 )
        deallocate(cg1_zv,cg2_zv)

C ... 4. Make cn = screening charge = (eps^-1 - 1) (n_out - n_in)
        tpiba = 2*pi/alat
        call lindsc ( 2 , ng , rv_a_ogv , tpiba , elinl , w_ocn )
C ... 5. Add cn = screening charge into smrnew
c      call defcc(owk,kkk)
        allocate(w_owk(kkk))
        call gvputf ( ng , 1 , iv_a_okv , k1 , k2 , k3 , w_ocn , 
     . w_owk )
        call fftz3(w_owk,n1,n2,n3,k1,k2,k3,1,0,1)
        call daxpy(kkk*2,1d0,w_owk,1,smrnew,1)
        deallocate(w_owk)
C ... 6. Restore smrho+, smrho-
        if (nsp .eq. 2) then
          call dsumdf(kkk*2,.5d0,smrho,0,1,smrho(1,1,1,2),0,1)
          call dsumdf(kkk*2,.5d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
        endif
      endif
      if(.not.noelind()) then
C --- 7. Project cn = screening density into local densities ---
        k0 = 20
        allocate(fkl_zv((k0+1)*nlm0*nbas))
        call ftlxp ( nbas , ssite , sspec , alat , ng , rv_a_ogv ,  
     .  w_ocn , k0 , nlm0 , fkl_zv)
      endif
      do  ib = 1, nbas
        is = int(ssite(ib)%spec)
        a   =sspec(is)%a
        nr  =sspec(is)%nr
        rmt =sspec(is)%rmt
        lmxl=sspec(is)%lmxl
        rsmv=sspec(is)%rsmv
        kmxv=sspec(is)%kmxv
        if (lmxl .lt. 0) cycle

        nlml = (lmxl+1)**2
        if (nlml.gt.nlm0) call rxi('mixrho: nlml.gt.nlm0, need',nlml)
        allocate(rofi_rv(nr))
        allocate(rwgt_rv(nr))
        call radmsh ( rmt , a , nr , rofi_rv)
        call radwgt ( rmt , a , nr , rwgt_rv)

        if(.not.noelind()) then
C       Overwrite rho+, rho- with rho, rho+ - rho-
          call splrho ( 0 , nsp , nr , nlml , sv_p_orhnew( 1 , ib )%v , 
     .   sv_p_orhnew( 2 , ib )%v , sv_p_orhnew( 3 , ib )%v )
C   ... Add site-projected screening density to rhn1,rhn2
          call pkl2ro ( 110 , ib , rsmv , kmxv , nr , nlml , 1 , rofi_rv 
     .    , rwgt_rv , k0 , nlm0 , fkl_zv , iwdummy , sv_p_orhnew ( 1 , 
     .    ib ) %v , sv_p_orhnew ( 2 , ib ) %v , qmx )
C       Restore rho+, rho-
          call splrho ( 1 , nsp , nr , nlml , sv_p_orhnew( 1 , ib )%v , 
     .    sv_p_orhnew( 2 , ib )%v , sv_p_orhnew( 3 , ib )%v )
        endif

C   ...  Always work with rho1+rho2, rho1-rho2
C        print *, 'ib=',ib
C        call prrmsh('rhold1',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C        call prrmsh('rhold2',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

        call pvmix9 ( 1 , 0 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , sv_p_orhold( 1 , ib )%v 
     .   , sv_p_orhold( 2 , ib )%v )
        call pvmix9 ( 1 , 0 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , sv_p_orhnew( 1 , ib )%v 
     .   , sv_p_orhnew( 2 , ib )%v )
        if (allocated(rwgt_rv)) deallocate(rwgt_rv)
        if (allocated(rofi_rv)) deallocate(rofi_rv)

      enddo                     ! Loop over sites
      if (allocated(fkl_zv)) deallocate(fkl_zv)
      if(allocated(w_ocn)) deallocate(w_ocn)


C --- Fancy mixing of smoothed + some representation of local rho ---
C ... Count number of elts from local densities for fancy mixing scheme
      nda = 0
      do  ib = 1, nbas
        is = int(ssite(ib)%spec)
        nr = int(sspec(is)%nr)
        lmxl = int(sspec(is)%lmxl)
        nlml = (lmxl+1)**2
        if (lmxl .eq. -1) goto 20
C       include spherical part of local densities only
        if (locmix .le. 1) then
          nda = nda + 2*nr
C       also include nonspherical part, G_kL expansion
        elseif (locmix .ge. 2) then
          nda = nda + 2*(kmxr+1)*nlml
C         and spherical part of rho1-rho2
          if (locmix .eq. 3) nda = nda + 2*nr
        else
          call rxi('bad locmix,',locmix)
        endif
   20   continue
      enddo

      if(mixrealsmooth()) then
        ng02 = k1*k2*k3
        ng2 = ng02
        nda = nda + ng02
        allocate(w_ocn(ng02*nsp),co_rv(ng02*nsp))
        call dcopy(ng02*nsp,dreal(smrnew), 1, w_ocn,1)
        call dcopy(ng02*nsp,dreal(smrho),  1, co_rv,1)
cccccccccccccccccccccccc
        wgtsmooth=1d0/ng02**0.5d0 !try this relative weight. Not correct weight charge mixing.
        if(iprint()>10) print *,'wgtsmooth=',wgtsmooth
cccccccccccccccccccccccc
        w_ocn= w_ocn*wgtsmooth !
        co_rv= co_rv*wgtsmooth !
      else
C ... 8. FFT smooth densities -> rho(G) for mixing
C ... Find and include number of smooth mesh points.
        allocate(ips0_iv(ng))
        call lgstar ( 0 , ng , 1 , rv_a_ogv , ng0 , ips0_iv , iwdummy )
        ng02= ng0*2
        ng2=ng*2
        nda = nda + ng02
        allocate(w_ocn(2*ng*nsp),co_rv(ng*2*nsp))
        allocate(w_owk(kkk*nsp))
        call dpcopy(smrnew,w_owk,1,kkk*2*nsp,1d0)
        call fftz3(w_owk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
        call gvgetf ( ng , nsp , iv_a_okv , k1 , k2 , k3 , w_owk, w_ocn)
        call lgstar ( 1 , ng , nsp , rv_a_ogv , i , ips0_iv , w_ocn)
        call dpcopy(smrho,w_owk,1,kkk*2*nsp,1d0)
        call fftz3(w_owk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
        call gvgetf ( ng , nsp , iv_a_okv , k1 , k2 , k3 , w_owk, co_rv)
        call lgstar ( 1 , ng , nsp , rv_a_ogv , i , ips0_iv , co_rv)
        deallocate(w_owk)
      endif
c



c      call defrr(oa,-nda*nsp*(mxsav+2)*2)
      allocate(w_oa(nda*nsp*(mxsav+2)*2))
      w_oa=0d0

C ... Allocate memory for coffs to G_kL expansion of rho
c      oqkl = 1
c      if (locmix .ge. 2) call defcc(oqkl,-(kmxr+1)*nlm0*nsp*4*nbas)
      if(locmix .ge. 2) then
        allocate(w_oqkl(2*(kmxr+1)*nlm0*nsp*4*nbas))
        w_oqkl=0d0
      else
        allocate(w_oqkl(1))
      endif


C --- 9. Read prior iterations from disk; update with current iter ---
      if (procid .eq. master) then
         ifi=ifile_handle()
         open(ifi,file=trim(fnam)//'.'//trim(sname),form='unformatted')
c        ifi = fopna(fnam,-1,4)
c        rewind ifi
      endif
      call MPI_BCAST(ifi,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
      if (mlog) then
        call gettime(datim)
        call awrit3(' mixrho '//datim//' Process %i of %i on '
     .  //shortname(procid)(1:namelen(procid))//
     .  ' bcast ifi = %i',' ',256,stml,procid,numprocs,ifi)
      endif
C     NB: For now, nx must be zero
      k9 = 10
      call pvmix5 ( nmix , mxsav , fnam , ifi , .true. , rmsdel , locmix 
     .  , k9 , nbas , kmxr , nlm0 , ssite , sspec , nsp , sv_p_orhold
     .  , sv_p_orhnew , co_rv , w_ocn , ng2 , ng02 , (/0/) , nda , w_oa , w_oqkl 
     .     , rms2 , nmixr )
      rmsdel = rms2
      nmix = min(nmix,nmixr)
C ... Write this and prior iterations onto disk
      call pvmix5 ( nmix , mxsav , fnam , - ifi , .true. , rmsdel , 
     .  locmix , k9 , nbas , kmxr , nlm0 , ssite , sspec , nsp , sv_p_orhold
     .  , sv_p_orhnew , co_rv , w_ocn , ng , ng02 , (/0/) , nda , w_oa , w_oqkl 
     .  , rms2 , nmixr )
      if (nkill .lt. 0) then
        if(ipr>=20) then
          sout = ' ...  deleting file '//fnam
          write(stdo,"(a,i5)") trim(sout)//" nkill=",nkill
        endif
        close(ifi,status='delete')
      else  
        close(ifi)  
      endif

C --- Printout smooth density mixing data ---
      if (nnnew+nnmix.gt.0 .and. ipr.ge.20) call awrit2(
     .' mixrho: (warning) scr. and lin-mixed densities had'//
     .' %i and %i negative points',' ',80,stdo,nnnew,nnmix)
      call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qscr)
C     if (ipr .gt. 30) write(stdo,100)
C    .  sumo*fac,sumu*fac,sums*fac,rms,summ*fac
      if (ipr >45) then
        write(stdo,100)
     .  qin(1),qout(1),qscr(1),rms,beta*qscr(1)+(1-beta)*qin(1)
        if (nsp .eq. 2) write(stdo,101)
     .  qin(2),qout(2),beta*qscr(2)+(1-beta)*qin(2)
      endif
  100 format(' charges:',7x,'old',11x,'new',9x,'screened',
     .6x,'rms diff',7x,'lin mix'/' smooth ',5f14.6)
  101 format(' mmom   ',2f14.6,28x,f14.6)

C --- 10. Linear mixing of local densities  ---
      call pvmix3 ( ssite , sspec , nbas , nsp , beta , locmix , wt 
     .  , kmxr , nlm0 , k9 , w_oqkl , sv_p_orhold , sv_p_orhnew , difx 
     .  )
      difxu = difx




!!== Main Mixing part ==
!!=== 11. Spin polarized case: separate weighting for spin channels ===
      if (nsp .eq. 2 .or. nx .gt. 0) then
        if (wt(2).ne.0 .and. nsp.eq.1)
     .  call rx1('mixrho wt(2)=%d invalid when nsp=1',wt(2))
C       Map to ASA call:
C             dim. of a     extra    #-mix   #-elts/spin  dim of aa
C       ASA    nda           nx      naa      npq            naa
C       FP     nda*nsp       0       naa      nda            naa
        if (nx .gt. 0) call rx('mixrho not ready for nx=0')
        naa = 0
        if (wt(1) .ne. 0) naa = naa+nda
        if (wt(2) .ne. 0) naa = naa+nda
        if (wt(3) .ne. 0) naa = naa+nx
        offx = 0                !offset to extra elements (none now)
        off2 = (nsp-1)*nda      !offset to spin down part of a
c        call defdr(oaa,-naa*(mxsav+2)*2)
        allocate(w_oaa(naa*(mxsav+2)*2))
        w_oaa=0d0
        call pqsclf(0,nda*nsp,nda,offx,off2,nx,naa,mxsav,wt,
     .  w_oa,w_oaa,rms2f)
        if (wt(1)*wt(2) .ne. 0) then
C          rms2f = rms2f * 2
        else
          call info2(20,0,0,' Constrained spin mixing, wt =%2:1;5d.'//
     .    '  Constrained rms DQ=%1,3;3e',wt,rms2f)
          rmsdel = rms2f
        endif
!!=== 12. Mix the soup of densities ===
        beta0 = beta
        call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oaa)
!!=== 13. Restore matrix a to rho+, rho===
c       if (nsp .eq. 2 .or. nx .gt. 0) then
        call pqsclb(nda*nsp,nda,offx,off2,nx,naa,mxsav,wt,w_oa,w_oaa)
        call pqsclc(nda*nsp,nda*nsp,nx,mxsav,w_oa)
c       call rlse(oaa)
        deallocate(w_oaa)
c       endif
      else
c        oaa = oa
        naa = nda
!!=== 12. Mix the soup of densities ===
        beta0 = beta
        call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oa)
      endif
C ... 14. Poke mixed smooth and local densities into smrho,rhoold
c      call defcc(owk,kkk)
      allocate(w_owk(kkk))
      call pvmix7 ( ssite , sspec , nbas , nsp , nda , w_oa , n1 , 
     .   n2 , n3 , k1 , k2 , k3 , locmix , wt , k9 , kmxr , nlm0 , w_oqkl
     .   , ng , ng2, ng02 , iv_a_okv , ips0_iv , rv_a_ogv , co_rv , w_owk , 
     .   sv_p_orhold , smrho, wgtsmooth )
      deallocate(w_oqkl)
      deallocate(w_owk,w_oa)
      if (allocated(co_rv)) deallocate(co_rv)
      deallocate(w_ocn)
      if (allocated(ips0_iv)) deallocate(ips0_iv)
C ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-'
      call dpzero(qmix,2)
      do  ib = 1, nbas
        is = int(ssite(ib)%spec)

        a=sspec(is)%a
        nr=sspec(is)%nr
        rmt=sspec(is)%rmt

        lmxl=sspec(is)%lmxl
        rsmv=sspec(is)%rsmv
        kmxv=sspec(is)%kmxv

        if (lmxl .lt. 0) cycle
        nlml = (lmxl+1)**2
        if (nlml.gt.nlm0) call rxi('mixrho: nlml.gt.nlm0, need',nlml)
        allocate(rofi_rv(nr))
        allocate(rwgt_rv(nr))
        call radmsh ( rmt , a , nr , rofi_rv)
        call radwgt ( rmt , a , nr , rwgt_rv)

        call pvmix9 ( 1 , - 1 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , 
     .   sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


        call pvmix9 ( 1 , - 1 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , 
     .   sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )

C       debugging
C        print *, 'ib=',ib
C        call prrmsh('1 final',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C        call prrmsh('2 final',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

C   ... Add net local charge to qmix
        do  i = 1, nsp
          off2 = 1 + nr*nlml*(i-1)
          allocate(wk1_rv(nr))
          allocate(wk2_rv(nr))
          call dpscop ( sv_p_orhold( 1 , ib )%v , wk1_rv , nr , off2 , 
     .     1 , 1d0 )


          call dpscop ( sv_p_orhold( 2 , ib )%v , wk2_rv , nr , off2 , 
     .     1 , 1d0 )


          qmx = srfpi * ( ddot ( nr , wk1_rv , 1 , rwgt_rv , 1) 
     .    - ddot ( nr , wk2_rv , 1 , rwgt_rv , 1))

C         print *, 'spin, qmx',i,qmx
          if (i .eq. 2) qmix(2) = qmix(2) + qmx-q1
          q1 = qmx
          qmix(1) = qmix(1) + qmx
          if (allocated(wk2_rv)) deallocate(wk2_rv)
          if (allocated(wk1_rv)) deallocate(wk1_rv)

        enddo

        if (allocated(rwgt_rv)) deallocate(rwgt_rv)
        if (allocated(rofi_rv)) deallocate(rofi_rv)

      enddo                     !Loop over sites

C ... Force density positive
C     call rhopos(smrho,k1,k2,k3,n1,n2,n3)

C ... Net interstitial charge and cell charge
      summ = 0
      do    i = 1, nsp
      do    i3 = 1, n3
      do    i2 = 1, n2
      do    i1 = 1, n1
C       smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + .001
         summ = summ + dble(smrho(i1,i2,i3,i))
      enddo
      enddo
      enddo
      enddo
C     Net system charge
      qcell  = qval - summ*fac - qmix(1)

C     Add constant to smrho to force charge neutrality
      xx = qcell/(vol*nsp)
      summ = 0

cccccccccccccccccccccccccc
      if(iprint()>10) write(6,"(a,d13.5,d13.5)")' mixrho: add corrections to qcell smrho =',qcell,xx
c       print *,'vvv no xx test'
c       xx=0d0
ccccccccccccccccccccccccc
      do    i  = 1, nsp
      do    i3 = 1, n3
      do    i2 = 1, n2
      do    i1 = 1, n1
         smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + xx
      enddo
      enddo
      enddo
      enddo
C       summ = summ + dble(smrho(i1,i2,i3,i))
C     qcell  = qval - summ*fac - qmix(1)
C     print *, 'qcell after shift',qcell; stop

C --- Clean up ---
      if (nmix .lt. 0) dmxp(7) = -nmix
      if (beta0 .ne. beta) dmxp(2) = beta
      dmxp(11) = rmsdel
      dmxp(12) = difx
      dmxp(13) = iabs(nmix)
      dmxp(14) = broy
      dmxp(15) = beta
      if (broy .eq. 1) dmxp(15) = 1
      dmxp(25) = 0
      if (wt(1) .ne. 0 .or. wt(2) .ne. 0) dmxp(25) = 1
      if (wt(3) .ne. 0) dmxp(25) = dmxp(25) + 10

C ... Printout
      if (ipr .ge. 10 .and. abs(qcell) .gt. 1d-6) write(stdo,
     .'('' add q='',f10.6,'' to preserve neutrality'')') qcell

      if (ipr .ge. 30) then
        if (elinl .ne. 0) then
          write(stdo,450) ' unscreened ',rmsuns,difxu
          write(stdo,450) '   screened ',rms,difx,rmsdel
  450     format(a,'rms difference:  smooth',f10.6,'   local',f10.6:
     .   '   tot',f10.6)
        endif
      elseif (ipr .ge. 20) then
        call awrit3(' rms smooth dq=%;3g  max local dq=%;3g  dq=%;3g',
     .  ' ',80,stdo,rms,difx,rmsdel)
      endif
      if (ipl .gt. 0 .and. ipr .gt. 0) then
        call awrit6('%xfp %?;n;elind %;4g  ;%j;'//
     .  '%?#(n==1)#Broyden n %1i wc %;3g#%2j#%-3j'//
     .  '%?#(n==0)#Anderson n %i beta %j%;3g#%3j#',
     .  sout,80,0,isw(elinl.ne.0),elinl,broy,nmix,wc,beta)
        call awrit3('%a  sm-dq %;3g  mx loc %;3g  dq %;3g',sout,80,
     .  -stdl,rms,difx,rmsdel)
      endif

C      call zprm3('exit sm rho, spin1',0,smrho(1,1,1,1),k1,k2,k3)
C      call zprm3('exit sm rho, spin2',0,smrho(1,1,1,2),k1,k2,k3)

      call tcx('mixrho')
C     print *, '!!' ; call poppr
C     stop 'for now'
      nnnew = 0
      nnmix = 0
      do  i3 = 1, n3
        do  i2 = 1, n2
          do  i1 = 1, n1
            sumo = sumo + dble(smrho(i1,i2,i3,1))
            sums = sums + dble(smrnew(i1,i2,i3,1))
            dif = dble(smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1))
            rms = rms + dif*dif
            top = dmax1(top,dabs(dif))
            xxc = beta*smrnew(i1,i2,i3,1) + (1d0-beta)*smrho(i1,i2,i3,1)
            if (dble(smrnew(i1,i2,i3,1)) .lt. 0) nnnew = nnnew+1
            if (dble(xxc) .lt. 0) nnmix = nnmix+1
c       smrho(i1,i2,i3) = xxc
            summ = summ + dble(xxc)
          enddo
        enddo
      enddo

cccccccccccccccccccccccccccccccccccc
      do isp=1,nsp
        nnnx = 0
        smmin=1d0
        do i1=1,k1
          do i2=1,k2
            do i3=1,k3
c         print *,i1,i2,i3,isp
c         print *,i1,i2,i3,isp,smrho(i1,i2,i3,isp)
              sss=dreal(smrho(i1,i2,i3,isp))
              if(sss<0d0) then
                nnnx=nnnx+1
                if(sss<smmin) then
                  smmin=sss
                endif
c            smrho(i1,i2,i3,isp)=minimumrho
              endif
            enddo
          enddo
        enddo
        if(nnnx>0) then
          write(6,"(a,2i8,d13.5)") ' mixrho: warning. negative smrho; isp number min=',isp,nnnx,smmin
c          print *,'enforce smrho >',minimumrho
        else
          if(iprint()>45) write(6,"(a,i3)") ' mixrho: all smrho are positive for isp=',isp
        endif
      enddo
C$$$      nnnew=0
C$$$c      open(1898,file='test3vvv')
C$$$      do  i3 = 1, k3
C$$$        do  i2 = 1, k2
C$$$          do  i1 = 1, k1
C$$$c        write(1898,"(3i5,2d13.5)")i1,i2,i3,smrho(i1,i2,i3,1)
C$$$            if (dreal(smrho(i1,i2,i3,1)) .lt. 0) nnnew = nnnew+1
C$$$          enddo
C$$$        enddo
C$$$      enddo
C$$$c      close(1898)
C$$$c      print *,'mixrho: sum smrho output=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
C$$$      write(6,"(a,3d13.6,i8)")
C$$$    & ' mixrho: sum smrho output=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
c      nnnew=0
c      do  i3 = 1, k3
c      do  i2 = 1, k2
c      do  i1 = 1, k1
c        if(dreal(smrho(i1,i2,i3,1))<1d-10) smrho(i1,i2,i3,1)=1d-10
c        if (dreal(smrho(i1,i2,i3,1)) .lt. 0) nnnew = nnnew+1
c      enddo
c      enddo
c      enddo
c      print *,'vvv mixrho sum smrho output 222=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
ccccccccccccccccccccccccccccccccc
      end subroutine mixrho





      subroutine pvmix3 ( ssite , sspec , nbas , nsp , beta , locmix 
     .  , wt , kmxr , nlm0 , k9 , qkl , sv_p_orhold , sv_p_orhnew , difx 
     .  )



      use m_struc_def  !Cgetarg

C- Linearly mix local densities, possibly subtracting G_kL expansion
C ----------------------------------------------------------------------
Ci Inputs
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: spec
Ci     Stored:    *
Ci     Passed to: *
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: a nr rmt rg lmxl
Ci     Stored:    *
Ci     Passed to: *
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   beta  :linear mixing parameter
Cl Local variables
Cl   locmix :governs linear transformation of local densities for mixing
Cl          :see description in Local variables, routine mixrho.
Ci   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
Ci   nlm0   :second dimension of qkl
Ci   qkl    :(locmix>=2) G_kL expansion of local densities
Ci          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
Ci          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
Ci          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
Ci          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
Cio Inputs/Outputs
Cio  orhold :On input, local densities generating hamiltonian
Cio         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Cio         :If a G_kL expansion has been generated (if locmix>=2)
Cio         :this expansion is first subtracted from w(orhold).
Cio         :On output, w(orhold) is overwritten by the linear
Cio         :combination (1-beta)*w(orhold) + beta*w(orhnew)
Cio  orhnew :On input, local densities gen. by ham. (maybe screened)
Cio         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Cio         :If a G_kL expansion has been generated (if locmix>=2)
Cio         :this expansion is first subtracted from w(orhnew).
Co Outputs
Co   difx   :maximum rms difference in rhonew-rhoold
Cr Remarks
Cr
Cu Updates
Cu   21 Nov 01 First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nbas,nsp,kmxr,nlm0,locmix,k9
      type(s_rv1) :: sv_p_orhold(3,nbas)

      type(s_rv1) :: sv_p_orhnew(3,nbas)

ckino wt(3)      real(8):: difx , beta , wt(2) , qkl(0:kmxr,nlm0,nsp,4,nbas)
      real(8):: difx , beta , wt(3) , qkl(0:kmxr,nlm0,nsp,4,nbas)
      type(s_site)::ssite(*)
      type(s_spec)::sspec(*)

C ... Local parameters
      integer ib,is,igetss,nr,nlml,m,lmxl,k9l
      integer::  i !orsm(4) ,
      real(8) ,allocatable :: ri_rv(:)
      real(8) ,allocatable :: rwgt_rv(:)
      double precision a,rmt,rg,difa,rf
C ... Heap
      real(8),allocatable:: w_orsm(:,:)
      real(8):: wdummy

      difx  = 0
      do  ib = 1, nbas
        is = int(ssite(ib)%spec)

        a=sspec(is)%a
        nr=sspec(is)%nr
        rmt=sspec(is)%rmt
        rg=sspec(is)%rg

        lmxl = int(sspec(is)%lmxl)

        if (lmxl .eq. -1) goto 10
        nlml = (lmxl+1)**2
        allocate(ri_rv(nr))
        allocate(rwgt_rv(nr))
        call radmsh ( rmt , a , nr , ri_rv)
        call radwgt ( rmt , a , nr , rwgt_rv)
        rf = rmt/3
c
        if (locmix .ge. 2) then
          allocate(w_orsm(nr*nlml*nsp,4))
        else
          allocate(w_orsm(1,4)) !dummy
        endif

        do  m = 1, 4
          if (locmix .ge. 2) then
C           Generate on a mesh the smooth density to be subtracted
c            call defrr(orsm(m),nr*nlml*nsp)
            i = 1001
            if (wt(1) .eq. 0) i = 11001
            if (wt(2) .eq. 0) i = 21001
            call pkl2ro ( i , 1 , rg , kmxr , nr , nlml , nsp , ri_rv 
     .      , rwgt_rv , kmxr , nlm0 , wdummy , qkl ( 0 , 1 , 1 , m , ib) , 
     .      w_orsm(1,m) , wdummy , difa)

C           Undo scaling of rho1+rho2 for linear mix
            if (locmix .eq. 3 .and. (m .eq. 2 .or. m .eq. 4)) then
C             qlk(1,2) -> scaled rho1+rho2, rho1-rho2
C             qkl(3,4) -> scaled rhn1+rhn2, rhn1-rhn2
C             if (m .eq. 2) print *, m, 'old'
C             if (m .eq. 4) print *, m, 'new'
C             call prrmsh('scaled rhosm1+2 from qkl',w(ori),w(orsm(m-1)),
C     .         nr,nr,nlml*nsp)
C             call prrmsh('scaled rhosm1-2 from qkl',w(ori),w(orsm(m)),
C     .         nr,nr,nlml*nsp)
              k9l = k9 - mod(k9,10)
              call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , ri_rv 
     .        , w_orsm(1,m-1) , w_orsm(1,m))
C             call prrmsh('unscaled rhosm1+2',w(ori),w(orsm(m-1)),
C     .         nr,nr,nlml*nsp)
C             call prrmsh('unscaled rhosm1-2',w(ori),w(orsm(m)),
C     .         nr,nr,nlml*nsp)
            endif
          else
            w_orsm(1,m) = 1
          endif
        enddo

C   ... Constraints on rnew, smoothed rho
C        i = 10
C        if (wt(1) .eq. 0) i = 110
C        if (wt(2) .eq. 0) i = 210
C        call pvmix8(i,nr,nlml,nsp,w(orhnew(1,ib)),w(orhnew(2,ib)))
C        call pvmix8(i,nr,nlml,nsp,w(orsm(1)),w(orsm(2)))
C        call pvmix8(i,nr,nlml,nsp,w(orsm(3)),w(orsm(4)))

C   ... Linear mix, this site
        call pvmix4 ( nr , nlml , nsp , ri_rv , locmix , wt , beta , 
     .    ib , w_orsm ( 1 , 1 ) , w_orsm ( 1 , 2 ) , w_orsm ( 1 , 3 ) , 
     .    w_orsm ( 1 , 4 ) , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v 
     .    , sv_p_orhold( 3 , ib )%v , sv_p_orhnew ( 1 , ib ) %v , sv_p_orhnew 
     .    ( 2 , ib ) %v , sv_p_orhnew ( 3 , ib ) %v , rwgt_rv , difa )



        difx  = dmax1(difx,difa)

        if (allocated(rwgt_rv)) deallocate(rwgt_rv)
        if (allocated(ri_rv)) deallocate(ri_rv)
Cki#error, rlse?  orsm = ['orsm(4)', 'integer']
c        call rlse(orsm(1))
        deallocate(w_orsm)
   10   continue
      enddo
      end subroutine pvmix3


      subroutine pvmix4(nr,nlml,nsp,ri,locmix,wt,beta,ib,
     .rhos1,rhos2,rhns1,rhns2,
     .rho1,rho2,rho3,rhn1,rhn2,rhn3,rwgt,dif)

C- Linear mixing of local densities for one site
C ----------------------------------------------------------------------
Ci Inputs
Ci   nr    :number of radial mesh points
Ci   nlml  :L-cutoff for rho1,rho2
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ri    :radial mesh points
Ci   locmix:>2 => work with difference rho-rhos
Ci   beta  :Linear mixing beta
Ci   ib    :site index (printout only)
Ci   rhos1 :input local true density, G_kL expansion
Ci   rhos2 :input local smoothed density, G_kL expansion
Ci   rhns1 :output local true density, G_kL expansion
Ci   rhns2 :output local smoothed density, G_kL expansion
Ci   rho1  :input local true density (generates output rho)
Ci   rho2  :input local smoothed density (generates output rho)
Ci   rho3  :input core charge (generates output rho)
Ci   rhn1  :output local true density (generated by input rho)
Ci   rhn2  :output local smoothed density (generated by input rho)
Ci   rhn3  :output core charge (generated by input rho)
Ci   rwgt  :radial mesh weights
Co Outputs
Co   dif   :integral (rho_out - rho_in)**2
Co   rho1,rho2,rho3 are overwritten by the linearly mixed densities
Cr Remarks
Cu Updates
Cu   09 Dec 08 Suppress q,moment mixing when wt(1) or wt(2) is zero
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nr,nlml,nsp,ib,locmix
      double precision dif,beta,wt(3)
      double precision ri(nr),rwgt(nr),
     .rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rho3(nr,nsp),
     .rhn1(nr,nlml,nsp),rhn2(nr,nlml,nsp),rhn3(nr,nsp),
     .rhos1(nr,nlml,nsp),rhos2(nr,nlml,nsp),
     .rhns1(nr,nlml,nsp),rhns2(nr,nlml,nsp)
C ... Local parameters
      integer i,ir,iprint,np,npc
      double precision pi,srfpi,vsph,ddot,qnew,qold,qmix,rmt,
     .amnew,amold,amix

C      print *, 'start of pvmix4'
C      call prrmsh('rho1',ri,rho1,nr,nr,nlml*nsp) ! rho1+rho2
C      call prrmsh('rho2',ri,rho2,nr,nr,nlml*nsp) ! rho1-rho2
C      call prrmsh('rhn1',ri,rhn1,nr,nr,nlml*nsp) ! rhscr1+rhscr2
C      call prrmsh('rhn2',ri,rhn2,nr,nr,nlml*nsp) ! rhscr1-rhscr2
C
C      call prrmsh('rhos1',ri,rhos1,nr,nr,nlml*nsp) ! rhos1+rhos2
C      call prrmsh('rhos2',ri,rhos2,nr,nr,nlml*nsp) ! rhos1-rhos2
C      call prrmsh('rhns1',ri,rhns1,nr,nr,nlml*nsp) ! rhscrs1+rhscrs2
C      call prrmsh('rhns2',ri,rhns2,nr,nr,nlml*nsp) ! rhscrs1-rhscrs2


C ... Setup
c      stdo = lgunit(1)
      pi = 4d0*datan(1d0)
      srfpi = dsqrt(4d0*pi)
      rmt = ri(nr)

C ... rho+,rho- -> rho,amag  and some integrated quantities
      call splrho(0,nsp,nr,nlml,rho1,rho2,rho3)
      call splrho(0,nsp,nr,nlml,rhn1,rhn2,rhn3)
C      qnew = srfpi*(ddot(nr,rhn1,1,rwgt,1) - ddot(nr,rhn2,1,rwgt,1))
C      qold = srfpi*(ddot(nr,rho1,1,rwgt,1) - ddot(nr,rho2,1,rwgt,1))
C      amnew = srfpi*(ddot(nr,rhn1(1,1,nsp),1,rwgt,1) -
C     .               ddot(nr,rhn2(1,1,nsp),1,rwgt,1))
C      amold = srfpi*(ddot(nr,rho1(1,1,nsp),1,rwgt,1) -
C     .               ddot(nr,rho2(1,1,nsp),1,rwgt,1))
      qnew = srfpi*ddot(nr,rhn2,1,rwgt,1)
      qold = srfpi*ddot(nr,rho2,1,rwgt,1)
      amnew = srfpi*ddot(nr,rhn2(1,1,nsp),1,rwgt,1)
      amold = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

      dif = 0
      do  i  = 1, nsp
        if (wt(1) .eq. 0 .and. i .eq. 1) cycle
        if (wt(2) .eq. 0 .and. i .eq. 2) cycle
        do  ir = 1, nr
          dif  = dif + rwgt(ir)*(rhn2(ir,1,i)-rho2(ir,1,i))**2
        enddo
      enddo
      vsph = (4d0*pi/3d0)*rmt**3
      dif = dsqrt(dif/vsph)

C --- Overwrite rho with (1-beta)*rho + beta*rhn ---
C     wt(1)=0 => only mix spin part (set i=2)
C     wt(2)=0 => only mix charge part (set i=1)
      np = nr*nlml*nsp
      i = 1
      if (wt(1) .eq. 0) then
        np = nr*nlml
        i = 2
      elseif (wt(2) .eq. 0) then
        np = nr*nlml
        i = 1
      endif
      call dscal(np,1-beta,rho1(1,1,i),1)
      call daxpy(np,beta,rhn1(1,1,i),1,rho1(1,1,i),1)
      call dscal(np,1-beta,rho2(1,1,i),1)
      call daxpy(np,beta,rhn2(1,1,i),1,rho2(1,1,i),1)
      npc = nr*nsp
      if (wt(1) .eq. 0 .or. wt(2) .eq. 0) npc = nr
      call dscal(npc,1-beta,rho3(1,i),1)
      call daxpy(npc,beta,rhn3(1,i),1,rho3(1,i),1)

C ... Charges and mag. moments of mixed density
      qmix = srfpi*(ddot(nr,rho2,1,rwgt,1))
      if (nsp .eq. 2) amix = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

C --- Subtract smoothed (1-beta)*rhos + beta*rhns ---
      if (locmix .ge. 2) then
        call splrho(20,nsp,nr,nlml,rhos1,rhos2,rho3)
        call splrho(20,nsp,nr,nlml,rhns1,rhns2,rhn3)
        np = nr*nlml*nsp
        call daxpy(np,-(1-beta),rhos1,1,rho1,1)
        call daxpy(np,-beta,rhns1,1,rho1,1)
        call daxpy(np,-(1-beta),rhos2,1,rho2,1)
        call daxpy(np,-beta,rhns2,1,rho2,1)
        call splrho(21,nsp,nr,nlml,rhos1,rhos2,rho3)
        call splrho(21,nsp,nr,nlml,rhns1,rhns2,rhn3)
      endif

C ... Restore rho,amag -> rho+,rho-
      call splrho(1,nsp,nr,nlml,rho1,rho2,rho3)
      call splrho(1,nsp,nr,nlml,rhn1,rhn2,rhn3)

      if (iprint() >45 ) then
        write(stdo,100) ib,qold,qnew,qnew,dif,qmix
  100   format(' site ',i4,f12.6,5f14.6)
C  100   format(' site ',i4,f12.6,f14.6,14x,2f14.6)
        if (nsp .eq. 2) write(stdo,101) amold,amnew,amix
  101   format(' mmom   ',2f14.6,28x,f14.6)
      endif

C       print *, 'end of pvmix4'
C       call prrmsh('rho1 after lin mix',ri,rho1,nr,nr,nlml*nsp)
C       call prrmsh('rho2 after lin mix',ri,rho2,nr,nr,nlml*nsp)

      end subroutine pvmix4


      subroutine pvmix5 ( nmix , mxsav , fnam , ifi , lbin , rmsdel 
     .  , locmix , k9 , nbas , kmxr , nlm0 , ssite , sspec , nsp , sv_p_orhold 
     .  , sv_p_orhnew , co , cn , ng2 , ng02 , cnst , nda , a , qkl , rms2 
     .  , nmixr )



      use m_struc_def  !Cgetarg

C- Copy rho into holding array, read prior iterations from disk
C ----------------------------------------------------------------------
Ci Inputs
Ci   nmix  :number of prior iterations sought (for printout)
Ci   mxsav :max no. prior iteration to read, also dimensions a
Ci   fnam  :file name (for printout)
Ci   ifi   :file logical unit; sign delineates whether copying into
Ci         :or out of holding array
Ci   lbin  :T if binary read
Ci  rmsdel :Same as rms2 (see Outputs), from prior iteration.
Ci         :If no prior iteration, rsmdel=0.  For printout only.
Ci  locmix :switch governing linear transformation of local densities
Ci          for mixing; see Local variables in subroutine mixrho.
Ci  nbas   :size of basis
Ci  ssite  :struct for site-specific information; see routine usite
Ci     Elts read: spec
Ci     Stored:    *
Ci     Passed to: rhogkl
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: a nr rmt lmxl
Ci     Stored:    *
Ci     Passed to: rhogkl
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   orhold:input local density this iteration,
Ci         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Ci   orhnew:output local density this iteration,
Ci         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
Ci   co    :input smooth density this iteration, in FT form
Ci   cn    :output smooth density this iteration, in FT form
Ci   ng    :leading dimension of co,cn
Ci   ng0   :number of Fourier coefficients
c    ng02=ng0*2 in the mixrealsmooth()=F (original case)
Ci   cnst  :site-dependent vector marking whether to constrain
Ci         :selected mixing (not used here)
Co Inputs/Outputs
Cio  nmixr :(output for ifi>0) number of prior iter read from file
Cio        :(input  for ifi<0) number of prior iter written to file
Cio        :on output number of prior iterations read from file
Cio  a,nda :work array a and leading dimension (nda must be >= na)
Cio         a(*,i,1) holds f(xi) for iteration i-1
Cio         a(*,i,2) holds   xi  for iteration i-1
Co Outputs
Co  qkl    :(locmix>=2) G_kL expansion of local densities
Co         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
Co         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
Co         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
Co         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
Co  rms2   :rms difference in f-x, where f=output density and x the
Co          input density.  f and x include smoothed and local
Co          contributions, with the latter depending on choice of
Co          linear transformation; see locmix above.  Thus, there
Co          is some arbitrariness in rms2.
Cr Remarks
Cr   Content of a(*) = a(*,isp,:,:):
Cr   Case locmix = 0:
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = l=0 part of rho(1), rho(2)
Cr     ... nda = 2*ng0 + 2*nr
Cr   Case locmix = 1:
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
Cr     ... nda = 2*ng0 + 2*nr
Cr   Case locmix = 2
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+(1+kmxr)*nlml) = P_kL expansion of rho1-rho2
Cr     ... nda = 2*ng0 + (1+kmxr)*nlml
Cr   Case locmix = 3
Cr     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
Cr     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
Cr     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
Cr                                             w/ l=0 part zeroed out
Cr     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
C -----------------------------------------------------------------
      implicit none
C ... Passed parameters
#if MPI | MPIK
      include "mpif.h"
      integer procid, master, numprocs, ierr, status(MPI_STATUS_SIZE)
      integer MAX_PROCS
      parameter (MAX_PROCS = 100)
      integer resultlen
      character*(MPI_MAX_PROCESSOR_NAME) name
      character*10 shortname(0:MAX_PROCS-1)
      character*20 ext
      character*26 datim
      integer namelen(0:MAX_PROCS-1)
      double precision starttime, endtime
      character*120 strn
      logical mlog,cmdopt
      integer iunit
      logical readerror
#endif
      logical lbin
      integer ng2,ng02,nda,nmix,mxsav,ifi,nbas,nr,nsp,cnst(0:*),locmix,
     .k9,kmxr,nlm0
      type(s_rv1) :: sv_p_orhold(3,1)

      type(s_rv1) :: sv_p_orhnew(3,1)

      double precision a(nda,nsp,mxsav+2,2),rms2,rmsdel
      real(8):: co(ng2,nsp) , cn(ng2,nsp) , qkl(0:kmxr,nlm0,nsp,4,1)
      type(s_site)::ssite(*)
      type(s_spec)::sspec(*)

      character fnam*8
C ... Local parameters
      integer ib,na,i,j,k,m,np,iprint,nmixr,is,igetss,
     .awrite,off,nlml,lmxl,k9l
      real(8) ,allocatable :: rofi_rv(:)

      logical lcnst,lfdmp,lddump
      double precision ddot,rmt,aat,rf

      character outs*80
C ... Heap

#if MPI | MPIK
      call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr)
      call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr)
      call MPI_GET_PROCESSOR_NAME(name, resultlen, ierr)
      call strcop(shortname(procid),name,10,'.',i)
      namelen(procid) = i-1
      master = 0
      mlog = cmdopt('--mlog',6,0,strn)
#endif

c      stdo = lgunit(1)
      lcnst = cnst(0) .gt. 0

C --- Copy rho to a; calc. RMS error; read prior iter from ifi ---
      if (ifi .gt. 0) then

C   ... FT Mesh density
        na = 1
        do  i = 1, nsp
          call dpcopy(co(1,i),a(na+00,i,1,2),1,ng02,1d0)
          call dpcopy(cn(1,i),a(na+00,i,1,1),1,ng02,1d0)
        enddo
        na = 1 + ng02

C   ... Site densities, depending on locmix
        do  ib = 1, nbas
          is = int(ssite(ib)%spec)


          aat=sspec(is)%a
          nr=sspec(is)%nr
          rmt=sspec(is)%rmt
          lmxl=sspec(is)%lmxl

          if (lmxl .eq. -1) cycle
          rf = rmt/3
          nlml = (lmxl+1)**2
          allocate(rofi_rv(nr))

          call radmsh ( rmt , aat , nr , rofi_rv)


C   ... If site is constrained, freeze density at rhold (not checked)
          if (lcnst) then
            if (cnst(ib) .ne. 0) then
              do  i = 1, nsp
                off = 1+nr*nlml*(i-1)
                call dpscop ( sv_p_orhold( 1 , ib )%v , sv_p_orhnew ( 1 , ib 
     .            ) %v , nr , off , off , 1d0 )


                call dpscop ( sv_p_orhold( 2 , ib )%v , sv_p_orhnew ( 2 , ib 
     .            ) %v , nr , off , off , 1d0 )


              enddo
            endif
          endif

C   --- Copy local densities to mix matrix a, depending on locmix ---

C   ... Overwrite rho1,rho2 with linear transf. according to k9
CXX     mch tmp/rho1 tmp/rho2 -+ out.fe -- -coll 2,18  -px
C        call prrmsh('rhold1',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C        call prrmsh('rhold2',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

C   ... locmix=0,1,3 : copy spherical part of local rho to a
C       NB: Increment na after all actions takend w/ local densities
          if (locmix .le. 1 .or. locmix .eq. 3) then

C         Scaling rho1+rho2, old and new densities
            k9l = k9 - mod(k9,10)
            call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , 
     .       sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


            call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , 
     .       sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )


C         call prrmsh('1 post',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C         call prrmsh('2 post',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
C         Copy (scaled) spherical part of rho1+rho2, rho1-rho2 to a
            do  i = 1, nsp
              off = 1+nr*nlml*(i-1)
              call dpscop ( sv_p_orhold( 1 , ib )%v , a ( na + 00 , i , 1 , 
     .         2 ) , nr , off , 1 , 1d0 )

              call dpscop ( sv_p_orhold( 2 , ib )%v , a ( na + nr , i , 1 , 
     .         2 ) , nr , off , 1 , 1d0 )

              call dpscop ( sv_p_orhnew( 1 , ib )%v , a ( na + 00 , i , 1 , 
     .         1 ) , nr , off , 1 , 1d0 )

              call dpscop ( sv_p_orhnew( 2 , ib )%v , a ( na + nr , i , 1 , 
     .         1 ) , nr , off , 1 , 1d0 )

            enddo

C         Undo scaling transformation of rho1+rho2
C          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),w(orhold(1,ib)),
C     .      w(orhold(2,ib)))
C          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),w(orhnew(1,ib)),
C     .      w(orhnew(2,ib)))
C         call prrmsh('1 rest',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C         call prrmsh('2 rest',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

          endif
C       print *, 'a(nr)'
C       print *, a(na+nr-1,:,1,:)

C   ... locmix>=2 : Make G_kL expansion of rho; copy coffs to a
          if (locmix .ge. 2) then
            do  i = 1, nsp
              call pshpr(iprint()-30)
              call rhogkl ( ib , ib , i , 2 , ssite , sspec , sv_p_orhold , 
     .         kmxr , qkl ( 0 , 1 , i , 1 , ib ) )

              call rhogkl ( ib , ib , i , 3 , ssite , sspec , sv_p_orhold , 
     .         kmxr , qkl ( 0 , 1 , i , 2 , ib ) )

              call rhogkl ( ib , ib , i , 2 , ssite , sspec , sv_p_orhnew , 
     .         kmxr , qkl ( 0 , 1 , i , 3 , ib ) )

              call rhogkl ( ib , ib , i , 3 , ssite , sspec , sv_p_orhnew , 
     .         kmxr , qkl ( 0 , 1 , i , 4 , ib ) )

              call poppr
C           Convert qkl for 2nd spin channel into 2nd channel only,
C           since rhogkl makes expansion combining channels 1+2
              if (i .eq. 2) then
                j = (1+kmxr)*nlm0
C             qkl(nsp=2) -> qkl(nsp=1) - qkl(nsp=2)
                do  m = 1, 4
                  call dpsadd(qkl(0,1,1,m,ib),qkl(0,1,1,m,ib),j,1+j,1,-1d0)
                enddo
              endif

C           locmix=3 : zero out spherical part of G_kL
              if (locmix .eq. 3) then
C             print *, '!! skip zero qkl'
                do  m = 1, 4
                  call dpzero(qkl(0,1,i,m,ib),kmxr+1)
                enddo
              endif

C           locmix=3 : increment index by 2*nr
              if (locmix .eq. 3) na = na + 2*nr

C           Copy qkl into a
              np = (1+kmxr)*nlml
              call dpscop(qkl(0,1,i,1,ib),a(na+00,i,1,2),np,1,1,1d0)
              call dpscop(qkl(0,1,i,2,ib),a(na+np,i,1,2),np,1,1,1d0)
              call dpscop(qkl(0,1,i,3,ib),a(na+00,i,1,1),np,1,1,1d0)
              call dpscop(qkl(0,1,i,4,ib),a(na+np,i,1,1),np,1,1,1d0)

C           locmix=3, : undo increment unless final spin
              if (locmix .eq. 3 .and. i .lt. nsp) na = na - 2*nr

            enddo                 ! end of spin loop
C         call prmx('qkl',qkl,1+kmxr,1+kmxr,nlm0*nsp)
          endif

C       Undo scaling transformation of rho1+rho2
          if (locmix .le. 1 .or. locmix .eq. 3) then
            call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv 
     .       , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


            call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv 
     .       , sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )


C         call prrmsh('1 rest',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C         call prrmsh('2 rest',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
          endif

C   ... Increment index na to a
          if (locmix .le. 1) then
            na = na + 2*nr
          elseif (locmix .ge. 2) then
            na = na + 2*np
          endif

          if (allocated(rofi_rv)) deallocate(rofi_rv)

        enddo                     !Loop over sites
        na = na-1
        if (nda .ne. na) call rx('mixrho: bug in pvmix5')
        na = na*nsp
C       call prmx('a',a,nda,na,1)
        rms2 = dsqrt(dabs(ddot(na,a,1,a,1)     -
     .  2*ddot(na,a,1,a(1,1,1,2),1) +
     .  ddot(na,a(1,1,1,2),1,a(1,1,1,2),1))/(na-0))*nsp
        if (mxsav .eq. 0) return
C   ... File I/O of previous iterations; nmixr is number actually read
        nmixr = 0
#if ! (MPI | MPIK)
        if (lbin) read (ifi,err=131,end=131) nmixr, na
        if (.not. lbin) read (ifi,*,err=131,end=131) nmixr, na
        if (nda*nsp .ne. na) then
          call awrit2(' mixrho:  expecting %i elements but found %i ...'
     .    //' discarding file',' ',80,stdo,nda*nsp,na)
          nmixr = 0
          goto 131
        endif
        k = min(mxsav,nmixr)
        do  130  j = 1, k
          if (lbin) then
            if (.not. lddump(a(1,1,j+1,1),na,ifi)) goto 131
            if (.not. lddump(a(1,1,j+1,2),na,ifi)) goto 131
          else
            if (.not. lfdmp(a(1,1,j+1,1),na,ifi)) goto 131
            if (.not. lfdmp(a(1,1,j+1,2),na,ifi)) goto 131
          endif
          nmixr = j
  130   continue
  131   continue
#else
        readerror = .true.
        if (procid .eq. master) then
          readerror = .false.
          if (lbin) read (ifi,err=311,end=311) nmixr, na
          if (.not. lbin) read (ifi,*,err=311,end=311) nmixr, na
          goto 312
  311     continue
          readerror = .true.
  312     continue
        endif
        call MPI_BCAST(readerror,1,MPI_LOGICAL,
     .  master,MPI_COMM_WORLD,ierr)
        if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on '
     .    //shortname(procid)(1:namelen(procid))//
     .    ' bcast readerror = %l',' ',
     .    256,stml,procid,numprocs,readerror)
        endif
        if (readerror) goto 31
        call MPI_BCAST(nmixr,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
        if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on '
     .    //shortname(procid)(1:namelen(procid))//
     .    ' bcast nmixr = %i',' ',
     .    256,stml,procid,numprocs,nmixr)
        endif
        call MPI_BCAST(na,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
        if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on '
     .    //shortname(procid)(1:namelen(procid))//
     .    ' bcast na = %i',' ',
     .    256,stml,procid,numprocs,na)
        endif
        if (nda*nsp .ne. na) then
          if (procid .eq. master) then
            call awrit2
     .      (' mixrho:  expecting %i elements but found %i ...'
     .      //' discarding file',' ',80,stdo,nda*nsp,na)
          endif
          nmixr = 0
          goto 31
        endif
        k = min(mxsav,nmixr)
        if (procid .eq. master) then
          readerror = .false.
          do  30  j = 1, k
            if (lbin) then
              if (.not. lddump(a(1,1,j+1,1),na,ifi)) readerror = .true.
              if (.not. lddump(a(1,1,j+1,2),na,ifi)) readerror = .true.
            else
              if (.not. lfdmp(a(1,1,j+1,1),na,ifi)) readerror = .true.
              if (.not. lfdmp(a(1,1,j+1,2),na,ifi)) readerror = .true.
            endif
            if (readerror) goto 313
            nmixr = j
   30     continue
        endif
  313   continue
        if (nmixr .gt. 0) then
          call MPI_BCAST(a,nda*nsp*(mxsav+2)*2,MPI_DOUBLE_PRECISION,
     .    master,MPI_COMM_WORLD,ierr)
          if (mlog) then
            call gettime(datim)
            call awrit3(' mixrho '//datim//' Process %i of %i on '
     .      //shortname(procid)(1:namelen(procid))//
     .      ' bcast (mix) a %i d.p. numbers',' ',
     .      256,stml,procid,numprocs,nda*nsp*(mxsav+2)*2)
          endif
        endif
   31   continue
#endif
        if (iprint() .ge. 20) then
          j = awrite('%x mixrho:  sought %i iter from file',
     .    outs,len(outs),0,nmix,0,0,0,0,0,0,0)
          outs(j+2:len(outs)) = fnam
          call awrit2('%a; read %i.  RMS DQ=%1,3;3e',outs,80,0,nmixr,
     .    rms2)
          if (rmsdel .ne. 0)
     .    call awrit1('%a  last it=%1,3;3e',outs,80,0,rmsdel)
          call awrit0('%a',outs,-len(outs),-stdo)
        endif
C       call prm('a after read',a,nda*nsp,nda*nsp,(mxsav+2)*2)

C --- Save iterations on disk ---
      else
#if MPI | MPIK
        if (procid .eq. master) then
#endif
          rewind (-ifi)
          if (lbin) write (-ifi) min(nmix+1,mxsav), nda*nsp
          if (.not. lbin) write (-ifi,*) min(nmix+1,mxsav), nda*nsp
          do  j = 1, min(nmix+1,mxsav)
            if (lbin) then
              call dpdump(a(1,1,j,1),nda*nsp,ifi)
              call dpdump(a(1,1,j,2),nda*nsp,ifi)
            else
              call dfdump(a(1,1,j,1),nda*nsp,ifi)
              call dfdump(a(1,1,j,2),nda*nsp,ifi)
            endif
          enddo
C       call prm('a after write',a,nda*nsp,nda*nsp,(mxsav+2)*2)
#if MPI | MPIK
        endif
#endif
      endif

      end subroutine pvmix5


      subroutine pvmix6(broy,nmix,mmix,mxsav,beta,wc,nda,a)
      use m_amix,only: amix

C- Mixing of the total density
C ------------------------------------------------------------------
Ci  broy   : 0 for Anderson mixing
Ci         : 1 for Broyden mixing
Ci  nmix   : nmix: number of iter to try and mix
Ci  mmix   : number of iterates available to mix
Ci  mxsav  : second dimension of a
Cio Inputs/Outputs
Cio  a     :On input:
Cio         (*,i,1)  output vector for prev. iteration i
Cio         (*,i,2)  input  vector for prev. iteration i
Cio        :On output:
Cio         (*,0,1) and (*,0,2) estimated new vector
Cio         (*,i,1), i>1 destroyed
Cr  Remarks
Cr    Broyden mixing adapted from Duane Johnson.  Notation:
Cr    x^(m): input vector for iteration m
Cr    F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nda,nmix,mmix,mxsav,broy
      double precision beta,a(nda,0:mxsav+1,2)
C ... Local parameters
      integer j,iprint!,amix
      double precision tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
C     integer idamax
C     double precision dval,rmskm(100),rmsmx
      parameter (tjmax = 5d0)

C ... This is the result of linear mixing, q=0 smooth rho
C     sqmix = a(1,0,1)*beta + a(1,0,2)*(1-beta)
      real(8),allocatable:: aaa(:)

C$$$ccccccccccccccccccccccccccccccccccccccccc
C$$$c takao simple mixing test
C$$$      print *,' vvv: takao simple mixing test'
C$$$      allocate(aaa(nda))
C$$$c      aaa = .2d0*a(:,0,1)+.8d0*a(:,0,2)
C$$$c      aaa = .40d0*a(:,0,1)+.6d0*a(:,0,2)
C$$$c      aaa = .9d0*a(:,0,1)+.1d0*a(:,0,2)
C$$$      aaa = 1.d0*a(:,0,1)+.0d0*a(:,0,2)
C$$$c       aaa = .5d0*a(:,0,1)+.5d0*a(:,0,2)
C$$$c      aaa = .8d0*a(:,0,1)+.2d0*a(:,0,2)
C$$$      call dcopy(nda,aaa,1,a(1,0,1),1)
C$$$      call dcopy(nda,aaa,1,a(1,0,2),1)
C$$$      deallocate(aaa)
C$$$      return
C$$$cccccccccccccccccccccccccccccccccccccccccc


C --- Anderson mixing ---
      if (nmix .eq. 0 .or. nmix .eq. 1 .or. broy .eq. 0) then
C ... amix needs f-x for prior iterations
        do  30  j = 1, nmix
          call daxpy(nda,-1d0,a(1,j,2),1,a(1,j,1),1)
   30   continue
c        call query('beta',4,beta)
        nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,a,tj, !norm,kpvt
     .  rms2)
C      if (iprint() .ge. 20) write(stdo,101) strn,rms2,(tj(j), j=1,nmix)
C  101 format(1x,a4,':     rms diff',f10.6:'  tj=',5f8.3)
C     call prm('a out',a,nda,nda,(mxsav+2)*2)
C ... Copy x*=a(*,0,2) to a(*,0,1)
        call dcopy(nda,a(1,0,2),1,a(1,0,1),1)

C --- Broyden mixing, Duane Johnson's approach ---
      elseif (broy .eq. 1) then
        call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
C   ... Copy x*=a(*,0,2) to a(*,0,1)
        call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
      else
        call rx('pvmix6: bad value for broy')
      endif

C ... Add the change relative to linear mixing
C     sqmix = (a(1,0,1) - sqmix)*vol

      end subroutine pvmix6


      subroutine pvmix7 ( ssite , sspec , nbas , nsp , nda , a , n1 
     . , n2 , n3 , k1 , k2 , k3 , locmix , wt , k9 , kmxr , nlm0 , qkl 
     . , ng , ng2, ng02 , kv , ips0 , gv , crho , wk , sv_p_orhold , smrho 
     . ,wgtsmooth)


      use m_struc_def  !Cgetarg

C- Restore mixed density into specific arrays
C ----------------------------------------------------------------------
Ci Inputs
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: spec
Ci     Stored:    *
Ci     Passed to: *
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: a nr rmt lmxl rg
Ci     Stored:    *
Ci     Passed to: *
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   nda   :leading dimension of a
Ci   a     :mixed density from pvmix6, smoothed + local densities
Ci         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
Ci         :If locmix =  0,1, or 3, a contains spherical part on mesh
Ci         :If locmix =  2,3 a full rho, GkL expansion
Ci   n1..3 :FT mesh
Ci   k1..3 :dimensions smrho
Ci   locmix:mixing mode for local densities
Ci   ng    :number of FT G-vectors
Ci   ng0   :condensed number of G vector (excluding hermitian equiv)
Ci   kv    :indices for gather/scatter operations (gvlist.f)
Ci   ips0  :permutation array mapping ng0 vectors to ng vectors (lgstar)
Ci   gv    :list of reciprocal lattice vectors G (gvlist.f)
Ci   crho  :FT coefficients of smrho(G)
Ci   wk    :complex work array of dimension (k1,k2,k3)
Ci   smrho :smooth density that generated the hamiltonian
Ci   orhold:local  density that generated the hamiltonian,
Ci         :a portion of which which has been linearly mixed (pvmix4)
Ci         :orhold(1) contains rho1+rho2;
Ci         :orhold(2) contains rho1-rho2; see pvmix9
Co Outputs
Co   smrho :overwritten by mixed smooth density
Co   orhold:mixed local density is returned, in rho1+rho2,rho10rho2 form
Cr Remarks
Cu Updates
C ----------------------------------------------------------------------
      implicit none
C ... Passed parameters
      integer nsp,n1,n2,n3,k1,k2,k3,ng,ng02,nda,na,nr,nbas,locmix,k9,
     .kv(ng,3),ips0(ng),kmxr,nlm0,ng2
      type(s_rv1) :: sv_p_orhold(3,1)

      real(8):: gv(ng,3) , a(nda,nsp) , qkl(0:kmxr,nlm0,nsp,4,nbas) 
     ., rf , wt(2), wgtsmooth
      type(s_site)::ssite(*)
      type(s_spec)::sspec(*)

      double complex smrho(k1,k2,k3,nsp),wk(k1,k2,k3)
      real(8):: crho(ng2,nsp)
C ... Local parameters
      real(8) ,allocatable :: rofi_rv(:)
      real(8) ,allocatable :: rwgt_rv(:)

      integer ib,is,igetss,i,m,lmxl,nlml,off,np,k9l,orsm(2)
      double precision aat,rmt,rg,xx
C ... Heap
      integer ::iwdummy

      real(8),allocatable:: w_orsm(:,:)
      logical:: mixrealsmooth

C ... Restore mixed smoothed density
      if(mixrealsmooth()) then
        do  i = 1, nsp
          call dscal(ng02,-1d0/wgtsmooth,crho(1,i),1)
          call daxpy(ng02,1d0/wgtsmooth,a(1,i),1,crho(1,i),1)
          call daxpy(k1*k2*k3,1d0,crho(1,i),1,smrho(1,1,1,i),2)
        enddo
      else
        do  i = 1, nsp
C       Add difference of mixed, old to minimize perturbation
ccccccccccccccccc
c        print *,' vvv pvmix7 TEST!!! a=0 test'
c        a=0d0
ccccccccccccccc
          call dscal(ng02,-1d0,crho(1,i),1)
          call daxpy(ng02,1d0,a(1,i),1,crho(1,i),1)
          call lgstar(2,ng,1,gv,m,ips0,crho(1,i))
          call gvputf(ng,1,kv,k1,k2,k3,crho(1,i),wk)
          call fftz3(wk,n1,n2,n3,k1,k2,k3,1,0,1)
          call daxpy(2*k1*k2*k3,1d0,wk,1,smrho(1,1,1,i),1)
        enddo
      endif

C ... Update local densities
      na = 1 + ng02
      k9l = k9 - mod(k9,10)
      do  ib = 1, nbas
        is = int(ssite(ib)%spec)

        aat=sspec(is)%a
        nr=sspec(is)%nr
        rmt=sspec(is)%rmt
        lmxl=sspec(is)%lmxl

        if (lmxl .eq. -1) cycle
        rf = rmt/3
        rg = sspec(is)%rg
        nlml = (lmxl+1)**2
        allocate(rofi_rv(nr))
        allocate(rwgt_rv(nr))
        call radmsh ( rmt , aat , nr , rofi_rv)
        call radwgt ( rmt , aat , nr , rwgt_rv)

C       Scale rho1+rho2 to match scaled spherical parts and sm parts
C       call prrmsh('1 mix7a',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
        call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , 
     .   sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


C       call prrmsh('1 mix7b',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)

C       Overwrite sph. rhold with scaled mixed rho; do not unscale
        if (locmix .le. 1 .or. locmix .eq. 3) then
          do  i = 1, nsp
            off = 1+nr*nlml*(i-1)

            call dpscop ( a ( na + 00 , i ) , sv_p_orhold( 1 , ib )%v , nr 
     .       , 1 , off , 1d0 )

            call dpscop ( a ( na + nr , i ) , sv_p_orhold( 2 , ib )%v , nr 
     .       , 1 , off , 1d0 )

C            call pvmix9(k9l,-1,nr,1,off-1,rf,w(orofi),w(orhold(1,ib)),
C     .        w(orhold(2,ib)))
C          call prrmsh('1 mix7c',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
C          call prrmsh('2 mix7c',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
          enddo
          na = na + 2*nr
        endif

C   ... Mixing mode 2,3: add mixed sm density to existing rhold
        if (locmix .ge. 2) then

C         call prrmsh('1 scale',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
          np = (1+kmxr)*nlml
          allocate(w_orsm(nr*nlml*nsp,2))
          do  m = 1, 2
c            call defrr(orsm(m),nr*nlml*nsp)
            do  i = 1, nsp
              call dpscop(a(na+np*(m-1),i),qkl(0,1,i,m,ib),np,1,1,1d0)
            enddo
            i = 1001
            if (wt(1) .eq. 0) i = 11001
            if (wt(2) .eq. 0) i = 21001
            call pkl2ro ( i , 1 , rg , kmxr , nr , nlml , nsp , rofi_rv , 
     .       rwgt_rv , kmxr , nlm0 , iwdummy , qkl ( 0 , 1 , 1 , m , ib ) 
     .       , w_orsm ( 1 , m ) , iwdummy , xx )

          enddo
C         Don't undo scaling of smoothed density since rho1+rho2 scaled
C          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),
C     .      w(orsm(1)),w(orsm(2)))
C         Add to rhold(1,2)
          call daxpy ( nr * nlml * nsp , 1d0 , w_orsm ( 1 , 1 ) , 1 , sv_p_orhold( 1 , ib )%v 
     .     , 1 )

          call daxpy ( nr * nlml * nsp , 1d0 , w_orsm ( 1 , 2 ) , 1 , sv_p_orhold( 2 , ib )%v 
     .     , 1 )

          deallocate(w_orsm)
c          call rlse(orsm(2))
c          call rlse(orsm(1))
          na = na + 2*np
        endif
C       call prrmsh('1 mix7d',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)

        call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv 
     .   , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )



C      call prrmsh('rho1,mixed',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
C      call prrmsh('rho2,mixed',w(orofi),w(orhold(2,ib)),nr,nr,nlml*nsp)

        if (allocated(rwgt_rv)) deallocate(rwgt_rv)
        if (allocated(rofi_rv)) deallocate(rofi_rv)
Cki  bug fix,  unecessary
Cki         call rlse(orsm(1))

      enddo                     !Loop over sites
      na = na-1
      if (nda .ne. na) call rx('mixrho: bug in pvmix7')

      end subroutine pvmix7


C      subroutine pvmix8(mode,nr,nlml,nsp,rho1,rho2)
CC- Handle possible constraints for change in smooth density
CC ----------------------------------------------------------------------
CCi Inputs
CCi   mode  :a compound of digits :
CCi         :10s digit
CCi         :  0 apply to rho1 only; rho2 is not touched
CCi         :  1 apply to both rho1 and rho2
CCi         :100s digit for spin polarized case
CCi         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
CCi         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
CCi   nr    :number of radial mesh points
CCi   nlml  :L-cutoff for rho1,rho2
CCi   nsp   :2 for spin-polarized case, otherwise 1
CCio Inputs/Outputs
CCio  rho1  :overwritten with constraints controlled by mode
CCio  rho2  :overwritten with constraints controlled by mode
CCr Remarks
CCu Updates
CCu   16 Dec 08 First created
CC ----------------------------------------------------------------------
C      implicit none
CC ... Passed parameters
C      integer mode,nr,nlml,nsp
C      double precision rho1(nr,nlml,nsp),rho2(nr,nlml,nsp)
CC ... Local parameters
C      integer np,mode0,mode1,mode2,i
C      double precision xx
C
CC ... Setup
C      mode0 = mod(mode,10)
C      mode1 = mod(mode/10,10)
C      mode2 = mod(mode/100,10)
C      np = nr*nlml
C      if (mode2 .eq. 0 .or. nsp .ne. 2) return
C
C      i = 20                   ! No core
C      if (mode1 .eq. 0) i = 30 ! No rho2
C      call splrho(i,nsp,nr,nlml,rho1,rho2,xx)
C      if (mode2 .eq. 1) then   ! Zero density
C        call dpzero(rho1(1,1,1),np)
C        if (mode1 .ne. 0) then ! Including rho2
C          call dpzero(rho2(1,1,1),np)
C        endif
C      endif
C      if (mode2 .eq. 2) then   ! Zero spin
C        call dpzero(rho1(1,1,nsp),np)
C        if (mode1 .ne. 0) then ! Including rho2
C          call dpzero(rho2(1,1,nsp),np)
C        endif
C      endif
C      call splrho(i+1,nsp,nr,nlml,rho1,rho2,xx)
C
C      end
      subroutine pvmix9(mode,linv,nr,nlml,off,rf,rofi,rho1,rho2)

C- Transformation of local densities rho1,rho2 for mixing
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :transformation mode; see Remarks
Ci         : mode  transform
Ci         : 1s digit
Ci         : <=0    do nothing
Ci         :  1     rho1 <= rho1+rho2  rho2 <= rho1-rho2
Ci         : 10s digit
Ci         : 10     scale rho1 by gaussian exp(-(r/rf)**2)
Ci         : 20     scale rho1 by gaussian 1/(1+(r/rf)**2)
Ci   linv  :0  forward transform
Ci         :-1 inverse transform
Ci   nr    :number of radial mesh points
Ci   nlml  :number of L channels
Ci   off   :offset to start of first point (0 for first point)
Ci   rf    :factor used in scaling; see mode
Cio Inputs/Outputs
Ci   rho1  :On input, local true density, or the transformation
Ci         :of it if the inverse is to be made
Ci         :On output, some linear combination of rho1,rho2.
Ci   rho2  :On input, local smoothed density, or the transformation
Ci         :of it if the inverse is to be made
Ci         :On output, some linear combination of rho1,rho2
Cr Remarks
Cr   This routine takes as input rho1,rho2 and returns in
Cr   rho1,rho2 some linear combination of them, depending on mode
Cr   If linv=1, the inverse transform is done.
Cu Updates
Cu   18 Nov 01 First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer mode,nr,nlml,linv,off
      double precision rho1(nr,nlml),rho2(nr,nlml),rofi(nr),rf
C ... Local parameters
      integer i,ilm,mode0,mode1
      double precision ri
      logical:: l_dummy_isanrg,isanrg

      if (mode .le. 0) return
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
Ckino isanrg is logical function,       call isanrg(linv,-1,0,'pvmix9:','linv', .true.)
      l_dummy_isanrg=isanrg(linv,-1,0,'pvmix9:','linv', .true.)
Ckino isanrg is logical function,       call isanrg(mode0,0,1,'pvmix9:','1s digit mode', .true.)
      l_dummy_isanrg=isanrg(mode0,0,1,'pvmix9:','1s digit mode', .true.)
Ckino isanrg is logical function,       call isanrg(mode1,0,2,'pvmix9:','10s digit mode', .true.)
      l_dummy_isanrg=isanrg(mode1,0,2,'pvmix9:','10s digit mode', .true.)

C ... Forward
      if (linv .eq. 0) then
        if (mode0 .eq. 1) then
          call dsumdf(nr*nlml,1d0,rho1,off,1,rho2,off,1)
        endif

        if (mode1 .eq. 1) then
          do  ilm = 1, nlml
            do  i = 1, nr
              ri = rofi(i)/rf
              rho1(i+off,ilm) = rho1(i+off,ilm) * exp(-ri**2)
            enddo
          enddo

        elseif (mode1 .eq. 2) then
          do  ilm = 1, nlml
            do  i = 1, nr
              ri = rofi(i)/rf
              rho1(i+off,ilm) = rho1(i+off,ilm) / (1 + ri**2)
            enddo
          enddo
        endif

C ... Inverse
      else
        if (mode1 .eq. 1) then
          do  ilm = 1, nlml
            do  i = 1, nr
              ri = rofi(i)/rf
              rho1(i+off,ilm) = rho1(i+off,ilm) * exp(ri**2)
            enddo
          enddo

        elseif (mode1 .eq. 2) then
          do  ilm = 1, nlml
            do  i = 1, nr
              ri = rofi(i)/rf
              rho1(i+off,ilm) = rho1(i+off,ilm) * (1 + ri**2)
            enddo
          enddo
        endif

        if (mode0 .eq. 1) then
          call dsumdf(nr*nlml,0.5d0,rho1,off,1,rho2,off,1)
        endif

      endif

C      call prrmsh('pvmix9 rho1',rofi,rho1,nr,nr,nlml)
C      call prrmsh('pvmix9,rho2',rofi,rho2,nr,nr,nlml)

      end subroutine pvmix9



      subroutine pqsclf(mode,nda,npq,offx,off2,nx,na,mxsav,wt,a,a2,rms2)
C- Split into (a+ + a-) and (a+ - a-); include extra data
C ------------------------------------------------------------------
Ci Inputs
Ci   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
Ci   nda   :leading dimension of a
Ci   npq   :number of elements to spin-split with wt(1),wt(2)
Ci   offx  :(nx>0)offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data to weight with w3
Ci   na    :dimension of a2 and number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a     :(na,1:2,i,1) output vector for prev. iteration i
Ci         :(na,1:2,i,2) input  vector for prev. iteration i
Co Outputs
Co   a2    :(*,i,1) output charge and moments, scaled by weights
Co         :(*,i,2) input  charge and moments, scaled by weights
Co   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
Cr Remarks
Cr   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
Cr   If wt(1) or wt(2) is zero, a2 holds q or mom only.
Cr   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
C ------------------------------------------------------------------
C     implicit none
      integer mode,nda,npq,nx,mxsav,na,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2),
     .rms2,ddot
      integer is,ia,ja

C      print *, '!!'; wt(1) = 1 ; wt(2) = 1
      ja = 0
      if (wt(1) .eq. 0 .and. wt(2) .eq. 0) goto 11
      do  10  is = 0, mxsav+1
        ja = 0
        do  12  ia = 1, npq

C         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
C           print *, 'hi',ia,wt(1:2)
C           print 987, 'rhold+,-',a(ia,is,2),a(ia+off2,is,2)
C           print 987, 'rhnew+,-',a(ia,is,1),a(ia+off2,is,1)
C  987      format(a,2x,4f12.6)
CC          pause
C         endif

          if (wt(1) .ne. 0 .and. mode .eq. 0) then
            ja = ja+1
C           Given (rhnew+ + rhnew-)*wt(1) ,  (rhold+ + rhold-)*wt(1)
            a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
            a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          elseif (wt(1) .ne. 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia,is,1)*wt(1)
            a2(ja,is,2) = a(ia,is,2)*wt(1)
          endif
          if (wt(2) .ne. 0 .and. mode .eq. 0) then
            ja = ja+1
C           Given (rhnew+ - rhnew-)*wt(2) ,  (rhold+ - rhold-)*wt(2)
            a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
            a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          elseif (wt(2) .ne. 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia+off2,is,1)*wt(2)
            a2(ja,is,2) = a(ia+off2,is,2)*wt(2)
          endif
   12   continue
   10 continue
   11 continue

      if (wt(3) .ne. 0) then
        do  20  ia = 1, nx
          ja = ja+1
          do  22  is = 0, mxsav+1
            a2(ja,is,1) = a(ia+offx,is,1)*wt(3)
            a2(ja,is,2) = a(ia+offx,is,2)*wt(3)
   22     continue
   20   continue
      endif

      rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1)     -
     .2*ddot(na,a2,1,a2(1,0,2),1) +
     .ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))

      if (ja .ne. na) call rx('pqsclf: element mismatch')

      end
      subroutine pqsclb(nda,npq,offx,off2,nx,na,mxsav,wt,a,a2)
C- Undo split into wt1*q and wt2*mom done by pqsclf
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   offx  :offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data
Ci   na    :dimensions a2; number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
Co Outputs
Co   a     :a2 is unscaled and restored into a
Cr Remarks
Cu Updates
Cu   10 Dec 08
C ----------------------------------------------------------------------
C     implicit none
      integer nda,na,npq,nx,mxsav,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),
     .a2(na,0:mxsav+1,2),sum,diff
      integer is,ia,ja

      if (wt(1) .eq. 0 .and. wt(2) .eq. 0) then
        ja = 0
      elseif (wt(1) .ne. 0 .and. wt(2) .ne. 0) then
        do  is = 0, mxsav+1
          ja = 1
          do  ia = 1, npq
C          if ((ia .eq. 3221 .or. ia .eq. -3) .and. is .eq. 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'mxold+,-',
C     .        (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2,
C     .        (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
C            print 987, 'mxnew+,-',
C     .        (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2,
C     .        (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
CC 987       format(a,2x,4f12.6)
CC           pause
C          endif
C         mixed  rhonew+,rhold+
            a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
            a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2
C         mixed  rhonew-,rhold-
            a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
            a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
            ja = ja+2
          enddo
        enddo
        ja = 2*npq
      elseif (wt(1) .ne. 0) then
        diff = 0
        do  ia = 1, npq
          do  is = 0, mxsav+1
            ja = ia+off2
            sum  = a2(ia,is,1)/wt(1)
            diff = (a(ia,is,1) - a(ja,is,1))
            a(ia,is,1) = (sum + diff)/2
            a(ja,is,1) = (sum - diff)/2
            sum  = a2(ia,is,2)/wt(1)
            diff = (a(ia,is,2) - a(ja,is,2))
            a(ia,is,2) = (sum + diff)/2
            a(ja,is,2) = (sum - diff)/2
          enddo
        enddo
        ja = npq
      elseif (wt(2) .ne. 0) then
        do  ia = 1, npq
          do  is = 0, mxsav+1
            ja = ia+npq

C         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'given qold, mixed (+)-(-)',
C     .        (a(ia,is,2) + a(ja,is,2)),a2(ia,is,2)
C            sum  = (a(ia,is,2) + a(ja,is,2))
C            diff = a2(ia,is,2)/wt(2)
C            print 987, 'mixed +,-                ',
C     .        (sum + diff)/2, (sum - diff)/2
C  987       format(a,2x,4f12.6)
C          endif

C         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
            sum  = (a(ia,is,1) + a(ja,is,1))
            diff = a2(ia,is,1)/wt(2)
            a(ia,is,1) = (sum + diff)/2
            a(ja,is,1) = (sum - diff)/2
C         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
            sum  = (a(ia,is,2) + a(ja,is,2))
            diff = a2(ia,is,2)/wt(2)
            a(ia,is,2) = (sum + diff)/2
            a(ja,is,2) = (sum - diff)/2
          enddo
        enddo
        ja = npq
      endif

C --- Extra mixing data ---
      if (wt(3) .ne. 0) then
        do  is = 0, mxsav+1
          do  ia = 1, nx
            a(ia+offx,is,1) = a2(ia+ja,is,1)/wt(3)
            a(ia+offx,is,2) = a2(ia+ja,is,2)/wt(3)
          enddo
        enddo
      endif

      end

      subroutine pqsclc(nda,npq,nx,mxsav,a)
C- Copy a(:,0,2) into a(:,0,1)
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   nx    :number of extra data
Cio Inputs/Outputs
Cio  a     :On input
Cio        :(*,0,1) mixed output vector
Cio        :(*,0,2) mixed input vector
Cio        :On output
Cio        :(*,0,2) -> (*,0,1)
Cr Remarks
Cu Updates
Cu   10 Dec 08 First created
C ----------------------------------------------------------------------
      implicit none
      integer nda,npq,nx,mxsav
      double precision a(nda,0:mxsav+1,2)
      integer is,ia

      is = 0
      do  ia = 1, npq+nx
C        if (a(ia,is,1) .ne. a(ia,is,2)) then
C          call rx('pqsclc: oops')
C        endif
        a(ia,is,1) = a(ia,is,2)
      enddo
C     stop 'here'

      end

      subroutine pqmixa(nda,nmix,mmix,mxsav,beta,rms2,a,tj)
c      use m_lgunit,only:stdo
      use m_amix,only: amix
      use m_ftox
C- Anderson mixing of a vector
Ci  mmix: number of iterates available to mix
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
      implicit none
      integer nda,nmix,mmix,mxsav
      double precision rms2,tj(1),a(nda,0:mxsav+1,2),beta
      integer:: im , imix , jmix , iprint , i1mach !, amix
      real(8) ,allocatable :: norm_rv(:)
      integer ,allocatable :: kpvt_iv(:)
      real(8) ,allocatable :: a_rv(:)

      double precision tjmax
      parameter (tjmax = 10d0)
c heap
c      integer w(1)
c      common /w/ w

C ... default nmix
      if (nmix .lt. 0) nmix = 2
      nmix = min(mmix,nmix)
      allocate(norm_rv(mxsav**2))

      allocate(kpvt_iv(mxsav))

      if (beta .lt. 0) nmix = -nmix
C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix
C ... save PQ array
      allocate(a_rv(nda*(mxsav+2)*2))

      call dcopy ( nda * ( mxsav + 2 ) * 2 , a , 1 , a_rv , 1 )


C ... for iterations 1,2,... amix needs F-x
    1 continue
      do  10  jmix = 1, nmix
        call daxpy(nda,-1d0,a(1,jmix,2),1,a(1,jmix,1),1)
   10 continue

c      call query('beta',4,beta)
      jmix = min(mmix,iabs(imix))
      imix = amix ( nda , jmix , mxsav , 0 , dabs ( beta ) , iprint 
     .( ) , tjmax  , a , tj , rms2 ) !, norm_rv , kpvt_iv

      im = imix
c      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. im)
     .write(stdo,ftox)' (warning) only',mmix,'iter available'
      if (im .ne. imix) then
        call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

        goto 1
      endif
      nmix = imix

C ... Restore PQ array, updating new x
      call dpscop ( a , a_rv , nda , 1 + nda * ( mxsav + 2 ) , 1 
     .+ nda * ( mxsav + 2 ) , 1d0 )

      call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

      if (allocated(a_rv)) deallocate(a_rv)
      if (allocated(kpvt_iv)) deallocate(kpvt_iv)
      if (allocated(norm_rv)) deallocate(norm_rv)


      end
C      subroutine pqmixb(nda,nmix,mmix,mxsav,wc,rms2,a,wctrue)
CC- Broyden mixing of a vector, old style
CC ------------------------------------------------------------------
CCi  mmix: number of iterates available to mix
CCi  a:    (*,i,1)  output values for prev. iteration i
CCi        (*,i,2)  input  values for prev. iteration i
CCio nmix: nmix > 0: number of iter to try and mix
CCi        nmix < 0: use mmix instead of nmix.
CCo  nmix: (abs)  number of iter actually mixed.
CCo        (sign) <0, intended that caller update nmix for next call.
CCr  Notations:
CCr  x^(m): input vector for iteration m
CCr  F^(m): difference between output and input vector in iteration m
CC ------------------------------------------------------------------
C      implicit none
C      integer nda,nmix,mmix,mxsav
C      double precision wc,rms2,wctrue,a(nda,0:mxsav+1,2)
C      double precision tol,ddot,dFm,diff,dval
C      parameter (tol=1d-12)
C      integer im,info,i,j,iprint,i1mach,imix,jmix,
C     .  obt,obtx,ojac,obet,ogam,okpvt,oFmp1,oxmp1,odFm,odxm
Cc heap
C      integer w(1)
C      common /w/ w
C
CC --- Allocate some arrays ---
C      call defdr(obt,nda)
C      call defdr(obtx,nda)
C      call defdr(ojac,nda**2)
C      call defdr(obet,nda**2)
C      call defdr(ogam,nda**2)
C      call defdr(oFmp1,nda)
C      call defdr(oxmp1,nda)
C      call defdr(odFm,nda)
C      call defdr(odxm,nda)
C      okpvt = obt
C      wctrue = 0
CC ... imix is a local copy of nmix
C      imix = nmix
C      if (imix .lt. 0) imix = mmix
C
CC --- First Jacobian matrix ---
CC ... See Eq. A6; for beta, eq. A14; for gamma, eq. A15.
CC ... x^(2) = x^(1) + [J^(1)]**(-1) * F^(m), so
CC     J^(1) = F^(1) / [x^(2) - x^(1)]
CC     Also, beta^(1) = 1 and gamma^(1) = J^(1)
C    1 continue
C      call dpzero(w(ojac),nda**2)
C      call dpzero(w(obet),nda**2)
C      call dpzero(w(ogam),nda**2)
C      call dcopy(nda,a(1,mmix,1),1,w(odFm),1)
C      call daxpy(nda,-1d0,a(1,mmix,2),1,w(odFm),1)
C      call dcopy(nda,a(1,mmix-1,2),1,w(oxmp1),1)
C      call dcopy(nda,a(1,mmix,2),1,w(odxm),1)
C      j = 1
C      do  20  i = 1, nda
C        call dvset(w(ogam),j,j,1d0)
C        call dvset(w(obet),j,j,1d0)
C        diff = dval(w(oxmp1),i) - dval(w(odxm),i)
C        dFm  = dval(w(odFm),i)
C        if (dabs(diff) .gt. tol .and. dFm .ne. 0)
C     .    call dvset(w(ogam),j,j,dFm/diff)
C        j = j + 1 + nda
C   20 continue
C
CC --- Starting from iteration mmix, build the Jacobian matrix ---
C      jmix = min(mmix,iabs(imix))
C      do  10  im = jmix, 1, -1
CC  ...  F^(m+1) -> a(*,im-1,1)  x^(m+1) -> a(*,im-1,2)
CC  ...  dF^(m)  -> a(*,im,1)    dx^(m)  -> a(*,im,2)
C        call dcopy(nda,a(1,im-1,2),1,w(oxmp1),1)
C        call dcopy(nda,a(1,im-1,1),1,w(oFmp1),1)
C        call daxpy(nda,-1d0,w(oxmp1),1,w(oFmp1),1)
C        call dcopy(nda,w(oxmp1),1,w(odxm),1)
C        call dcopy(nda,w(oFmp1),1,w(odFm),1)
C        call daxpy(nda,-1d0,a(1,im,2),1,w(odxm),1)
C        call daxpy(nda,-1d0,a(1,im,1),1,w(odFm),1)
C        call daxpy(nda, 1d0,a(1,im,2),1,w(odFm),1)
C        rms2 = dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/(nda-0))
C
CC ---   Determine wc_true if wc < 0 ---
C        if (wc .lt. 0) then
C          wctrue = -wc/dsqrt(nda*rms2**2)
C        else
C          wctrue = wc
C        endif
C
CC ---   Broyden updates gamma,beta,J, making J^(m+1) ---
C        call broydn(w(ojac),w(odFm),w(odxm),w(obet),w(ogam),
C     .    w(obt),w(obtx),nda,wctrue)
C
CC ---   Factor Jacobian; linear mixing if singular ---
C        call dgefa(w(ojac),nda,nda,w(okpvt),info)
C        if (info .ne. 0) then
C          if (iprint() .ge. 30)
C     .      call awrit1(' PQMIXB Broyden iter %i: Jacobian matrix '//
C     .      'singular',' ',80,i1mach(2),jmix-im+1)
C        else
CC     ... Solve J^(m+1) * y = F^(m+1)  with  y = x^(m+2) - x^(m+1)
C          call dgesl(w(ojac),nda,nda,w(okpvt),w(oFmp1),0)
CC     ... Make x^(m+2) = y + x^(m+1)
C          call daxpy(nda,1d0,w(oFmp1),1,w(oxmp1),1)
C          if (iprint() .gt. 40 .or. iprint() .ge. 30 .and. im .eq. 1)
C     .      call awrit5(' PQMIXB  Broyden iter %i:  rms(F-x)='//
C     .      '%1;3e  rms(dx)=%1;3e  wc=%1;3g  nelts=%i',' ',80,i1mach(2),
C     .      jmix-im+1,dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/nda),
C     .      rms2,wctrue,nda)
C        endif
C
C   10 continue
C
CC --- Check for interactive change of nmix ---
CC NB negative sign signals request for permanent change in nmix
C      im = imix
C      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
C      if (iabs(imix) .gt. mmix .and. imix .ne. im)
C     .  call awrit1(' (warning) only %i iter available',
C     .  ' ',80,i1mach(2),mmix)
C      if (im .ne. imix) goto 1
C      nmix = imix
CC ... If no prior iter allowed, give up on nmix
C      if (nmix .eq. 0) return
C
CC --- Printout ---
C      if (iprint() .gt. 40) then
C        print 310
C        do  12  i = 1, nda
C          if (dabs(a(i,0,1)-a(i,0,2)) .ge. 5d-9)  print 311, i,
C     .      a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(w(oxmp1),i)
C   12   continue
C  311   format(i5,4f14.6)
C  310   format(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')
C      endif
C
CC --- Save x^(m+2) into a(*,0,2) and exit ---
C      if (info .ne. 0) then
C        nmix = 0
C        return
C      endif
C      call dcopy(nda,w(oxmp1),1,a(1,0,2),1)
C      call rlse(obt)
C      end
      subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
c      use m_lgunit,only:stdo
      use m_ftox
C- Broyden mixing of a vector, Duane Johnson's approach
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
      implicit none
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,wctrue,a(nda,0:mxsav+1,2)
      double precision ddot,dval,wc
      integer:: im , km , i , iprint , i1mach , imix , jmix
      real(8) ,allocatable :: xmp1_rv(:)

      integer:: broyj
      real(8) ,allocatable :: f_rv(:)
      real(8) ,allocatable :: ui_rv(:)
      real(8) ,allocatable :: vti_rv(:)
      real(8) ,allocatable :: xold_rv(:)
      real(8) ,allocatable :: df_rv(:)
      real(8) ,allocatable :: dx_rv(:)
      real(8) ,allocatable :: wk_rv(:)


c heap
c      integer w(1)
c      common /w/ w

C --- Allocate some arrays ---
      allocate(xmp1_rv(nda))

      allocate(f_rv(nda))

      allocate(ui_rv(nda))

      allocate(vti_rv(nda))

      allocate(xold_rv(nda))

      allocate(df_rv(nda))

      allocate(dx_rv(nda))


C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
    1 jmix = min(mmix,iabs(imix))
      allocate(wk_rv(nda*2*(jmix+2)))

      do  10  km = 1, jmix
C   ... this loops from most-distant to most-recent
        im = jmix-km+1
C   ... this loops from most-recent to most-distant
C       im = km

        call dcopy ( nda , a ( 1 , im - 1 , 1 ) , 1 , dx_rv , 1 )

        call daxpy ( nda , - 1d0 , a ( 1 , im - 1 , 2 ) , 1 , dx_rv 
     .  , 1 )

        rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( 
     .  nda - 0 ) )


C ---   Determine wc_true if wc < 0 ---
        if (wc .lt. 0) then
          wctrue = -wc/100/dsqrt(nda*rms2**2)
          wctrue = min(max(wctrue,1d0),1d4)
        else
          wctrue = wc
        endif
        if (km .eq. 1) wctrue = .01d0

        i = iprint()
        if (km .ne. jmix) i = i-20
        i = broyj ( nda , a ( 1 , im - 1 , 2 ) , dx_rv , km , 0 , 
     .  i , beta , 0d0 , 0d0 , 0d0 , wctrue , wk_rv , nda , xmp1_rv 
     .  )

   10 continue

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      im = imix
c      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. im)
     .write(stdo,ftox)' (warning) only ',mmix,' iter available'
      if (im .ne. imix) goto 1
      nmix = imix
C ... If no prior iter allowed, give up on nmix
Cki#error, have return with len(w_varlist)>0 at line 769
      if ( nmix .eq. 0 ) then
        if (allocated(wk_rv)) deallocate(wk_rv)
        if (allocated(dx_rv)) deallocate(dx_rv)
        if (allocated(df_rv)) deallocate(df_rv)
        if (allocated(xold_rv)) deallocate(xold_rv)
        if (allocated(vti_rv)) deallocate(vti_rv)
        if (allocated(ui_rv)) deallocate(ui_rv)
        if (allocated(f_rv)) deallocate(f_rv)
        if (allocated(xmp1_rv)) deallocate(xmp1_rv)
        return
      endif


C --- Printout ---
      if (iprint().gt.60 .or. (iprint().ge.40 .and. nda.le.100)) then
        print 310
        do  12  i = 1, nda
          if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) .ge. 5d - 9 ) 
     .    print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 
     .    , 1 ) - a ( i , 0 , 2 ) , dval ( xmp1_rv , i )

   12   continue
  311   format(i5,4f14.6)
  310   format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
      endif

C --- Save x^(m+2) into a(*,0,2) and exit ---
      call dcopy ( nda , xmp1_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

      if (allocated(xmp1_rv)) deallocate(xmp1_rv)

      if (allocated(f_rv)) deallocate(f_rv)
      if (allocated(ui_rv)) deallocate(ui_rv)
      if (allocated(vti_rv)) deallocate(vti_rv)
      if (allocated(xold_rv)) deallocate(xold_rv)
      if (allocated(df_rv)) deallocate(df_rv)
      if (allocated(dx_rv)) deallocate(dx_rv)
      if (allocated(wk_rv)) deallocate(wk_rv)

      end
      subroutine pqmixc(nda,nmix,mmix,mxsav,beta,rms2,a,xn)
      use m_gradzr,only:drgrzr
c      use m_lgunit,only:stdo
      use m_ftox
C- C. G. mixing of a vector
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Co  xn:   projection along line minimization.
Co        (sign) <0, new line minimization
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
      implicit none
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,xn,a(nda,0:mxsav+1,2)
      double precision ddot,dval,dxmx,xtoll,grfac,wk(0:26)
      save wk
      real(8) ,allocatable :: p_rv(:)
      real(8) ,allocatable :: dx_rv(:)
      integer ir,imix,jmix,km,iprint,i1mach,i,idx,idamax
      real(8):: ww(1,1) !dummy
C --- Allocate some arrays ---
      allocate(p_rv(nda*6))
      allocate(dx_rv(nda))
C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
    1 jmix = min(mmix,iabs(imix))
      ir = 0
      do  10  km = jmix, 0, -1

        call dcopy ( nda , a ( 1 , km , 2 ) , 1 , dx_rv , 1 )

        call daxpy ( nda , - 1d0 , a ( 1 , km , 1 ) , 1 , dx_rv , 
     .  1 )

        rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( 
     .  nda - 0 ) )

        idx = idamax ( nda , dx_rv , 1 )

        dxmx = beta * abs ( dval ( dx_rv , idx ) )

        xtoll = dxmx/10
        grfac = min(2d0,1/beta)
        call pshpr(80)
        wk(0) = xn
        call drgrzr ( nda , a ( 1 , km , 2 ) , dx_rv , p_rv , ww 
     .  , xtoll , dxmx , 1d - 10 , 1d - 10 , grfac , wk , ' ' , 00040 
     .  , ir )

        xn = wk(0)
        call poppr

   10 continue
      if (ir .eq. -1) xn = -xn

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      km = imix
c      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. km)
     .write(stdo,ftox)' (warning) only ',mmix,' iter available'
      if (km .ne. imix) goto 1
      nmix = imix

C --- Printout ---
      if (iprint() .gt. 40) then
        print 310
        do  12  i = 1, nda
          if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) .ge. 5d - 9 ) 
     .    print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 
     .    , 1 ) - a ( i , 0 , 2 ) , dval ( p_rv , i )

   12   continue
  311   format(i5,4f14.6)
  310   format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
      endif

C --- Save x^(m+2) into a(*,0,2) and exit ---
      call dcopy ( nda , p_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

      if (allocated(dx_rv)) deallocate(dx_rv)
      if (allocated(p_rv)) deallocate(p_rv)

      end
      subroutine pqmxup(na,mxsav,nclass,nl,nsp,nx,lmx,
     .pnu,qnu,xnew,pold,qold,xold,cnst,nda,a,rms2)
C- Copy from holding array into P,Q
      implicit none
      integer nda,mxsav,nclass,nl,nsp,nx,lmx(nclass),cnst(0:*)
      double precision a(nda,0:mxsav+1,2),rms2,
     .pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx),ddot
      integer ic,isp,l,na,i
      logical lcnst

      lcnst = cnst(0) .gt. 0
      na = 1
      rms2 = 0
      do  110  isp = 1, nsp
      do  11  ic = 1, nclass
        if (lcnst) then
          if (cnst(ic) .ne. 0) goto 11
        endif
        do  12  l = 0, lmx(ic)
C       print *, pold(l+1,isp,ic) - a(na,0,2)
          pnu(l+1,isp,ic) = a(na,0,2)
          rms2 = rms2 + (qold(1,l+1,isp,ic) - a(na+1,0,2))**2
          do  21  i = 1, 3
C       print *, i, qold(i,l+1,isp,ic) -  a(na+i,0,2)
            qnu(i,l+1,isp,ic) = a(na+i,0,2)
   21     continue
          na = na+4
   12   continue
   11 continue
 110  continue

      call dcopy(nx,a(na,0,2),1,xnew,1)
      rms2 =  rms2 + ddot(nx,xnew,1,xnew,1) -
     .2*ddot(nx,xnew,1,xold,1) +
     .ddot(nx,xold,1,xold,1)
      na = na + nx
      rms2 = dsqrt(4*rms2/(na-0))
      end
      subroutine pqmxio(nmix,mxsav,ifi,lbin,nclass,nl,nsp,nx,lmx,
     .pnu,pold,qnu,qold,xnew,xold,cnst,nda,a,na,rms2)
c      use m_lgunit,only:stdo
      use m_ftox
C- Copy P,Q into holding array, read prior P,Q from disk
C -----------------------------------------------------------------
Ci  nmix  number of prior iterations sought; returns no. actually read
Ci  mxsav maximum number of prior iter to save, and dimensions a
Ci  ifi   : >0, copy pnu,qnu to a(1..nda,0,1), pold,qold to a(1..nda,0,2)
Ci          read prior iter into a(1..nda,1..nmix,1..2)
Ci          <0  write a(1..nda,1..nmix,1..2) to disk
Ci          (NB: Does not update pnu,qnu from a)
Ci  lbin  :T: read prior iterations from binary file, else ascii file
Ci  nclass:number of inequivalent classes
Ci  nl    :(global maximum l) + 1
Ci  nsp   :2 for spin-polarized case, otherwise 1
Ci  nx    :number of p,q and number of extra data xnew,xold
Ci  lmx   :lmx(j) = maximum l for atom j
Ci  pnu   :boundary conditions.  If Dl = log. deriv. at rmax,
Ci         pnu = .5 - atan(Dl)/pi + (princ.quant.number).
Ci  qnu   :energy-weighted moments of the sphere charges
Ci  qold  :old moments
Ci  xnew  :additional parameters to be included in mix
Ci  xold  :additional parameters to be included in mix
Ci  cnst  :for each class, if nonzero, copy pold->pnu
Ci  nda   :leading dimension of a (must be at least na)
Cio Inputs/Outputs
Cio (Inputs for ifi<0, outputs for ifi>0)
Cio  a    :array containing input,output of prior iterations.
Cio       :a is updated with input,output from last iteration.
Cio       :and prior iterations are read from file ifi
Cio  na   :number of values included into mix
Co Outputs
Ci  rms2  :rms change in parameters to be mixed.
C -----------------------------------------------------------------
      implicit none
      logical lbin
      integer nda,nmix,mxsav,ifi,nclass,nl,nsp,lmx(nclass),nx,cnst(0:*)
      double precision a(nda,0:mxsav+1,2),rms2,
     .pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C Local variables
      double precision ddot
      integer i1mach,ic,na,isp,i,j,k,l,iprint,mmix
      logical lcnst

      lcnst = cnst(0) .gt. 0

C --- Copy p,q to a; calc. RMS error; read prior iter from ifi ---
      if (ifi .gt. 0) then
        na = 1
        do  100  isp = 1, nsp
        do  10  ic = 1, nclass
          if (lcnst) then
            if (cnst(ic) .ne. 0) then
              do  121  l = 0, lmx(ic)
                pnu(l+1,isp,ic) = pold(l+1,isp,ic)
              do  21  i = 1, 3
                qnu(i,l+1,isp,ic) = qold(i,l+1,isp,ic)
   21         continue
  121         continue
              goto 10
            endif
          endif
          do  11  l = 0, lmx(ic)
            a(na,0,1) = pnu(l+1,isp,ic)
            a(na,0,2) = pold(l+1,isp,ic)
            do  20  i = 1, 3
              a(na+i,0,1) = qnu(i,l+1,isp,ic)
              a(na+i,0,2) = qold(i,l+1,isp,ic)
   20       continue
            na = na+4
   11     continue
   10   continue
  100   continue

C   ... Append extra vector to a
        call dcopy(nx,xnew,1,a(na,0,1),1)
        call dcopy(nx,xold,1,a(na,0,2),1)
        na = na + nx - 1
        rms2 =  dsqrt(dabs(ddot(na,a,1,a,1) - 2*ddot(na,a,1,a(1,0,2),1)
     .  + ddot(na,a(1,0,2),1,a(1,0,2),1))/(na-0))
C        call prmx('a1',a,na,na,1)
C        call prmx('a2',a(1,0,2),na,na,1)
        mmix = 0
        if (lbin) then
          do  30  j = 1, min(nmix,mxsav)
            read(ifi,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
            mmix = j
   30     continue
        else
          do  33  j = 1, min(nmix,mxsav)
            read(ifi,333,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
            mmix = j
   33     continue
        endif
        goto 32
   31   if (iprint() .ge. 30)
     .  write(stdo,ftox)' PQMXIO:  sought ',nmix,' mixing iter from disk, but read ',mmix
   32   continue
        nmix = mmix
C --- Save iterations to disk ---
      else
        if (lbin) then
          do  34  j = 0, min(nmix,mxsav)-1
            write(-ifi) ((a(i,j,k), i=1,na), k=1,2)
   34     continue
        else
          do  35  j = 0, min(nmix,mxsav)-1
            write(-ifi,333) ((a(i,j,k), i=1,na), k=1,2)
   35     continue
  333     format(1p,4e20.13)
        endif
      endif
      end
C testing ...
C      subroutine fmain
C      implicit none
C      integer nclass,nl,nsp
C      parameter (nclass=2,nl=3,nsp=2)
C      integer lmx(nclass),fadd,mxsav,mmix,nmix,ifi,nlspc,fopn,i,wksize,
C     .  nx,iter,fopna
C      double precision pnu(nl,nsp,nclass),pold(nl,nsp,nclass),
C     .  qnu(3,nl,nsp,nclass),qold(3,nl,nsp,nclass),wj(10),rms2,
C     .  rmsdel,pwk(nl,nsp,nclass),qwk(3,nl,nsp,nclass),
C     .  xnew(100),xold(100),dmxprm(20)
C      character*82 mixmod
C      parameter (wksize=250000)
C      integer w(wksize)
C      common /w/ w
C
C      call wkinit(wksize)
C      call finits(2,0,0,ifi)
C      call initqu(.true.)
C      i = 51
C      call pshpr(i)
C
C      mixmod = 'B,w=0,1,wa=1,fn=mm,k=2'
C      mixmod = 'B,n=3,w=0,1,wa=1,fn=mm,k=3'
C      mixmod = 'B,w=1,2,wa=1,b=.4,n=3;B,b=.02,w=2,1,n=3'
C      dmxprm(1) = 0.0d0
C      dmxprm(2) = 1.0d0
C      dmxprm(3) = -1.0d0
C      dmxprm(4) = 1.0d0
C      dmxprm(5) = 1.0d0
C      dmxprm(6) = 50.0d0
C      dmxprm(7) = -1.0d0
C      dmxprm(8) = -1.0d0
C      dmxprm(9) = 1.0d0
C      dmxprm(10) = -1.0d0
C      dmxprm(11) = 0.0d0
C      dmxprm(12) = 0.0d0
C      dmxprm(13) = 0.0d0
C      dmxprm(14) = 0.0d0
C      dmxprm(15) = 0.0d0
C      dmxprm(16) = 0.0d0
C      dmxprm(17) = 0.0d0
C      dmxprm(18) = 0.0d0
C      dmxprm(19) = 0.0d0
C      dmxprm(20) = 0.0d0
C      print *, 'iter?'
C      read(*,*) iter
C*     iter = 5
C      nx = 9*nclass
C
C      ifi = fadd('LOG',10,0)
C      nlspc = nl*nsp*nclass
C      do  2  i = 1, nclass
C    2 lmx(i) = 2
C
C      ifi = fopna('MIXV',-1,0)
C      do  10  i = 1, 1
C      call dfdump(pnu,nlspc,ifi)
C      call dfdump(pold,nlspc,ifi)
C      call dfdump(qnu,3*nlspc,ifi)
C      call dfdump(qold,3*nlspc,ifi)
C      call dfdump(xnew,nx,ifi)
C      call dfdump(xold,nx,ifi)
C      if (i .gt. 1) then
C        call snot(1*nl*nsp*nclass,pwk,pold)
C        call snot(3*nl*nsp*nclass,qwk,qold)
C      endif
C      call pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxprm,0,
C     .  pold,qold,xold,pnu,qnu,xnew)
C      stop 'patch call to shoctl'
C      call shoctl(nclass,'xx',nl,nsp,lmx,pnu,qnu,
C     .  0,pnu,fopn('LOG'))
C
C   10 continue
C      end
C      subroutine snot(n,f1,f2)
C      implicit none
C      integer n,i
C      double precision f1(n),f2(n)
C
C      write(*,110)
C      do  12  i = 1, n
C        if (dabs(f1(i)-f2(i)) .ge. 5d-9)
C     .  write(*,111) i,f1(i),f2(i),f1(i)-f2(i)
C   12 continue
C  111 format(i5,4f14.6)
C  110 format(14x,'OLD',11X,' NEW',9X,'DIFF',10X,'MIXED')
C     end
      logical function parmxp(iter,strn,lstrn,broy,nmix,wgt,beta,
     .elind,mixnam,wc,nkill,betv,rmserr)
C- Parse strng to get mixing parameters for current iteration
C --------------------------------------------------
Ci Inputs
Ci iter: current iteration
Ci       iter=-1 => strn parsed to check integrity of string,
Ci       and optionally to display (iprint().ge.10)
Ci       parmxp does not set parameters broy...betv in this case
Ci strn: string, parsed to extract mixing parameters for this iteration.
Cio Inputs/Outputs
Cio rmserr used in a conditional expression to determine whether
Cio       mixing mode should shift (see "r<expr", Remarks)
Cio       On output, rmserr is changed to -rmserr if a new mixing block is
Cio       started caused by the condition rmserr<rmsc. This acts as a signal
Cio       in the event that one may wish to kill the mix files.
Co Outputs
Co   Each of mixing parameters broy,nmix,wgt,beta,mixnam,wc,nkill may be
Co   updated depending on the current iteration and strn.  Parameters
Co   not found withing strn take default values (see Remarks).
Co   broy   0 for linear or Anderson mixing
Co          1 for Broyden mixing
Co          2 for conjugate gradients mixing
Co   nmix   number of prior iterations to include in mix
Co   wgt    relative weights to assign; see Remarks
Co   beta   mixing beta (Anderson and CG mixing)
Co   elind  Lindhard screening parameter (when dielectric F can be est)
Co   mixnam file name to read prior iterations
Co   wc     mixing weights for Broyden mixing (see Remarks)
Co   nkill  for periodic mixing file deletion (see Remarks)
Co   betv   for independent potential mixing
Co   parmxp returns false if the parse fails, otherwise true.
Cr Remarks
Cr The general syntax for strn is a sequence of groups of mixing
Cr parameters.  The syntax of one group looks like the following.
Cr   A[nmix][some-parameters--see below][;another-sequence]  or
Cr   B[nmix][some-parameters--see below][;another-sequence]
Cr   thus a ';' indicates the start of a new block in the sequence
Cr   The mixing parameters are as follows:
Cr   ,b=#:   set mixing beta=#.
Cr           (NB: for Broyden mixing, only meaningful to get started)
Cr   ,bv=#[,#2] set extra potential mixing parameter betv to #.  If
Cr           last in this block, set to #2.
Cr   ,n=#    do this mixing for # iterations
Cr   ,k=#    kill the mixing file after # iterations
Cr   ,fn=nam set the mixing file name to 'nam'
Cr   ,wc=#   set Broyden wc to #.  Smaller wc more heavily weights
Cr           most recent iterations.  wc<0 sets wc to abs(wc)*rms error.
Cr   ,w=w1,w2 (spin pol only).  Spin-pol calculations mix up+down and
Cr           up-down.  w1 and w2 are the relative weights to assign
Cr           to these two channels.  w2=0=> magnetic moments frozen;
Cr           w1=0 => total charge is frozen.
Cr   ,wa=#   weight for additonal parameters to be mixed
Cr   ,elind=# Lindhard screening parameter
Cr   ,r<expr continue this block of mixing sequence until rmserr<expr.
Cr           NB: parmxp temporarily loads into the variables table
Cr           the value of errmin, which may be used in parsing expr.
Cr           The latter is set by calling parmx0(0,0,errmin).
Cr           If r<expr is to be used then n=1 must also be set.
Cr Groups are separated by a ";".  parmxp determines which group belongs
Cr   to the current iteration (iter) by adding the number of iterations
Cr   nit for the first group, second group, etc. until their sum exceeds
Cr   the current iteration number (iter).  Thus if strn = "B,n=2;A,n=3",
Cr   the current group would be "B,n=2" for iter = 1,2,6,7,11,12,...
Cr   and would be "A,n=3" for iter = 3,4,5,8,9,10.
Cr Example value of strn : B30,n=8,w=2,1,fn=mxm,wc=11,k=3;A2,b=1
Cr   does 8 iterations of Broyden mixing, followed by Anderson mixing
Cr   The Broyden iterations weight the (up+down) double that of
Cr   (up-down) for the spin pol case, and iterations are saved in a file
Cr   which is deleted at the end of every third iteration.  WC is 11.
Cr   beta assumes the default value.
Cr   The Anderson iterations mix two prior iterations with beta of 1.
Cr Periodic file deletion (nkill):  parmxp returns nkill as -nkill when
Cr   mod(iter-nitj,nkill) is zero, as a signal that the current mixing
Cr   file is to be deleted after it is used.  Here nitj is the sum of
Cr   the number of iterations prior to the current group.
Cb Bugs:
Cb   parmxp cannot tell if this iterations is the last one in a block
Cb   if the constraint rmsc<rmserr is not satisfied.  If it is not,
Cb   betv always returns bv(1).
Cr Defaults:
Cr   nkill has hardwired defaults of -1 and 0.
Cr   nit defaults to infinity
Cr   broy,nmix,wgt,beta,mixnam,wc,betv default to their input values.
Cr   Setting input wgt(3) to -9 signals that wgt(3) is not used.
Cl Local variables
Cl   iblk:  index to current sequence of mixing parameters
Cl   nitj:  effective iter corresponding to last iteration of last
Cl          mixing block, to determine position in current mixing block
Cl   lstblk:index to block of mixing parameters of last call.  Normally
Cl          set and saved internally.  Caller may set lstblk (entry
Cl           parmx0) to fix the current place in the mixing block group.
Cl   lstitj:performs a dual function, depending on sign.
Cl          lstitj<=0: corresponds to -nitj of prior call.  parmxp sets
Cl                     lstitj internally for this mode.
Cl          lstitj>0:  (set by caller), which iteration within the
Cl                     current mixing block the next iteration will
Cl                     correspond to.
Cu Updates
Cu    20 Jul 08 (ATP) returns rmserr as -rmserr to signal new block
Cu    1  Jun 00 added argument elind
C --------------------------------------------------
C     implicit none
C Passed parameters
      integer broy
C     character strn*(*),mixnam*8
      character strn*(*),mixnam*8
      integer iter,lstrn,nkill,nmix
      double precision wgt(3),beta,elind,wc,betv,rmserr
C Local variables
      integer i,j,np,it(5),parg,nit,nmixj,jp,kp,killj,nitj,
     .iprint,i1mach,a2vec,lstblk,lstitj,iblk,nbump,k,ia0,lbroy
      logical lpr,lagain,cmdopt
      character outs*100,fnam*8
      double precision bet,elin,wt(3),wcj,rmsc,bv(2),errmin,xx
C ... this is the only way to create static variables in fortran
      common /parmx1/ lstblk,lstitj,errmin

      parmxp = .true.
      ia0 = -1
      call bin2a0(ia0)
C ... Internal defaults
      if (iter .gt. 0) then
        nkill = 0
        nit = -1
      endif
      if (strn .eq. ' ' .or. lstrn .le. 0) goto 9999
C ... Passed defaults
      call bin2a0(10)
      fnam = mixnam
      lbroy = broy
      wcj = wc
      nmixj = nmix
      bet = beta
      elin = elind
      bv(1) = betv
      bv(2) = betv
      wt(1) = wgt(1)
      wt(2) = wgt(2)
      wt(3) = wgt(3)
      nit = -1
      if (wgt(3) .eq. -9) wt(3) = 0
C ... lpr: switch to determine whether to print or not
C     lpr = .false.
C ... iblk,iit: current mixing block and iter within block
      iblk = 0
      nitj = 0
      np = 0
      outs = ' mixing: mode=A'

C --- Entry point for parsing a new set of switches ---
   10 continue
      call skipbl(strn,lstrn,np)
      if (np .ge. lstrn) then
        if (iter .lt. 0) goto 9999
        if (cmdopt('--nomixcycle',12,0,outs)) then
          nkill = -999
          goto 9999
        else
          np = 0
          goto 10
        endif
      endif
C ... Switch for Broyden or Anderson mixing
      jp = np
      call chrps2(strn,'AaBbCc',6,np,jp,it)
      if (it(1) .eq. 0) goto 999
      iblk = iblk+1
C ... If iblk=lstblk, override nitj with lstitj
      if (iter .gt. 0 .and. iblk .eq. lstblk) then
        nitj = -lstitj
        if (lstitj .gt. 0) nitj = iter - lstitj
        lstitj = -nitj
C  ...  A bug if starting iteration bigger than iter
        if (nitj .gt. iter) call rx('parmxp: bad lstitj')
      endif
      lbroy = 0
      if (it(1) .ge. 3) lbroy = 1
      if (it(1) .ge. 5) lbroy = 2
      if (lbroy .eq. 1) call awrit0('%a%bB',outs,len(outs),0)
      if (lbroy .eq. 2) call awrit0('%a%bC',outs,len(outs),0)
C ... Pick up nmix
      jp = np+1
      call chrps2(strn,',; ',3,np+1,jp,it)
      if (it(1) .eq. 0) then
        if (a2vec(strn,lstrn,jp,2,',; ',3,1,1,it,nmixj) .lt. 0) goto 999
        call awrit1('%a  nmix=%i',outs,len(outs),0,nmixj)
      endif
C ... Pick up rmsc
      rmsc = -1
      jp = np
C ... set variable errmin to current value of errmin
      call getsyv('errmin',xx,j)
      call lodsyv('errmin',1,errmin,k)
      i = parg(',r<',4,strn,jp,lstrn,',; ',2,1,it,rmsc)
C ... Put back the original one, or remove newly created one
      if (j .eq. k) then
        call lodsyv('errmin',1,xx,k)
      else
        call clrsyv(k-1)
      endif
      if (i .lt. 0) goto 999
C     if (i .gt. 0) lpr = .true.
      if (rmsc .ge. 0 .and. iter .lt. 0)
     .call awrit1('%a  err<%1;3g',outs,len(outs),0,rmsc)
      if (rmsc .ge. 0 .and. iter .gt. 0)
     .call awrit2('%a  err(%1;3g)<%1;3g',outs,len(outs),0,rmserr,rmsc)
C ... Pick up nit
      jp = np
      i = parg(',n=',2,strn,jp,lstrn,',; ',2,1,it,nit)
      if (i .lt. 0) goto 999
C ... increment nit if rmserr>rmsc and iter>=nit+nitj
      nbump = 0
      if (nit .ne. -1) then
        if (iter .lt. 0) call awrit1('%a  nit=%i',outs,len(outs),0,nit)
        if (iter .gt. 0) then
          call awrit2('%a  it %i of %i',outs,len(outs),0,iter,nit+nitj)
          if (iblk .ge. lstblk .and. iter .ge. nit+nitj .and.
     .    rmserr .gt. rmsc .and. rmsc .gt. 0) then
            nbump = iter - (nit+nitj) + 1
            nit = nit + nbump
            call awrit0('%a(*)',outs,len(outs),0)
          endif
        endif
      endif

C ... ATP added this:
      if (rmserr .lt. rmsc .and. iblk .eq. lstblk .and. rmserr .ne. 0)
     .rmserr = -rmserr

C      if (nit .eq. -1 .and. iter .gt. 0)
C     .  call awrit1('%a  it %i of *',outs,len(outs),0,iter)

C     if (i .gt. 0) lpr = .true.
C ... Pick up file name
      jp = np
      i = parg(',fn=',0,strn,jp,lstrn,',; ',2,0,it,0)
      if (i .gt. 0) then
        kp = jp+1
        call chrps2(strn,',; ',3,jp+5,kp,it)
        fnam = strn(jp+1:kp)
        call awrit0('%a  fnam='//fnam,outs,len(outs),0)
C       lpr = .true.
      endif
C ... Pick up mixing wc
      jp = np
      if (lbroy .eq. 1) then
        i = parg(',wc=',4,strn,jp,lstrn,',; ',2,1,it,wcj)
        if (i .lt. 0) goto 999
C       if (i .gt. 0) lpr = .true.
        if (i .gt. 0) call awrit1('%a  wc=%d',outs,len(outs),0,wcj)
      endif
C ... Pick up mixing beta
      jp = np
      i = parg(',b=',4,strn,jp,lstrn,',; ',2,1,it,bet)
      if (i .lt. 0) goto 999
C     if (i .gt. 0) lpr = .true.
      call awrit1('%a  beta=%d',outs,len(outs),0,bet)
C ... Pick up elind
      jp = np
      i = parg(',elind=',4,strn,jp,lstrn,',; ',2,1,it,elin)
      if (i .lt. 0) goto 999
C     if (i .gt. 0) lpr = .true.
      if (elin.ne.0) call awrit1('%a  elind=%;3d',outs,len(outs),0,elin)
C ... Pick up weights
      jp = np
      i = parg(',w=',4,strn,jp,lstrn,',; ',2,2,it,wt)
      if (i .lt. 0) goto 999
      jp = np
      j = parg(',wa=',4,strn,jp,lstrn,',; ',2,1,it,wt(3))
      if (j .lt. 0) goto 999
      if (i .gt. 0 .or. j .gt. 0) then
        call awrit2('%a  wgt=%d,%d',outs,len(outs),0,wt(1),wt(2))
        if (j .gt. 0 .and. wgt(3) .ne. -9) then
          call awrit1('%a(%d)',outs,len(outs),0,wt(3))
        elseif (j .gt. 0) then
          call awrit0('%a(-)',outs,len(outs),0)
        endif
      endif
C...  Pick up iteration number for file kill
      killj = -1
      jp = np
      i = parg(',k=',2,strn,jp,lstrn,',; ',2,1,it,killj)
      if (i .lt. 0) goto 999
C     if (i .gt. 0) lpr = .true.
      if (killj .ne. -1) call awrit1('%a  kill=%i',outs,len(outs),
     .0,killj)
C...  Pick up betv
      jp = np
      i = parg(',bv=',4,strn,jp,lstrn,',; ',2,2,it,bv)
C     if only one element found, copy 1st element to second:
      if (i .eq. -2) then
        bv(2) = bv(1)
        i = 1
      endif
      if (i .lt. 0) goto 999
      if (i .gt. 0) lpr = .true.
      if (iter .eq. nitj+nit .and. iblk .ge. lstblk) bv(1) = bv(2)
      if (bv(1).ne.1) call awrit1('%a  betv=%1;3g',outs,len(outs),0,bv)
C ... If iter < 0, printout and parse through all strings
      if (iter .lt. 0) then
        if (iprint().ge.10) call awrit0('%a',outs,-len(outs),-i1mach(2))
        lagain = nit .ne. -1
        outs = '         mode=A'
      endif

C --- If this is last pass, eg nitj <= iter <nitj+nit ---
      if (iter .gt. 0 .and. iblk .ge. lstblk .and. nitj .lt. iter
     ..and. (iter .le. nitj+nit .or. nit .eq. -1)) then
        if (iprint().ge.20) call awrit0('%a',outs,-len(outs),-i1mach(2))
        broy = lbroy
        nmix = nmixj
        wgt(1) = wt(1)
        wgt(2) = wt(2)
        if (wgt(3) .eq. -9) wt(3) = 0
        wgt(3) = wt(3)
        beta = bet
        elind = elin
        mixnam = fnam
        wc = wcj
        nkill = max(killj,0)
        if (nkill .gt. 1) then
          if (mod(iter-nitj,nkill) .eq. 0) nkill=-nkill
        endif
        if (nkill .eq. 1) nkill=-nkill
        betv = bv(1)
        lstblk = iblk
        lstitj = -nitj
        if (nbump .gt. 0) lstitj = lstitj - (nbump-1)
C       print *, 'exiting', lstitj,nbump
        goto 9999
      else
        nitj = nitj+nit
        lagain = .true.
        outs = ' mixing: mode=A'
      endif

C  99 continue
      if (lagain) then
        call chrps2(strn,'; ',2,lstrn,np,it)
        np = np+1
        goto 10
      else
        goto 9999
      endif

C --- Error exit ---
  999 outs = 'parmxp: parse failed:'//strn(1:lstrn)
      if (iprint() .ge. 10) call awrit0('%a',outs,-len(outs),-i1mach(2))
      parmxp = .false.
C --- Normal exit ---
 9999 continue
      call bin2a0(ia0)
      end function parmxp

      subroutine parmx0(i1,i2,errxx)
C- sets lstblk,lstitj and errmin
C     implicit none
      integer i1,i2,lstblk,lstitj,mode
      double precision errxx,errmin
C ... this is the only way to create static variables in fortran
      common /parmx1/ lstblk,lstitj,errmin
      if (i1 .gt. 0) lstblk = i1
      if (i2 .gt. 0) lstitj = i2
      if (errxx .ge. 0d0) then
        if (errmin .gt. 0) errmin = min(errmin,errxx)
        if (errmin .eq. 0) errmin = errxx
      endif
C     print *, 'errmin=',errmin
      return
      entry parms0(i1,i2,errxx,mode)
      if (mode .gt. 0) then
        i1 = lstblk
        i2 = lstitj
        errxx = errmin
      else
        lstblk = i1
        lstitj = i2
        errmin = errxx
      endif
      end subroutine parmx0

c$$$      block data dparmx
c$$$      integer lstblk,lstitj
c$$$      double precision errmin
c$$$      common /parmx1/ lstblk,lstitj,errmin
c$$$      data lstblk /0/ lstitj /0/ errmin /0d0/
c$$$      end block data dparmx

c ... testing parmxp
C      subroutine fmain
C      implicit none
C      character*90 strn,mixnam*8
C      integer i,ip,it(100),iter,nkill,nmix,i1,i2
C      double precision wgt(3),beta,betv,wc,rmserr
C      real ran1
C      logical lbroy,parmxp
C
C      nmix = -1
C      iter = -1
C      wc = -1
C      beta = .7d0
C      betv = .01d0
C      wgt(1) = 1
C      wgt(2) = 1
C      wgt(3) = 1
C      rmserr = -1
C      mixnam = 'MiXm'
C      strn = ' B30,n=4,w=2,1,wa=9,fn=mxm,wc=11,b=1; A,k=3,bv=.11,.22'
C      if (.not. parmxp(iter,strn,len(strn),lbroy,nmix,wgt,beta,mixnam,
C     .    wc,nkill,betv,rmserr)) stop
C      print *, '-----'
C      do  10  iter = 3, 12
C      if (.not. parmxp(iter,strn,len(strn),lbroy,nmix,wgt,beta,mixnam,
C     .    wc,nkill,betv,rmserr)) stop
C      print 333, iter,lbroy,nmix,wgt,beta,mixnam,wc,nkill,betv,rmserr
C  333 format('iter=',i3,' lbroy=',l1,' nmix=',i2,' wgt=',3f8.4,' beta=',
C     . f8.4,' mixnam=',a,' wc=',f8.4,' nkill=',i3,' betv,rmserr=',2f8.4)
C      print *, ' '
C   10 continue
C
C      call parmx0(2,2,0d0)
C
C      strn = ' B30,n=4,w=2,1,wa=9,fn=mxm,wc=11,b=1;'//
C     .  ' A,k=3,bv=.11,.22,n=3;A,b=.88,r<.2,n=2,bv=.11,.33'
C      strn = ' B30,n=4,w=2,1,wa=9,fn=mxm,wc=11,b=1;'//
C     .  ' A,k=3,bv=.11,.22,n=3;A,b=.88,r<errmin+.2,n=2,bv=.11,.33'
C      if (.not. parmxp(-1,strn,len(strn),lbroy,nmix,wgt,beta,mixnam,
C     .    wc,nkill,betv,rmserr)) stop
C      call ran1in(1)
C      print *, '-----'
C      do  20  iter = 3, 18
C      rmserr = ran1()
C      if (.not. parmxp(iter,strn,len(strn),lbroy,nmix,wgt,beta,mixnam,
C     .    wc,nkill,betv,rmserr)) stop
C      call parmx0(0,0,rmserr)
C      print 333, iter,lbroy,nmix,wgt,beta,mixnam,wc,nkill,betv,rmserr
C      print *, ' '
C   20 continue
C
CC      strn = ' '
CC      read(*,'(a70)') strn
CC      if (.not. parmxp(iter,strn,len(strn),lbroy,nmix,wgt,beta,mixnam,
CC     .  wc,nkill,betv,rmserr)) stop
C
CC      call parms0(i1,i2,rmserr,1)
CC      print *, i1,i2,rmserr
CC      i1 = 8
CC      i2 = -15
CC      rmserr = .1234d0
CC      call parms0(i1,i2,rmserr,-1)
CC      i1 = 0
CC      i2 = 0
CC      rmserr = 0
CC      call parms0(i1,i2,rmserr,1)
CC      print *, i1,i2,rmserr
C
C     end
      

      
      subroutine dpsadd(adest,asrc,nel,n1,n2,fac)
C- shift and add. nel=number of elements, n1,n2= start in asrc,adest
C     implicit none
      integer n1,n2,i,iadd,ntop,nel
      double precision asrc(1),adest(1),fac
      call daxpy(nel,fac,asrc(n2),1,adest(n1),1)
      end
      end module m_mixrho

      
      subroutine lgstar(mode,ng,n,gv,ng0,ips0,cg)
C- Compresses F.T. of a real function, using fact it is hermitian
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :0, count number of inequivalent points ng0,
Ci             and make ips0.  cg is not used.
Ci         :1  same as mode 0, but also compress cg
Ci         :2  use ips0 to undo compression of cg
Ci   ng    :number of G-vectors
Ci   n     :cg array holds n functions;
Ci   gv    :list of reciprocal lattice vectors G (gvlist.f)
Co   ng0   :(mode=2) number of inequivalent points
Ci   ips0  :(mode=2) permutation array.
Ci   cg    :list of g-vectors for each of n functions
Co Outputs
Co   ng0   :(mode=0,1) number of inequivalent points
Co   ips0  :(mode=0,1) array of permutation indices.  A negative value
Co         :signifies the point's hermitian counterpart falls earlier in
Co         :the list, and points to that element.
Cr Remarks
Cr   Hacked from svgsym, using only one symmetry operation
Cr   to reduce (G,-G) pairs to a single element.
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
      integer mode,ng,n,ips0(ng),ng0,iprint
      double precision gv(ng,3)
      double complex cg(ng,n)
      integer i,i0,i00,irep,k,j,j0,lwarn,m
      double precision v(3),df
      if (mode.lt.0 .or. mode.gt.2) call rxi('lgstar, bad mode',mode)
      lwarn = 0
      if (mode .eq. 2) goto 200

C --- mode = 0,1 ---
      ng0 = 0
      do  5  i = 1, ng
        ips0(i) = 0
    5 continue

C --- Main loop: look for next unclassified vector ---
      i00 = 1
      do  10  irep = 1, ng+1
        i0 = 0
        do  12  i = i00, ng
          i0 = i
          if (ips0(i) .eq. 0) goto 80
   12   continue
        goto 81
   80   continue
C   ... Apply all point ops, find in list, add to phase sum
        ng0 = ng0 + 1
        ips0(i0) = ng0
        if (mode .eq. 1)  then
          do  21  m = 1, n
            cg(ng0,m) = cg(i0,m)
   21     continue
        endif
        do  20  k = 1, 1
          v(1) = gv(i0,1)
          v(2) = gv(i0,2)
          v(3) = gv(i0,3)
          do  22  j = i0+1,ng
            df = (v(1)+gv(j,1))**2+(v(2)+gv(j,2))**2+(v(3)+gv(j,3))**2
            j0 = j
            if (df .lt. 1d-8) goto 70
   22     continue
C     ... No matching vector here ... should only happen for G=0
          i00 = i0
          goto 10
   70     continue
          ips0(j0) = -i0
          if (mode .eq. 1) then
            if (abs(cg(i0,1)-dconjg(cg(j0,1))).gt.1d-9) lwarn = lwarn+1
          endif
   20   continue
        i00 = i0
   10 continue
      call rxi('bug in lgstar, irep=',irep)
   81 continue
      if (lwarn .gt. 1 .and. iprint() .ge. 10) print 345, lwarn
  345 format(' lgstar (warning):',i6, ' points not hermitian')
      return
C --- mode = 2 ---
  200 continue
C ... Unpack original points first
      do    m = 1, n
      do    i = ng, 1, -1
        k = ips0(i)
        if (k .gt. 0) cg(i,m) = cg(k,m)
      enddo
      enddo
C ... Unpack hermitian points
      do    m = 1, n
      do    i = 1, ng
        k = -ips0(i)
        if (k .gt. 0) cg(i,m) = dconjg(cg(k,m))
      enddo
      enddo
      end subroutine lgstar
      
