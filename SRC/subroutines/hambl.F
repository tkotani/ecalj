      subroutine hambl(lso,isp,qin, smpot,vconst,sv_p_osig,sv_p_otau,sv_p_oppi, h, s, hso)
      use m_lmfinit,only: nbas , ssite=>v_ssite , sspec=>v_sspec,lcplxp ,nsp,iprmb
      use m_igv2x,only: napw, igvapwin=>igv2x, ndimh
      use m_supot,only: k1,k2,k3
      use m_struc_def,only: s_rv1
      use m_lattic,only:plat=>lat_plat,qlat=>lat_qlat
C- Make the LDA hamiltonian and overlap for one k-point.
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :1s digit specifies LDA matrix elements
Ci         :  0 compute LDA hamiltonian and overlap
Ci         :  1 compute the overlap only
Ci         :10s digit
Ci         :  0 do not compute hso
Ci         :  1 compute hs0
Ci         :    Note: only a portion of hso is computed for a
Ci         :    particular isp.  The total hso is assembled
Ci         :    after isp loops from 1..2.  hso should not be
Ci         :    initialized between isp=1 and isp=2 loops.
Ci   nbas  :size of basis
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: plat
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: oindxo
Ci     Stored:    *
Ci     Passed to: *
Ci   isp   :spin index
Ci   q     :Bloch vector (k-point)
Ci   k1,k2,k3 dimensions of smpot
Ci   smpot :smooth potential on uniform mesh (mkpot.f)
Ci   vconst:additional constant potential
Ci   osig,otau,oppi  augmentation matrices
Ci   alfa  :add alfa * overlap to hamiltonian
Ci         :This is for stability in evals.  Preferably alfa=0
Ci   ndimh :dimension of hamiltonian and ovrlap h,s
Co Outputs
Co   h     :Hamiltonian matrix
Co   s     :overlap matrix
Co   hso   :spin off-diagonal block of spin-orbit hamiltonian
Cr Remarks
Cu Updates
Cu   04 Jul 08 (T. Kotani) New PW addition to basis
Cu   03 Feb 05 (A. Chantis) calculate hso
Cu    1 Sep 04 Adapted to handle complex ppi; S.O. put into ppi
Cu   25 Aug 04 modifications for extended local orbitals
Cu   15 Jul 04 (Chantis) Add Lz.Sz spin-orbit coupling
Cu   10 Jan 03 Remove addition from hambl.  See hambls.f
Cu   10 Jan 03 put sigma back into Bloch transform only
Cu   14 Aug 02 Added overlap-only option and option for orthog sigm
Cu   20 Jul 02 Can add Bloch transform of sigma matrix to ham
Cu   18 May 00 Adapted from nfp mk_hamiltonian.f
C     ----------------------------------------------------------------------
      implicit none
      integer mode,igvapw(3,napw),isp
      type(s_rv1) :: sv_p_oppi(3,nbas)
      type(s_rv1) :: sv_p_otau(3,nbas)
      type(s_rv1) :: sv_p_osig(3,nbas)
c      double precision alfa
      real(8):: q(3), vconst
      complex(8):: smpot(k1,k2,k3,nsp)
      double complex h(ndimh,ndimh),s(ndimh,ndimh),hso(ndimh,ndimh)
      integer mode0,mode1,ipr,inn(3),ig,lso
      double precision vavg
      real(8):: qin(3),qlatinv(3,3)
!! ---------------------------------------------------
      call tcn('hambl')
      mode = 0
      if (lso == 1) mode = 10
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
!! Originally Given q should be shorted becasue (takao think)
!! hamble ->smhsbl-->hhibl-->hklbl ---> hsmq requires
!! lat_rv_a_o_dlv and lat_rv_a_o_qlv, generated by lattic.F (call lattc)  where we assume q is shortened. I think.
!! But we need extensive test to improve this part...
!! Easier way to manage any q with shorbz.

!! input and output
!!   qpg(ig) = tpiba * ( qin + matmul(qlat,igapwin(1:3,ig))) for h,o,hso
!! internal
!!   qpg(ig) = tpiba * ( q  + matmul(qlat,igapw(1:3,ig)))
!!  NOTE: both qpg are the same for given ig.
!! qlat*igapw = qlat*igqwin + (qin-q) ---> igvapw = igvapwin + matmul(qlatinv,qin-q)
      qlatinv = transpose(plat)
      call shorbz(qin,q,qlat,plat) !is this fine?
      call rtoint(matmul(qlatinv,qin-q),inn,3)
      do ig=1,napw
        igvapw(:,ig) = inn + igvapwin(:,ig)
      enddo  
C ... Initialization of quantities to be computed
      if (mode0 .eq. 0) call dpzero(h,ndimh*ndimh*2)
      if (mode0 .le. 1) call dpzero(s,ndimh*ndimh*2)
      if (mode1 .eq. 1 .and. isp .eq. 1) call dpzero(hso,ndimh*ndimh*2)
C ... Skip LDA H, S
      if (mode0 .gt. 1) goto 100
C --- Augmentation part of hamiltonian and overlap ---
      call augmbl ( mode0 + 10 * mode1 , ssite , sspec , isp !slat , 
     .    , lcplxp , q , sv_p_osig , sv_p_otau , sv_p_oppi , iprmb 
     .    , ndimh , napw , igvapw , h , hso , s )
C --- Add alfa S+ S ---
c      if (dabs(alfa) .gt. 1d-10 .and. mode0 .eq. 0)  then
c        call z2herm('U',ndimh,ndimh,s)
c        call zgemm('C','N',ndimh,ndimh,ndimh,dcmplx(alfa,0d0),
c     .  s,ndimh,s,ndimh,dcmplx(1d0,0d0),h,ndimh)
c      endif
C ... Optionally set average istl potential to zero
      vavg = 0
      call smhsbl ( mode0 , ssite , sspec ,  vavg + vconst , !slat ,
     . q , ndimh , iprmb , napw , igvapw , h , s )
      if (mode0 .eq. 1) goto 100
      call hsibl ( ssite , sspec ,  k1 , k2 , k3 , smpot , isp !slat ,
     . , q , ndimh , iprmb , napw , igvapw , h )
C ... End of assembling LDA H, S
  100 continue
      if (mode0 .eq. 0) call z2herm('U',ndimh,ndimh,h)
      if (mode0 .le. 1) call z2herm('U',ndimh,ndimh,s)
      call getpr(ipr)
      if (ipr .ge. 90) then
        call info(0,0,0,' h and s for q=%3:1;6,6d',q,0)
        if (mode0 .eq. 0) call zprm('h',12,h,ndimh,ndimh,ndimh)
        if (mode0 .le. 1) call zprm('s',12,s,ndimh,ndimh,ndimh)
        if (mode1 .eq. 1) call zprm('hso',2,hso,ndimh,ndimh,ndimh)
      endif
      call tcx('hambl')
      end subroutine hambl

      subroutine pvhmb1(mode,k1,k2,k3,smpot,vavg) !slat,
      use m_supot,only:lat_nabc
C- Add subtract a constant from smooth potential
C ----------------------------------------------------------------------
Ci Inputs
Ci    mode :0 do not adjust smpot; just return avg smpot
Ci         :1 add vavg to smpot
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: nabc
Ci   k1,k2,k3 dimensions of smpot
Cio Inputs/Outputs
Cio  smpot :(input for mode=0, altered for mode=1)
Cio        :smooth potential on uniform mesh (mkpot.f)
Cio  vavg  :(output for mode=0, input for mode=1) average potential
Cr Remarks
Cr
Cu Updates
Cu   16 Aug 04 First created
C ----------------------------------------------------------------------
      implicit none
      integer mode,k1,k2,k3
      double complex smpot(k1,k2,k3)
C ... Local parameters
      double precision vavg
      double complex xx
      integer ngabc(3),i
      if (mode .eq. 0) then
        ngabc=lat_nabc
        call mshint(1d0,1,ngabc(1),ngabc(2),ngabc(3), k1,k2,k3,smpot,vavg,xx)
      elseif (mode .eq. 1) then
        do i = 1, k1*k2*k3
          smpot(i,1,1) = smpot(i,1,1) + vavg
        enddo
      else
        call rx('pvhmb1: bad mode')
      endif
      end subroutine pvhmb1
