module m_mixrho !mixing routine of density given by smrho and orho
  use m_lmfinit,only: z_i=>z,nr_i=>nr,rmt_i=>rmt,lmxl_i=>lmxl,spec_a,rg_i=>rg,rsmv_i=>rsmv,nbas
  use m_ll,only:ll
  use m_lgunit,only:stdo,stml !  integer,parameter,public:: kmxv=15
  public:: mixrho
  private
  real(8),parameter::pi = 4d0*datan(1d0), srfpi = dsqrt(4d0*pi)
  logical:: old2023mixing=.true. ! old2023mixing=F sets newmixing mode. I think it will be better but not tested well.
contains
  subroutine mixrho(iter, qval,  sv_p_orhnew, sv_p_orho, smrnew, smrho,rmsdel) ! Mixing old and new charge densities: real space mixing of smrho. It works OK. However, we may need to fix it so that this is well-defined chi=|rho-f(rho)|**2 minimization mixing.
    use m_supot,only: iv_a_okv,rv_a_ogv,n1,n2,n3
    use m_lmfinit,only:alat=>lat_alat,nbas,stdl,ispec,nsp,broyinit,nmixinit,betainit,killj,wtinit,wc,bexist,mix_nsave
    use m_lattic,only: vol=>lat_vol
    use m_supot,only:  ng=>lat_ng,n1,n2,n3
    use m_ext,only:    sname
    use m_ftox
    use m_struc_def
    implicit none
    ! 2023-10-12 In, ubunu gfortran, co fail or success even with the same binary. MPI bug?
    
    ! i iter
    ! i qval  :total valence charge, used to estimate Lindhard parameter
    ! i Read mixing parameter from m_lmfinit
    ! i   orhnew:On input, local parts of the density that generated the ham. =>DESTROYED on output
    ! i   smrnew:smooth density generated by the H(rhold,smrho)               =>DESTROYED on output
    ! i/o  orho:Local parts of the density that the hamiltonian generated
    !         :On output, the mixed density
    !      NOTE :  rho1=reshape(orho(1,ibas)%v,[nr,nlml,nsp]) : (1st component of true density)*r**2 tabulated on a radial mesh
    !
    ! i/o  smrho :On input, smooth density that generated the hamiltonian H
    !         :On output mixed smooth density
    
    !Mechanism of mixing
    ! We mix smrho and rho_onsite, where we divide rho_site=  rho_spherical + rho_GkL + rho_remnant
    ! We apply (smrho, rho_sherical, rho_GkL) by a mixer, but rho_remnant is just liner mixed.
    !
    ! step1. (smrho, rho_sherical, coefficients of rho_GkL) are packed into an array a by 'call packdensity'.
    ! step2. Main mixing step of (smrho, rho_sherical, coefficients of rho_GkL)
    !       The mixer is 'call mixdensity'.
    ! step3. rho_remnant is extracted and linealy mixed by call getrhoremnant.
    ! step4. call unpack density gives new mixed denisty from rho_remnant, and mixed (smrho, rho_sherical, coefficients of rho_GkL).
    !
    ! Caution:  Mark notes that G-kL expansion may be not good enough to represent rim density well; not good for rho1+rho2.
    ! --> In .not.old2023mixing, TK removed a factor exp(+(r/rf)**2). Probably the rim density problem?
    !
    
    !l   rms2   : <(rout-rin)**2>, where rin and rout are the input and
    !l          : screened output densities represented as a vector,
    !l          : including smoothed and local parts.  rmsdel changes with
    !l          : the choice of transformation of local densities;see locmix
    !l          : above.
    !l   rmsdel : (linked to dmxp(11)).
    !l          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
    !l          : On output, rmsdel is overwritten by rms2.
    !l   rms    : RMS difference in output-input sm. density
    !l   kmxr   : k-cutoff for G_kL expansion used to smooth local densities for mixing
    !l   ng0    : condensed number of G vectors. That rho(G) is hermitian is exploited to reduce ng to ng0
    !l   qcell  : cell charge

    !! Warn. For Co case, I found broyden mixing works wrong.! ITER    NIT=30 MIX=B3,n=5,b=.7,w=1,0 However, as in copt, Broyden mixing is efficient.
    
    ! o Mixing parameters from m_lmfinit
    ! o         : broy  :mixing scheme: 0->Anderson 1->Broyden
    ! o         : beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
    ! o         : wc    :Broyden weights for prior iterations
    ! o         : wt    weights for n^+ + n^- and n^+ - n^- in spin pol cases
    ! o                Avg, diff weighted by wt(1) and wt(2) in the mixing.
    ! o                As special cases,
    ! o                wt(2)=0 freezes the moments and mixes the charge only
    ! o                wt(1)=0 freezes the charge and mixes the moments only
    ! o         : mxsav : maximum number of prior iter to save on disk
    ! o         : mmix  : maximum number of prior iter to mix
    ! o         : nkill : kill mixing file after multiples nkill
    ! o         : betv  : special potential mixing parameter
    ! o         :Outputs
    ! o         : rmsdel : rms (output-input) density
    ! o         : rmsl   : rms (output-input) local density
    ! o         : nmix   : number of prior iter actually mixed
    ! o         : broy   : actual mixing scheme used
    ! o         : beta   : actual mixing beta used
    ! o         : tj  : Anderson mixing coefficients
    ! o         :         : (spin polarized case only)
    ! o                      : 1  if weight for n^+ + n^- is nonzero
    ! o                      : 10 if weight for n^+ - n^- is nonzero
    ! o                      : 11 if both nonzero

    type(s_rv1) :: sv_p_orho(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    character sout*80,fnam*8
    character(20) :: ext
    logical::  mixrealsmooth, init=.true., initd=.true. !noelind,
    integer :: numprocs, ierr,isp,nnnx,ng02,ng2, iprint, iter,procid,master
    integer :: i,ib,ipl,ipr,is,k0, lmxl,nlml,nr,nmixr,nda,ifi,kkk,nnnew,nnmix,nx,nkill,naa,kmxr,kmxs,locmix,offx,off2,nlmlx,ng0
    integer,save:: broy,nmix,mxsav
    real(8),save:: rmsdelsave,beta,wt(2)
    real(8):: smmin,sss,wgtsmooth,qval !elinl
    real(8) :: a,beta0,dif,fac,rms,rmt,summ,top,tpiba,dquns,q1,qin(2),qout(2),qcell,rms2,rms2f,rsmv,qmx, rmsdel,xx
    real(8),allocatable :: rofi_rv(:),rwgt_rv(:), wn1_rv(:),wn2_rv(:),co_rv(:,:,:,:)
    real(8),allocatable:: w_oqkl(:), w_oa(:,:,:,:),w_oaa(:), cn_rv(:,:,:,:),rho1bk(:),rho2bk(:)
    complex(8):: smrnew(n1,n2,n3,nsp),smrho(n1,n2,n3,nsp)
    complex(8),allocatable :: cg1_zv(:), cg2_zv(:),fkl_zv(:), smrnewbk(:,:,:,:),w_owk(:),cn_rvc(:),co_rvc(:)
    include "mpif.h"
    call tcn('mixrho')
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr )
    call getpr(ipr)
    master = 0
    ipl = 1
    kkk = n1*n2*n3 
    kmxr = 8
    if(initd) then
       mxsav = mix_nsave !out 
       rmsdelsave=0d0
       beta=1d0
       initd=.false.
    endif
    rms2 = 0
    fnam = 'mixm' 
    nmix = nmixinit
    broy = broyinit
    if(bexist) beta=betainit
    nkill = max(killj,0) ! Periodic file deletion (nkill):   
    if (nkill>1 .and. mod(iter,nkill) == 0) nkill=-nkill
    if (nkill == 1) nkill=-nkill
    rmsdel = rmsdelsave
    if (nmix == 0) broy = 0
    if (nmix < 0) nmix = mxsav
    call rhoqm(smrho, n1,n2,n3,nsp,vol,qin ) ! ... Initial charges
    call rhoqm(smrnew,n1,n2,n3,nsp,vol,qout)
    fac = vol/(n1*n2*n3)
    rms = sum((smrnew(:,:,:,:)-smrho(:,:,:,:))**2) ! RMS difference. Before 2023-10-8, it is sum of the differenc of charge (not spin density).
    rms = dsqrt(fac*rms/vol)
    !!== elind mode ==> removed
    nlmlx=maxval((lmxl_i+1)**2)
    nda=0
    do ib = 1, nbas
       is = ispec(ib) 
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       nr  =nr_i(is)
       nlml = (lmxl+1)**2
       allocate(rho1bk,source=sv_p_orho(1,ib)%v)
       allocate(rho2bk,source=sv_p_orho(2,ib)%v)
       sv_p_orho(1,ib)%v=rho1bk+rho2bk
       sv_p_orho(2,ib)%v=rho1bk-rho2bk   
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=rho1bk+rho2bk
       sv_p_orhnew(2,ib)%v=rho1bk-rho2bk   
       deallocate(rho1bk,rho2bk) 
       nda = nda + 2*(kmxr+1)*(lmxl+1)**2 + 2*nr_i(is) ! include spherical part of local densities and non-spherical part of rho1-rho2
    enddo    
    ng02 = n1*n2*n3
    ng2 = ng02
    nda = nda + ng02
    wgtsmooth=1d0/ng02**0.5d0 !try this relative weight. Not correct weight charge mixing.
    if(iprint()>10) print *,'wgtsmooth=',wgtsmooth
    allocate(cn_rv(n1,n2,n3,nsp),co_rv(n1,n2,n3,nsp))
    cn_rv= dreal(smrnew)*wgtsmooth 
    co_rv= dreal(smrho)*wgtsmooth 
    allocate(w_oa(nda,nsp,(mxsav+2),2),source=0d0)
    allocate(w_oqkl(2*(kmxr+1)*nlmlx*nsp*4*nbas))
    w_oqkl=0d0
    if (procid==master) open(newunit=ifi,file=trim(fnam)//'.'//trim(sname),form='unformatted')
    call packdensity(nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx, nsp,sv_p_orho & !Setup mixing array w_oa
        ,sv_p_orhnew,co_rv,cn_rv,ng2,ng02,nda, w_oa,w_oqkl,rms2,nmixr ) !w_oa contains mixingsource
    rmsdel = rms2
    nmix = min(nmix,nmixr)
    WriteThisANDPriorIterationsONTOdisk:block
      integer:: j
      if (procid==master) then
         rewind(ifi)
         write(ifi) min(nmix+1,mxsav), nda*nsp
         do  j = 1, min(nmix+1,mxsav)
            write(ifi)w_oa(:,:,j,1)
            write(ifi)w_oa(:,:,j,2)
         enddo
      endif
    endblock WriteThisANDPriorIterationsONTOdisk
    if (nkill < 0) then
       if(ipr>=20) write(stdo,"(a,i5)")' ...  deleting file '//trim(fnam)//" nkill=",nkill
       if(procid==master) close(ifi,status='delete')
    else
       if(procid==master) close(ifi)
    endif
    if(ipr>45)write(stdo,"(' charges:',7x,'old',11x,'new',9x,'rms diff',5f14.6)") qin(1),qout(1),rms 
    if (nsp == 2) then 
       write(stdo,"(' mmom   ',2f14.6,28x,f14.6)") qin(2),qout(2)!,beta*qscr(2)+(1-beta)*qin(2)
       wt(1:2)   = wtinit     
       if(sum(wt**2)==0d0) call rx('MIXRHO: bad mixing weights wt=0')
       wt= wt/sum(wt**2)**.5  !we need this just to keep fe_gwsc !without this, mixing changes things slightly.
       naa = 0
       if (abs(wt(1))>1d-12) naa = naa+nda
       if (abs(wt(2))>1d-12) naa = naa+nda
       offx = 0        !offset to extra elements (none now)
       off2 = nda      !offset to spin down part of a
       allocate(w_oaa(naa*(mxsav+2)*2),source=0d0)
       call pqsclf(nda*nsp,nda,offx,off2,naa,mxsav,wt, w_oa,w_oaa,rms2f)
       if (abs(wt(1)*wt(2))<1d-12 ) then
          write(stdo,ftox)' Constrained spin mixing wt =',ftof(wt),' Constrained rms DQ=',ftod(rms2f)
          rmsdel = rms2f
       endif
       call mixdensity(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oaa) !main part of mixing
       call pqsclb(nda*nsp,nda,offx,off2,naa,mxsav,wt,w_oa,w_oaa) !Restore matrix a to rho+, rho===
        w_oa(:,:,1,1)=w_oa(:,:,1,2) 
       deallocate(w_oaa)
    else
       naa = nda
       call mixdensity(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oa) !main part of mixing
    endif
    call getrhoremnant(nbas,nsp,beta,kmxr,nlmlx,w_oqkl,sv_p_orho,sv_p_orhnew) !Linear mixing of remnants of rho. 
    call unpackdensity(nbas,nsp,nda,w_oa,n1,n2,n3,kmxr,nlmlx,w_oqkl,ng,ng02,iv_a_okv,rv_a_ogv,wgtsmooth, smrho,sv_p_orho) !Get mixed smrho,orho
    deallocate(w_oqkl,w_oa,co_rv,cn_rv)
    qmx=0d0
    do ib = 1, nbas ! ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-'
       is = ispec(ib)
       lmxl=lmxl_i(is)
       if (lmxl < 0) cycle
       allocate(rho1bk,source=sv_p_orho(1,ib)%v)
       allocate(rho2bk,source=sv_p_orho(2,ib)%v)
       sv_p_orho(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orho(2,ib)%v=.5d0*(rho1bk-rho2bk) 
       rho1bk=sv_p_orhnew(1,ib)%v
       rho2bk=sv_p_orhnew(2,ib)%v
       sv_p_orhnew(1,ib)%v=.5d0*(rho1bk+rho2bk)
       sv_p_orhnew(2,ib)%v=.5d0*(rho1bk-rho2bk)
       deallocate(rho1bk,rho2bk)
       nlml = (lmxl+1)**2
       nr=nr_i(is)
       allocate(rwgt_rv(nr))
       call radwgt( rmt_i(is),spec_a(is),nr,rwgt_rv)
       do i = 1, nsp !  Net local site charge q1-q2
          off2 = 1 + nr*nlml*(i-1)
          associate(rho1s=> sv_p_orho(1,ib)%v(off2:off2+nr-1), rho2s=> sv_p_orho(2,ib)%v(off2:off2+nr-1)) 
            qmx = qmx+srfpi*sum((rho1s-rho2s)*rwgt_rv) !charge
          endassociate
       enddo
       deallocate(rwgt_rv)
    enddo      
    summ = sum(smrho) ! ... Net interstitial charge and cell charge
    qcell= qval - summ*fac - qmx !     Net system charge
    xx = qcell/(vol*nsp)
    if(iprint()>10) write(6,"(a,4d13.5)")' mixrho: qcell,correction,qmx,summ =',qcell,xx,qmx,summ
    smrho=smrho+xx ! Add constant to smrho to force charge neutrality
    rmsdelsave = rmsdel
    if(ipr>=10 .AND. abs(qcell) > 1d-6) write(stdo,'('' add q='',f10.6,'' to preserve neutrality'')') qcell
    nnnx=count(dreal(smrho)<0d0)
    smmin=minval(dreal(smrho))
    if(nnnx>0 ) write(6,"(a,i8,d13.5)") ' mixrho: warning. negative smrho; isp number min=',nnnx,smmin
    if(nnnx<=0) write(6,"(a)") ' mixrho: all smrho are positive'
    call tcx('mixrho') ! ... old code=> call rhopos(smrho,n1,n2,n3,n1,n2,n3) to enforce density positive
  end subroutine mixrho
  subroutine getrhoremnant(nbas,nsp,beta,kmxr,nlmlx,qkl,sv_p_orho,sv_p_orhnew) ! Linearly mix local densities, possibly subtracting G_kL expansion
    use m_struc_def  
    use m_lmfinit,only: ispec
    !i   beta  :linear mixing parameter
    !i   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
    !i   nlmlx   :second dimension of qkl
    !i   qkl    :G_kL expansion coefficients of local densities
    !i          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !i          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !i          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !i          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    ! o Inputs/Outputs
    ! o  orho :On input, local densities generating hamiltonian
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orho).
    ! o         :On output, w(orho) is overwritten by the linear
    ! o         :combination (1-beta)*w(orho) + beta*w(orhnew)
    ! o  orhnew :On input, local densities gen. by ham. (maybe screened)
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhnew).
    implicit none
    integer :: nbas,nsp,kmxr,nlmlx,locmix
    type(s_rv1) :: sv_p_orho(3,nbas)
    type(s_rv1) :: sv_p_orhnew(3,nbas)
    real(8):: difx,beta,qkl(0:kmxr,nlmlx,nsp,4,nbas)
    integer :: ib,is,igetss,nr,nlml,m,lmxl,ir,mode4
    real(8) ,allocatable :: ri_rv(:), rwgt_rv(:),w_orsm(:,:,:,:)
    real(8) :: a,rmt,rg,difa,rf
    do  ib = 1, nbas
       is = ispec(ib)
       lmxl = int(lmxl_i(is))
       if (lmxl == -1) cycle
       a=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       rg=rg_i(is)
       nlml = (lmxl+1)**2
       allocate(ri_rv(nr),rwgt_rv(nr),w_orsm(nr,nlml,nsp,4))
       call radmsh( rmt,a,nr,ri_rv)
       call radwgt( rmt,a,nr,rwgt_rv)
       rf = rmt/3
       do m=1,4
          call pkl2ro(rg,kmxr,nr,nlml,nsp,ri_rv,rwgt_rv,nlmlx,qkl(0,1,1,m,ib), w_orsm(:,:,:,m))
       enddo
       if(old2023mixing) then
          forall(ir=1:nr) w_orsm(ir,:,:,1)=w_orsm(ir,:,:,1)* exp((ri_rv(ir)/rf)**2) !scale up orsm
          forall(ir=1:nr) w_orsm(ir,:,:,3)=w_orsm(ir,:,:,3)* exp((ri_rv(ir)/rf)**2)
       endif
       associate( rhos1=>w_orsm(:,:,:,1),rhos2=>w_orsm(:,:,:,2),rhns1=>w_orsm(:,:,:,3),rhns2=>w_orsm(:,:,:,4),&
            rho1=>sv_p_orho(1,ib)%v, rho2=>sv_p_orho(2,ib)%v, rho3=>sv_p_orho(3,ib)%v, &
            rhn1=>sv_p_orhnew(1,ib)%v, rhn2=>sv_p_orhnew(2,ib)%v, rhn3=>sv_p_orhnew(3,ib)%v)
         rho1=(1-beta)*rho1 +beta*rhn1 -reshape((1-beta)*rhos1+beta*rhns1 ,shape(rho1)) !Subtract scale up orsm
         rho2=(1-beta)*rho2 +beta*rhn2 -reshape((1-beta)*rhos2+beta*rhns2 ,shape(rho2))
         rho3=(1-beta)*rho3 +beta*rhn3
       endassociate
       deallocate(rwgt_rv,ri_rv,w_orsm)
    enddo
  end subroutine getrhoremnant
  subroutine packdensity(nmix,mxsav,fnam,ifi,rmsdel,nbas,kmxr,nlmlx,nsp,sv_p_orho,sv_p_orhnew,co,cn,ng2,ng02,nda, a,qkl,rms2 ,nmixr)  !Set up mixing array
    use m_lmfinit,only:ispec
    use m_struc_def
    use m_ftox
    !i   nmix  :number of prior iterations sought (for printout)
    !i   mxsav :max no. prior iteration to read, also dimensions a
    !i   fnam  :file name (for printout)
    !i   ifi  :file logical unit
    !i  rmsdel :Same as rms2 (see Outputs), from prior iteration.
    !i         :If no prior iteration, rsmdel=0.  For printout only.
    !i   orho:input local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 
    !i   orhnew:output local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 
    !i   co    :input smooth density this iteration, in FT form
    !i   cn    :output smooth density this iteration, in FT form
    !i   ng    :leading dimension of co,cn
    !i   ng0   :number of Fourier coefficients
    !o Inputs/Outputs
    ! o  nmixr :(output for ifi>0) number of prior iter read from file
    ! o        :on output number of prior iterations read from file
    ! o  a,nda :work array a and leading dimension (nda must be >= na)
    ! o         a(*,i,1) holds f(xi) for iteration i-1
    ! o         a(*,i,2) holds   xi  for iteration i-1
    !o Outputs
    !o  qkl    : G_kL expansion of local densities
    !o         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !o         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !o         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !o         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    !o  rms2   :rms difference in f-x, where f=output density and x the
    !o          input density.  f and x include smoothed and local
    !o          contributions, with the latter depending on choice of
    !o          linear transformation; see locmix above.  Thus, there
    !o          is some arbitrariness in rms2.
    !r Remarks
    !r   Content of a(*) = a(*,isp,:,:):
    !r   Case locmix = 3
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
    !r     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
    !r                                             w/ l=0 part zeroed out
    !r     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
    implicit none
    include "mpif.h"
    integer :: procid, master, numprocs, ierr
    character(20) :: ext
    logical :: readerror!,lddump
    integer :: ng2,ng02,nda,nmix,mxsav,ifi,nbas,nr,nsp,kmxr,nlmlx
    type(s_rv1) :: sv_p_orho(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    real(8):: a(nda,nsp,mxsav+2,2),rms2,rmsdel
    real(8):: co(ng2,nsp),cn(ng2,nsp),qkl(0:kmxr,nlmlx,nsp,4,1)
    character fnam*8
    integer :: ib,na,i,j,k,m,np,iprint,nmixr,is,igetss, off,nlml,lmxl 
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ::rmt,aat,rf
    character outs*80
    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr)
    master = 0
    ! smooth part
    a(1:ng02,1:nsp,1,2)=co(1:ng02,1:nsp) !old
    a(1:ng02,1:nsp,1,1)=cn(1:ng02,1:nsp) !new
    ! atomic part
    na = 1 + ng02
    do ib = 1, nbas
       is  = ispec(ib)
       lmxl= lmxl_i(is)
       if(lmxl == -1) cycle
       nr = nr_i(is)
       rmt=rmt_i(is)
       rf = rmt/3
       nlml = (lmxl+1)**2
       np = (1+kmxr)*nlml
       block
         integer:: ir
         real(8):: rhoold1(nr,nlml,nsp),rhonew1(nr,nlml,nsp),rhoold2(nr,nlml,nsp),rhonew2(nr,nlml,nsp)
         real(8):: rofi_rv(nr)
         rhoold1=reshape(sv_p_orho(1,ib)%v, shape(rhoold1))
         rhoold2=reshape(sv_p_orho(2,ib)%v, shape(rhoold2))
         rhonew1=reshape(sv_p_orhnew(1,ib)%v, shape(rhonew1))
         rhonew2=reshape(sv_p_orhnew(2,ib)%v, shape(rhonew2))
         call radmsh( rmt,spec_a(is),nr,rofi_rv)
         if(old2023mixing) then
            forall(ir = 1:nr) rhoold1(ir,:,:) = rhoold1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
            forall(ir = 1:nr) rhonew1(ir,:,:) = rhonew1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
         endif
         do  i = 1, nsp ! spherical part 
            a(na:na+nr-1,     i,1,2)= rhoold1(:,1,i) !old
            a(na+nr:na+2*nr-1,i,1,2)= rhoold2(:,1,i)
            a(na:na+nr-1 ,    i,1,1)= rhonew1(:,1,i) !new
            a(na+nr:na+2*nr-1,i,1,1)= rhonew2(:,1,i)
         enddo
         if(.not.old2023mixing) then
            forall(ir = 1:nr) rhoold1(ir,:,:) = rhoold1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
            forall(ir = 1:nr) rhonew1(ir,:,:) = rhonew1(ir,:,:) * exp(-(rofi_rv(ir)/rf)**2)
         endif
         call rhogkl( ib,nsp,rhoold1,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,1,ib ) ) !old
         call rhogkl( ib,nsp,rhoold2,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,2,ib ) )
         call rhogkl( ib,nsp,rhonew1,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,3,ib ) ) !new
         call rhogkl( ib,nsp,rhonew2,  kmxr,nlml,nlmlx,nr,qkl(:,:,:,4,ib ) )
         na=na+2*nr
         do  i = 1, nsp ! moment part
            qkl(0:kmxr,1,i,1:4,ib)=0d0 !  zero out spherical part of G_kL
            a(na:na+np-1,     i,1,2)=reshape(qkl(:,1:nlml,i,1,ib),[np]) !old
            a(na+np:na+2*np-1,i,1,2)=reshape(qkl(:,1:nlml,i,2,ib),[np])
            a(na:na+np-1,     i,1,1)=reshape(qkl(:,1:nlml,i,3,ib),[np]) !new
            a(na+np:na+2*np-1,i,1,1)=reshape(qkl(:,1:nlml,i,4,ib),[np])
         enddo
       endblock
       na = na + 2*np
    enddo         
    if(nda/= na-1) call rx('mixrho: bug in packdensity nda/=na-1')
    na   = nda*nsp
    rms2 = (sum((a(:,:,1,1)-a(:,:,1,2))**2)/(nda*nsp))**.5*nsp ! *nsp is right?
    if(mxsav == 0) return
    ReadPreviousIterations: block
      nmixr = 0
      if(procid == master) then
         readerror = .true.
         read (ifi,err=311,end=311) nmixr, na
         readerror = .false.
         do j = 1,  min(mxsav,nmixr)
            read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,1) 
            read(ifi,end=90,err=90) a(1:nda,1:nsp,j+1,2)
            nmixr = j
            cycle
90          continue
            write(stdo,ftox) 'packdensity: reading only nmixr=',nmixr
            exit
         enddo
         goto 312
311      continue
      endif
312   continue
      call MPI_BCAST(readerror,1,MPI_LOGICAL,   master,MPI_COMM_WORLD,ierr)
      if(readerror) goto 9999
      call MPI_BCAST(na,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
9999  continue
      call MPI_BCAST(nmixr,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
      if(nmixr > 0) call MPI_BCAST(a,nda*nsp*(mxsav+2)*2,MPI_DOUBLE_PRECISION, master,MPI_COMM_WORLD,ierr)
    endblock ReadPreviousIterations
    if(iprint() >= 20) then !this is needed for test
       write(stdo,fmt=ftox, advance='no')' mixrho: sought',nmix,'iter from file '//trim(fnam)
       write(stdo,fmt='("; read ",g0," RMS DQ=",es8.2e1)',advance='no') nmixr, rms2
       if (rmsdel/= 0) write(stdo,"('  last it=',es8.2e1)",advance='no')rmsdel
       write(stdo,*)
    endif
  end subroutine packdensity
  subroutine mixdensity(broy,nmix,mmix,mxsav,beta,wc,nda,a)!- Mixing of the total density
    use m_amix,only: amix
    !i  broy   : 0 for Anderson mixing,   : 1 for Broyden mixing
    !i  nmix   : nmix: number of iter to try and mix
    !i  mmix   : number of iterates available to mix
    !i  mxsav  : second dimension of a
    ! o Inputs/Outputs
    ! o  a     :On input:
    ! o         (*,i,1)  output vector for prev. iteration i
    ! o         (*,i,2)  input  vector for prev. iteration i
    ! o        :On output:
    ! o         (*,0,1) and (*,0,2) estimated new vector
    ! o         (*,i,1), i>1 destroyed
    !r  Remarks
    !r    Broyden mixing adapted from Duane Johnson.  Notation:
    !r    x^(m): input vector for iteration m
    !r    F^(m): difference between output and input vector in iteration m
    implicit none
    integer :: nda,nmix,mmix,mxsav,broy
    real(8) :: beta,a(nda,0:mxsav+1,2)
    integer :: j,iprint!,amix
    real(8) :: tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
    parameter (tjmax = 5d0) 
    real(8),allocatable:: aaa(:)
    if (nmix == 0 .OR. nmix == 1 .OR. broy == 0) then
       do  j = 1, nmix
          a(:,j,1)=a(:,j,1)-a(:,j,2) ! ... amix needs f-x for prior iterations
       enddo
       nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,a,tj,  rms2)               ! Anderson mixing
    elseif(broy == 1) then; call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) ! Broyden mixing, Duane Johnson's approach ---
    else;                   call rx('mixdensity: bad value for broy')
    endif
    a(:,0,1)=a(:,0,2)
  end subroutine mixdensity
  subroutine unpackdensity(nbas,nsp,nda,a,n1,n2,n3,kmxr,nlmlx,qkl,ng,ng02,kv,gv,wgtsmooth, smrho,sv_p_orho) !read from array a
    use m_lmfinit,only: ispec
    use m_struc_def 
    !i   nda   :leading dimension of a
    !i   a     :mixed density from mixdensity, smoothed + local densities
    !i         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
    !i         :locmix = 3, a contains spherical part on mesh a full rho, GkL expansion
    !i   n1..3 :FT mesh
    !i   n1..3 :dimensions smrho
    !i   ng    :number of FT G-vectors
    !i   ng0   :condensed number of G vector (excluding hermitian equiv)
    !i   kv    :indices for gather/scatter operations (gvlist.f)
    !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
    !i   wk    :complex work array of dimension (n1,n2,n3)
    !i   smrho :smooth density that generated the hamiltonian
    !i   orho:local  density that generated the hamiltonian,
    !i         :a portion of which which has been linearly mixed 
    !i         :orho(1) contains rho1+rho2
    !i         :orho(2) contains rho1-rho2
    !o Outputs
    !o   smrho :overwritten by mixed smooth density
    !o   orho:mixed local density is returned, in rho1+rho2,rho10rho2 form
    implicit none
    integer :: nsp,n1,n2,n3,ng,ng02,nda,na,nr,nbas, kv(ng,3),kmxr,nlmlx
    type(s_rv1) :: sv_p_orho(3,1)
    real(8):: gv(ng,3),a(nda,nsp),qkl(0:kmxr,nlmlx,nsp,4,nbas),rf, wgtsmooth
    complex(8):: smrho(n1,n2,n3,nsp),wk(n1,n2,n3)
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    integer :: ib,is,mode4,m,lmxl,nlml,off,np,orsm(2),i,ir
    real(8) :: aat,rmt,rg,xx
    real(8),allocatable:: w_orsm(:,:,:,:)
    forall(i=1:nsp)smrho(:,:,:,i)=1d0/wgtsmooth*reshape(a(:,i),[n1,n2,n3])
    na = 1 + ng02
    do  ib = 1, nbas
       is = ispec(ib)
       aat=spec_a(is)
       nr=nr_i(is)
       rmt=rmt_i(is)
       lmxl=lmxl_i(is)
       if (lmxl == -1) cycle
       rf = rmt/3
       rg = rg_i(is)
       nlml = (lmxl+1)**2
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh(rmt,aat,nr,rofi_rv)
       call radwgt(rmt,aat,nr,rwgt_rv)
       do  i = 1, nsp
          off = 1+nr*nlml*(i-1)
          sv_p_orho(1,ib)%v(off:off+nr-1)= a(na:   na+nr-1,  i ) ! Overwrite spherical orho
          if(old2023mixing) sv_p_orho(1,ib)%v(off:off+nr-1)= a(na:   na+nr-1,  i )* exp((rofi_rv(:)/rf)**2) !scale up readin a
          sv_p_orho(2,ib)%v(off:off+nr-1)= a(na+nr:na+2*nr-1,i )
       enddo
       na = na + 2*nr
       np = (1+kmxr)*nlml
       allocate(w_orsm(nr,nlml,nsp,2))
       do m = 1, 2
          forall(i=1:nsp) qkl(:,1:nlml,i,m,ib)= reshape(a(na+np*(m-1):na+np*(m-1)+np-1,i),[kmxr+1,nlml])
          call pkl2ro(rg,kmxr,nr,nlml,nsp,rofi_rv,rwgt_rv,nlmlx,qkl(0,1,1,m,ib),w_orsm(:,:,:,m))
          if(old2023mixing.and.m==1) forall(ir=1:nr) w_orsm(ir,:,:,m)=w_orsm(ir,:,:,m)* exp((rofi_rv(ir)/rf)**2) !scale up orsm
       enddo
       sv_p_orho(1,ib)%v = sv_p_orho(1,ib)%v + reshape(w_orsm(:,:,:,1),shape(sv_p_orho(1,ib)%v)) !Add mixed qkl density to existing orho
       sv_p_orho(2,ib)%v = sv_p_orho(2,ib)%v + reshape(w_orsm(:,:,:,2),shape(sv_p_orho(2,ib)%v))
       deallocate(w_orsm)
       na = na + 2*np
       deallocate(rwgt_rv,rofi_rv)
    enddo               
    na = na-1
    if(nda/=na) call rx('mixrho: bug in unpackdensity')
  end subroutine unpackdensity
  subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue) !Broyden mixing of a vector, Duane Johnson's approach
    use m_ftox
    !i  mmix: number of iterates available to mix
    !i  a:    (*,i,1)  output values for prev. iteration i
    !i        (*,i,2)  input  values for prev. iteration i
    ! o nmix: nmix > 0: number of iter to try and mix    nmix < 0: use mmix instead of nmix.
    !o  nmix: (abs)  number of iter actually mixed.  (sign) <0, intended that caller update nmix for next call.
    !r  x^(m): input vector for iteration m
    !r  F^(m): difference between output and input vector in iteration m
    implicit none
    integer :: nda,nmix,mmix,mxsav,im,km,i,iprint,i1mach,imix,jmix
    real(8) :: beta,rms2,wctrue,a(nda,0:mxsav+1,2), wc
    real(8) :: xmp1_rv(nda), f_rv(nda), ui_rv(nda), vti_rv(nda), xold_rv(nda), df_rv(nda), dx_rv(nda)
    real(8),allocatable:: wk_rv(:)
    imix = merge(mmix,nmix, nmix < 0) !imix is a local copy of nmix
    jmix = min(mmix,iabs(imix))
    do km = 1, jmix
       im = jmix-km+1
       dx_rv=a(:,im-1,1)- a(:,im-1,2)
       rms2 = (sum(dx_rv**2)/nda)**.5
       wctrue= merge(min(max(-wc/100/dsqrt(nda*rms2**2),1d0),1d4),wc,wc < 0) !Determine wc_true if wc < 0 ---
       if(km == 1) wctrue = .01d0
       i = iprint()
       if (km /= jmix) i = i-20
       allocate(wk_rv(nda*2*(jmix+2)))
       i = broyj ( nda,a(1,im-1,2),dx_rv,km, i,beta,0d0,0d0,0d0,wctrue,wk_rv,nda,xmp1_rv )
       deallocate(wk_rv)
    enddo
    nmix = imix
    if(nmix == 0 ) return
    if(iprint() > 60 .OR. (iprint() >= 40 .AND. nda <= 100)) then
       write(stdo,"(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')") 
       do i = 1, nda
          if(dabs(a(i,0,1)-a(i,0,2))>= 5d-9 ) write(stdo,"(i5,4f14.6)")i,a( i,0,2 ),a( i,0,1 ),a(i,0,1)-a( i,0,2 ),xmp1_rv(i) 
       enddo
    endif
    a(:,0,2)=xmp1_rv !Save x^(m+2) into a(*,0,2)
  end subroutine pqmixb
  subroutine pkl2ro(rsm,kmax,nr,nlml,nsp,rofi,rwgt,nlmlx,qkl,rho1) !- Get rho_GkL from qkl
    !i   rsm   :smoothing radius for P_kL (or G_kL) expansion
    !i   kmax  :k-cutoff for P_kL (or G_kL) expansion
    !i   nr    :number of radial mesh points
    !i   nlml  :L-cutoff for rho1,rho2
    !i   nsp   :2 if fkl is spin-pol; 1 if not
    !i   rofi  :radial mesh points
    !i   rwgt  :radial mesh weights
    !i   nlmlx  :second dimension of fkl
    !i   qkl  :real coefficients to P_kL (or G_kL) expansion for this site
    !o  rho1  : \sum qkL G_kL (or G_kL).
    implicit none
    integer :: mode,kmax,nlmlx,nr,nlml,nsp,i,ilm,isp,k,l,lmxl,np 
    real(8) :: qmx,rsm, rofi(nr),rwgt(nr), rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),nchg(nr,nlml),nspn(nr,nlml),qkl(0:kmax,nlmlx,nsp)
    lmxl = ll(nlml)
    block
      real(8):: pkl(nr,0:kmax,0:lmxl)
      do i = 2, nr
         call radgkl(rofi(i),rsm,kmax,lmxl,kmax,pkl(i,:,:))
      enddo
      do ilm = 1, nlml
         l = ll(ilm)
         do  isp = 1, nsp
            rho1(1:nr,ilm,isp) = [0d0,(sum(qkl(:,ilm,isp)*pkl(i,:,l))*rofi(i)**(l+2),i=2,nr)] !Eq.(12.15)(12.10) !noe r**2 factor.
         enddo
      enddo
    endblock
  end subroutine pkl2ro
  subroutine rhoqm(smrho,n1,n2,n3,nsp,vol, qsum)    !- Return charge, magnetic moment of smooth density
    !o Outputs
    !o   qsum  :qsum(1) = smrho(+) + smrho(-)
    !o         :qsum(2) = smrho(+) - smrho(-) (for nsp=2 only)
    implicit none
    integer ::  n1,n2,n3,nsp,i
    complex(8):: smrho(n1,n2,n3,nsp)
    real(8):: vol,qsum(nsp),sumi(nsp)
    sumi = [(sum(smrho(:,:,:,i)),i=1,nsp)]
    qsum(1) = vol/(n1*n2*n3)*sum(sumi)
    if(nsp==2) qsum(2) = vol/(n1*n2*n3)*(sumi(1)-sumi(2))
  end subroutine rhoqm
  integer function broyj(n,xin,gin,ir,ipr,beta,dxmx,xtol,gtol, wc,wk,ndw,xnew)   !- One Broyden step in finding gin = f[xin]-xin = 0
    !i Inputs
    !i   n:     number of variables
    !i   ir:    Number of iterations of x and g.
    !i          1 initiates a new sequence of mixing;
    !i          broyj uses linear mixing for this iteration.
    !i   beta:  linear mixing parameter (ir=1 only)
    !i   xin:   input vector, this iteration
    !i   gin:   output-input vector, f[xin]-xin, this iteration
    !i   wc:    weighting for this iteration
    ! o  wk     workspace of 2*ndw*(ir+2), ndw>=n
    ! o         wk must be preserved between calls to broyj.
    ! o         (*,1,0) x of the prior iteration.
    ! o         (*,2,0) g of the prior iteration.
    ! o         (*,1..2,1..ir-1) u and vt of this and prior iterations
    ! o         (*,1,ir) g(this iter) - g (prior iter).
    !o Outputs
    !o   xnew   estimate of x
    !o   broyj
    !r Remarks
    !r   Adapted from Duane Johnson
    implicit none
    integer,parameter::nn=20
    integer :: ir,n,ipr,ndw,i,ip,j,k,irm1,irm2,lm,ln,ierr
    real(8) :: beta,dxmx,wc,xin(n),gin(n),xnew(n),xtol,gtol, wk(ndw,2,0:ir), aij,cmj,dfnorm,fac1,fac2,gmi,ddot,w0
    real(8) :: a(nn,nn),cm(nn),w(nn),d(nn,nn), betx,diff,gmax,xmax
    save w,cm,a,w0 ! NOTE here!!!!
    if (ir > nn) call rxi('broyj: increase nn, need',ir)
    if (ir == 1) then !First iteration: simple mixing ---
       w0 = wc
       gmax = maxval(gin)
       xnew = xin + merge( beta*dxmx/gmax,beta,dxmx>0d0.AND.gmax>dxmx)*gin
    else ! --- Subsequent iterations: Broyden mixing ---
       wk(:,1,0) =xin-wk(:,1,0) !Make xold, gold
       wk(:,1,ir)=gin-wk(:,2,0)
       !   --- Coefficient matrices and the sum for corrections ---
       fac2 = 1d0/(sum(wk(:,1,ir)**2)**.5+1d-12) !dfnorm = |g(i)-g(i-1)|, used for normalization
       fac1 = beta*fac2
       irm1 = ir-1
       irm2 = ir-2
       wk(:,:, 2:irm2+1)=wk(:,:, 1:irm2) !Shuffle each prior u,vt to prior+1 iteration
       wk(:,1, 1) = fac1*wk(:,1,ir)+fac2*wk(:,1,0) !   ... Make u,vt for this iteration
       wk(:,2, 1) = fac2*wk(:,1,ir)
       do  j = 1, irm2 !Make  a and b = ( w0**2 I + a )^-1 (symmetric) ---
          a(irm1,j) = sum(wk(:,2,ir-j)*wk(:,2,1))
          a(j,irm1) = a(irm1,j)
          cm(j) = sum(wk(:,2,ir-j)*gin)
       enddo
       a(irm1,irm1) = sum(wk(:,2,1)*wk(:,2,1))
       cm(irm1) = sum(wk(:,2,1)*gin)
       w(irm1) = wc
       forall(lm=1:irm1,ln=1:irm1) d(ln,lm) = a(ln,lm)*w(ln)*w(lm) + merge(w0**2,0d0,lm==ln) ! Set up and calculate beta matrix
       call matinv2(irm1,d(1:irm1,1:irm1),ierr) !Invert to make d ---
       xnew = xin + beta*gin !xnew <- vector for the new iteration ---
       do i = 1, irm1
          gmi =  sum([(cm(ip)*d(ip,i)*w(ip),ip=1,irm1)])
          xnew = xnew - gmi*wk(:,1,ir-i)*w(i)
       enddo
       if(dxmx>0d0) then !  ... Cap to maximum allowed shift xnew-xin
          diff = maxval(abs(xnew-xin))
          if(diff>dxmx) xnew = xin + dxmx/diff*(xnew-xin)
       endif
    endif
    wk(:,2,0) = gin
    wk(:,1,0) = xin
    j = ir+1
    broyj = j
  end function broyj
  subroutine rhogkl(ib,nsp,rho,kmax,nlml,nlmlx,nr,qkl )!- G_kL expansion of valence sphere densities
    use m_lgunit,only:stdo
    use m_struc_def  
    use m_lmfinit,only: ispec
    use m_hansr,only:corprm
    !i   kmax  : make expansion coffs to polynomial cutoff kmax
    !i   orhoat: vector of offsets containing site density
    !o   qkl  :Expansion coefficients, stored as a single long vector.
    !o        := integral pkl Y_L integrand where integrand is according to mode
    !r Remarks1
    !r   Q_kL = integral p_kl (rho1-rho2) + l=0 contr. from core spillout.  Ser rhomom
    !r   The core spillout term is:
    !r      qcore(rhoc)-z  - sm_qcore-sm_qnuc
    !r   NB: p0l = a**l and scaling factor for k=0 is 4*pi/(a**l * (2l+1)!!)
    !r       => q0l = 4*pi/(2l+1)!! q_l, where q_l is the multipole moment
    !r Remarks2
    !r   P_kL are polyonomials orthogonal in the following sense:
    !r                                          (4a^2)^k a^l k! (2l+1)!!
    !r    int P_kL G_k'L' = delta_kk'*delta_ll'  ----------------------
    !r                                                    4pi
    !r   See defined in J. Math. Phys. 39, 3393 (1988).
    !r   Combining eqns 12.7 and 5.19 in that paper, we obtain
    !r    p_kl = a**l / (2a**2)^(k+l) (2l+1)!! / (2k+2l+1)!! phi_kl
    !r    p_0l = a**l
    !r    p_1l = a**l (2*(ar)**2/(2l+3) - 1)
    !r    p_kl = [(2*(ar)**2 - (4k+2l-1))p_k-1,l - 2(k-1)p_k-2,l]  / (2k+2l+1)
    implicit none
    integer::nsp,mode,kmax,nlmlx
    type(s_rv1) :: sv_p_orhoat(3,nbas)
    real(8):: qkl(0:kmax,nlmlx,nsp),z,qc,a,rmt,qcorg,qcorh,qsc,cofg,cofh,rg, ceh,rfoc,df(0:20),rho(nr,nlml,nsp) 
    integer:: ipr,iprint, ib,is,lmxl,nr,nlml,ilm,j,lfoc,k,l,m,isp
    real(8),allocatable :: rofi(:), rwgt(:)
    real(8),parameter:: fpi = 16d0*datan(1d0)
    ipr  = iprint()
    is = ispec(ib)
    lmxl=lmxl_i(is)
    if (lmxl == -1) return
    z=z_i(is)
    a=spec_a(is)
    nr=nr_i(is)
    rmt=rmt_i(is)
    rg=rg_i(is)
    call corprm(is,qcorg,qcorh,qsc,cofg,cofh,ceh,lfoc,rfoc,z)
    qc = qcorg+qcorh
    allocate(rofi(nr),rwgt(nr))
    call radmsh(rmt,a,nr,rofi )
    call radwgt(rmt,a,nr,rwgt )
    QKL_Pkl: block
      real(8):: dfactl(0:lmxl),kfact(0:kmax) ,pkl(nr,0:kmax,0:lmxl),a,ag
      integer::kk,lx
      a = 1d0/rg
      do l = 0, lmxl
         pkl(:,0,l) = a**l *rofi**l !Scale by r^l 
         pkl(:,1,l) = a**l*(2*a*a*rofi**2/(2*l+3)-1d0) *rofi**l
         do  k = 2, kmax ! --- Recursion for higher k ---
            pkl(:,k,l) = 1d0/(2*k+2*l+1)*((2*a*a*rofi**2-(4*k+2*l-1))*pkl(:,k-1,l) - 2*(k-1)*pkl(:,k-2,l)) !Eq.(12.7) right?
         enddo
      enddo
      dfactl(0:lmxl)=[(product([(2*lx+1,lx=0,l)]),   l=0,lmxl)]
      kfact(0:kmax)= [(product([(max(1,kk),kk=0,k)]),k=0,kmax)]
      ag = 1/rg
      do isp=1,nsp
         do  ilm=1,(lmxl+1)**2
            l=ll(ilm)
            do  k = 0, kmax
               qkl(k,ilm,isp)=fpi*sum(rwgt(:)*pkl(:,k,l)*rho(:,ilm,isp))/ ((4*ag**2)**k*ag**l*kfact(k)*dfactl(l)) !Eq.(12.16)
            enddo
         enddo
      enddo
    endblock QKL_Pkl
    checkrwrite: if(ipr >=40) then
       write(stdo,221)
       write(stdo,222) ib,0,1,((qkl(k,1,isp), k=0,kmax),isp=1,nsp)
       call stdfac(20,df)
       do isp=1,nsp
       do  ilm=1,(lmxl+1)**2
          l=ll(ilm)
          if (dabs(qkl(0,ilm,isp))*df(2*l+1) > 1d-6) write(stdo,220) isp,ilm,(qkl(k,ilm,isp)*df(2*l+1),k=0,kmax)
       enddo
       enddo
222    format(2x,'ib=',i3,i5,i6,20f12.6)
220    format(9x,i4,x,i6,f12.6,20f12.6)
221    format(/' rhogkl:    k   ilm      qkl (2l+1)!! ...')
    endif checkrwrite
  end subroutine rhogkl
  subroutine pqsclf(ndansp,nda,offx,off2,na,mxsav,wt,a,a2,rms2)    !- Split into (a+ + a-) and (a+ - a-); include extra data
    !i   ndansp   :leading dimension of a
    !i   nda   :number of elements to spin-split with wt(1),wt(2)
    !i   offx  :(nx>0)offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimension of a2 and number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a     :(na,1:2,i,1) output vector for prev. iteration i
    !i         :(na,1:2,i,2) input  vector for prev. iteration i
    !o Outputs
    !o   a2    :(*,i,1) output charge and moments, scaled by weights
    !o         :(*,i,2) input  charge and moments, scaled by weights
    !o   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
    !r Remarks
    !r   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
    !r   If wt(1) or wt(2) is zero, a2 holds q or mom only.
    !r   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
    implicit none
    integer :: mode,ndansp,nda,mxsav,na,offx,off2,is,ia,ja
    real(8) :: wt(2),a(ndansp,0:mxsav+1,2),a2(na,0:mxsav+1,2), rms2,ddot
    if (abs(wt(1))<1d-12 .AND. abs(wt(2))<1d-12) goto 11
    do is = 0, mxsav+1
       if(abs(wt(1))>1d-12) a2(1:nda,is,:) = (a(1:nda,is,:) + a(1+off2:nda+off2,is,:))*wt(1) !  (rhnew+ + rhnew-)*wt(1), (rhold+ + rhold-)*wt(1)
       ja=merge(nda,0,abs(wt(1))>1d-12)
       if(abs(wt(2))>1d-12) a2(ja+1:ja+nda,is,:)= (a(1:nda,is,:) -a(1+off2:nda+off2,is,:))*wt(2) ! (rhnew+ - rhnew-)*wt(2), (rhold+ - rhold-)*wt(2)
    enddo
11  continue
    rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1) - 2*ddot(na,a2,1,a2(1,0,2),1) + ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))
  end subroutine pqsclf
  subroutine pqsclb(ndansp,nda,offx,off2,na,mxsav,wt,a,a2)    !- Undo split into wt1*q and wt2*mom done by pqsclf
    !i   ndansp   :leading dimension of a
    !i   nda   :number of P,Q
    !i   offx  :offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   na    :dimensions a2; number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn)
    !i   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
    !o Outputs
    !o   a     :a2 is unscaled and restored into a
    implicit none
    integer :: ndansp,na,nda,mxsav,offx,off2,is,ia
    real(8) :: wt(2),a(ndansp,0:mxsav+1,2),    a2(na,0:mxsav+1,2),summ(2),diff(2)
    logical:: wt1zero,wt2zero
    wt1zero = abs(wt(1))<1d-12
    wt2zero = abs(wt(2))<1d-12
    if ((.not.wt1zero) .AND. (.not.wt2zero) ) then
       do  is = 0, mxsav+1
          do  ia = 1, nda
             a(ia,is,:)     = (a2(ia,is,:)/wt(1) + a2(ia+nda,is,:)/wt(2))/2!   mixed  rhonew-,rhold-
          enddo
          do  ia = 1, nda
             a(ia+nda,is,:) = (a2(ia,is,:)/wt(1) - a2(ia+nda,is,:)/wt(2))/2
          enddo
       enddo
    elseif ((.not.wt1zero) ) then
       do  ia = 1, nda
          do  is = 0, mxsav+1
             diff = (a(ia,is,:) - a(ia+off2,is,:))
             a(ia,is,:)      = (a2(ia,is,:)/wt(1) + diff)/2
             a(ia+off2,is,:) = (a2(ia,is,:)/wt(1) - diff)/2
          enddo
       enddo
    elseif ((.not.wt2zero) ) then
       do  ia = 1, nda
          do  is = 0, mxsav+1
             summ  = (a(ia,is,:) + a(ia+nda,is,:))          !  given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
             a(ia,is,:)     = (summ + a2(ia,is,:)/wt(2))/2
             a(ia+nda,is,:) = (summ - a2(ia,is,:)/wt(2))/2  !summ = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
          enddo
       enddo
    endif
  end subroutine pqsclb
end module m_mixrho
