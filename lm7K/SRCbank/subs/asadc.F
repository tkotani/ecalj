      subroutine asadc(isph,nr,nsp,z,ri,a,wt,v,rhoc,rho,
     .  rhov,bmval,xcore,rhoexc,rhomu,utot,qval)
C- Make sphere double-counting terms for ASA total energy
C ----------------------------------------------------------------------
Ci Inputs
Ci   isph  :sphere index; used for printout only
Ci   nr    :number of radial mesh points
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   z     :nuclear charge
Ci   ri    :radial mesh
Ci   a     :radial mesh parameter needed for poiss0
Ci   wt    :radial mesh weights for integration
Ci   v     :ASA spherical potential used to make hamiltonian
Ci   rhoc  :core charge density = 4 pi r**2 (true rhoc)
Ci   rho   :spherical charge density = 4 pi r**2 (true rho).
Ci         :HK functional: rho is density generated by v, or
Ci         :HF functional: rho is input density
Co Outputs
Co   rhov  : double counting term for K.E. ; see Remarks
Co   bmval : magnetic part of double counting term; see Remarks
Co   xcore : double counting core term for K.E
Co   utot  : electrostatic energy corresponding to rho; see Remarks
Co   rhoexc: XC energy corresponding to rho; see Remarks
Cr Remarks
Cr   Sphere total energy is sum of K.E., Hartree energy, XC energy:
Cr      etot = ekin + utot + rhoexc
Cr   The kinetic energy is computed via double-counting terms
Cr     ekin = sumev + sumec + dsumec - rhov
Cr
Cr   utot and rhoexc are electrostatic and XC energies of the density
Cr   rho; i.e. integral v[rho] rho, whereas the double counting terms
Cr   are computed from the input potential v
Cr
Cr   rhov  = integral v * rho(valence)
Cr   xcore = integral v * rho(core)
Cr
Cr   dsumec is correction to core eigenvalues if sumec not obtained
Cr   from v
Cr
Cr   This routine makes :
Cr   * rhov needed to computed ekin for the HK functional
Cr   * utot and rhoexc needed to compute etot.
Cr
Cr   The electrostatic nuclear-electron interaction is computed as:
Cr     int Z delta(r) ves(r) = int 2*Z/r rho(r) + b.c. term
Cr   Since sphere e.s. interaction is computed
Cr     int Z delta(r) ves(r) = int 2*Z/r rho(r) + 2*qt/rmax * Z
Cr   where qt is the total charge.
Cr
Cr   NB: in the spin-polarized case, decompose rhov as follows:
Cr     rhov = Q+<V+> + Q-<V->
Cr   where <B+> = <phi+ B+ phi+>; similar for <B->.
Cr   Write Q+ = (Q+M)/2 and V+ = V+B and Q- = (Q-M)/2 and V- = V-B
Cr   (Thus M = Q+ - Q-   and Q = Q+ + Q-)  Then
Cr     rhov = (Q+M)/2<V+B> + (Q-M)/2<V-B>
Cr          =  Q<V> + M<B>
Cr   In this routine, vtrval=Q<V> and bmval=M<B>.  This bmval is 
Cr   needed because in the noncollinear case, the double-counting
Cr   contribution to M<B> is replaced with <B.sig rho>.
Cr
Cr  Debugging:
Cr  set getv = "-vz=27 -e3 x1 x2-z/x1/.5 x3-z/x1/.5"
Cr  set rdf = \
C  "-qr vin $getv -a vin vin -coll 1 -a ri -qr rho -av:nr,1 rmax -a rho rho"
Cr
Cu Updates
Cu    4 Apr 04 Added generation of bmval
Cu    7 Mar 03 first created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer isph,nr,nsp
      double precision z,rhov,rhoexc,rhomu,utot,xcore,a,qval,
     .  ri(nr),wt(nr),v(nr,nsp),rhoc(nr,nsp),rho(nr,nsp)
C ... Local parameters
      integer ir,isp,iprint,stdo,nglob,IPRT
      double precision rhoval,vi,vrval(2),vrc(2),
     .  b,rhovh(2),vsum,vout(nr,nsp),zvnucl,rho0(2),reps(2),rmu(2),
     .  exrmax(2),qsph(2),qc(2),qt,rmax,mval,bmval,vtrval
      parameter (IPRT=90/1)

      stdo = nglob('stdo')

C     call prrmsh('rho ',ri,rho,nr,nr,nsp)
C      call prrmsh('rhoc ',ri,rhoc,nr,nr,nsp)
C      call prrmsh('V   ',ri,v,nr,nr,nsp)

      do  isp = 1, 2
        vrval(isp) = 0
        vrc(isp) = 0
        rhovh(isp) = 0
        reps(isp) = 0
        rmu(isp) = 0
        qsph(isp) = 0
        qc(isp) = 0
      enddo
      rmax = ri(nr)

C --- Hartree and XC potential for rho ---
      call pshpr(0)
      b = rmax/(dexp(a*(nr-1)) - 1)
      call poiss0(z,a,b,ri,rho,nr,0d0,vout,rhovh,vsum,nsp)
      call vxc0sp(a,b,ri,rho,nr,vout,rho0,reps,rmu,nsp,exrmax)
      call poppr

C --- Make rhov = v*rho, zvnucl = Z*ves = ves(nuc)*rho ---
      rhov = 0
      rhoexc = 0
      zvnucl = 0
      xcore = 0
      do  isp = 1, nsp
        do  ir = 2, nr
          vi = v(ir,isp) - 2*z/ri(ir)
          rhoval = rho(ir,isp) - rhoc(ir,isp)
          vrval(isp) = vrval(isp) + rhoval * vi * wt(ir)
          vrc(isp)   = vrc(isp) + rhoc(ir,isp) * vi * wt(ir)
          zvnucl = zvnucl - rho(ir,isp) * 2*z/ri(ir) * wt(ir)
          qsph(isp) = qsph(isp) + rho(ir,isp)*wt(ir)
          qc(isp) = qc(isp) + rhoc(ir,isp)*wt(ir)
        enddo
        bmval = 0
        if (nsp .eq. 2) then
          mval = 0
          vtrval = 0
          do  ir = 2, nr
            mval  = mval + wt(ir)*
     .        (rho(ir,1)-rhoc(ir,1) - rho(ir,2)+rhoc(ir,2))
            bmval  = bmval + wt(ir)*
     .        (v(ir,1)-v(ir,2))/2 *
     .        (rho(ir,1)-rhoc(ir,1) - rho(ir,2)+rhoc(ir,2))
            vtrval = vtrval + wt(ir)*
     .        ((v(ir,1)+v(ir,2))/2 - 2*z/ri(ir)) *
     .        (rho(ir,1)-rhoc(ir,1) + rho(ir,2)-rhoc(ir,2))
          enddo
        endif
        rhov = rhov + vrval(isp)
        xcore = xcore + vrc(isp)
      enddo

      qval = qsph(1) + qsph(2) - qc(1) - qc(2)

C ... Correct zvnucl to boundary conditions ves[rmax]=0
      qt = qsph(1) + qsph(2) - z
      zvnucl = zvnucl + 2*qt/rmax*z

C --- Make utot, rhoexc ---
      utot = .5d0*(rhovh(1) + rhovh(2) + zvnucl)
      rhoexc = reps(1) + reps(2)
      rhomu  = rmu(1)  + rmu(2)

      if (iprint() .ge. IPRT) then
        write(stdo,138) isph,z,qval,rhov,rhoexc,rhomu,xcore,zvnucl,utot
      endif
      if (iprint() .ge. IPRT .and. nsp .eq. 2) then
        write(stdo,139)
     .    (vrval(isp),vrc(isp),reps(isp),isp, isp=1,nsp),
     .    mval,bmval,vtrval
      endif

  138 format(/' ASADC: double-counting terms for sphere',i3,
     .  ', Z =',f6.2,':  qval=',f12.6,
     .       /' rhov*v=',f15.6,'  rho*exc=',f15.6,'   rho*mu=',f15.6,
     .       /' rhoc*v=',f15.6,'   zvnucl=',f15.6,'     utot=',f15.6)

  139 format(
     .  6x,'rhov*v',7x,'rhoc*v',8x,'rho*eps'/
     .    2(f13.6,f15.6,f13.6,'   spin',i2/),
     .  '   |Mz| =',f12.6,'   Bxc*Mz =',f12.6,
     .  '   (rho1+rho2)*(v1+v2)=',2f12.6)


      end

