      integer function rdtok(token,instr,descr,sep0,sep,cast,swt,
     .n1,count,resn,resc)
C- Seek a token within a string and read associated data into array
C ----------------------------------------------------------------
Ci Inputs
Ci   token: string marking data to follow token
Ci   instr: string in which to seek token
Ci   descr: descriptor string composed of one or more parts.
Ci        : It is used to format printouts generated by rdtok,
Ci        : in 'print' modes
Ci        :*The first part, if present, is a formatting string
Ci        : for writing the contents of a token, awrite conventions
Ci        : It is delimited by a double-colon, e.g.
Ci        :    descr = '%;6d,,string-for-remaining-parts'
Ci        : The format statement is used when the token's contents
Ci        : are written out (swt(5)>2, below).  A default format
Ci        : is used if one is not supplied
Ci        :*The second part, if present, is a character consisting
Ci        : of a single digit '0'..'9', and is the number of spaces
Ci        : to indent before writing the token, in all modes swt(5).
Ci        : It is delimited by a double-semicolon, e.g.
Ci        :    descr = '%;6d,,4;;string-for-remaining-part'
Ci        : If not present, a default indentation of 2 is used.
Ci        :*The third part, if present, describe the token's purpose.
Ci        : It is used only for input mode 0 (swt(5)=0).
Ci        : It consists of any part of the string after the first or
Ci        : second parts.
Ci    sep0: the character immediately to the left of the token
Ci          must be one of the characters in sep0
Ci    sep:  The token's arguments are delineated by characters in
Ci       :  this list.
Ci    cast: data following token is one of the following.
Ci          cast    class of token
Ci           0      logical
Ci           1      char
Ci           2      int
Ci           3      real
Ci           4      double
Ci        : result is stored into resn for cast=0,2,3,4
Ci        :           stored into resc for cast=1
Ci     n1 : Data associated with token are put into:
Ci          resn(n1),resn(n1+1),... for cast=0,2,3,4    and
Ci          resc(n1),resc(n1+1),... for cast=1
Ci   count: The number of elements (numbers or strings) to try and parse
Ci        : It may be permissible to read fewer than `count' elements;
Ci        : see swt(3)
Ci Inputs/Outputs
Cio  swt  : a vector of switches governing how gtcat and rdtok behave.
Cio       : Its internal structure is described in stswt, below.
Cio       : User is advised to set these parameters via routine stswt.
Cio       : and query the state of using quswt; then there is no need
Cio       : know the internal structure of swt.
Cio       : As described in detail in stst, quantities that can be set
Cio       : and probed are the following:
Cio       : structure of swt.
Cio       : swt()  function (see stswt)
Ci        :  1     offset to instr where parsing begins
Cio       :  2     parse up to this character
Ci        :  3     governs behavior when token or some data is missing,
Ci        :        whether tokens are optional or required, if
Ci        :        there may be multiple occurences of this token, and
Ci        :        whether number of elements may be less than count.
Ci        :  5     read and printout mode
Ci        :        0=> do not attempt to read token but show
Ci        :            what token would have been sought
Ci        :        1=> attempt to find token and read contents
Ci        :        2=> print token name
Ci        :        3=> combination of 1 and 2
Ci        :  6     file logical unit for printout
Co        :  7     index to last character parsed
Co Outputs
Co   rtdok: -999   No token was sought
Co        :   0    No match to token is found
Co        :   n    token matched and converted sans error n elements
Co        :        (for count=0, returns 1 if token matched)
Co        :  -n    if error on conversion of argument n
Cl Local variables
Cl   lopt :  0 if token is optional
Cl        :  1 if token is required
Cl        :  2 alternate token may be subst.
Cl        :  3 if token is ignored
Cb Bugs
Cb   when n1>0, data not placed in proper location for integer, logical
Cb   arrays
Cu Updates
Cu   06 Nov 01 Initially created
C ----------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer swt(7),cast,n1,count
      character*(1) instr(*)
      character*(*) token,descr,resc(1),sep0,sep
      double precision resn(1)
C ... Local parameters
      logical logval,parstr,l1,l2,lhelp,lshow,lread
      integer a2vec,awrite,i,ifipr,ifmt,io,ip,is,isave,it(99),ival,k,ks,
     .linstr,rdtk2,recl,retval,ltok,quswt,lfixl,lopt,lmult,lio
      parameter (recl=500)
      character   aa*(recl),prs*(recl)
      character*8 nmcast(0:4),fmt*20
      save ip,prs
      data nmcast /'logical','char','integer','real','double'/
      data ip /0/

C ... Setup
      lopt  = quswt('token,opt',swt)
      if (lopt .eq. 3) then
        rdtok = -999
        return
      endif
      ifipr = quswt('lunit',swt)
      ltok = len(token)
      lhelp = quswt('io,help',swt) .eq. 1
      lshow = quswt('io,w',swt) .eq. 1
      lread = quswt('io,r',swt) .eq. 1
      lio   = quswt('io',swt)
      lfixl = quswt('token,fixlen',swt)
      lmult = quswt('token,mult',swt)

C --- Show what token would have been sought ---
      if (lhelp) then

C       Find indentation, offset to descriptor string
C       Default indentation
        ks = 2
C       Default offset to start of descriptor
        i = 0
        if (descr .ne. ' ') then
C         Strip off first parts, if either exists
          l2 = parstr(descr,';;',len(descr)-1,2,'a',i,k)
          if (l2) then
            ks = ichar(descr(i:i)) - ichar('0')
          else
            i = 0
            l1 = parstr(descr,',,',len(descr)-1,2,'a',i,k)
            if (.not. l1) i = -2
          endif
        endif
        fmt = ' '
        is= ltok
        if (count .eq. 0) then
          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
     .    '%a (no arguments; %?#(n==0)#optional#required#)'
          call awrit1(aa,' ',72,ifipr,lopt)
        elseif (count .eq. 1) then
          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
     .    '%a takes 1 argument of cast '//nmcast(cast)//
     .    '%a %?#(n==0)#(optional)##%-1j'//
     .    '%a %?#(n==1)#(required)##%-1j'//
     .    '%a %?#(n==2)#%N'//fmt(1:ks)//
     .    '   (choose either this token or the next one)##'
          call awrit1(aa,' ',128,ifipr,lopt)
        else
          aa = fmt(1:ks) // ' *token  ' // token(1:is) //
     .    '%a takes %?#(n==0)#up to ##'//
     .    '%i arguments of cast '//nmcast(cast)//
     .    '%a %?#(n==0)#(optional)##%-1j'//
     .    '%a %?#(n==1)#(required)##%-1j'//
     .    '%a %?#(n==2)#%N'//fmt(1:ks)//
     .    '   (choose either this token or the next one)##'
          call awrit3(aa,' ',128,ifipr,lfixl,count,lopt)
        endif
        if (descr .ne. ' ') then
          fmt = ' '
          aa = '   ' // fmt(1:ks) // descr(i+3:)
          call awrit0(aa,' ',-len(aa),ifipr)
        endif
        rdtok = -999
        ip = 0
        return

C --- No token to read ---
      elseif (.not. lread) then
        retval = -999
        goto 999
      endif

C --- Try and find token ---
      linstr = swt(2)
      if (token .eq. ' ') then
        is = swt(1)
      else
        is = rdtk2(instr,linstr,token,sep0,lopt.eq.1,swt(1))
      endif
C ... No token found ... exit
      if (is .le. 0) then
        swt(7) = linstr
        rdtok = 0
        return
      endif

C --- Parse for token arguments ---
      swt(7) = is

C ... Case count=0
      if (count .eq. 0) then
        retval = 1
        goto 999
      endif

C ... Case further delimit range of search
      if (lmult .ne. 0) then
        ks = rdtk2(instr,linstr,token,sep0,.false.,is)
        if (ks .gt. 0) linstr = ks-ltok-1
        swt(2) = linstr
      endif

C ... Parse for vector of character arguments
      if (cast .eq. 1) then
        isave = is - ltok
        do  i = 1, count

C         Skip past leading blanks
          is = is-1
          call skipbl(instr,linstr,is)
          is = is+1

C         End-of-category encountered before loop over count exhausted
          if (is .ge. linstr) then
            if (lfixl .ne. 0) then
              if (count .eq. 1) then
                aa = 'Exit -1 rdtok: no string after token '//
     .          token(1:ltok)
                call fexit(-1,1,aa,0)
              else
                aa = 'Exit -1 rdtok: failed to parse %i strings, token'
                call strncp(aa,instr,53,isave,min(recl-53,linstr-isave)-1)
              endif
              call fexit(-1,1,aa,count)
            endif
            retval = -i
            swt(7) = linstr+1
            goto 999
          endif

          call cpstr(instr,linstr,1001,sep,is,io,resc(i+n1-1))
          is = is+1
        enddo
        swt(7) = is-1
        retval = count
        goto 999
      endif

C ... Parse for vector of numerical arguments
      isave = is - ltok
      swt(7) = is
      is = is-1
      k = a2vec(instr,linstr,is,cast,sep,len(sep),-99,-count,it,
     .resn(n1))
      retval = k

C ... a2vec encountered an illegitimate expression
      if (k .lt. 0) then
        if (lfixl .ne. 0) then
          aa = ' Exit -1 rdtok: error parsing expr no %i, token'
          call strncp(aa,instr,52,isave,min(recl-52,linstr-isave)-1)
          call fexit(-1,1,aa,-k)
        endif
C ... a2vec read fewer than count expressions
      elseif (k .lt. count) then
        if (lfixl .ne. 0) then
          aa = ' Exit -1 rdtok: read only %i of %i values, token'
          call strncp(aa,instr,52,isave,min(recl-52,linstr-isave)-1)
          call fexit2(-1,1,aa,k,count)
        endif
        retval = -k
      endif

C --- Cleanup: check for printout ---
  999 continue
      rdtok = retval
      if (.not. lshow) return

C     Find format, if supplied, and indentation
C     Default indentation
      ks = 2
      fmt = ' '
      if (descr .ne. ' ') then
        i = 0
        l2 = parstr(descr,';;',len(descr)-1,2,'a',i,k)
        if (l2) then
          ks = ichar(descr(i:i)) - ichar('0')
        endif
        ifmt = 0
        l1 = parstr(descr,',,',len(descr)-1,2,'a',ifmt,k)
        if (l1) fmt = descr(1:ifmt)
      endif

C ... Write token name to string
      if (ip .eq. 0) then
        prs = ' '
      else
        ks = min(ks,2)
      endif
      ip = ks + ip + awrite(token,prs(ks+ip+1:),128,0,0,0,0,0,0,0,0,0)
      if (count .eq. 0) then
C   ... format applied after token write
C        if (fmt .ne. ' ')
C     .  ip = awrite(fmt,prs,128,0,0,0,0,0,0,0,0,0)
        goto 998
      endif

C ... Write token contents to string, vec of length |retval|
C     ip = ip+1

C     Number of elements to write
      k = retval
      if (retval .lt. 0) k = -retval-1
      if (lio .eq. 2) k = count
C     Write the elements
      do  i = 1, k
        if (cast .eq. 1) then
          ip = ip + awrite(resc(n1+i-1),prs(ip+1:),128,
     .    0,0,0,0,0,0,0,0,0)
          call skpblb(prs,ip,ip)
          ip = ip+1
          if (fmt .ne. ' ')
     .    ip = awrite(fmt(1:ifmt),prs,128,0,0,0,0,0,0,0,0,0)
        elseif (cast .eq. 0) then
          if (fmt .eq. ' ') then
            fmt = '%l'
            ifmt = 2
          endif
          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,
     .    logval(resn,n1+i-1),0,0,0,0,0,0,0)
        elseif (cast .eq. 2) then
          if (fmt .eq. ' ') then
            fmt = '%i'
            ifmt = 2
          endif
          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,
     .    ival(resn,n1+i-1),0,0,0,0,0,0,0)
        elseif (cast .eq. 4) then
          if (fmt .eq. ' ') then
            fmt = '%;10F'
            ifmt = 5
          endif
          ip = ip + awrite(fmt(1:ifmt),prs(ip+1:),128,0,resn(n1+i-1),
     .    0,0,0,0,0,0,0)
        endif
C       ip = ip+2
        if (i .lt. k) then
          if (prs(ip:ip) .ne. sep(1:1)) then
            ip = ip+1
            write(prs(ip:ip),'(a)') sep(1:1)
          endif
        elseif (retval .lt. 0 .and. lio .ne. 2) then
          ip = ip+1
          write(prs(ip:),'(a,''***'')') sep(1:1)
          ip = ip+3
        endif
      enddo

  998 continue
c     call skpblb(prs,ip,ip)
C     ip = ip+1

C ... Printout, or just preserve in string prs if ifipr is 0
      if (ifipr .gt. 0) then
        write(ifipr,'(a)') prs(1:ip)
        ip = 0
      else
      endif

      end

      integer function rdtk2(instr,linstr,token,sep0,lreqd,i1)
C- Kernel called by rdtok to find a token
C ----------------------------------------------------------------------
Ci Inputs
Ci   instr :string in which to seek token
Ci   linstr:length of instr
Ci   token :token
Ci    sep0 :the character immediately to the left of the token
Ci         :must be one of the characters in sep0
Ci   lreqd :T, abort with error if token is not found
Ci    i1   :start search at i1
Co Outputs
Co   rdtk2 :if token found, rdtk2 points to first character past token
Co         :if no token found, rdtok = -linstr
Cu Updates
Cu   02 Nov 01 First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      logical lreqd
      integer linstr,i1
      character*(*) token,sep0
      character*(1) instr(linstr)
C ... Local parameters
      integer ltok,k,iterm,is,lgunit,stderr
      character ct*1

      ltok = len(token)
      ct = token
      stderr = lgunit(2)

C --- Loop over length of string ---
C     Match by:
C     1.  First character matches at instr(k)
C     2.  character to left matches on of sep0
C     3.  token matches
      do  k = i1, linstr

        if (instr(k) .eq. ct) then
          iterm = 1
          if (k .gt. 1) then
            is = 0
            call chrps2(instr(k-1),sep0,len(sep0),0,is,iterm)
          endif
          if (iterm .gt. 0) then
            do  is = 1, ltok
              if (instr(k+is-1) .ne. token(is:is)) goto 31
            enddo
C           A match was found
            rdtk2 = ltok+k
            return
          endif
        endif
   31   continue
      enddo
C ... We have fallen through the loop, so no token found
      rdtk2 = -linstr
      if (lreqd) then
        write(stderr,'(1x)')
        call rxs2('rdtok: failed to find token `',token,'''')
      endif
      end

