      logical function mtosigmaonly() !this is also in fpgw/gwsrc/switches.
      mtosigmaonly=.true.
      end
      real(8) function epsnevec()
      epsnevec=1d-8 !it was 1d-6
      end

      logical function mixrealsmooth()
      logical,save :: init=.true.
! Takao think mixrho should give a correct guess from informations
! of |rho_in - f(rho_in)|**2
! In our procedure now, takao think the weight from smooth part is rather small.
! Thus our mixing procedure is mainly controlled by atoic part.
! This works OK but may be not best...
!   How to choose wgtsmooth? or it will be better to take correct weighting for
!   mixing.
c      mixrealsmooth=.false.
!===================
!mixrealsmooth=T is added on 28Aug2010 --> 
!mixrealsmooth=F on 24dec2012 (why?) -->
!mixrealsmooth=T (move it back) on 16Jan2013.
      mixrealsmooth=.true. !
      if(init) then
        if(iprint()>10) print *,'mixrealsmooth=',mixrealsmooth
        init=.false.
      endif
      end

      logical function noelind()
      noelind=.false. !in mixrho.F. If T, ELIND procedure is not.
! Does elind really works fine? It works for LiC2 case.
! Probably, we first have to modify mixrho.
      end

      logical function enforce_positive_smrho()
!      enforce smrho to positive in mkpot.F
      enforce_positive_smrho=.true.
      end

c-----------
Cr   1. newsigmasw=F : new result               (test mode)
Cr   1. newsigmasw=T (then pmtsig is irrelevant): new result (run mode)
Cr Note: you also need to use sigswitch=0 if you want to reproduce old results.

c      logical function newsigmasw()
! newsigmasw: in this case, we only use emax_sigm in hqpe.sc.m.F when we construct sigma.
!!       T: newsigma rotation, and interpolation. !this is still problematic
c        O: old version
c      newsigmasw=.true.
!! in future, I like to modify the interpolation scheme, but not yet.
c      newsigmasw=.true.
c      newsigmasw=.false.
c      end

      integer function debugmode()
      debugmode=0
      end

c
      integer function sigswitch()
c sigma interpolation
Cr This switch is effective only when newsigmasw=F.
Cr This is used in hambls.F.
c
c sigswitch=0: old version
c sigswitch=1: new version of sigma interpolation. (asig bsig are unused). 
c              Readin constant shift given in ESEAVR, generated by hqpe.
c              new interpolation mode for self-energy: Neglect asig and bsig
c      sigswitch=0
      sigswitch=1
      end

      logical function fullmesh()
c      fullmesh=.true. !including all G vector to expand charge density. I think this did not work well.
      fullmesh=.false.
      end

c      logical function nomshsiz()
c      nomshsiz=.true.
c      end


!! we now use 'noshorbz=T' mode. (exactly speaking, shorbz is now embedded in hamble.F.)
c$$$      logical function noshorbz()
c$$$!! shorbz is confusing (pull back k vector to 1st BZ). Especially, in the case of PMT, where we use exp(i (q+G)r).
c$$$!! It is better to use different algolism in future if required.
c$$$c      noshorbz=.false. 
c$$$      noshorbz=.true. !<--- i think this is better in future.
c$$$      end

      integer function matmul_pwhovl()
c switch used in gwd/pwmat.F
c  matmul_pwhovl=1 uses matmul,
c  matmul_pwhovl=2 and matmul_pwhovl=3 uses BLAS. In cases, it fails in centos(gfortran and so) in core-i7.
      matmul_pwhovl=2
      end

      logical function oncewrite(id)
      integer,save:: idx(1:100)=1
      if(id<1. or. id >100 ) call rx("oncewrite index out of range")
      oncewrite=.false.
      if( idx(id) ==1)  then
        oncewrite=.true.
        idx(id)=0
      endif
      end
