!A collection of switches. Many of the switches can be obsolate or not so meaningful now.
real(8) function tolq() !tolerance to judge identical q vectors when rotated
  tolq=1d-7
END function tolq
logical function mtosigmaonly() !this is also in fpgw/gwsrc/switches.
  mtosigmaonly=.true.
end function mtosigmaonly
real(8) function epsnevec()
  epsnevec=1d-8 !it was 1d-6
END function epsnevec
logical function mixrealsmooth()
  logical,save :: init=.true.
  integer:: iprint
  ! Takao think mixrho should give a correct guess from informations
  ! of |rho_in - f(rho_in)|**2lo
  ! In our procedure now, takao think the weight from smooth part is rather small.
  ! Thus our mixing procedure is mainly controlled by atoic part.
  ! This works OK but may be not best...
  !   How to choose wgtsmooth? or it will be better to take correct weighting for
  !   mixing.
  !      mixrealsmooth=.false.
  !===================
  ! ixrealsmooth=T is added on 28Aug2010 -->
  ! ixrealsmooth=F on 24dec2012 (why?) -->
  ! ixrealsmooth=T (move it back) on 16Jan2013.
  mixrealsmooth=.true. !
  if(init) then
     if(iprint()>10) print *,'mixrealsmooth=',mixrealsmooth
     init=.false.
  endif
end function mixrealsmooth
!logical function noelind() !  noelind=.true. !in mixrho.F. If T, ELIND procedure is not.
!  ! Does elind really works fine? It works for LiC2 case.
!  ! Probably, we first have to modify mixrho.
!end function noelind
logical function enforce_positive_smrho()  !      enforce smrho to positive in mkpot.F
  enforce_positive_smrho=.true.
end function enforce_positive_smrho
integer function debugmode()
  debugmode=0
end function debugmode
integer function sigswitch()  ! sigma interpolation
  !r This switch is effective only when newsigmasw=F.
  !r This is used in hambls.F.
  ! sigswitch=0: old version
  ! sigswitch=1: new version of sigma interpolation. (asig bsig are unused).
  !              Readin constant shift given in ESEAVR, generated by hqpe.
  !              new interpolation mode for self-energy: Neglect asig and bsig
  !      sigswitch=0
  sigswitch=1
end function sigswitch
logical function fullmesh()  !      fullmesh=.true. !including all G vector to expand charge density. I think this did not work well.
  fullmesh=.false.
end function fullmesh
logical function oncewrite(id)
  integer:: id
  integer,save:: idx(1:100)=1
  if(id<1 .OR. id >100 ) call rx("oncewrite index out of range")
  oncewrite=.false.
  if( idx(id) ==1)  then
     oncewrite=.true.
     idx(id)=0
  endif
end function oncewrite
