      subroutine scrmom(sham,sbz,slat,mode,nbas,nsp,nl,nclass,nrclas
     .  ,ipc,wsr,nRLc,pstat,vmad,ldv,vintra,vin,vqin,vout,qin,qout)
C- Estimate the self-consistent moments from the dielectric response
C ----------------------------------------------------------------------
Ci Inputs
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: oindxo ldham
Ci     Stored:    *
Ci     Passed to: *
Ci   sbz   :struct for the Brillouin Zone; see routine ubz
Ci     Elts read: zval
Ci     Stored:
Ci     Passed to:
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: vol
Ci     Stored:
Ci     Passed to:
Ci   mode  :1s digit
Ci          0 do nothing
Ci          1 Estimate vsc from vin,vout
Ci          2 Estimate qsc from qin,qout
Ci          3 Estimate qsc from qin,qout,vin,vout
Ci          4 Do both 3 and 2
Ci         :10s digit use model dielectric function
Ci          1 Estimate qsc from qin,qout,vin,vout using model eps
Ci   nbas  :size of basis
Ci   nl    :(global maximum l) + 1
Ci   nclass:number of inequivalent classes
Ci   nrclas:nrclas(i) = number of atoms in the ith class
Ci   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
Ci
Ci   wsr   :Wigner-Seitz radius, in a.u. (input; alias rmax)
Ci   nRLc  :number of Rl channels in sites 1..nbas
Ci   pstat :static unscreened response function
Ci   vmad  :Madelung matrix
Ci   ldv   :leading dimension of vmad
Ci   vintra:Intra-atomic screened coulomb interaction, by class
Ci   vin   :input es potential used to make hamiltonian, by class
Ci   vqin  :es potential generated by qin
Ci   qin   :moments used to generate hamiltonian
Cio Inputs/Outputs
Cio  qout  :On input, moments generated by the hamiltonian (output moments)
Cio        :On output, qout is overwritten by :
Cio        :  qin + epsilon^-1 [(qout-qin) - P (Vin -V[qin])]
Cio  vout  :On input, es pot generated by the hamiltonian (output pot)
Cio        :On output, vout is overwritten by :
Cio        :  epsilon+^-1 [Vout-Vin]
Cl Local variables
Cl   eps:  Inverse of q=0 static dielectric matrix, epsilon^-1
Cb Bugs
Cb   The correction P (Vin -V[qin])] uses the spin-1 P function
Cb   only for now.
Cu Updates
Cu   24 Feb 05 (Jailei Xu) Screening through model dielectric function
Cu   19 Feb 02 dimensions of vmad passed separately to accomodate
Cu             padding sites.
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer mode,nbas,nclass,nrclas(1),ipc(nbas),nl,nsp,nRLc,ldv
      double precision sham(1),sbz(1),slat(1),wsr(1),
     .  pstat(nRLc,nsp,nRLc,nsp),
     .  vmad(ldv,1),vintra(nl,nl,nsp,nsp,1),vin(nclass),vqin(nclass),
     .  vout(nclass),qin(3,nl,nsp,*),qout(3,nl,nsp,*)
C ... Local parameters
      double precision elind,qval,vol,pi,dgets,xx
      integer ierr,oidxsh,odq,oqwk,job0,job1,lhdim,ldham(16),nRLc2,isw,
     .  opstaa,ovbare,ovmadb,oeps,owkr,oepsa,opsta,odqv,is1,is2,iprint,
     .  oivmad,oivbar,ovintr,ovtemp,ovtmp1,ovtmp2,ovtmp3,ovtmp4
C     Tolerance in deviation in P0 from hermicity
      double precision htol
      parameter (htol=1d-6)
      equivalence (lhdim,ldham(3))
*     integer ib,ic,il
C heap:
      integer w(1)
      common /w/ w

C     call pshpr(60)
      pi = 4d0*datan(1d0)
      job0 = mod(mode,10)
      job1 = mod(mode/10,10)
      nRLc2 = nRLc * nsp
C     call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)

C     Check that P0 is hermitian
      if (job1 .eq. 0) then
      do  2  is1 = 1, nRLc2
      do  2  is2 = 1, nRLc2
        if (abs(pstat(is1,1,is2,1)-pstat(is2,1,is1,1)) .gt. htol) then
          if (iprint() .gt. 10) print *,
     .      'scrmom (warning) response function is not symmetric'
          goto 3
        endif
    2 continue
    3 continue
      endif

      call upack('ham oindxo ldham',sham,oidxsh,ldham,0,0,0)

C --- Make vbare, q=0, monopoles ---
      call defrr(ovmadb,nbas**2)
      call pscrm3(nbas,ipc,wsr,vmad,ldv,w(ovmadb))

      call defrr(odq,  3*nl*nsp*nbas)
      call defrr(oqwk, 3*nl*nsp*nbas)
      call defrr(odqv, -nRLc*nsp)

C --- Overwrite vout with estimate for the self-consistent V ---
      if (job0 .eq. 1 .or. job0 .ge. 3) then

        if (job1 .eq. 1)
     .    call rxi('scrmom not implemented, mode',mode)

C   ... epsilon_a = (1 - pstat vbare), contracted over l
         call defrr(oepsa, nbas**2)
         call defrr(opsta, -nbas**2)
         do  is1 = 1, nsp
         do  is2 = 1, nsp
           call plm2pa(pstat(1,is1,1,is2),nbas,nRLc2,lhdim,w(oidxsh),
     .       1011,1,w(opsta))
         enddo
         enddo
         call prjrsp(1,1,1,nbas,1,w(opsta))
C        call prmx('contracted pstat',w(opsta),nbas,nbas,nbas)
         call dgemm('N','N',nbas,nbas,nbas,-1d0,w(opsta),nbas,
     .        w(ovmadb),nbas,0d0,w(oepsa),nbas)
         call daxpy(nbas,1d0,1d0,0,w(oepsa),nbas+1)

C  --- model dielectric function (not implemented)
c      else if (job0 .eq. 0) then
c         call defrr(oepsa, nbas**2)

C --- diagonalize the vbare matrix ---
C     ovmadb2 stores the diagonal part of diagonalized matrix,
C     ovmvec stores the normalized eigenvectors of vbare
c         call defrr(ovmadb2,nbas)
c         call defrr(ovmvec,nbas**2)
c         call defrr(ofv1,nbas)
c         call defrr(ofv2,nbas)

c         call rs(nbas,nbas,w(ovmadb),w(ovmadb2),1,w(ovmvec),w(ofv1),
c     .        w(ofv2),ierr)
c         call rlse(ofv1)
c         call rlse(ofv2)
C --- make epsilon_a2 = 1 + elind * vmadb2 ---
c         call defrr(oepsa2,nbas**2)
c         call dpzero(w(oepsa2),nbas**2)
c         call daxpy(nbas,elind,w(ovmadb2),1,w(oepsa2),nbas+1)
c         call daxpy(nbas,1d0,1d0,0,w(oepsa2),nbas+1)

C --- transfer back to original space to get epsilon ---
C     one option, can use dtrmm.f zgemm.f ztrmm.f in BLAS directory
c         call defrr(ovdtmp,nbas**2)
c         call dgemm('N','N',nbas,nbas,nbas,1d0,w(ovmvec),nbas,w(oepsa2),
c     .        nbas,0d0,w(ovdtmp),nbas)
c         call dgemm('N','T',nbas,nbas,nbas,1d0,w(ovdtmp),nbas,w(ovmvec),
c     .        nbas,0d0,w(oepsa),nbas)
c         call rlse(oepsa2)
c         call rlse(ovmadb2)
c         call rlse(ovdtmp)
c         call rlse(ovmvec)
c         call rlse(oepsa)
c      end if

C     ... epsa^-1
         call defrr(owkr,nbas**2)
         call dqinv('n',w(oepsa),nbas,4,nbas,w(owkr),nbas,ierr)
         if (ierr .ne. 0) call rx('scrmom failed to invert epsilon')

C     call prmx('epsa',w(oepsa),nbas,nbas,nbas)
C     call prmx('vin',vin,nclass,nclass,1)
C     call prmx('vout',vout,nclass,nclass,1)
         call pscrm2(nbas,nclass,nrclas,ipc,w(oepsa),vin,vout,
     .    w(odq),w(oqwk))
         call rlse(oepsa)
      end if

C --- Linear response estimate for unscreened dq(Vin - V[nin]) ---
      if (job0 .ge. 3) then
        if (job1 .eq. 1)
     .    call rxi('scrmom not implemented, mode',mode)

        call defrr(opstaa,nbas*nRLc*nsp*nsp)
        call pscrm5(nbas,nsp,nRLc,lhdim,w(oidxsh),ipc,
     .    pstat,w(opstaa),vin,vqin,w(odq),w(odqv))
        call rlse(opstaa)
      endif

C --- Expand vbare as l-dependent matrix, add vintra ---
      call defrr(oeps,   -nRLc2**2)
      call defrr(ovbare, -nRLc2**2)
      call pa2plm(w(ovmadb),nbas,nRLc2,lhdim,w(oidxsh),1011,1,w(ovbare))
      call pscrm4(nbas,nl,nsp,ipc,nRLc,lhdim,w(oidxsh),vintra,w(ovbare))

C --- Model for epsilon^-1 ---
      if (job1 .eq. 1) then
         call upack('ham elind',sham,elind,0,0,0,0)
         xx = elind
         qval = dgets('bz zval', sbz)
         vol  = dgets('lat vol', slat)
         if (elind .eq. 0) elind = -1
         if (elind .lt. 0d0) elind=-elind*(3*pi**2*qval/vol)**.66666d0
         call info5(20,0,0,' SCRMOM: screen output rho using model '//
     .     'response, elind=%,3;3d %?#n#(input elind=%;3d)##',
     .     elind,isw(elind.ne.xx),xx,0,0)

         call defrr(oivmad, -nbas**2)
         call defrr(oivbar, -nRLc2**2)
         call defrr(ovintr, -nRLc2**2)
         call defrr(ovtemp, -nRLc2**2)
         call defrr(ovtmp1, -nRLc2**2)
         call defrr(ovtmp2, -nbas**2)
         call defrr(ovtmp3, -nRLc2**2)
         call defrr(ovtmp4, -nRLc2**2)

         call dcopy(nbas**2,w(ovmadb),1,w(oivmad),1)
         call dqinv('n',w(oivmad),nbas,4,nbas,w(ovtmp2),nbas,ierr)
         if (ierr .ne. 0) call rx('scrmom failed to invert vmadb')

c         call dgemm('n','n',nbas,nbas,nbas,1.d0,w(oivmad),nbas,
c     .        w(ovmadb),nbas,0d0,w(ovtmp2),nbas)
c         call diaprint(nbas,w(ovtmp2))
c         call diaprint(nbas,w(ovmadb))
         call rlse(ovtmp2)

         call pa2plm(w(oivmad),nbas,nRLc2,lhdim,w(oidxsh),1011,1,
     .        w(oivbar))
         call pa2plm(w(ovmadb),nbas,nRLc2,lhdim,w(oidxsh),1011,1,
     .        w(ovtmp4))
c         call dcopy(nRLc2**2,w(ovbare),1,w(ovtmp1),1)
c         call daxpy(nRLc2**2,-1.d0,w(ovtemp),1,w(ovtmp1),1)

         call pscrm4(nbas,nl,nsp,ipc,nRLc,lhdim,w(oidxsh),vintra,
     .        w(ovintr))

c         call mcomp(nRLc2**2,w(ovtmp1),w(ovintr),ierr)
c         call dcopy(nRLc2**2,w(oivbar),1,w(ovtmp3),1)

         call dgemm('N','N',nRLc2,nRLc2,nRLc2,1.d0/3.d0,w(ovintr),nRLc2
     .        ,w(oivbar),nRLc2,0d0,w(ovtemp),nRLc2)
         call daxpy(nRLc2,1.d0,1.d0,0,w(ovtemp),nRLc2+1)

         call dcopy(nRLc2**2,w(ovtemp),1,w(ovtmp3),1)

         call dqinv('n',w(ovtemp),nRLc2,4,nRLc2,w(ovtmp1),nRLc2,ierr)
         if (ierr .ne. 0) call rx('scrmom failed to invert temp matrix')

c         call dgemm('n','n',nRLc2,nRLc2,nRLc2,1.d0,w(ovtemp),nRLc2,
c     .        w(ovtmp3),nRLc2,0d0,w(ovtmp1),nRLc2)
c         call diaprint(nRLc2,w(ovtmp1))

c         print *, 'ok'
c         call mcomp(nRLc2**2,w(ovtmp3),w(oivbar),ierr)

         call dgemm('N','N',nRLc2,nRLc2,nRLc2,1.d0/3.d0,w(oivbar),
     .        nRLc2,w(ovtemp),nRLc2,0d0,w(ovtmp1),nRLc2)
         call dcopy(nRLc2**2,w(ovtmp1),1,w(oivbar),1)

         call dcopy(nRLc2**2,w(ovbare),1,w(oivbar),1)
         call dqinv('n',w(oivbar),nRLc2,4,nRLc2,w(ovtmp3),nRLc2,ierr)
         if (ierr .ne. 0)call dcopy(nRLc2**2,w(ovtmp1),1,w(oivbar),1)



c         call dgemm('n','n',nRLc2,nRLc2,nRLc2,1.d0,w(ovtmp3),nRLc2,
c     .        w(ovtmp4),nRLc2,0d0,w(ovtemp),nRLc2)
c         call mcomp(nRLc2**2,w(ovtemp),w(ovbare),ierr)

c         call dgemm('n','n',nRLc2,nRLc2,nRLc2,1.d0,w(oivbar),nRLc2,
c     .        w(ovbare),nRLc2,0d0,w(ovtemp),nRLc2)
c         call diaprint(nRLc2,w(ovtemp))

         Call pscrm7(nRLc,nsp,elind,w(ovbare),w(oivbar),w(oeps))

         call rlse(oivmad)
         call rlse(oivbar)
         call rlse(ovintr)
         call rlse(ovtemp)
         call rlse(ovtmp1)
         call rlse(ovtmp3)
         call rlse(ovtmp4)
C --- epsilon^-1 = (1 - pstat vbare)^-1 ---
      else
         call prjrsp(nsp,nsp,1,nRLc,1,pstat)
         call pscrm6(nRLc,nsp,pstat,w(ovbare),w(oeps))
      end if
C      call prmx('qin',qin,3*nl*nsp,3*nl*nsp,nclass)
C      call prmx('qout',qout,3*nl*nsp,3*nl*nsp,nclass)

C --- Linear response estimate for self-consistent moments ---
      if (job0 .ge. 2) then
         call dpzero(w(odqv),nRLc*nsp)
         call pscrm1(nbas,nl,nsp,nRLc,nclass,nrclas,ipc,lhdim,
     .    w(oidxsh),w(oeps),w(odqv),w(odq),w(oqwk),qin,qout)
      endif

C     call poppr

C --- Make the inversion of vbare, then make the inversion of (vbare+vintra)


      end

      subroutine pscrm1(nbas,nl,nsp,nRLc,nclass,nrclas,ipc,
     .  lhdim,indxsh,eps,dqv,dq,dqscr,qin,qout)
C- Linear response estimate for self-consistent moments
Ci dq should be dim 3*nl*nsp*nbas to accomodate both functions here
C     implicit none
      integer nbas,nl,nsp,nclass,nrclas(1),nRLc,ipc(nbas)
      integer indxsh(1),lhdim
      double precision eps(nRLc,nsp,nRLc,nsp),qin(3,nl,nsp,1),
     .  dqv(nRLc,2),qout(3,nl,nsp,1),dq(nRLc,nsp,3),dqscr(nRLc,nsp,3)
C Local variables
      double precision rmsdq(2),xx
      integer isp,ib,ic,iprint,lgunit,lp1,lmri,lmrci,li,mi,id,mxorb,
     .  nglob,nRLc2,stdo

      mxorb = nglob('mxorb')
      nRLc2 = nRLc * nsp
      stdo = lgunit(1)

C --- dq = qout - qin (reorder by ib) ---
      rmsdq(1) = 0
      lmrci = 0
      do  10  ib = 1, nbas
        ic = ipc(ib)
        lmri = mxorb*(ib-1)
        do  12  li = 0, nl-1
        do  12  mi = -li, li
          lmri = lmri+1
          id = indxsh(lmri)
          if (id .gt. lhdim .or. mi .gt. -li) goto 12
          lmrci = lmrci+1
          do  14  isp = 1, nsp
            dq(lmrci,isp,1) = qout(1,li+1,isp,ic) - qin(1,li+1,isp,ic)
            dq(lmrci,isp,2) = qout(2,li+1,isp,ic) - qin(2,li+1,isp,ic)
            dq(lmrci,isp,3) = qout(3,li+1,isp,ic) - qin(3,li+1,isp,ic)
            rmsdq(1) = rmsdq(1) + dq(lmrci,isp,1)**2
C       ... Subtract dqv = linear response estimate for dq(Vin-V[qin])
            dq(lmrci,isp,1) = dq(lmrci,isp,1) - dqv(lmrci,isp)
   14     continue
   12   continue
   10 continue
      call rxx(lmrci.ne.nRLc,'pscrm1: index mismatch')
C     call prmx('qout - qin - dqv',dq,nRLc,nRLc,nsp*3)

C --- epsilon^-1 dq ---
C ... Copy array, so we can screen only first column
C     call dcopy(nl*nbas*nsp*3,dq,1,dqscr,1)
C ... Use 3*nsp for all moments, 1*nsp for first only
      call dpzero(dqscr, nRLc2*1)
      call dgemm('N','N',nRLc2,1,nRLc2,1d0,eps,nRLc2,dq,nRLc2,1d0,
     .  dqscr,nRLc2)
C     call prmx('dqscr=eps^-1(qout-qin)',dqscr,nRLc,nRLc,nsp*1)

C --- Overwrite with = qin + epsilon^-1 dq ---
C ... Save old qout in dq for printout; initialize 0th moment of qout
      call dcopy(nl*nclass*nsp*3,qout,1,dq,1)
       do  21  isp = 1, nsp
       do  21  ic = 1, nclass
       do  21  lp1 = 1, nl
        dq(lp1+nl*(ic-1),isp,1) = qout(1,lp1,isp,ic)
        qout(1,lp1,isp,ic) = 0
   21 continue
C ... Accumulate eps^-1 (qout-qin), averaging by classes
      rmsdq(2) = 0
      lmrci = 0
      do  20  ib = 1, nbas
        ic = ipc(ib)
        lmri = mxorb*(ib-1)
        do  22  li = 0, nl-1
        do  22  mi = -li, li
          lmri = lmri+1
          id = indxsh(lmri)
          if (id .gt. lhdim .or. mi .gt. -li) goto 22
          lmrci = lmrci+1
          do  24  isp = 1, nsp
            rmsdq(2) = rmsdq(2) + dqscr(lmrci,isp,1)**2
            qout(1,li+1,isp,ic) = qout(1,li+1,isp,ic) +
     .                            dqscr(lmrci,isp,1)/nrclas(ic)
   24     continue
   22   continue
   20 continue

C ... Add qin to qout; if qout is zero, assume unscreened qout??
      do  25  ic = 1, nclass
      do  25  isp = 1, nsp
      do  25  lp1 = 1, nl
        qout(1,lp1,isp,ic) = qout(1,lp1,isp,ic) + qin(1,lp1,isp,ic)
   25 continue

C --- Printout ---
      rmsdq(1) = sqrt(rmsdq(1)/nRLc*nsp)
      rmsdq(2) = sqrt(rmsdq(2)/nRLc*nsp)
      if (iprint() .ge. 20) call awrit2(' SCRMOM: unscreened '//
     .  'dq=%1,3;3e  screened dq=%1,3;3e',' ',80,lgunit(1),
     .  rmsdq(1),rmsdq(2))
       if (iprint() .le. 40) return
       write(stdo,441)
  441  format('  ic  l      qin         qout',8x,'qscr',8x,'diff')
       do  30  isp = 1, nsp
         if (isp .eq. 2) print *, ' .... spin 2'
       do  30  ic = 1, nclass
       do  30  lp1 = 1, nl
         xx = dq(lp1+nl*(ic-1),isp,1)
         write(stdo,440) ic,lp1-1,qin(1,lp1,isp,ic),xx,
     .     qout(1,lp1,isp,ic),qout(1,lp1,isp,ic)-xx
   30 continue
  440 format(i4,i3,4f12.6)

      end

      subroutine pscrm2(nbas,nclass,nrclas,ipc,epsa,vin,vout,dv,dvscr)
C- Linear response estimate for self-consistent v
C     implicit none
      integer nbas,nclass,ipc(nbas),nrclas(nbas)
      double precision vin(1),vout(1),dv(nbas),dvscr(nbas),
     .  epsa(nbas,nbas)
C Local variables
      double precision rmsdv(2)
      integer ib,ic,iprint,lgunit

C --- dv = vout - vin ---
      rmsdv(1) = 0
      do  10  ib = 1, nbas
        ic = ipc(ib)
        dv(ib) = vout(ic) - vin(ic)
        rmsdv(1) = rmsdv(1) + dv(ib)**2
   10 continue
*     call prmx('dv',dv,nbas,nbas,1)

C --- Save in vscr : eps^-1 (vout - vin) ---
      call dgemm('T','N',nbas,1,nbas,1d0,epsa,nbas,dv,nbas,0d0,
     .  dvscr,nbas)

C --- vscr = vin + eps^-1 (vout - vin) ---
C ... Save old vout in dv for printout
      call dcopy(nclass,vout,1,dv,1)
      call dpzero(vout,nclass)
      rmsdv(2) = 0
      do  20  ib = 1, nbas
        ic = ipc(ib)
        vout(ic) = vout(ic) + (dvscr(ib) + vin(ic))/nrclas(ic)
        rmsdv(2) = rmsdv(2) + dvscr(ib)**2
   20 continue

      if (iprint() .ge. 20) call awrit2(' SCRMOM: unscreened '//
     .  'dv=%1,3;3e  screened dv=%1,3;3e',' ',80,lgunit(1),
     .  rmsdv(1),rmsdv(2))
       if (iprint() .le. 40) return
       print '(''  ic      Vin         Vout        Vscr'')'
       do  30  ic = 1, nclass
         print 440, ic,vin(ic),dv(ic),vout(ic)
  440   format(i4,3f12.6)
   30 continue

      end
      subroutine pscrm3(nbas,ipc,wsr,vmad,ldv,vmadb)
C- Kernel called by scrmom to make unscreened Madelung matrix.
C     implicit none
      integer nbas,ipc(1),ldv
      double precision wsr(1),vmad(ldv,ldv),vmadb(nbas,nbas)
      integer ib

C     call prmx('madelung matrix',vmad,ldv,ldv,ldv)

C ... Madelung potential = Madelung matrix * 2
      call dmscop(vmadb,nbas,vmad,ldv,1,nbas,1,nbas,1,1,2d0)

C ... Add site-diagonal 2/r
      do  10 ib = 1, nbas
   10 vmadb(ib,ib) = vmadb(ib,ib) + 2/wsr(ipc(ib))

C     call prmx('vmadb',vmadb,nbas,nbas,nbas)

      end

      subroutine pscrm4(nbas,nl,nsp,ipc,nRLc,ldim,indxsh,vintra,vbare)
C- Add vintra to vbare
C ----------------------------------------------------------------------
Ci Inputs
Ci   nbas,nl,nsp,nRLc,ipc
Ci   vintra on-site density-density response matrix
Ci   vbare  bare Coulomb matrix with no intra-atomic terms and, not
Ci          spin polarized.
Ci          NB: in the spin polarized case, input vbare is dimensioned
Ci              WITHOUT spin polarization.
Co Outputs
Co   vbare  on-site vintra is added to vbare.
Co          NB: in the spin polarized case, output vbare is dimensioned
Co              WITH spin polarization; see pscrm5.
C ----------------------------------------------------------------------
C     implicit none
      integer nbas,nl,nsp,nRLc,ldim,ipc(nbas),indxsh(1)
      double precision vintra(nl,nl,nsp,nsp,1),vbare(nRLc,nsp,nRLc,nsp)
C Local variables
      integer ib,ic,idim0,il,ilb,jl,jlb,li,lj,norb,ntorbi,n0,nkap0
      parameter (n0=10,nkap0=3)
      integer isp,jsp,offi,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)

      if (nsp .eq. 2) then
        call dmcpy(vbare,nRLc*2,1,vbare(1,1,1,2),nRLc*2,1,nRLc,nRLc)
        call dmcpy(vbare,nRLc*2,1,vbare(1,2,1,1),nRLc*2,1,nRLc,nRLc)
        call dmcpy(vbare,nRLc*2,1,vbare(1,2,1,2),nRLc*2,1,nRLc,nRLc)
      endif

      idim0 = 0
      do  10  ib = 1, nbas
        ic = ipc(ib)
C       uses norb,ltab
        call orbl(ib,0,ldim,indxsh,norb,ltab,ktab,offi,offl,ntorbi)

        ilb = idim0
        do  20  il = 1, norb
          ilb = ilb+1
          li = ltab(il)+1
          jlb = idim0
          do  22  jl = 1, norb
            jlb = jlb+1
            lj = ltab(jl)+1

            do  22  isp = 1, nsp
            do  22  jsp = 1, nsp
            vbare(ilb,isp,jlb,jsp) = vbare(ilb,isp,jlb,jsp) +
     .                               vintra(li,lj,isp,jsp,ic)
   22     continue
   20   continue
        idim0 = idim0+norb
   10 continue

C     print *, 'ok in prscm4'
C     call prmx('vbare incl vintra',vbare,nRLc*nsp,nRLc*nsp,nRLc*nsp)

      end

      subroutine pscrm5(nbas,nsp,nRLc,lhdim,indxsh,ipc,pstat,pstaa,vin,
     .  vqin,dv,dqv)
C- Linear response estimate for unscreened dq(Vin - V[nin])
C     implicit none
      integer nbas,nsp,lhdim,nRLc,ipc(nbas),indxsh(1)
      double precision vin(1),vqin(1),dv(nbas),
     .  pstat(nRLc,nsp,nRLc,nsp),dqv(nRLc,nsp)
      double precision pstaa(nbas,nRLc,nsp,nsp)
C Local variables
      double precision rmsdv(2),dsum,qtot,sump,xx
      integer ib,ic,is1,i,nRLc2

      nRLc2 = nRLc * nsp

C --- dv = vqin - vin ---
      rmsdv(1) = 0
      do  10  ib = 1, nbas
        ic = ipc(ib)
        dv(ib) = vqin(ic) - vin(ic)
        rmsdv(1) = rmsdv(1) + dv(ib)**2
   10 continue

C     call prmx('v[qin]-vin',dv,nbas,nbas,1)

      call dpzero(dqv,nRLc2)

C --- Unscreened dq(Vin - V[nin]) = P (Vin - V[nin]) ---
      do  20  is1 = 1, nsp

C   ... Collapse one l-sigma index of p, to multiply by V
        call plm2pa(pstat(1,is1,1,1),nbas,nRLc2,lhdim,indxsh,10,
     .    nRLc2,pstaa(1,1,1,is1))

        call dgemm('T','N',nRLc2,1,nbas,-1d0,pstaa(1,1,1,is1),nbas,dv,
     .    nbas,1d0,dqv,nRLc2)

C      call prmx('pstaa',pstaa(1,1,1,is1),nbas,nbas,nRLc2)
C      call prmx('dq(v[qin]-vin before renorm)',dqv,nRLc,nRLc,nsp)

   20 continue

C     Ensure charge neutrality --- should do by renorm of pstaa
      qtot = dsum(nRLc2,dqv,1)
      sump = dsum(nRLc2*nbas*nsp,pstaa,1)
      do  22  is1 = 1, nsp
      do  22  i = 1, nRLc
        xx = dsum(nbas,pstaa(1,i,is1,1),1)
        if (nsp .eq. 2) xx = xx + dsum(nbas,pstaa(1,i,is1,2),1)
        dqv(i,is1) = dqv(i,is1) - qtot/sump * xx
   22 continue

C     call prmx('dq(v[qin]-vin)',dqv,nRLc,nRLc,nsp)

      end
      subroutine pscrm6(nRLc,nsp,pstat,vbare,eps)
C- Make epsilon^-1 = (1 - pstat vbare)^-1
C ----------------------------------------------------------------------
Ci Inputs
Ci For debugging, to make eps^-1
Ci   mc -1:24 pstat.nsp=1 vbare+vintra -x -s-1 -+ -i
C ----------------------------------------------------------------------
C     implicit none
      integer nsp,nRLc
      double precision pstat(nRLc,nsp,nRLc,nsp),vbare(nRLc,nsp,nRLc,nsp)
      double precision eps(nRLc,nsp,nRLc,nsp)
C heap:
      integer w(1)
      common /w/ w
C Local variables
      integer ierr,owkr,nRLc2

      nRLc2 = nRLc * nsp

C --- epsilon = (1 - pstat vbare) ---
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1d0,pstat,nRLc2,
     .  vbare,nRLc2,0d0,eps,nRLc2)
      call daxpy(nRLc2,1d0,1d0,0,eps,nRLc2+1)
C     call prm('epsilon',ierr,eps,nRLc2,nRLc2,nRLc2)

C --- epsilon^-1 ---
      call defrr(owkr,nRLc2**2)
      call dqinv('n',eps,nRLc2,4,nRLc2,w(owkr),nRLc2,ierr)
      if (ierr .ne. 0) call rx('scrmom failed to invert epsilon')

      call rlse(owkr)

C ... debugging
C     call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)
C     call prm('vbare',ierr,vbare,nRLc2,nRLc2,nRLc2)
C     call prm('epsilon^-1',ierr,eps,nRLc2,nRLc2,nRLc2)

      end

      subroutine pscrm7(nRLc,nsp,elind,vbare,invbar,eps)
C- Make epsilon^-1 using a model aproach without using pstat
C ----------------------------------------------------------------------
Ci Inputs
Ci   nRLc  :
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   elind :
Ci   vbare :
Co Outputs
Co   eps   :model dielectric function
Cl Local variables
Cr Remarks
Cr   First diagonalize vbare to vbare2, and make eps2, then transfer
Cr   the eps2 to the original space to make eps. Finally, make epsilon^-1
Cu Updates
Cu   24 Feb 05 (Jialei Xu) first created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nsp,nRLc
      double precision eps(nRLc,nsp,nRLc,nsp),elind
      double precision vbare(nRLc,nsp,nRLc,nsp),
     .     invbar(nRLc,nsp,nRLc,nsp)
C ... Local parameters
      integer ierr,owkr,nRLc2,ovbar2,ovbvec,ofv1,ofv2,oeps2,oqdtmp,
     .     opstat
C heap:
      integer w(1)
      common /w/ w

      nRLc2 = nRLc * nsp

C --- diagonalize the vbare matrix ---
C     ovbar2 stores the diagonal part of diagonalized matrix,
C     ovbvec stores the normalized eigenvectors of vbare
      call defrr(ovbar2,nRLc2)
      call defrr(ovbvec,nRLc2**2)
      call defrr(ofv1,nRLc2)
      call defrr(ofv2,nRLc2)

      call rs(nRLc2,nRLc2,vbare,w(ovbar2),1,w(ovbvec),w(ofv1),w(ofv2),
     .        ierr)
      if (ierr .ne. 0) call rx('scrmom: diagonalization failed')
      call rlse(ofv1)
      call rlse(ofv2)

      call defrr(oeps2,nRLc2**2)
      call dpzero(w(oeps2),nRLc2**2)

C --- make epsilon2 = 1 + elind * vbare2 ---
cx      print *, elind
      call dpzero(w(oeps2),nRLc2**2)
      call daxpy(nRLc2,elind,w(ovbar2),1,w(oeps2),nRLc2+1)
      call daxpy(nRLc2,1d0,1d0,0,w(oeps2),nRLc2+1)
      call dvset(w(oeps2),1,1,1d0)

cx      call mdprint(nRLc2,w(oeps2))

C --- transfer back to original space to get epsilon ---
C     one option, can use dtrmm.f zgemm.f ztrmm.f in BLAS directory
      call defrr(oqdtmp,nRLc2**2)
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,1d0,w(ovbvec),nRLc2,w(oeps2),
     .           nRLc2,0d0,w(oqdtmp),nRLc2)
      call dgemm('N','T',nRLc2,nRLc2,nRLc2,1d0,w(oqdtmp),nRLc2,
     .           w(ovbvec),nRLc2,0d0,eps,nRLc2)
c      eps(1,1,1,1) = 1.d0
c      call mdzero(nRLc2,eps)
      call rlse(oeps2)
      call rlse(ovbar2)
      call rlse(oqdtmp)
      call rlse(ovbvec)

C     projecting the response function to conserve the charge
      call defrr(opstat,-nRLc2**2)
      call daxpy(nRLc2,-1.d0,1.d0,0,eps,nRLc2+1)
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1.d0,eps,nRLc2,invbar,
     .     nRLc2,0d0,w(opstat),nRLc2)
      call prjrsp(nsp,nsp,1,nRLc,1,w(opstat))
      call dgemm('N','N',nRLc2,nRLc2,nRLc2,-1.d0,w(opstat),nRLc2,
     .     vbare,nRLc2,0d0,eps,nRLc2)
      call daxpy(nRLc2,1.d0,1.d0,0,eps,nRLc2+1)

      call rlse(opstat)

C --- epsilon^-1 ---
      call defrr(owkr,nRLc2**2)
      call dqinv('n',eps,nRLc2,4,nRLc2,w(owkr),nRLc2,ierr)
      if (ierr .ne. 0) call rx('scrmom failed to invert epsilon')

      call rlse(owkr)

C ... debugging
C     call prm('pstat',ierr,pstat,nRLc2,nRLc2,nRLc2)
C     call prm('vbare',ierr,vbare,nRLc2,nRLc2,nRLc2)
C     call prm('epsilon^-1',ierr,eps,nRLc2,nRLc2,nRLc2)
      end

C      subroutine mcomp(n, A, B, ires)
C      integer n,i
C      double precision A(n),B(n),error,etmp,atmp
C      error = 0d0
C      ires = 1
C      do 10, i = 1,n
C         etmp = abs(A(i)-B(i))
C         if (etmp .gt. 1e-4) then
C            print *, etmp, B(i),A(i)
C         end if
C 10   continue
C
CC      if (error .gt. 1e-1) ires = 0
CCc      print * , 'matrix A and B differ, the error = ',error,' A= ',atmp
CC
C      end
C      subroutine diaprint(n,A)
C      integer n, i
C      double precision A(n,n)
C      do, i = 1, n
C         print *, A(i,i)
C      end do
C
C      end
C

