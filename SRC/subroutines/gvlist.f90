subroutine gvlist_notused(alat,plat,tau,n1,n2,n3,gmax,job,ngmx,ng,kv,gv, &
     igv,igv2)
  use m_shortn3,only: shortn3_initialize,shortn3
  use m_lgunit,only:stdo
  !- Create a list of G vectors for a specified uniform mesh and cutoff
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   alat     Lattice constant
  !i   plat     Real-space primitive lattice vectors
  !i   tau      offset subtracted from gv to measure length
  !i            Used if 100s digit job is 1 or 2
  !i   n1..n3   no. divisions along the three lattice vectors
  !i   job      1s digit
  !i              0 return ng only
  !i              1 return kv and igv
  !i              2 return kv and igv2
  !i              4 return kv and gv
  !i              8 return kv and gv, and sort list
  !i                any combination of 1,2,4,8 is allowed
  !i            100s digit
  !i              0 specify cutoff as |G|<Gmax
  !i              1 specify cutoff as |G+tau|<Gmax
  !i              2 specify cutoff as |G-tau|<Gmax
  !i              Add 4 if to return gv = G+/-tau
  !i            1000s digit
  !i              not used
  !i   gmax     Energy cutoff
  !i   ngmx     Leading dimension of gv,kv,igv; must be at least ng
  !i            if any of these are to be generated.
  !o Outputs (which quantities are ouptut depends on job)
  !o   ng       Number of lattice vectors
  !o   gv       list of reciprocal lattice vectors G
  !o   kv       indices for gather/scatter operations.
  !o            kv(ig,i=1,2,3) for vector ig=1..ng points to which entry
  !o            on the mesh (i1,i2,i3) vector ig belongs:
  !o              1<=i1<=n1; 1<=i2<=n2;  1<=i3<=n3
  !o   igv      list of reciprocal lattice vectors G, represented as
  !o            three integers (multiples of qlat).
  !o            gv and igv are related by:
  !o              gv(1:3,1:ng) = 2*pi/alat * (qlat * igv(1:ng))
  !o   igv2     same as igv except first and second columns are permuted
  !r Remarks
  !r   Collects a list of q + reciprocal lattice vectors (G+q) out of
  !r   a uniform 3D mesh lie within a cutoff gmax.  Sorted by length.
  !r   Criterion for cutoff is |(gv-tau)|<gmax
  !r   Use with the following:
  !r     call gvgetf(ng,1,kv,k1,k2,k3,c,c0)
  !r       to collect elements into list c0 from 3D array c
  !r     call gvputf(ng,1,kv,k1,k2,k3,c0,c)
  !r       to poke elements from list c0 into 3D array c
  !r     call gvaddf(ng,kv,k1,k2,k3,c0,c)
  !r       to add elements from list c0 into 3D array c
  !r
  !r   The following routines are designed to work either with a
  !r   specified uniform mesh of G vectors, specified by primitive
  !r   lattice vectors and numbers of divisions n1,n2,n3 (gvcutof,
  !r   gvlist) or without it (gvlst2).
  !r
  !r     gvctof takes as input a uniform mesh of points n1..n3. gvctof
  !r            generates an appropriate energy cutoff gmax, and counts
  !r            the number of G vectors within the cutoff.  The list of
  !r            vectors is generated by looping over all points
  !r            0..n1,0..n2,0..n3, shortens each vector, and retaining
  !r            those for which G<Gmax.  Because only points on the
  !r            specified mesh are considered, there is no guarantee
  !r            that all vectors G<Gmax will be included in the list.
  !r
  !r     gvlist takes as input uniform mesh of G vectors specified by
  !r            n1..n3 and an energy cutoff Gmax, and creates a list of
  !r            G-vectors that lie within Gmax.  gvlist operates in the
  !r            same way as gvctof, and generates the same list of
  !r            vectors.  The list of vectors is sorted by increasing
  !r            length.
  !r
  !r     gvlst2 is designed to work without any constraint that the list
  !r            of vectors map onto a specified mesh n1..n3.  It takes
  !r            as input an energy cutoff Gmax, and returns a list of
  !r            all G vectors whose length G is G<Gmax.  There is no
  !r            shortening of vectors; the number of divisions n1..n3
  !r            needed to encompass all vectors cannot be specified, but
  !r            is output by gvlst2.  Thus, this routine is only
  !r            suitable in cases where there is no need for the vectors
  !r            to map onto a specified mesh.  Offset q in gvlst2
  !r            corresponds to -tau in gvlist.
  !r
  !u Updates
  !u   20 Jul 02 Bug fix for nonzero tau
  !u   31 May 01 gvlist was significantly altered.  See ogvlst for
  !u             original version.
  !u   07 Feb 01 changed gmax tolerance to be consistent with gvlst2
  !u   10 Jun 00 added extra argument to gvgetf and gvputf
  !u    2 Sep 98 Adapted from nfp gvlist.f
  ! ----------------------------------------------------------------------
  implicit none
  ! ... Passed parameters
  integer :: job,n1,n2,n3,ng,ngmx,kv(ngmx,3),igv(ngmx,3),igv2(3,*)
  double precision :: alat,gmax,gv(ngmx,3),plat(3,3),tau(3)
  ! ... Local parameters
  logical :: ligv,ligv2,lgv,lsort,lgpq
  integer :: m,ig,j1,j2,j3,iprint,ogg,okk,oiwk,PRTG,job0
  double precision :: qlat(3,3),plat1(3,3),qlat1(3,3),qpg(3),gs(3),pi, &
       tpiba,tol,gg,vol,gmax2,q(3),s1,s2,s3,ddot
  character(256) :: outs
  parameter (PRTG=30)
  external dinv33,dpcopy,dpzero,pvglst,rx,shorbz
  integer,save:: i,iyy
  integer,allocatable:: ixx(:,:)
  integer,parameter :: m_gslist=10
  integer:: n_gslist,i_gslist,if1,if2,if3
  real(8):: gslist(3,m_gslist)
  integer:: gsflags(3),nout,noutmx
  logical:: fullmesh
  real(8) ,allocatable :: gg_rv(:)
  real(8) ,allocatable :: kk_rv(:)
  real(8) ,allocatable :: iwk_rv(:)
  integer,allocatable:: nlatout(:,:)
  logical:: isanrg, l_dummy_isanrg
  real(8):: rlatp(3,3),xmx2(3)

  ! ... Setup
  !      stdo = lgunit(1)
  job0  = mod(job,100)
  ligv  = mod(job0,2)   .ne. 0
  ligv2 = mod(job0/2,2) .ne. 0
  lgv   = mod(job0/4,4) .ne. 0
  lsort = mod(job0/8,2) .ne. 0
  pi = 4d0*datan(1d0)
  call dinv33(plat,1,qlat,vol)
  tpiba = 2*pi/alat
  tol = 1d-8
  m = mod(mod(job/100,10),4)
  lgpq = mod(job/100,10) .gt. 4

  ! ino isanrg is logical function,       call isanrg(job0,0,11,'gvlist','1+10s digit job',.true.)
  l_dummy_isanrg=isanrg(job0,0,11,'gvlist','1+10s digit job',.true.)
  ! ino isanrg is logical function,       call isanrg(m,0,2,'gvlist','100s digit job',.true.)
  l_dummy_isanrg=isanrg(m,0,2,'gvlist','100s digit job',.true.)
  call dpzero(q,3)
  if (m == 1) then
     call dpcopy(tau,q,1,3,1d0)
  elseif (m == 2) then
     call dpcopy(tau,q,1,3,-1d0)
  endif

  ! ... Basis vectors for real-space mesh and recip-space supercell
  do  10  m = 1, 3
     plat1(m,1) = plat(m,1)/n1
     plat1(m,2) = plat(m,2)/n2
     plat1(m,3) = plat(m,3)/n3
     qlat1(m,1) = qlat(m,1)*n1
     qlat1(m,2) = qlat(m,2)*n2
     qlat1(m,3) = qlat(m,3)*n3
10 enddo

  ! --- Loop through g vectors, shorten, count and keep if within gmax ---
  ig = 0
  gmax2 = (gmax-tol)**2/tpiba**2

  if(fullmesh()) then !kino's path. Something wrong
     ! ---> Kino think this is OK even for fullmesh()=F.
     ! But this path did not go through make check.
     noutmx=48
     call shortn3_initialize(qlat1) !initialization for shoten3
     allocate(nlatout(3,noutmx))
     do  21  j1 = 0, n1-1
        do  22  j2 = 0, n2-1
           do  23  j3 = 0, n3-1
              !              n_gslist=0
              !              do 21 if1=0,1
              !                do 21 if2=0,1
              !                  do 21 if3=0,1
              !                    gsflags=(/if1,if2,if3/)
              !                    qpg(1) = j1*qlat(1,1) + j2*qlat(1,2) + j3*qlat(1,3) + q(1)
              !                    qpg(2) = j1*qlat(2,1) + j2*qlat(2,2) + j3*qlat(2,3) + q(2)
              !                    qpg(3) = j1*qlat(3,1) + j2*qlat(3,2) + j3*qlat(3,3) + q(3)

              qpg= (/j1, j2, j3/) + matmul(q,plat(:,:))
              qpg= (/ qpg(1)/dble(n1), qpg(2)/dble(n2), qpg(3)/dble(n3) /)
              call shortn3(qpg, noutmx, nout,nlatout)
              gs= matmul(qlat1(:,:), (qpg+nlatout(:,1))) ! We use first nlatout only.
              !--->This may numerically break crystal symmetry (very slightly).
              ! hortn3 requires shotn3_init in advance.
              !                    call shorbzm(gsflags,qpg,gs,qlat1,plat1)
              !                    do i_gslist=1,n_gslist
              !                      if ( gs(1).eq.gslist(1,i_gslist) .and.
              !     .                gs(2).eq.gslist(2,i_gslist) .and.
              !     .                gs(3).eq.gslist(3,i_gslist) ) then
              !                        goto 21
              !                      endif
              !                    enddo
              !                    n_gslist=n_gslist+1
              !                    gslist(1:3,n_gslist)=gs(1:3)
              !        if (n_gslist>1)then
              !                    write(6,'(a,i5,3f15.5)')'new gs=',n_gslist,gs
              !        endif

              !        print 333, j1,j2,j3,gs !+tau(1),gs(2)+tau(2),gs(3)+tau(3)
              !  333   format(3i4,3f12.6)
              gg = (gs(1)**2+gs(2)**2+gs(3)**2)
              if (gg <= gmax2) then
                 ig = ig+1

                 !         if (abs(gs(1)+5) .lt.1d-4 .and. gs(3).lt.-10.8) then
                 !           print *, j1,j2,j3
                 !           print *, gs
                 !         endif

                 if (job0 /= 0) then

                    if (ig > ngmx) call rx('gvlist: ng exceeds ngmx')

                    kv(ig,1) = j1+1
                    kv(ig,2) = j2+1
                    kv(ig,3) = j3+1

                    !     ... Copy lattice vectors to gv,igv,igv2, depending on job
                    if (ligv .OR. ligv2 .OR. .TRUE. ) then
                       s1 = (gs(1)-q(1))*plat(1,1) &
                            + (gs(2)-q(2))*plat(2,1) &
                            + (gs(3)-q(3))*plat(3,1)
                       s2 = (gs(1)-q(1))*plat(1,2) &
                            + (gs(2)-q(2))*plat(2,2) &
                            + (gs(3)-q(3))*plat(3,2)
                       s3 = (gs(1)-q(1))*plat(1,3) &
                            + (gs(2)-q(2))*plat(2,3) &
                            + (gs(3)-q(3))*plat(3,3)
                       ! if DEBUG
                       !            if ((nint(s1)-s1)**2+(nint(s2)-s2)**2+(nint(s3)-s3)**2
                       !     .        .gt. 1d-12) call rx('bug in gvlist')
                       ! endif
                       if (ligv) then
                          igv(ig,1) = nint(s1)
                          igv(ig,2) = nint(s2)
                          igv(ig,3) = nint(s3)
                       endif
                       if (ligv2) then
                          igv2(1,ig) = nint(s1)
                          igv2(2,ig) = nint(s2)
                          igv2(3,ig) = nint(s3)
                       endif
                    endif

                    if (lgv) then
                       if (lgpq) then
                          gv(ig,1) = gs(1)
                          gv(ig,2) = gs(2)
                          gv(ig,3) = gs(3)
                       else
                          gv(ig,1) = gs(1) - q(1)
                          gv(ig,2) = gs(2) - q(2)
                          gv(ig,3) = gs(3) - q(3)
                       endif
                    endif

                 endif
              endif
23         enddo
22      enddo
21   enddo
     deallocate(nlatout)
  else

     do  120  j1 = 0, n1-1
        do  121  j2 = 0, n2-1
           do  122  j3 = 0, n3-1
              qpg(1) = j1*qlat(1,1) + j2*qlat(1,2) + j3*qlat(1,3) + q(1)
              qpg(2) = j1*qlat(2,1) + j2*qlat(2,2) + j3*qlat(2,3) + q(2)
              qpg(3) = j1*qlat(3,1) + j2*qlat(3,2) + j3*qlat(3,3) + q(3)
              call shorbz(qpg,gs,qlat1,plat1)
              !        print 333, j1,j2,j3,gs(1)+tau(1),gs(2)+tau(2),gs(3)+tau(3)
              !  333   format(3i4,3f12.6)
              gg = (gs(1)**2+gs(2)**2+gs(3)**2)
              if (gg <= gmax2) then
                 ig = ig+1
                 !         if (abs(gs(1)+5) .lt.1d-4 .and. gs(3).lt.-10.8) then
                 !           print *, j1,j2,j3
                 !           print *, gs
                 !         endif

                 if (job0 /= 0) then

                    if (ig > ngmx) call rx('gvlist: ng exceeds ngmx')

                    kv(ig,1) = j1+1
                    kv(ig,2) = j2+1
                    kv(ig,3) = j3+1

                    !             write(*,"('wwwww2222 j1j2j3=',4i4,f13.5)")ig,j1,j2,j3,gg

                    !     ... Copy lattice vectors to gv,igv,igv2, depending on job
                    if (ligv .OR. ligv2 .OR. .TRUE. ) then
                       s1 = (gs(1)-q(1))*plat(1,1) &
                            + (gs(2)-q(2))*plat(2,1) &
                            + (gs(3)-q(3))*plat(3,1)
                       s2 = (gs(1)-q(1))*plat(1,2) &
                            + (gs(2)-q(2))*plat(2,2) &
                            + (gs(3)-q(3))*plat(3,2)
                       s3 = (gs(1)-q(1))*plat(1,3) &
                            + (gs(2)-q(2))*plat(2,3) &
                            + (gs(3)-q(3))*plat(3,3)
                       ! if DEBUG
                       !            if ((nint(s1)-s1)**2+(nint(s2)-s2)**2+(nint(s3)-s3)**2
                       !     .        .gt. 1d-12) call rx('bug in gvlist')
                       ! endif
                       if (ligv) then
                          igv(ig,1) = nint(s1)
                          igv(ig,2) = nint(s2)
                          igv(ig,3) = nint(s3)
                       endif
                       if (ligv2) then
                          igv2(1,ig) = nint(s1)
                          igv2(2,ig) = nint(s2)
                          igv2(3,ig) = nint(s3)
                       endif
                    endif

                    if (lgv) then
                       if (lgpq) then
                          gv(ig,1) = gs(1)
                          gv(ig,2) = gs(2)
                          gv(ig,3) = gs(3)
                       else
                          gv(ig,1) = gs(1) - q(1)
                          gv(ig,2) = gs(2) - q(2)
                          gv(ig,3) = gs(3) - q(3)
                       endif
                    endif

                 endif
              endif
122        enddo
121     enddo
120  enddo

  endif
  ng = ig

  ! ... Printout
  if (iprint() >= PRTG) then
     !$$$#if AWRITE
     !$$$        s1 = alat*sqrt(ddot(3,plat(1,1),1,plat(1,1),1))/n1
     !$$$        s2 = alat*sqrt(ddot(3,plat(1,2),1,plat(1,2),1))/n2
     !$$$        s3 = alat*sqrt(ddot(3,plat(1,3),1,plat(1,3),1))/n3
     !$$$        call awrit4('%x%N GVLIST: gmax = %,1;4g'//
     !$$$     .  ' a.u. created %i vectors of %i (%i%%)',
     !$$$     .  outs,len(outs),0,gmax,ng,n1*n2*n3,(ng*100)/(n1*n2*n3))
     !$$$        call awrit6('%a%N%9fmesh has %i x %i x %i'//
     !$$$     .  ' divisions; length %,3;3d, %,3;3d, %,3;3d',outs,
     !$$$     .  len(outs),0,n1,n2,n3,s1,s2,s3)
     !$$$        call awrit0('%a',outs,len(outs),-stdo)
     !$$$#else
     if (iprint() >= PRTG) print 861, gmax,ng,n1*n2*n3
861  format(/' gvlist: cutoff radius ',f7.3,' gives',i7, &
          '   recips of max',i7)
     ! endif
  endif

  ! ... Sort the list of vectors
  if ( .NOT. lsort) return
  !      call defrr(ogg,   ng)
  !      call defrr(okk,   ng)
  !      call defrr(oiwk,  ng)
  !      allocate(gg_rv(ng))
  !      allocate(kk_rv(ng))
  !      allocate(iwk_rv(ng))
  if (lgpq) q=0 !call dpzero(q,3)
  !      call pvglst(w(ogg),w(okk),w(oiwk),q,ngmx,ng,ligv,ligv2,gv,kv,igv,
  !     .  igv2)
  call pvglst ( q , ngmx , ng &
       , ligv , ligv2 , gv , kv , igv , igv2 )
  !      call rlse(ogg)
  !      deallocate(gg_rv,kk_rv,iwk_rv)

  !$$$ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  !$$$c      if(job==509) print *,'509q=',q
  !$$$c      print *,'ggg: 1 job=',job
  !$$$      allocate(ixx(ng,3))
  !$$$      do i=1,ng
  !$$$         ixx(i,1)=i*1
  !$$$         ixx(i,2)=i*2
  !$$$         ixx(i,3)=i*3
  !$$$      enddo
  !$$$c      print *,'ggg: x job=',job
  !$$$      if(job==509) then
  !$$$        iyy=iyy+1
  !$$$        write(6,"('ggg509:',5i12,d13.5)") ngmx,ng,sum(ixx*kv(1:ng,:)),
  !$$$     &  sum(ixx*igv(1:ng,1:3)),
  !$$$c     &  sum(transpose(ixx)*igv2(1:3,1:ng)),
  !$$$     &  sum(ixx*gv(1:ng,:))
  !$$$         if(iyy<5) then
  !$$$          do i=1,ng
  !$$$c         write(6,"('ggg509:',i5,4d13.5)")i,gv(i,:),sqrt(sum(gv(i,:)**2))
  !$$$          write(6,"('ggg509:',i5,14d13.5)")i,gv(i,:)-tau,
  !$$$     &   sqrt( sum((gv(i,:)-tau)**2))
  !$$$          enddo
  !$$$         endif
  !$$$      endif
  !$$$      if(job==8) then
  !$$$      write(6,"('ggg008:',3i12,d13.5)") ngmx,ng,sum(ixx*kv(1:ng,:)),
  !$$$     &  sum(ixx*gv(1:ng,:))
  !$$$      endif
  !$$$      deallocate(ixx)
  !$$$ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
end subroutine gvlist_notused

subroutine pvglst(p,ngmx,ng,ligv,ligv2,gv,kv,igv,igv2)
  !- Kernel called by gvlist to sort gv and kv
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   gg    :double precision work array of length ng
  !i   kk    :integer work array of length ng
  !i   iwk   :integer work array of length ng : returns permutation of gg
  !i   p     :offset subtracted from g to measure length
  !i   ngmx  :dimensions gv,kv,igv
  !i   ng    :number of G-vectors
  !i   ng    :number of group operations
  !i   ligv  :sort igv also
  !i   ligv2 :sort igv2 also
  ! o Inputs/Outputs
  !i         :the following arrays are sorted:
  !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
  !i   kv    :indices for gather/scatter operations (gvlist.f)
  !i   igv   :G vectors in integer format
  !i   igv2  :like igv, but array dimensions inverted
  !r Remarks
  !r
  !u Updates
  !u   20 Jul 02 Bug fix for nonzero tau
  !u   01 Jun 01  Added igv,igv2
  ! ----------------------------------------------------------------------
  implicit none
  logical :: ligv,ligv2
  integer :: ngmx,ng,kk(ng),iwk(ng),kv(ngmx,3),igv(ngmx,3),igv2(3,*)
  double precision :: gv(ngmx,3),gg(ng),p(3)
  ! Local variables
  integer :: ig,m,jg,PRTG,iprint
  parameter (PRTG=80)
  !      parameter (PRTG=0)
  ! ... External calls
  external dvshel

  do  ig = 1, ng
     gg(ig)= (gv(ig,1)+p(1))**2+(gv(ig,2)+p(2))**2+(gv(ig,3)+p(3))**2
     ! akao Apr2009. Ordering is clealy fixed---without this, ordering can be ambigous when gg is degenerated.
     gg(ig)= gg(ig) *(1d0 + 1d-15*ig)
  enddo

  !     dvshel seems to work a little faster for vectors this size
  call dvshel(1,ng,gg,iwk,1)
  !     call dvheap(1,ng,gg,iwk,0d0,11)

  ! ... Rearrange gv,kv,igv,igv2
  do  20  m = 1, 3
     do  22  ig = 1, ng
        jg = iwk(ig)+1
        gg(ig) = gv(jg,m)
        kk(ig) = kv(jg,m)
22   enddo
     do  24  ig = 1, ng
        gv(ig,m) = gg(ig)
        kv(ig,m) = kk(ig)
24   enddo
     if (ligv) then
        do  25  ig = 1, ng
           jg = iwk(ig)+1
           kk(ig) = igv(jg,m)
25      enddo
        do  26  ig = 1, ng
           gv(ig,m) = gg(ig)
           igv(ig,m) = kk(ig)
26      enddo
     endif
     if (ligv2) then
        do  27  ig = 1, ng
           jg = iwk(ig)+1
           kk(ig) = igv2(m,jg)
27      enddo
        do  28  ig = 1, ng
           gv(ig,m) = gg(ig)
           igv2(m,ig) = kk(ig)
28      enddo
     endif
20 enddo

  if (iprint() >= PRTG) then
     print 333, p
333  format(' gvlist: g vectors after sorting: p=',3f12.6)
     !      do  30  ig = 1, min(ng,50)
     do  30  ig = 1, ng
        gg(ig)=(gv(ig,1)+p(1))**2+(gv(ig,2)+p(2))**2+(gv(ig,3)+p(3))**2
        !        print 550, ig,gv(ig,1)+p(1),gv(ig,2)+p(2),gv(ig,3)+p(3),
        print 550, ig,gv(ig,1),gv(ig,2),gv(ig,3), &
             kv(ig,1),kv(ig,2),kv(ig,3),sqrt(gg(ig))
550     format(i5,3f11.5,3i6,f11.5)
30   enddo
     !     pause
  endif

end subroutine pvglst

subroutine gvgetf(ng,n,kv,k1,k2,k3,c,c0)
  !- Gathers Fourier coefficients from 3D array c into list c0.
  !     implicit none
  integer :: ng,n,k1,k2,k3,kv(ng,3)
  double complex c0(ng,n),c(k1,k2,k3,n)
  integer :: ig,i,j1,j2,j3
  do   i = 1, n
     do   ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        c0(ig,i) = c(j1,j2,j3,i)
     enddo
  enddo
end subroutine gvgetf
subroutine gvgetf_test(ng,n,kv,k1,k2,k3,c,c0)
  !- Gathers Fourier coefficients from 3D array c into list c0.
  !     implicit none
  integer :: ng,n,k1,k2,k3,kv(ng,3)
  double complex c0(ng,n),c(k1,k2,k3,n)
  integer :: ig,i,j1,j2,j3

  do   i = 1, n
     do   ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        !        print *,'vvvvvvvvvvv kv=',j1,j2,j3,i
        c0(ig,i) = c(j1,j2,j3,i)
        !     print *,'vvvvvvvvvvv xxx'
     enddo
  enddo
end subroutine gvgetf_test

subroutine gvputf(ng,n,kv,k1,k2,k3,c0,c)
  !- Pokes Fourier coefficients from gathered list c0 into 3D array c.
  !     implicit none
  integer :: ng,n,k1,k2,k3,kv(ng,3)
  double complex c0(ng,n),c(k1,k2,k3,n)
  integer :: ig,i,j1,j2,j3

  call dpzero(c,2*k1*k2*k3*n)
  do   i = 1, n
     do   ig = 1, ng
        j1 = kv(ig,1)
        j2 = kv(ig,2)
        j3 = kv(ig,3)
        c(j1,j2,j3,i) = c0(ig,i)
     enddo
  enddo
end subroutine gvputf
subroutine gvaddf(ng,kv,k1,k2,k3,c0,c)
  !  Adds Fourier coefficients from gathered list c0 into 3D array c.
  !     implicit none
  integer :: ng,k1,k2,k3,kv(ng,3)
  double complex c0(ng),c(k1,k2,k3)
  integer :: ig,j1,j2,j3
  do  10  ig = 1, ng
     j1 = kv(ig,1)
     j2 = kv(ig,2)
     j3 = kv(ig,3)
     c(j1,j2,j3) = c(j1,j2,j3) + c0(ig)
10 enddo
end subroutine gvaddf

!      subroutine gvlstp(p,ng,gv,sgv)
!C- Adds offset to lattice vectors, and resorts by increasing length
!C ---------------------------------------------------------------
! i Inputs:
! i  gv,ng:  lattice vectors, and number
! i  p:      vector to subtract from gv
! o  sgv:    lattice vectors, sorted by increasing (p-gv)**2
! r Remarks
! r  Shell sorting is apparently faster than heap sorting,
! r  because the starting vectors are approximately sorted already.
!C ---------------------------------------------------------------
!      implicit none
!      integer ng
!      double precision p(3),gv(3,ng),sgv(3,ng)
!      integer ir,oiwk
!      integer w(1)
!      common /w/ w

!      do  10  ir = 1, ng
!   10 sgv(ir,1) =
!     .  (p(1)-gv(1,ir))**2 + (p(2)-gv(2,ir))**2 + (p(3)-gv(3,ir))**2
!      call defi(oiwk, ng*3)
!      call dvshel(1,ng,sgv,w(oiwk),1)
!      call dvperm(3,ng,gv,sgv,w(oiwk),.false.)
!      call rlse(oiwk)

!      end
!      subroutine rx(string)
!      character *(*) string
!      print *, string
!      stop
!      end

