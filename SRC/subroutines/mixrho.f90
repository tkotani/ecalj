module m_mixrho
  use m_lgunit,only:stdo,stml
  integer,parameter,public:: kmxv=15
  public:: mixrho,parms0
  private
  !  mixing routine of smrho, rh. T.kotani think this routine is too compicated to maintain.
  !  It is better to rewrite all with keeping the functionality
contains
  subroutine mixrho(iter, qval,  sv_p_orhnew, sv_p_orhold, smrnew, smrho,rmsdel)
    use m_struc_def
    use m_supot,only: iv_a_okv,rv_a_ogv,k1,k2,k3
    use m_lmfinit,only:lat_alat,nbas,stdl, mixmod=>sstrnmix,ispec,sspec=>v_sspec,nsp
    use m_lattic,only: lat_vol
    use m_supot,only: lat_nabc, lat_ng
    use m_lmfinit, only:   mix_b,mix_bv,mix_w,mix_wc,mix_nsave,mix_mmix
    use m_ext,only:      sname
    !!= Mix old and new charge densities =
    !!  Takao's version: real space mixing of smrho. It works OK. However,
    !!  we may need to fix it so that this is well-defined chi=|rho-f(rho)|**2 minimization mixing.
    !!     Warn. For Co case, I found broyden mixing works wrong.
    !!     ITER    NIT=30 MIX=B3,n=5,b=.7,w=1,0
    !!     However, as in copt, Broyden mixing is efficient.
    !! ----------------------------------------------------------------------
    ! i Inputs
    ! i   ssite : maybe read only
    ! i   sspec :
    ! i   slat  :
    ! i   nsp   :2 for spin-polarized case, otherwise 1
    ! i   iter  :iteration number
    ! i   mixmod:string containing iteration-dependent mixing (parmxp) What this mean???
    ! i   k1,k2,k3 dimensions smrho
    !!
    ! i     qval  :total valence charge, used to estimate Lindhard parameter
    ! i     elind :default Lindhard screening parameter
    !!
    !!--- below is Mark's original documents.
    ! o Inputs/Outputs
    ! o   dmxp  :Default and other values of mixing parameters.
    ! o         :The input defaults may be overridden by the string mixmod.
    ! o         :Inputs (defaults)
    ! o         :(1)  broy  :mixing scheme: 0->Anderson 1->Broyden
    ! o         :(2)  beta  :linear mixing beta: nmix = (1-beta)nin + beta*nout
    ! o         :(3)  wc    :Broyden weights for prior iterations
    ! o         :(4,5) weights for n^+ + n^- and n^+ - n^- in spin pol cases
    ! o                Avg, diff weighted by wt(1) and wt(2) in the mixing.
    ! o                As special cases,
    ! o                wt(2)=0 freezes the moments and mixes the charge only
    ! o                wt(1)=0 freezes the charge and mixes the moments only
    ! o         :(6)  mxsav : maximum number of prior iter to save on disk
    ! o         :(7)  mmix  : maximum number of prior iter to mix
    ! o         :(8)  nkill : kill mixing file after multiples nkill
    ! o         :(9)  betv  : special potential mixing parameter
    ! o         :(10) rmscst: not used here
    ! o         :Outputs
    ! o         :(11) rmsdel : rms (output-input) density
    ! o         :(12) rmsl   : rms (output-input) local density
    ! o         :(13) nmix   : number of prior iter actually mixed
    ! o         :(14) broy   : actual mixing scheme used
    ! o         :(15) beta   : actual mixing beta used
    ! o         :(16-24) tj  : Anderson mixing coefficients
    ! o         :(25)        : (spin polarized case only)
    ! o                      : 1  if weight for n^+ + n^- is nonzero
    ! o                      : 10 if weight for n^+ - n^- is nonzero
    ! o                      : 11 if both nonzero
    !    dmxp for mixing.  Default parameters dmxp:
    !    1(I) mixing scheme; 2 beta; 3 wc; 4,5 wgt; 6(I)nsave 7(I) mmix;
    !    8(I) nkill; 9 betv; 10 rmscst.  11-20 are outputs:
    !    11 rmsdel 12 rms2 13 nmix 14 actual broy 15 actual beta 16-24 tj
    !    25 1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
    !    27..29: hold parms for static parms block regular mixing
    !    30..32: hold parms for static parms block Euler angle mixing
    !    33 : Lindhard screening parameter

    ! o   orhnew:On input, local parts of the density that generated the ham.
    ! o   orhold:local parts of the density that the hamiltonian generated
    ! o         :On output, the mixed density
    ! o   smrho :On input, smooth density that generated the hamiltonian H
    ! o         :On output mixed smooth density
    ! o   smrnew:smooth density generated by the H(rhold,smrho)
    ! o         :DESTROYED on output
    !l Local variables
    !l   locmix :governs linear transformation of local densities for mixing
    !l          :Note see Bugs, below
    !l          :0  This was the only mode in versions 6.11 and earlier.
    !l          :   The smooth part of the density and the spherical part of
    !l          :   the local densities are mixed in an Anderson or Broyden scheme.
    !l          :   In the remaining options,
    !l          :   local densities are rotated into
    !l          :     rho1,rho2 -> w(r)*(rho1+rho2), rho1-rho2
    !l          :   where w(r) is defined in pvmix9, mode controlled by k9.
    !l          :   For now, k9=10.
    !l          :   This has no effect for linear mixing, but affects the
    !l          :   Anderson or Broyden weights in the spherical part.
    !l          :1  Same as locmix=0, but for the transformation
    !l              CAUTION: not tested in a long time
    !l          :2  Local densities are further mapped onto a G_kL expansion.
    !l          :   whose coefficients are included in the Anderson/Broyden
    !l          :   mixing schemes, including the nonspherical densities.
    !l          :   the residual (what is left of rho beyond the G_kL expansion)
    !l          :   is linearly mixed.
    !l              CAUTION: not tested in a long time
    !l          :3  Similar to locmix=2, but l=0 part is of the G_kL expansion
    !l          :   is projected out.
    !l          :
    !l   rms2   : <(rout-rin)**2>, where rin and rout are the input and
    !l          : screened output densities represented as a vector,
    !l          : including smoothed and local parts.  rmsdel changes with
    !l          : the choice of transformation of local densities;see locmix
    !l          : above.
    !l   rmsdel : (linked to dmxp(11)).
    !l          : On input, rmsdel=<(rout-rin)**2>, defined as rms2, above.
    !l          : On output, rmsdel is overwritten by rms2.
    !l   rmsuns : RMS difference in output-input sm. density, unscreened
    !l   rms    : RMS difference in output-input sm. density, screened
    !l   sumo   : integral of smrho
    !l   sums   : integral of screened smoothed output rho
    !l   kmxs   : k-cutoff for G_kL expansion of screening charge projected
    !l          : into local densities; see Remarks
    !l   kmxr   : k-cutoff for G_kL expansion used to smooth local densities
    !l          : for mixing
    !l   ng0    : condensed number of G vectors. That rho(G) is hermitian
    !l          : is exploited to reduce ng to ng0
    !l   qcell  : cell charge
    !b Bugs
    !b   Mixing scheme needs some revision.  For now, uses locmix=3 and k9=10
    !b   Problem: G-kL expansion doesn't represent rim density well; not
    !b          : good for rho1+rho2.
    !b   Better:  1. Use simpler trans: (rho1+rho2)/100 or so, and (rho1-rho2)
    !b            2. For nonspherical parts, mix coefficient to multipole in
    !b               the Anderson/Broyden scheme; linearly mix the rest.
    !r Remarks
    !r   To estimate the self-consistent density a model (Lindhard) dielectric
    !r   function is used.  A smooth "total density" is assembled on a mesh
    !r   from the smooth density + local contributions; the latter are
    !r   smoothed into a G_kL expansion of rho1-rho2 and added to the mesh
    !r   density.  This "mesh total density" is assembled for the input and
    !r   output densities smrho and smrnew, and the screening charge
    !r   (eps^-1 - 1) (smrnew(tot) - smrho(tot)) is obtained using the
    !r   Lindhard approximation for eps^-1.  The screening charge is then:
    !r
    !r     (1)  added to smrnew
    !r
    !r     (2)  added back onto local densities as a G_kL expansion
    !r          to both the true and smooth local mixed densities.
    !r
    !r   Finally, the (screened) output density is mixed with the input density
    !r   using an Anderson or Broyden mixing scheme.  Both mesh part and local
    !r   parts are mixed, the latter consists of the true, smooth,
    !r   and core parts.
    !r   How the mixing proceeds depends on locmix; see Local variables above.
    !r
    !r   The steps in this routine follow this path (see numbers in comments)
    !r   1.   smooth rho+,rho-  ->  smrho, smmag
    !r   2.   FT smrnew(r)-smrho(r) -> cn = smrho(G)
    !r   3.   rho1-rho2 -> smoothed, FT; added to smrho(G)
    !r   4.   cn = screening (eps^-1 - 1) smrho(G)
    !r   5.   Add screening to smrnew; smrnew(G) -> smrnew(r)
    !r   6.   smrnew = sm. screened nout, smrho,smrnew -> smooth rho+,rho-
    !r        At this stage, smrho = input smooth rho+,rho-
    !r                       smrnew = screened output rho+,rho-
    !r   7.   Add screening to rho1, rho2; scale if locmix > 0
    !r   8.   smrho,smrnew(r) -> smrho,smrnew(G)
    !r   9.   Pack in,out densities into large matrix a;
    !r        Read prior iterations into a
    !r   10.  Linear mixing of local densities
    !r   11.  Make modified a when wt(1) or wt(2) restricts q or spin
    !r   12.  Mix input, output densities
    !r   13.  Inverse of step 11.
    !r   14.  Poke contents of a into smrho,orhold
    !r   15.  Undo scaling of local rho (step 7)
    !r
    !m MPI
    !m   master process handles the mix files and broadcasts. All processes
    !m   then mix.
    !u Updates
    !u   18 Dec 08 properly treats constrained cases w=1,0 and w=0,1
    !u   30 Jun 06 Bug fix (memory leak)
    !u   15 Feb 02 (ATP) Added MPI parallelization
    !u   21 Nov 01 Linear transformation of local densities for mixing.
    !u             New modes locmix.
    !u   23 Oct 01 Local densities used for screening charge are more
    !r             accurately represented in G_kL expansion, k=0..kmxs
    !u   19 Oct 01 correctly uses elind override from mixing string
    !u   22 Mar 01 Bug fix for case mixing string is empty
    !u   22 Jun 00 spin polarized
    !u   30 May 00 Adapted from nfp mix_rho
    ! ----------------------------------------------------------------------
    implicit none
    real(8),save::  dmxp(25)

    include "mpif.h"
    integer :: numprocs, ierr, status(MPI_STATUS_SIZE)
    integer :: MAX_PROCS
    parameter (MAX_PROCS = 100)
    integer :: resultlen
    character*(MPI_MAX_PROCESSOR_NAME) name
    character(10) :: shortname(0:MAX_PROCS-1)
    character(20) :: ext
    character(26) :: datim
    integer :: namelen(0:MAX_PROCS-1)
    double precision :: starttime, endtime
    integer :: iunit
    character(120) :: strn
    logical :: mlog,cmdopt
    integer::  iter , procid , master
    type(s_rv1) :: sv_p_orhold(3,1)
    type(s_rv1) :: sv_p_orhnew(3,1)
    !      character*(*) mixmod
    !      type(s_site)::ssite(*)
    !      type(s_spec)::sspec(*)
    !      type(s_lat)::slat

    double precision :: qval,elind=0d0
    double complex smrnew(k1,k2,k3,nsp),smrho(k1,k2,k3,nsp)
    ! ... Local parameters
    integer :: i,i1,i2,i3,ib,ipl,ipr,is,k0,k9, &
         lmxl,n1,n2,n3,ng,nglob,nlml,nr,nmixr,nmix,nda,mxsav,ifi,nlm0, &
         kkk,nnnew,nnmix,ngabc(3),igetss,broy,nx, &
         nkill,isw,naa,kmxr,kmxs,locmix,offx,off2
    integer:: ng0 !,  oa , oaa !, ocn ,owk , oqkl
    integer ,allocatable :: ips0_iv(:)
    real(8),allocatable :: co_rv(:)
    complex(8) ,allocatable :: cg1_zv(:)
    complex(8) ,allocatable :: cg2_zv(:)
    complex(8) ,allocatable :: fkl_zv(:)
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    real(8) ,allocatable :: wk1_rv(:)
    real(8) ,allocatable :: wk2_rv(:)

    equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
    parameter (nlm0=49)
    double precision :: a,beta0,beta,dif,difx,difxu,fac,rms,rmt, &
         sumo,summ,sums,top,vol,alat,tpiba,pi,dquns,rmsuns,ddot,q1, &
         qin(2),qout(2),qscr(2),qmix(2),qcell,rms2,rms2f,wc,rsmv,qmx, &
         dgets,wt(3),rmsdel,elinl,srfpi,xx
    double complex xxc
    !      logical parmxp
    character sout*80,fnam*8
    integer ::iwdummy ,isp,nnnx,ng02,ng2, iprint,ifile_handle
    real(8):: smmin,sss,wgtsmooth,wdummy(1,1,1,1)
    complex(8),allocatable:: smrnewbk(:,:,:,:),w_owk(:)
    !      complex(8),allocatable:: w_oqkl(:)
    real(8),allocatable:: w_oqkl(:)
    real(8),allocatable:: w_oa(:),w_oaa(:)
    real(8),allocatable:: w_ocn(:)
    logical::       noelind
    logical:: mixrealsmooth
    logical:: init=.true., initd=.true.
    call tcn('mixrho')
    if (mixmod == 'none') return
    !  Initial setup for mixrho (charge mixing). This is used in mixrho-parmax.
    if(initd) then
       dmxp   = 0d0
       dmxp(2) = mix_b
       dmxp(3) = mix_wc
       dmxp(4:5)= mix_w(1:2)
       dmxp(6) = mix_nsave
       dmxp(7) = mix_mmix
       dmxp(9) = mix_bv
       call parms0(0,0,0d0,0) !reset mixing block
       initd=.false.
    endif

    nnnew=0
    !      open(1898,file='test2vvv_smrho')
    do  i3 = 1, k3
       do  i2 = 1, k2
          do  i1 = 1, k1
             if (sum(dreal(smrho(i1,i2,i3,1:nsp))) < 0) nnnew = nnnew+1
             !        if( (i1==1.and.i2==1).or.
             !     &      (i3==1.and.i2==1).or.
             !     &      (i1==1.and.i3==1) ) then
             !        write(1898,"(3i5,2d13.5)")i1,i2,i3,smrho(i1,i2,i3,1)
             !        endif
          enddo
       enddo
    enddo
    !      close(1898)
    !      print *,'vvv'
    !      print *,'mixrho: sum smrho  init =',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
    !      write(6,"(a,3d13.6,i8)")' mixrho: sum smrho  init =',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
    !---
    nnnew=0
    !      open(1898,file='test2vvv_smrnew')
    do  i3 = 1, k3
       do  i2 = 1, k2
          do  i1 = 1, k1
             if (sum(dreal(smrnew(i1,i2,i3,1:nsp))) < 0) nnnew = nnnew+1
             !        if( (i1==1.and.i2==1).or.
             !     &      (i3==1.and.i2==1).or.
             !     &      (i1==1.and.i3==1) ) then
             !          write(1898,"(3i5,2d13.5)")i1,i2,i3,smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1)
             !        endif
          enddo
       enddo
    enddo
    !      close(1898)
    !      print *,'mixrho: sum smrnew new  =',sum(smrnew(:,:,:,1)),sum(abs(smrnew(:,:,:,1))),nnnew
    !      write(6,"(a,3d13.6,i8)")' mixrho: sum smrnew new  =',sum(smrnew(:,:,:,1)),sum(abs(smrnew(:,:,:,1))),nnnew
    ! ccccccccccccccccccccccccccccccccccc


    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr )
    call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr )
    call MPI_GET_PROCESSOR_NAME(name, resultlen, ierr)
    call strcop(shortname(procid),name,10,'.',i)
    namelen(procid) = i-1
    master = 0
    mlog = cmdopt('--mlog',6,0,strn)

    !      nbas = globalvariables%nbas
    !      stdo = globalvariables%stdo
    !      stdl = globalvariables%stdl
    call getpr(ipr)
    ipl = 1
    nx = 0
    kkk = k1*k2*k3
    pi = 4d0*datan(1d0)
    srfpi = dsqrt(4d0*pi)
    locmix = 3 !original lmv7 by mark.
    qmix(2) = 0
    ngabc=lat_nabc
    ng=lat_ng
    vol=lat_vol
    alat = lat_alat
    elinl = elind
    kmxs = 3
    kmxr = 8

    ! --- Iteration-dependent mixing parameters ---
    broy  = dmxp(1)
    beta  = dmxp(2)
    wc    = dmxp(3)
    wt(1) = dmxp(4)
    wt(2) = dmxp(5)
    wt(3) = dmxp(4)
    !     Flags parmxp that there are no extra elements to mix
    if (nx == 0) wt(3) = -9
    mxsav = nint(dmxp(6))
    nmix  = nint(dmxp(7))
    nkill = nint(dmxp(8))
    fnam  = 'mixm'
    rmsdel = dmxp(11)
    rms2 = 0
    if (ipr >= 20) write(stdo,*) ' '
    if ( .NOT. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,elinl, &
         fnam,wc,nkill,dmxp(9),rms2)) call rx( &
         'MIXRHO: parse in parmxp failed')

    !     In case parmxp doesn't touch wt, unset flag
    if (wt(3) == -9) wt(3) = 0
    if (nmix == 0) broy = 0
    ! ... Initial printout
    !      call awrit7(' Mix density with beta=%;4d'//
    !     .  '%?;n;, Lindhard E=%;3d;;'//
    !     .  '%?;(n==1);, Broyden scheme using n=%,1i;%j;'//
    !     .  '%?;(n==0);, Anderson scheme using n=%,1i;%j;',
    !     .  ' ',80,stdo,beta,isw(elinl.ne.0),elinl,broy,nmix,
    !     .  broy,nmix)
    !      call rx('done')

    ! ... Interactively reset mix-parms block
    i1 = 0
    i2 = 0
    !      call query('mix-parms-block',2,i1)
    !      call query('block-iter',2,i2)
    if (i1 > 0 .OR. i2 > 0) then
       if (i2 <= 0) i2 = 1
       call parmx0(i1,i2,0d0)
       if ( .NOT. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta, &
            elinl,fnam,wc,nkill,dmxp(9),rms2))call rx( &
            'MIXRHO: parse in parmxp failed')
    endif

    if (nsp == 1) wt(2) = 0
    if (wt(1)**2+wt(2)**2+wt(3)**2 == 0) &
         call fexit(-1,111,' Exit -1 MIXRHO: '// &
         'bad mixing weights w =%3:1;6d',wt)
    call dscal(3,1/dsqrt(wt(1)**2+wt(2)**2+wt(3)**2),wt,1)

    !      wt(1) = 1 ; wt(2) = 1; print * , '!! wt=', wt(1:2)

    if (nmix < 0) nmix = mxsav
    if (elinl < 0d0) elinl = -(3*pi**2*qval/vol)**.66666d0*elinl
    if (elinl < .01d0) elinl = 0

    ! ... Initial charges
    call rhoqm(smrho,k1,k2,k3,n1,n2,n3,nsp,vol,qin)
    call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qout)


    !!== difference in smooth part ==
    !      write(6,"(a,3d13.5)") ' mixrho: dqsum rmsuns='
    !     &  , dreal(sum((smrnew-smrho)/(n1*n2*n3)))
    !     &  , sqrt( sum((smrnew-smrho)**2)/(n1*n2*n3) )
    fac = vol/(n1*n2*n3)

    !!== RMS differences screened and input sm density; count neg points ==
    sumo = sum(dble(smrho))
    sums = sum(dble(smrnew))
    summ = 0d0
    top = 0d0
    rms = 0d0
    nnnew = 0
    nnmix = 0
    do  i3 = 1, n3
       do  i2 = 1, n2
          do  i1 = 1, n1
             dif = dble(sum(smrnew(i1,i2,i3,1:nsp))-sum(smrho(i1,i2,i3,1:nsp)))
             rms = rms + dif*dif
             top = dmax1(top,dabs(dif))
             xxc = beta*sum(smrnew(i1,i2,i3,1:nsp)) + (1d0-beta)*sum(smrho(i1,i2,i3,1:nsp))
             if( sum(dble(smrnew(i1,i2,i3,1:nsp))) < 0) nnnew = nnnew+1
             if( dble(xxc) < 0) nnmix = nnmix+1
             summ = summ + dble(xxc)
          enddo
       enddo
    enddo
    rms = dsqrt(fac*rms/vol)
    !!     Defer printout until after file read prior iterations; see '100' below


    !!== elind mode ==
    ! if(noelind()) then
    !    !        allocate(w_ocn(2*ng))
    !    !        w_ocn=0d0
    ! else
    !    ! --- Screen sm output rho; distribute screening rho over local rho ---
    !    ! ... 1. Overwrite smrho+, smrho- with smrho, smrho+ - smrho-
    !    if (nsp == 2) then
    !       call dsumdf(kkk*2,1d0,smrho,0,1,smrho(1,1,1,2),0,1)
    !       call dsumdf(kkk*2,1d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
    !    endif
    !    ! ... <smrout-smrhoin> and <(smrout-smrhoin)**2>, unscreened smrout
    !    dquns = 0
    !    rmsuns = 0
    !    do isp=1,nsp
    !       do   i3 = 1, n3
    !          do   i2 = 1, n2
    !             do   i1 = 1, n1
    !                dquns  = dquns  + dble(smrnew(i1,i2,i3,isp)-smrho(i1,i2,i3,isp))
    !                rmsuns = rmsuns + dble(smrnew(i1,i2,i3,isp)-smrho(i1,i2,i3,isp))**2
    !             enddo
    !          enddo
    !       enddo
    !    enddo
    !    rmsuns = dsqrt(rmsuns/(n1*n2*n3))
    !    ! ... 2. cn <- (smrnew - smrho)(G)
    !    allocate(w_ocn(2*ng),w_owk(kkk))
    !    call dcopy(kkk*2,smrnew,1,w_owk,1)
    !    !        call dpadd(w_owk,smrho,1,kkk*2,-1d0)
    !    call daxpy(kkk*2,-1d0,smrho,1,w_owk,1)
    !    call fftz3(w_owk,n1,n2,n3,k1,k2,k3,1,0,-1)
    !    call gvgetf ( ng , 1 , iv_a_okv , k1 , k2 , k3 , w_owk , &
    !         w_ocn )
    !    deallocate(w_owk)
    !    ! ... 3. Sum of local densities on Fourier mesh (up+down)
    !    allocate(cg1_zv(ng))
    !    allocate(cg2_zv(ng))
    !    cg1_zv=0d0
    !    cg2_zv=0d0
    !    call rhgcmp ( 131 , 1 , nbas , ssite , sspec ,  sv_p_orhold , kmxs , ng , cg1_zv )
    !    call rhgcmp ( 131 , 1 , nbas , ssite , sspec ,  sv_p_orhnew , kmxs , ng , cg2_zv )
    !    !     call gvputf(ng,1,w(okv),k1,k2,k3,w(ocg1),smrnew)
    !    !     call fftz3(smrnew,n1,n2,n3,k1,k2,k3,1,0,1)
    !    !     call zprm3('input local densities (r)',0,smrnew,k1,k2,k3)

    !    ! ... Add output-input difference in gaussian rho to make total rho
    !    call daxpy ( 2 * ng ,   1d0 , cg2_zv , 1 , w_ocn , 1 )
    !    call daxpy ( 2 * ng , - 1d0 , cg1_zv , 1 , w_ocn , 1 )
    !    deallocate(cg1_zv,cg2_zv)

    !    ! ... 4. Make cn = screening charge = (eps^-1 - 1) (n_out - n_in)
    !    tpiba = 2*pi/alat
    !    call lindsc ( 2 , ng , rv_a_ogv , tpiba , elinl , w_ocn )
    !    ! ... 5. Add cn = screening charge into smrnew
    !    !      call defcc(owk,kkk)
    !    allocate(w_owk(kkk))
    !    call gvputf ( ng , 1 , iv_a_okv , k1 , k2 , k3 , w_ocn , w_owk )
    !    call fftz3(w_owk,n1,n2,n3,k1,k2,k3,1,0,1)
    !    call daxpy(kkk*2,1d0,w_owk,1,smrnew,1)
    !    deallocate(w_owk)
    !    ! ... 6. Restore smrho+, smrho-
    !    if (nsp == 2) then
    !       call dsumdf(kkk*2,.5d0,smrho,0,1,smrho(1,1,1,2),0,1)
    !       call dsumdf(kkk*2,.5d0,smrnew,0,1,smrnew(1,1,1,2),0,1)
    !    endif
    ! endif
!    if( .NOT. noelind()) then
!       ! --- 7. Project cn = screening density into local densities ---
!       k0 = 20
!       allocate(fkl_zv((k0+1)*nlm0*nbas))
!       call ftlxp ( nbas , ssite , sspec , alat , ng , rv_a_ogv , &
!            w_ocn , k0 , nlm0 , fkl_zv)
!    endif
    do  ib = 1, nbas
       is = ispec(ib) !int(ssite(ib)%spec)
       a   =sspec(is)%a
       nr  =sspec(is)%nr
       rmt =sspec(is)%rmt
       lmxl=sspec(is)%lmxl
       rsmv=sspec(is)%rsmv
       !kmxv=sspec(is)%kmxv
       if (lmxl < 0) cycle

       nlml = (lmxl+1)**2
       if (nlml > nlm0) call rxi('mixrho: nlml > nlm0, need',nlml)
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh ( rmt , a , nr , rofi_rv)
       call radwgt ( rmt , a , nr , rwgt_rv)

       ! if( .NOT. noelind()) then
       !    !       Overwrite rho+, rho- with rho, rho+ - rho-
       !    call splrho ( 0 , nsp , nr , nlml , sv_p_orhnew( 1 , ib )%v , &
       !         sv_p_orhnew( 2 , ib )%v , sv_p_orhnew( 3 , ib )%v )
       !    !   ... Add site-projected screening density to rhn1,rhn2
       !    call pkl2ro ( 110 , ib , rsmv , kmxv , nr , nlml , 1 , rofi_rv &
       !         , rwgt_rv , k0 , nlm0 , fkl_zv , wdummy , sv_p_orhnew ( 1 , &
       !         ib ) %v , sv_p_orhnew ( 2 , ib ) %v , qmx )
       !    !       Restore rho+, rho-
       !    call splrho ( 1 , nsp , nr , nlml , sv_p_orhnew( 1 , ib )%v , &
       !         sv_p_orhnew( 2 , ib )%v , sv_p_orhnew( 3 , ib )%v )
       ! endif

       !   ...  Always work with rho1+rho2, rho1-rho2
       !        print *, 'ib=',ib
       !        call prrmsh('rhold1',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
       !        call prrmsh('rhold2',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

       call pvmix9 ( 1 , 0 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , sv_p_orhold( 1 , ib )%v &
            , sv_p_orhold( 2 , ib )%v )
       call pvmix9 ( 1 , 0 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , sv_p_orhnew( 1 , ib )%v &
            , sv_p_orhnew( 2 , ib )%v )
       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(rofi_rv)) deallocate(rofi_rv)

    enddo                     ! Loop over sites
    if (allocated(fkl_zv)) deallocate(fkl_zv)
    if(allocated(w_ocn)) deallocate(w_ocn)


    ! --- Fancy mixing of smoothed + some representation of local rho ---
    ! ... Count number of elts from local densities for fancy mixing scheme
    nda = 0
    do  ib = 1, nbas
       is = ispec(ib)!int(ssite(ib)%spec)
       nr = sspec(is)%nr
       lmxl = sspec(is)%lmxl
       nlml = (lmxl+1)**2
       if (lmxl == -1) goto 20
       !       include spherical part of local densities only
       if (locmix <= 1) then
          nda = nda + 2*nr
          !       also include nonspherical part, G_kL expansion
       elseif (locmix >= 2) then
          nda = nda + 2*(kmxr+1)*nlml
          !         and spherical part of rho1-rho2
          if (locmix == 3) nda = nda + 2*nr
       else
          call rxi('bad locmix,',locmix)
       endif
20     continue
    enddo

    if(mixrealsmooth()) then
       ng02 = k1*k2*k3
       ng2 = ng02
       nda = nda + ng02
       allocate(w_ocn(ng02*nsp),co_rv(ng02*nsp))
       call dcopy(ng02*nsp,dreal(smrnew), 1, w_ocn,1)
       call dcopy(ng02*nsp,dreal(smrho),  1, co_rv,1)
       ! cccccccccccccccccccccc
       wgtsmooth=1d0/ng02**0.5d0 !try this relative weight. Not correct weight charge mixing.
       if(iprint()>10) print *,'wgtsmooth=',wgtsmooth
       ! cccccccccccccccccccccc
       w_ocn= w_ocn*wgtsmooth !
       co_rv= co_rv*wgtsmooth !
    else
       ! ... 8. FFT smooth densities -> rho(G) for mixing
       ! ... Find and include number of smooth mesh points.
       allocate(ips0_iv(ng))
       call lgstar ( 0 , ng , 1 , rv_a_ogv , ng0 , ips0_iv , iwdummy )
       ng02= ng0*2
       ng2=ng*2
       nda = nda + ng02
       allocate(w_ocn(2*ng*nsp),co_rv(ng*2*nsp))
       allocate(w_owk(kkk*nsp))
       call dpcopy(smrnew,w_owk,1,kkk*2*nsp,1d0)
       call fftz3(w_owk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
       call gvgetf ( ng , nsp , iv_a_okv , k1 , k2 , k3 , w_owk, w_ocn)
       call lgstar ( 1 , ng , nsp , rv_a_ogv , i , ips0_iv , w_ocn)
       call dpcopy(smrho,w_owk,1,kkk*2*nsp,1d0)
       call fftz3(w_owk,n1,n2,n3,k1,k2,k3,nsp,0,-1)
       call gvgetf ( ng , nsp , iv_a_okv , k1 , k2 , k3 , w_owk, co_rv)
       call lgstar ( 1 , ng , nsp , rv_a_ogv , i , ips0_iv , co_rv)
       deallocate(w_owk)
    endif




    !      call defrr(oa,-nda*nsp*(mxsav+2)*2)
    allocate(w_oa(nda*nsp*(mxsav+2)*2))
    w_oa=0d0

    ! ... Allocate memory for coffs to G_kL expansion of rho
    !      oqkl = 1
    !      if (locmix .ge. 2) call defcc(oqkl,-(kmxr+1)*nlm0*nsp*4*nbas)
    if(locmix >= 2) then
       allocate(w_oqkl(2*(kmxr+1)*nlm0*nsp*4*nbas))
       w_oqkl=0d0
    else
       allocate(w_oqkl(1))
    endif


    ! --- 9. Read prior iterations from disk; update with current iter ---
    if (procid == master) then
       ifi=ifile_handle()
       open(ifi,file=trim(fnam)//'.'//trim(sname),form='unformatted')
       !        ifi = fopna(fnam,-1,4)
       !        rewind ifi
    endif
    call MPI_BCAST(ifi,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
    if (mlog) then
       call gettime(datim)
       call awrit3(' mixrho '//datim//' Process %i of %i on ' &
            //shortname(procid)(1:namelen(procid))// &
            ' bcast ifi = %i',' ',256,stml,procid,numprocs,ifi)
    endif
    !     NB: For now, nx must be zero
    k9 = 10
    call pvmix5 ( nmix , mxsav , fnam , ifi , .true. , rmsdel , locmix &
         , k9 , nbas , kmxr , nlm0 ,  nsp , sv_p_orhold &
         , sv_p_orhnew , co_rv , w_ocn , ng2 , ng02 , (/0/) , nda , w_oa , w_oqkl &
         , rms2 , nmixr )
    rmsdel = rms2
    nmix = min(nmix,nmixr)
    ! ... Write this and prior iterations onto disk
    call pvmix5 ( nmix , mxsav , fnam , - ifi , .true. , rmsdel , &
         locmix , k9 , nbas , kmxr , nlm0 ,   nsp , sv_p_orhold &
         , sv_p_orhnew , co_rv , w_ocn , ng , ng02 , (/0/) , nda , w_oa , w_oqkl &
         , rms2 , nmixr )
    if (nkill < 0) then
       if(ipr>=20) then
          sout = ' ...  deleting file '//fnam
          write(stdo,"(a,i5)") trim(sout)//" nkill=",nkill
       endif
       close(ifi,status='delete')
    else
       close(ifi)
    endif

    ! --- Printout smooth density mixing data ---
    if (nnnew+nnmix > 0 .AND. ipr >= 20) call awrit2( &
         ' mixrho: (warning) scr. and lin-mixed densities had'// &
         ' %i and %i negative points',' ',80,stdo,nnnew,nnmix)
    call rhoqm(smrnew,k1,k2,k3,n1,n2,n3,nsp,vol,qscr)
    !     if (ipr .gt. 30) write(stdo,100)
    !    .  sumo*fac,sumu*fac,sums*fac,rms,summ*fac
    if (ipr >45) then
       write(stdo,100) &
            qin(1),qout(1),qscr(1),rms,beta*qscr(1)+(1-beta)*qin(1)
       if (nsp == 2) write(stdo,101) &
            qin(2),qout(2),beta*qscr(2)+(1-beta)*qin(2)
    endif
100 format(' charges:',7x,'old',11x,'new',9x,'screened', &
         6x,'rms diff',7x,'lin mix'/' smooth ',5f14.6)
101 format(' mmom   ',2f14.6,28x,f14.6)

    ! --- 10. Linear mixing of local densities  ---
    call pvmix3 ( nbas , nsp , beta , locmix , wt &
         , kmxr , nlm0 , k9 , w_oqkl , sv_p_orhold , sv_p_orhnew , difx &
         )
    difxu = difx




    !!== Main Mixing part ==
    !!=== 11. Spin polarized case: separate weighting for spin channels ===
    if (nsp == 2 .OR. nx > 0) then
       if (wt(2) /= 0 .AND. nsp == 1) &
            call rx1('mixrho wt(2)=%d invalid when nsp=1',wt(2))
       !       Map to ASA call:
       !             dim. of a     extra    #-mix   #-elts/spin  dim of aa
       !       ASA    nda           nx      naa      npq            naa
       !       FP     nda*nsp       0       naa      nda            naa
       if (nx > 0) call rx('mixrho not ready for nx=0')
       naa = 0
       if (wt(1) /= 0) naa = naa+nda
       if (wt(2) /= 0) naa = naa+nda
       if (wt(3) /= 0) naa = naa+nx
       offx = 0                !offset to extra elements (none now)
       off2 = (nsp-1)*nda      !offset to spin down part of a
       !        call defdr(oaa,-naa*(mxsav+2)*2)
       allocate(w_oaa(naa*(mxsav+2)*2))
       w_oaa=0d0
       call pqsclf(0,nda*nsp,nda,offx,off2,nx,naa,mxsav,wt, &
            w_oa,w_oaa,rms2f)
       if (wt(1)*wt(2) /= 0) then
          !          rms2f = rms2f * 2
       else
          call info2(20,0,0,' Constrained spin mixing, wt =%2:1;5d.'// &
               '  Constrained rms DQ=%1,3;3e',wt,rms2f)
          rmsdel = rms2f
       endif
       !!=== 12. Mix the soup of densities ===
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oaa)
       !!=== 13. Restore matrix a to rho+, rho===
       !       if (nsp .eq. 2 .or. nx .gt. 0) then
       call pqsclb(nda*nsp,nda,offx,off2,nx,naa,mxsav,wt,w_oa,w_oaa)
       call pqsclc(nda*nsp,nda*nsp,nx,mxsav,w_oa)
       !       call rlse(oaa)
       deallocate(w_oaa)
       !       endif
    else
       !        oaa = oa
       naa = nda
       !!=== 12. Mix the soup of densities ===
       beta0 = beta
       call pvmix6(broy,nmix,nmixr,mxsav,beta,wc,naa,w_oa)
    endif
    ! ... 14. Poke mixed smooth and local densities into smrho,rhoold
    !      call defcc(owk,kkk)
    allocate(w_owk(kkk))
    call pvmix7 (   nbas , nsp , nda , w_oa , n1 , &
         n2 , n3 , k1 , k2 , k3 , locmix , wt , k9 , kmxr , nlm0 , w_oqkl &
         , ng , ng2, ng02 , iv_a_okv , ips0_iv , rv_a_ogv , co_rv , w_owk , &
         sv_p_orhold , smrho, wgtsmooth )
    deallocate(w_oqkl)
    deallocate(w_owk,w_oa)
    if (allocated(co_rv)) deallocate(co_rv)
    deallocate(w_ocn)
    if (allocated(ips0_iv)) deallocate(ips0_iv)
    ! ... 15. Restore local densities: rho+ +/- rho-  -> rho+, rho-'
    call dpzero(qmix,2)
    do  ib = 1, nbas
       is = ispec(ib)!int(ssite(ib)%spec)

       a=sspec(is)%a
       nr=sspec(is)%nr
       rmt=sspec(is)%rmt

       lmxl=sspec(is)%lmxl
       rsmv=sspec(is)%rsmv

       if (lmxl < 0) cycle
       nlml = (lmxl+1)**2
       if (nlml > nlm0) call rxi('mixrho: nlml > nlm0, need',nlml)
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh ( rmt , a , nr , rofi_rv)
       call radwgt ( rmt , a , nr , rwgt_rv)

       call pvmix9 ( 1 , - 1 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , &
            sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


       call pvmix9 ( 1 , - 1 , nr , nlml * nsp , 0 , 0d0 , rofi_rv , &
            sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )

       !       debugging
       !        print *, 'ib=',ib
       !        call prrmsh('1 final',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
       !        call prrmsh('2 final',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

       !   ... Add net local charge to qmix
       do  i = 1, nsp
          off2 = 1 + nr*nlml*(i-1)
          allocate(wk1_rv(nr))
          allocate(wk2_rv(nr))
          call dpscop ( sv_p_orhold( 1 , ib )%v , wk1_rv , nr , off2 , &
               1 , 1d0 )


          call dpscop ( sv_p_orhold( 2 , ib )%v , wk2_rv , nr , off2 , &
               1 , 1d0 )


          qmx = srfpi * ( ddot ( nr , wk1_rv , 1 , rwgt_rv , 1) &
               - ddot ( nr , wk2_rv , 1 , rwgt_rv , 1))

          !         print *, 'spin, qmx',i,qmx
          if (i == 2) qmix(2) = qmix(2) + qmx-q1
          q1 = qmx
          qmix(1) = qmix(1) + qmx
          if (allocated(wk2_rv)) deallocate(wk2_rv)
          if (allocated(wk1_rv)) deallocate(wk1_rv)

       enddo

       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(rofi_rv)) deallocate(rofi_rv)

    enddo                     !Loop over sites

    ! ... Force density positive
    !     call rhopos(smrho,k1,k2,k3,n1,n2,n3)

    ! ... Net interstitial charge and cell charge
    summ = 0
    do    i = 1, nsp
       do    i3 = 1, n3
          do    i2 = 1, n2
             do    i1 = 1, n1
                !       smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + .001
                summ = summ + dble(smrho(i1,i2,i3,i))
             enddo
          enddo
       enddo
    enddo
    !     Net system charge
    qcell  = qval - summ*fac - qmix(1)

    !     Add constant to smrho to force charge neutrality
    xx = qcell/(vol*nsp)
    summ = 0

    ! cccccccccccccccccccccccc
    if(iprint()>10) write(6,"(a,d13.5,d13.5)")' mixrho: add corrections to qcell smrho =',qcell,xx
    !       print *,'vvv no xx test'
    !       xx=0d0
    ! ccccccccccccccccccccccc
    do    i  = 1, nsp
       do    i3 = 1, n3
          do    i2 = 1, n2
             do    i1 = 1, n1
                smrho(i1,i2,i3,i) = smrho(i1,i2,i3,i) + xx
             enddo
          enddo
       enddo
    enddo
    !       summ = summ + dble(smrho(i1,i2,i3,i))
    !     qcell  = qval - summ*fac - qmix(1)
    !     print *, 'qcell after shift',qcell; stop

    ! --- Clean up ---
    if (nmix < 0) dmxp(7) = -nmix
    if (beta0 /= beta) dmxp(2) = beta
    dmxp(11) = rmsdel
    dmxp(12) = difx
    dmxp(13) = iabs(nmix)
    dmxp(14) = broy
    dmxp(15) = beta
    if (broy == 1) dmxp(15) = 1
    dmxp(25) = 0
    if (wt(1) /= 0 .OR. wt(2) /= 0) dmxp(25) = 1
    if (wt(3) /= 0) dmxp(25) = dmxp(25) + 10

    ! ... Printout
    if (ipr >= 10 .AND. abs(qcell) > 1d-6) write(stdo, &
         '('' add q='',f10.6,'' to preserve neutrality'')') qcell

    if (ipr >= 30) then
       if (elinl /= 0) then
          write(stdo,450) ' unscreened ',rmsuns,difxu
          write(stdo,450) '   screened ',rms,difx,rmsdel
450       format(a,'rms difference:  smooth',f10.6,'   local',f10.6: &
               '   tot',f10.6)
       endif
    elseif (ipr >= 20) then
       call awrit3(' rms smooth dq=%;3g  max local dq=%;3g  dq=%;3g', &
            ' ',80,stdo,rms,difx,rmsdel)
    endif
    if (ipl > 0 .AND. ipr > 0) then
       call awrit6('%xfp %?;n;elind %;4g  ;%j;'// &
            '%?#(n==1)#Broyden n %1i wc %;3g#%2j#%-3j'// &
            '%?#(n==0)#Anderson n %i beta %j%;3g#%3j#', &
            sout,80,0,isw(elinl.ne.0),elinl,broy,nmix,wc,beta)
       call awrit3('%a  sm-dq %;3g  mx loc %;3g  dq %;3g',sout,80, &
            -stdl,rms,difx,rmsdel)
    endif

    !      call zprm3('exit sm rho, spin1',0,smrho(1,1,1,1),k1,k2,k3)
    !      call zprm3('exit sm rho, spin2',0,smrho(1,1,1,2),k1,k2,k3)

    call tcx('mixrho')
    !     print *, '!!' ; call poppr
    !     stop 'for now'
    nnnew = 0
    nnmix = 0
    do  i3 = 1, n3
       do  i2 = 1, n2
          do  i1 = 1, n1
             sumo = sumo + dble(smrho(i1,i2,i3,1))
             sums = sums + dble(smrnew(i1,i2,i3,1))
             dif = dble(smrnew(i1,i2,i3,1)-smrho(i1,i2,i3,1))
             rms = rms + dif*dif
             top = dmax1(top,dabs(dif))
             xxc = beta*smrnew(i1,i2,i3,1) + (1d0-beta)*smrho(i1,i2,i3,1)
             if (dble(smrnew(i1,i2,i3,1)) < 0) nnnew = nnnew+1
             if (dble(xxc) < 0) nnmix = nnmix+1
             !       smrho(i1,i2,i3) = xxc
             summ = summ + dble(xxc)
          enddo
       enddo
    enddo

    ! cccccccccccccccccccccccccccccccccc
    do isp=1,nsp
       nnnx = 0
       smmin=1d0
       do i1=1,k1
          do i2=1,k2
             do i3=1,k3
                !         print *,i1,i2,i3,isp
                !         print *,i1,i2,i3,isp,smrho(i1,i2,i3,isp)
                sss=dreal(smrho(i1,i2,i3,isp))
                if(sss<0d0) then
                   nnnx=nnnx+1
                   if(sss<smmin) then
                      smmin=sss
                   endif
                   !            smrho(i1,i2,i3,isp)=minimumrho
                endif
             enddo
          enddo
       enddo
       if(nnnx>0) then
          write(6,"(a,2i8,d13.5)") ' mixrho: warning. negative smrho; isp number min=',isp,nnnx,smmin
          !          print *,'enforce smrho >',minimumrho
       else
          if(iprint()>45) write(6,"(a,i3)") ' mixrho: all smrho are positive for isp=',isp
       endif
    enddo
    !$$$      nnnew=0
    !$$$c      open(1898,file='test3vvv')
    !$$$      do  i3 = 1, k3
    !$$$        do  i2 = 1, k2
    !$$$          do  i1 = 1, k1
    !$$$c        write(1898,"(3i5,2d13.5)")i1,i2,i3,smrho(i1,i2,i3,1)
    !$$$            if (dreal(smrho(i1,i2,i3,1)) .lt. 0) nnnew = nnnew+1
    !$$$          enddo
    !$$$        enddo
    !$$$      enddo
    !$$$c      close(1898)
    !$$$c      print *,'mixrho: sum smrho output=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
    !$$$      write(6,"(a,3d13.6,i8)")
    !$$$    & ' mixrho: sum smrho output=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
    !      nnnew=0
    !      do  i3 = 1, k3
    !      do  i2 = 1, k2
    !      do  i1 = 1, k1
    !        if(dreal(smrho(i1,i2,i3,1))<1d-10) smrho(i1,i2,i3,1)=1d-10
    !        if (dreal(smrho(i1,i2,i3,1)) .lt. 0) nnnew = nnnew+1
    !      enddo
    !      enddo
    !      enddo
    !      print *,'vvv mixrho sum smrho output 222=',sum(smrho(:,:,:,1)),sum(abs(smrho(:,:,:,1))),nnnew
    ! ccccccccccccccccccccccccccccccc
  end subroutine mixrho





  subroutine pvmix3 ( nbas , nsp , beta , locmix &
       , wt , kmxr , nlm0 , k9 , qkl , sv_p_orhold , sv_p_orhnew , difx  )
    use m_struc_def  
    use m_lmfinit,only: ispec,sspec=>v_sspec
    !- Linearly mix local densities, possibly subtracting G_kL expansion
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   ssite :struct for site-specific information; see routine usite
    !i     Elts read: spec
    !i     Stored:    *
    !i     Passed to: *
    !i   sspec :struct for species-specific information; see routine uspec
    !i     Elts read: a nr rmt rg lmxl
    !i     Stored:    *
    !i     Passed to: *
    !i   nbas  :size of basis
    !i   nsp   :2 for spin-polarized case, otherwise 1
    !i   beta  :linear mixing parameter
    !l Local variables
    !l   locmix :governs linear transformation of local densities for mixing
    !l          :see description in Local variables, routine mixrho.
    !i   kmxr   :k-cutoff for G_kL expansion when locmix=2; also dim. qkl
    !i   nlm0   :second dimension of qkl
    !i   qkl    :(locmix>=2) G_kL expansion of local densities
    !i          : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !i          : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !i          : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !i          : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    ! o Inputs/Outputs
    ! o  orhold :On input, local densities generating hamiltonian
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhold).
    ! o         :On output, w(orhold) is overwritten by the linear
    ! o         :combination (1-beta)*w(orhold) + beta*w(orhnew)
    ! o  orhnew :On input, local densities gen. by ham. (maybe screened)
    ! o         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    ! o         :If a G_kL expansion has been generated (if locmix>=2)
    ! o         :this expansion is first subtracted from w(orhnew).
    !o Outputs
    !o   difx   :maximum rms difference in rhonew-rhoold
    !r Remarks
    !r
    !u Updates
    !u   21 Nov 01 First created
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: nbas,nsp,kmxr,nlm0,locmix,k9
    type(s_rv1) :: sv_p_orhold(3,nbas)

    type(s_rv1) :: sv_p_orhnew(3,nbas)

    ! ino wt(3)      real(8):: difx , beta , wt(2) , qkl(0:kmxr,nlm0,nsp,4,nbas)
    real(8):: difx , beta , wt(3) , qkl(0:kmxr,nlm0,nsp,4,nbas)
!    type(s_site)::ssite(*)
!    type(s_spec)::sspec(*)

    ! ... Local parameters
    integer :: ib,is,igetss,nr,nlml,m,lmxl,k9l
    integer::  i !orsm(4) ,
    real(8) ,allocatable :: ri_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)
    double precision :: a,rmt,rg,difa,rf
    ! ... Heap
    real(8),allocatable:: w_orsm(:,:)
    real(8):: wdummy
    complex(8):: cdummy(1,1,1,1)
    real(8):: rdummy(1,1,1)

    difx  = 0
    do  ib = 1, nbas
       is = ispec(ib)!int(ssite(ib)%spec)

       a=sspec(is)%a
       nr=sspec(is)%nr
       rmt=sspec(is)%rmt
       rg=sspec(is)%rg

       lmxl = int(sspec(is)%lmxl)

       if (lmxl == -1) goto 10
       nlml = (lmxl+1)**2
       allocate(ri_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh ( rmt , a , nr , ri_rv)
       call radwgt ( rmt , a , nr , rwgt_rv)
       rf = rmt/3

       if (locmix >= 2) then
          allocate(w_orsm(nr*nlml*nsp,4))
       else
          allocate(w_orsm(1,4)) !dummy
       endif

       do  m = 1, 4
          if (locmix >= 2) then
             !           Generate on a mesh the smooth density to be subtracted
             !            call defrr(orsm(m),nr*nlml*nsp)
             i = 1001
             if (wt(1) == 0) i = 11001
             if (wt(2) == 0) i = 21001
             call pkl2ro ( i , 1 , rg , kmxr , nr , nlml , nsp , ri_rv &
                  , rwgt_rv , kmxr , nlm0 , cdummy , qkl ( 0 , 1 , 1 , m , ib) , &
                  w_orsm(1,m) , rdummy , difa)

             !           Undo scaling of rho1+rho2 for linear mix
             if (locmix == 3 .AND. (m == 2 .OR. m == 4)) then
                !             qlk(1,2) -> scaled rho1+rho2, rho1-rho2
                !             qkl(3,4) -> scaled rhn1+rhn2, rhn1-rhn2
                !             if (m .eq. 2) print *, m, 'old'
                !             if (m .eq. 4) print *, m, 'new'
                !             call prrmsh('scaled rhosm1+2 from qkl',w(ori),w(orsm(m-1)),
                !     .         nr,nr,nlml*nsp)
                !             call prrmsh('scaled rhosm1-2 from qkl',w(ori),w(orsm(m)),
                !     .         nr,nr,nlml*nsp)
                k9l = k9 - mod(k9,10)
                call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , ri_rv &
                     , w_orsm(1,m-1) , w_orsm(1,m))
                !             call prrmsh('unscaled rhosm1+2',w(ori),w(orsm(m-1)),
                !     .         nr,nr,nlml*nsp)
                !             call prrmsh('unscaled rhosm1-2',w(ori),w(orsm(m)),
                !     .         nr,nr,nlml*nsp)
             endif
          else
             w_orsm(1,m) = 1
          endif
       enddo

       !   ... Constraints on rnew, smoothed rho
       !        i = 10
       !        if (wt(1) .eq. 0) i = 110
       !        if (wt(2) .eq. 0) i = 210
       !        call pvmix8(i,nr,nlml,nsp,w(orhnew(1,ib)),w(orhnew(2,ib)))
       !        call pvmix8(i,nr,nlml,nsp,w(orsm(1)),w(orsm(2)))
       !        call pvmix8(i,nr,nlml,nsp,w(orsm(3)),w(orsm(4)))

       !   ... Linear mix, this site
       call pvmix4 ( nr , nlml , nsp , ri_rv , locmix , wt , beta , &
            ib , w_orsm ( 1 , 1 ) , w_orsm ( 1 , 2 ) , w_orsm ( 1 , 3 ) , &
            w_orsm ( 1 , 4 ) , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v &
            , sv_p_orhold( 3 , ib )%v , sv_p_orhnew ( 1 , ib ) %v , sv_p_orhnew &
            ( 2 , ib ) %v , sv_p_orhnew ( 3 , ib ) %v , rwgt_rv , difa )



       difx  = dmax1(difx,difa)

       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(ri_rv)) deallocate(ri_rv)
       ! i#error, rlse?  orsm = ['orsm(4)', 'integer']
       !        call rlse(orsm(1))
       deallocate(w_orsm)
10     continue
    enddo
  end subroutine pvmix3


  subroutine pvmix4(nr,nlml,nsp,ri,locmix,wt,beta,ib, &
       rhos1,rhos2,rhns1,rhns2, &
       rho1,rho2,rho3,rhn1,rhn2,rhn3,rwgt,dif)

    !- Linear mixing of local densities for one site
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   nr    :number of radial mesh points
    !i   nlml  :L-cutoff for rho1,rho2
    !i   nsp   :2 for spin-polarized case, otherwise 1
    !i   ri    :radial mesh points
    !i   locmix:>2 => work with difference rho-rhos
    !i   beta  :Linear mixing beta
    !i   ib    :site index (printout only)
    !i   rhos1 :input local true density, G_kL expansion
    !i   rhos2 :input local smoothed density, G_kL expansion
    !i   rhns1 :output local true density, G_kL expansion
    !i   rhns2 :output local smoothed density, G_kL expansion
    !i   rho1  :input local true density (generates output rho)
    !i   rho2  :input local smoothed density (generates output rho)
    !i   rho3  :input core charge (generates output rho)
    !i   rhn1  :output local true density (generated by input rho)
    !i   rhn2  :output local smoothed density (generated by input rho)
    !i   rhn3  :output core charge (generated by input rho)
    !i   rwgt  :radial mesh weights
    !o Outputs
    !o   dif   :integral (rho_out - rho_in)**2
    !o   rho1,rho2,rho3 are overwritten by the linearly mixed densities
    !r Remarks
    !u Updates
    !u   09 Dec 08 Suppress q,moment mixing when wt(1) or wt(2) is zero
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: nr,nlml,nsp,ib,locmix
    double precision :: dif,beta,wt(3)
    double precision :: ri(nr),rwgt(nr), &
         rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rho3(nr,nsp), &
         rhn1(nr,nlml,nsp),rhn2(nr,nlml,nsp),rhn3(nr,nsp), &
         rhos1(nr,nlml,nsp),rhos2(nr,nlml,nsp), &
         rhns1(nr,nlml,nsp),rhns2(nr,nlml,nsp)
    ! ... Local parameters
    integer :: i,ir,iprint,np,npc
    double precision :: pi,srfpi,vsph,ddot,qnew,qold,qmix,rmt, &
         amnew,amold,amix

    !      print *, 'start of pvmix4'
    !      call prrmsh('rho1',ri,rho1,nr,nr,nlml*nsp) ! rho1+rho2
    !      call prrmsh('rho2',ri,rho2,nr,nr,nlml*nsp) ! rho1-rho2
    !      call prrmsh('rhn1',ri,rhn1,nr,nr,nlml*nsp) ! rhscr1+rhscr2
    !      call prrmsh('rhn2',ri,rhn2,nr,nr,nlml*nsp) ! rhscr1-rhscr2

    !      call prrmsh('rhos1',ri,rhos1,nr,nr,nlml*nsp) ! rhos1+rhos2
    !      call prrmsh('rhos2',ri,rhos2,nr,nr,nlml*nsp) ! rhos1-rhos2
    !      call prrmsh('rhns1',ri,rhns1,nr,nr,nlml*nsp) ! rhscrs1+rhscrs2
    !      call prrmsh('rhns2',ri,rhns2,nr,nr,nlml*nsp) ! rhscrs1-rhscrs2


    ! ... Setup
    !      stdo = lgunit(1)
    pi = 4d0*datan(1d0)
    srfpi = dsqrt(4d0*pi)
    rmt = ri(nr)

    ! ... rho+,rho- -> rho,amag  and some integrated quantities
    call splrho(0,nsp,nr,nlml,rho1,rho2,rho3)
    call splrho(0,nsp,nr,nlml,rhn1,rhn2,rhn3)
    !      qnew = srfpi*(ddot(nr,rhn1,1,rwgt,1) - ddot(nr,rhn2,1,rwgt,1))
    !      qold = srfpi*(ddot(nr,rho1,1,rwgt,1) - ddot(nr,rho2,1,rwgt,1))
    !      amnew = srfpi*(ddot(nr,rhn1(1,1,nsp),1,rwgt,1) -
    !     .               ddot(nr,rhn2(1,1,nsp),1,rwgt,1))
    !      amold = srfpi*(ddot(nr,rho1(1,1,nsp),1,rwgt,1) -
    !     .               ddot(nr,rho2(1,1,nsp),1,rwgt,1))
    qnew = srfpi*ddot(nr,rhn2,1,rwgt,1)
    qold = srfpi*ddot(nr,rho2,1,rwgt,1)
    amnew = srfpi*ddot(nr,rhn2(1,1,nsp),1,rwgt,1)
    amold = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

    dif = 0
    do  i  = 1, nsp
       if (wt(1) == 0 .AND. i == 1) cycle
       if (wt(2) == 0 .AND. i == 2) cycle
       do  ir = 1, nr
          dif  = dif + rwgt(ir)*(rhn2(ir,1,i)-rho2(ir,1,i))**2
       enddo
    enddo
    vsph = (4d0*pi/3d0)*rmt**3
    dif = dsqrt(dif/vsph)

    ! --- Overwrite rho with (1-beta)*rho + beta*rhn ---
    !     wt(1)=0 => only mix spin part (set i=2)
    !     wt(2)=0 => only mix charge part (set i=1)
    np = nr*nlml*nsp
    i = 1
    if (wt(1) == 0) then
       np = nr*nlml
       i = 2
    elseif (wt(2) == 0) then
       np = nr*nlml
       i = 1
    endif
    call dscal(np,1-beta,rho1(1,1,i),1)
    call daxpy(np,beta,rhn1(1,1,i),1,rho1(1,1,i),1)
    call dscal(np,1-beta,rho2(1,1,i),1)
    call daxpy(np,beta,rhn2(1,1,i),1,rho2(1,1,i),1)
    npc = nr*nsp
    if (wt(1) == 0 .OR. wt(2) == 0) npc = nr
    call dscal(npc,1-beta,rho3(1,i),1)
    call daxpy(npc,beta,rhn3(1,i),1,rho3(1,i),1)

    ! ... Charges and mag. moments of mixed density
    qmix = srfpi*(ddot(nr,rho2,1,rwgt,1))
    if (nsp == 2) amix = srfpi*ddot(nr,rho2(1,1,nsp),1,rwgt,1)

    ! --- Subtract smoothed (1-beta)*rhos + beta*rhns ---
    if (locmix >= 2) then
       call splrho(20,nsp,nr,nlml,rhos1,rhos2,rho3)
       call splrho(20,nsp,nr,nlml,rhns1,rhns2,rhn3)
       np = nr*nlml*nsp
       call daxpy(np,-(1-beta),rhos1,1,rho1,1)
       call daxpy(np,-beta,rhns1,1,rho1,1)
       call daxpy(np,-(1-beta),rhos2,1,rho2,1)
       call daxpy(np,-beta,rhns2,1,rho2,1)
       call splrho(21,nsp,nr,nlml,rhos1,rhos2,rho3)
       call splrho(21,nsp,nr,nlml,rhns1,rhns2,rhn3)
    endif

    ! ... Restore rho,amag -> rho+,rho-
    call splrho(1,nsp,nr,nlml,rho1,rho2,rho3)
    call splrho(1,nsp,nr,nlml,rhn1,rhn2,rhn3)

    if (iprint() >45 ) then
       write(stdo,100) ib,qold,qnew,qnew,dif,qmix
100    format(' site ',i4,f12.6,5f14.6)
       !  100   format(' site ',i4,f12.6,f14.6,14x,2f14.6)
       if (nsp == 2) write(stdo,101) amold,amnew,amix
101    format(' mmom   ',2f14.6,28x,f14.6)
    endif

    !       print *, 'end of pvmix4'
    !       call prrmsh('rho1 after lin mix',ri,rho1,nr,nr,nlml*nsp)
    !       call prrmsh('rho2 after lin mix',ri,rho2,nr,nr,nlml*nsp)

  end subroutine pvmix4


  subroutine pvmix5 ( nmix , mxsav , fnam , ifi , lbin , rmsdel &
       , locmix , k9 , nbas , kmxr , nlm0 , nsp , sv_p_orhold &
       , sv_p_orhnew , co , cn , ng2 , ng02 , cnst , nda , a , qkl , rms2 &
       , nmixr )
    use m_lmfinit,only:ispec,sspec=>v_sspec
    use m_struc_def  
    !- Copy rho into holding array, read prior iterations from disk
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   nmix  :number of prior iterations sought (for printout)
    !i   mxsav :max no. prior iteration to read, also dimensions a
    !i   fnam  :file name (for printout)
    !i   ifi   :file logical unit; sign delineates whether copying into
    !i         :or out of holding array
    !i   lbin  :T if binary read
    !i  rmsdel :Same as rms2 (see Outputs), from prior iteration.
    !i         :If no prior iteration, rsmdel=0.  For printout only.
    !i  locmix :switch governing linear transformation of local densities
    !i          for mixing; see Local variables in subroutine mixrho.
    !i  nbas   :size of basis
    !i  ssite  :struct for site-specific information; see routine usite
    !i     Elts read: spec
    !i     Stored:    *
    !i     Passed to: rhogkl
    !i   sspec :struct for species-specific information; see routine uspec
    !i     Elts read: a nr rmt lmxl
    !i     Stored:    *
    !i     Passed to: rhogkl
    !i   nsp   :2 for spin-polarized case, otherwise 1
    !i   orhold:input local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   orhnew:output local density this iteration,
    !i         :transformed into unscaled rho1+rho2 and rho1-rho2 (pvmix9)
    !i   co    :input smooth density this iteration, in FT form
    !i   cn    :output smooth density this iteration, in FT form
    !i   ng    :leading dimension of co,cn
    !i   ng0   :number of Fourier coefficients
    !    ng02=ng0*2 in the mixrealsmooth()=F (original case)
    !i   cnst  :site-dependent vector marking whether to constrain
    !i         :selected mixing (not used here)
    !o Inputs/Outputs
    ! o  nmixr :(output for ifi>0) number of prior iter read from file
    ! o        :(input  for ifi<0) number of prior iter written to file
    ! o        :on output number of prior iterations read from file
    ! o  a,nda :work array a and leading dimension (nda must be >= na)
    ! o         a(*,i,1) holds f(xi) for iteration i-1
    ! o         a(*,i,2) holds   xi  for iteration i-1
    !o Outputs
    !o  qkl    :(locmix>=2) G_kL expansion of local densities
    !o         : qkl(:,:,isp,1,ib) = rho1(rhold), G_kL expansion
    !o         : qkl(:,:,isp,2,ib) = rho2(rhold), G_kL expansion
    !o         : qkl(:,:,isp,3,ib) = rho1(rhnew), G_kL expansion
    !o         : qkl(:,:,isp,4,ib) = rho2(rhnew), G_kL expansion
    !o  rms2   :rms difference in f-x, where f=output density and x the
    !o          input density.  f and x include smoothed and local
    !o          contributions, with the latter depending on choice of
    !o          linear transformation; see locmix above.  Thus, there
    !o          is some arbitrariness in rms2.
    !r Remarks
    !r   Content of a(*) = a(*,isp,:,:):
    !r   Case locmix = 0:
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = l=0 part of rho(1), rho(2)
    !r     ... nda = 2*ng0 + 2*nr
    !r   Case locmix = 1:
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
    !r     ... nda = 2*ng0 + 2*nr
    !r   Case locmix = 2
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+(1+kmxr)*nlml) = P_kL expansion of rho1-rho2
    !r     ... nda = 2*ng0 + (1+kmxr)*nlml
    !r   Case locmix = 3
    !r     a(1:2*ng0) = Fourier coffs of sm density (hermitian => ng0<ng)
    !r     a(1+2*ng0:2*ng0+2*nr) = Weighted l=0 part of rho(1), rho(2)
    !r     a(1+k:2*ng0:2*ng0+2*nr+(1+kmxr)*nlml) = P_kL exp. of rho1-rho2
    !r                                             w/ l=0 part zeroed out
    !r     ... nda = 2*ng0 + 2*nr + (1+kmxr)*nlml
    ! -----------------------------------------------------------------
    implicit none
    ! ... Passed parameters
    include "mpif.h"
    integer :: procid, master, numprocs, ierr, status(MPI_STATUS_SIZE)
    integer :: MAX_PROCS
    parameter (MAX_PROCS = 100)
    integer :: resultlen
    character*(MPI_MAX_PROCESSOR_NAME) name
    character(10) :: shortname(0:MAX_PROCS-1)
    character(20) :: ext
    character(26) :: datim
    integer :: namelen(0:MAX_PROCS-1)
    double precision :: starttime, endtime
    character(120) :: strn
    logical :: mlog,cmdopt
    integer :: iunit
    logical :: readerror
    logical :: lbin
    integer :: ng2,ng02,nda,nmix,mxsav,ifi,nbas,nr,nsp,cnst(0:*),locmix, &
         k9,kmxr,nlm0
    type(s_rv1) :: sv_p_orhold(3,1)

    type(s_rv1) :: sv_p_orhnew(3,1)

    double precision :: a(nda,nsp,mxsav+2,2),rms2,rmsdel
    real(8):: co(ng2,nsp) , cn(ng2,nsp) , qkl(0:kmxr,nlm0,nsp,4,1)
!    type(s_site)::ssite(*)
!    type(s_spec)::sspec(*)

    character fnam*8
    ! ... Local parameters
    integer :: ib,na,i,j,k,m,np,iprint,nmixr,is,igetss, &
         awrite,off,nlml,lmxl,k9l
    real(8) ,allocatable :: rofi_rv(:)

    logical :: lcnst,lfdmp,lddump
    double precision :: ddot,rmt,aat,rf

    character outs*80
    ! ... Heap

    call MPI_COMM_RANK( MPI_COMM_WORLD, procid, ierr)
    call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr)
    call MPI_GET_PROCESSOR_NAME(name, resultlen, ierr)
    call strcop(shortname(procid),name,10,'.',i)
    namelen(procid) = i-1
    master = 0
    mlog = cmdopt('--mlog',6,0,strn)

    !      stdo = lgunit(1)
    lcnst = cnst(0) .gt. 0

    ! --- Copy rho to a; calc. RMS error; read prior iter from ifi ---
    if (ifi > 0) then

       !   ... FT Mesh density
       na = 1
       do  i = 1, nsp
          call dpcopy(co(1,i),a(na+00,i,1,2),1,ng02,1d0)
          call dpcopy(cn(1,i),a(na+00,i,1,1),1,ng02,1d0)
       enddo
       na = 1 + ng02

       !   ... Site densities, depending on locmix
       do  ib = 1, nbas
          is = ispec(ib)!int(ssite(ib)%spec)


          aat=sspec(is)%a
          nr=sspec(is)%nr
          rmt=sspec(is)%rmt
          lmxl=sspec(is)%lmxl

          if (lmxl == -1) cycle
          rf = rmt/3
          nlml = (lmxl+1)**2
          allocate(rofi_rv(nr))

          call radmsh ( rmt , aat , nr , rofi_rv)


          !   ... If site is constrained, freeze density at rhold (not checked)
          if (lcnst) then
             if (cnst(ib) /= 0) then
                do  i = 1, nsp
                   off = 1+nr*nlml*(i-1)
                   call dpscop ( sv_p_orhold( 1 , ib )%v , sv_p_orhnew ( 1 , ib &
                        ) %v , nr , off , off , 1d0 )


                   call dpscop ( sv_p_orhold( 2 , ib )%v , sv_p_orhnew ( 2 , ib &
                        ) %v , nr , off , off , 1d0 )


                enddo
             endif
          endif

          !   --- Copy local densities to mix matrix a, depending on locmix ---

          !   ... Overwrite rho1,rho2 with linear transf. according to k9
          ! X     mch tmp/rho1 tmp/rho2 -+ out.fe -- -coll 2,18  -px
          !        call prrmsh('rhold1',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
          !        call prrmsh('rhold2',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

          !   ... locmix=0,1,3 : copy spherical part of local rho to a
          !       NB: Increment na after all actions takend w/ local densities
          if (locmix <= 1 .OR. locmix == 3) then

             !         Scaling rho1+rho2, old and new densities
             k9l = k9 - mod(k9,10)
             call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , &
                  sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


             call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , &
                  sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )


             !         call prrmsh('1 post',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
             !         call prrmsh('2 post',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
             !         Copy (scaled) spherical part of rho1+rho2, rho1-rho2 to a
             do  i = 1, nsp
                off = 1+nr*nlml*(i-1)
                call dpscop ( sv_p_orhold( 1 , ib )%v , a ( na + 00 , i , 1 , &
                     2 ) , nr , off , 1 , 1d0 )

                call dpscop ( sv_p_orhold( 2 , ib )%v , a ( na + nr , i , 1 , &
                     2 ) , nr , off , 1 , 1d0 )

                call dpscop ( sv_p_orhnew( 1 , ib )%v , a ( na + 00 , i , 1 , &
                     1 ) , nr , off , 1 , 1d0 )

                call dpscop ( sv_p_orhnew( 2 , ib )%v , a ( na + nr , i , 1 , &
                     1 ) , nr , off , 1 , 1d0 )

             enddo

             !         Undo scaling transformation of rho1+rho2
             !          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),w(orhold(1,ib)),
             !     .      w(orhold(2,ib)))
             !          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),w(orhnew(1,ib)),
             !     .      w(orhnew(2,ib)))
             !         call prrmsh('1 rest',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
             !         call prrmsh('2 rest',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)

          endif
          !       print *, 'a(nr)'
          !       print *, a(na+nr-1,:,1,:)

          !   ... locmix>=2 : Make G_kL expansion of rho; copy coffs to a
          if (locmix >= 2) then
             do  i = 1, nsp
                call pshpr(iprint()-30)
                call rhogkl ( ib , ib , i , 2 , sv_p_orhold , &
                     kmxr , qkl ( 0 , 1 , i , 1 , ib ) )

                call rhogkl ( ib , ib , i , 3 , sv_p_orhold , &
                     kmxr , qkl ( 0 , 1 , i , 2 , ib ) )

                call rhogkl ( ib , ib , i , 2 , sv_p_orhnew , &
                     kmxr , qkl ( 0 , 1 , i , 3 , ib ) )

                call rhogkl ( ib , ib , i , 3 , sv_p_orhnew , &
                     kmxr , qkl ( 0 , 1 , i , 4 , ib ) )

                call poppr
                !           Convert qkl for 2nd spin channel into 2nd channel only,
                !           since rhogkl makes expansion combining channels 1+2
                if (i == 2) then
                   j = (1+kmxr)*nlm0
                   !             qkl(nsp=2) -> qkl(nsp=1) - qkl(nsp=2)
                   do  m = 1, 4
                      call dpsadd(qkl(0,1,1,m,ib),qkl(0,1,1,m,ib),j,1+j,1,-1d0)
                   enddo
                endif

                !           locmix=3 : zero out spherical part of G_kL
                if (locmix == 3) then
                   !             print *, '!! skip zero qkl'
                   do  m = 1, 4
                      call dpzero(qkl(0,1,i,m,ib),kmxr+1)
                   enddo
                endif

                !           locmix=3 : increment index by 2*nr
                if (locmix == 3) na = na + 2*nr

                !           Copy qkl into a
                np = (1+kmxr)*nlml
                call dpscop(qkl(0,1,i,1,ib),a(na+00,i,1,2),np,1,1,1d0)
                call dpscop(qkl(0,1,i,2,ib),a(na+np,i,1,2),np,1,1,1d0)
                call dpscop(qkl(0,1,i,3,ib),a(na+00,i,1,1),np,1,1,1d0)
                call dpscop(qkl(0,1,i,4,ib),a(na+np,i,1,1),np,1,1,1d0)

                !           locmix=3, : undo increment unless final spin
                if (locmix == 3 .AND. i < nsp) na = na - 2*nr

             enddo                 ! end of spin loop
             !         call prmx('qkl',qkl,1+kmxr,1+kmxr,nlm0*nsp)
          endif

          !       Undo scaling transformation of rho1+rho2
          if (locmix <= 1 .OR. locmix == 3) then
             call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv &
                  , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


             call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv &
                  , sv_p_orhnew( 1 , ib )%v , sv_p_orhnew( 2 , ib )%v )


             !         call prrmsh('1 rest',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
             !         call prrmsh('2 rest',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
          endif

          !   ... Increment index na to a
          if (locmix <= 1) then
             na = na + 2*nr
          elseif (locmix >= 2) then
             na = na + 2*np
          endif

          if (allocated(rofi_rv)) deallocate(rofi_rv)

       enddo                     !Loop over sites
       na = na-1
       if (nda /= na) call rx('mixrho: bug in pvmix5')
       na = na*nsp
       !       call prmx('a',a,nda,na,1)
       rms2 = dsqrt(dabs(ddot(na,a,1,a,1)     - &
            2*ddot(na,a,1,a(1,1,1,2),1) + &
            ddot(na,a(1,1,1,2),1,a(1,1,1,2),1))/(na-0))*nsp
       if (mxsav == 0) return
       !   ... File I/O of previous iterations; nmixr is number actually read
       nmixr = 0
       readerror = .true.
       if (procid == master) then
          readerror = .false.
          if (lbin) read (ifi,err=311,end=311) nmixr, na
          if ( .NOT. lbin) read (ifi,*,err=311,end=311) nmixr, na
          goto 312
311       continue
          readerror = .true.
312       continue
       endif
       call MPI_BCAST(readerror,1,MPI_LOGICAL, &
            master,MPI_COMM_WORLD,ierr)
       if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on ' &
               //shortname(procid)(1:namelen(procid))// &
               ' bcast readerror = %l',' ', &
               256,stml,procid,numprocs,readerror)
       endif
       if (readerror) goto 31
       call MPI_BCAST(nmixr,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
       if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on ' &
               //shortname(procid)(1:namelen(procid))// &
               ' bcast nmixr = %i',' ', &
               256,stml,procid,numprocs,nmixr)
       endif
       call MPI_BCAST(na,1,MPI_INTEGER,master,MPI_COMM_WORLD,ierr)
       if (mlog) then
          call gettime(datim)
          call awrit3(' mixrho '//datim//' Process %i of %i on ' &
               //shortname(procid)(1:namelen(procid))// &
               ' bcast na = %i',' ', &
               256,stml,procid,numprocs,na)
       endif
       if (nda*nsp /= na) then
          if (procid == master) then
             call awrit2 &
                  (' mixrho:  expecting %i elements but found %i ...' &
                  //' discarding file',' ',80,stdo,nda*nsp,na)
          endif
          nmixr = 0
          goto 31
       endif
       k = min(mxsav,nmixr)
       if (procid == master) then
          readerror = .false.
          do  30  j = 1, k
             if (lbin) then
                if ( .NOT. lddump(a(1,1,j+1,1),na,ifi)) readerror = .TRUE. 
                if ( .NOT. lddump(a(1,1,j+1,2),na,ifi)) readerror = .TRUE. 
             else
                if ( .NOT. lfdmp(a(1,1,j+1,1),na,ifi)) readerror = .TRUE. 
                if ( .NOT. lfdmp(a(1,1,j+1,2),na,ifi)) readerror = .TRUE. 
             endif
             if (readerror) goto 313
             nmixr = j
30        enddo
       endif
313    continue
       if (nmixr > 0) then
          call MPI_BCAST(a,nda*nsp*(mxsav+2)*2,MPI_DOUBLE_PRECISION, &
               master,MPI_COMM_WORLD,ierr)
          if (mlog) then
             call gettime(datim)
             call awrit3(' mixrho '//datim//' Process %i of %i on ' &
                  //shortname(procid)(1:namelen(procid))// &
                  ' bcast (mix) a %i d.p. numbers',' ', &
                  256,stml,procid,numprocs,nda*nsp*(mxsav+2)*2)
          endif
       endif
31     continue
       if (iprint() >= 20) then
          j = awrite('%x mixrho:  sought %i iter from file', &
               outs,len(outs),0,nmix,0,0,0,0,0,0,0)
          outs(j+2:len(outs)) = fnam
          call awrit2('%a; read %i.  RMS DQ=%1,3;3e',outs,80,0,nmixr, &
               rms2)
          if (rmsdel /= 0) &
               call awrit1('%a  last it=%1,3;3e',outs,80,0,rmsdel)
          call awrit0('%a',outs,-len(outs),-stdo)
       endif
       !       call prm('a after read',a,nda*nsp,nda*nsp,(mxsav+2)*2)

       ! --- Save iterations on disk ---
    else
       if (procid == master) then
          rewind (-ifi)
          if (lbin) write (-ifi) min(nmix+1,mxsav), nda*nsp
          if ( .NOT. lbin) write (-ifi,*) min(nmix+1,mxsav), nda*nsp
          do  j = 1, min(nmix+1,mxsav)
             if (lbin) then
                call dpdump(a(1,1,j,1),nda*nsp,ifi)
                call dpdump(a(1,1,j,2),nda*nsp,ifi)
             else
                call dfdump(a(1,1,j,1),nda*nsp,ifi)
                call dfdump(a(1,1,j,2),nda*nsp,ifi)
             endif
          enddo
          !       call prm('a after write',a,nda*nsp,nda*nsp,(mxsav+2)*2)
       endif
    endif

  end subroutine pvmix5


  subroutine pvmix6(broy,nmix,mmix,mxsav,beta,wc,nda,a)
    use m_amix,only: amix

    !- Mixing of the total density
    ! ------------------------------------------------------------------
    !i  broy   : 0 for Anderson mixing
    !i         : 1 for Broyden mixing
    !i  nmix   : nmix: number of iter to try and mix
    !i  mmix   : number of iterates available to mix
    !i  mxsav  : second dimension of a
    ! o Inputs/Outputs
    ! o  a     :On input:
    ! o         (*,i,1)  output vector for prev. iteration i
    ! o         (*,i,2)  input  vector for prev. iteration i
    ! o        :On output:
    ! o         (*,0,1) and (*,0,2) estimated new vector
    ! o         (*,i,1), i>1 destroyed
    !r  Remarks
    !r    Broyden mixing adapted from Duane Johnson.  Notation:
    !r    x^(m): input vector for iteration m
    !r    F^(m): difference between output and input vector in iteration m
    ! ------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: nda,nmix,mmix,mxsav,broy
    double precision :: beta,a(nda,0:mxsav+1,2)
    ! ... Local parameters
    integer :: j,iprint!,amix
    double precision :: tjmax,tj(10),norm(100),kpvt(10),wc,wctrue,rms2
    !     integer idamax
    !     double precision dval,rmskm(100),rmsmx
    parameter (tjmax = 5d0)

    ! ... This is the result of linear mixing, q=0 smooth rho
    !     sqmix = a(1,0,1)*beta + a(1,0,2)*(1-beta)
    real(8),allocatable:: aaa(:)

    !$$$ccccccccccccccccccccccccccccccccccccccccc
    !$$$c takao simple mixing test
    !$$$      print *,' vvv: takao simple mixing test'
    !$$$      allocate(aaa(nda))
    !$$$c      aaa = .2d0*a(:,0,1)+.8d0*a(:,0,2)
    !$$$c      aaa = .40d0*a(:,0,1)+.6d0*a(:,0,2)
    !$$$c      aaa = .9d0*a(:,0,1)+.1d0*a(:,0,2)
    !$$$      aaa = 1.d0*a(:,0,1)+.0d0*a(:,0,2)
    !$$$c       aaa = .5d0*a(:,0,1)+.5d0*a(:,0,2)
    !$$$c      aaa = .8d0*a(:,0,1)+.2d0*a(:,0,2)
    !$$$      call dcopy(nda,aaa,1,a(1,0,1),1)
    !$$$      call dcopy(nda,aaa,1,a(1,0,2),1)
    !$$$      deallocate(aaa)
    !$$$      return
    !$$$cccccccccccccccccccccccccccccccccccccccccc


    ! --- Anderson mixing ---
    if (nmix == 0 .OR. nmix == 1 .OR. broy == 0) then
       ! ... amix needs f-x for prior iterations
       do  30  j = 1, nmix
          call daxpy(nda,-1d0,a(1,j,2),1,a(1,j,1),1)
30     enddo
       !        call query('beta',4,beta)
       nmix = amix(nda,nmix,mxsav,0,beta,iprint(),tjmax,a,tj,  rms2)
       !      if (iprint() .ge. 20) write(stdo,101) strn,rms2,(tj(j), j=1,nmix)
       !  101 format(1x,a4,':     rms diff',f10.6:'  tj=',5f8.3)
       !     call prm('a out',a,nda,nda,(mxsav+2)*2)
       ! ... Copy x*=a(*,0,2) to a(*,0,1)
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)

       ! --- Broyden mixing, Duane Johnson's approach ---
    elseif (broy == 1) then
       call pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
       !   ... Copy x*=a(*,0,2) to a(*,0,1)
       call dcopy(nda,a(1,0,2),1,a(1,0,1),1)
    else
       call rx('pvmix6: bad value for broy')
    endif

    ! ... Add the change relative to linear mixing
    !     sqmix = (a(1,0,1) - sqmix)*vol

  end subroutine pvmix6


  subroutine pvmix7 ( nbas , nsp , nda , a , n1 &
       , n2 , n3 , k1 , k2 , k3 , locmix , wt , k9 , kmxr , nlm0 , qkl &
       , ng , ng2, ng02 , kv , ips0 , gv , crho , wk , sv_p_orhold , smrho &
       ,wgtsmooth)
    use m_lmfinit,only: ispec,sspec=>v_sspec
    use m_struc_def 
    !- Restore mixed density into specific arrays
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   ssite :struct for site-specific information; see routine usite
    !i     Elts read: spec
    !i     Stored:    *
    !i     Passed to: *
    !i   sspec :struct for species-specific information; see routine uspec
    !i     Elts read: a nr rmt lmxl rg
    !i     Stored:    *
    !i     Passed to: *
    !i   nbas  :size of basis
    !i   nsp   :2 for spin-polarized case, otherwise 1
    !i   nda   :leading dimension of a
    !i   a     :mixed density from pvmix6, smoothed + local densities
    !i         :For local parts, a contains SCALED rho1+rho2, rho1-rho2
    !i         :If locmix =  0,1, or 3, a contains spherical part on mesh
    !i         :If locmix =  2,3 a full rho, GkL expansion
    !i   n1..3 :FT mesh
    !i   k1..3 :dimensions smrho
    !i   locmix:mixing mode for local densities
    !i   ng    :number of FT G-vectors
    !i   ng0   :condensed number of G vector (excluding hermitian equiv)
    !i   kv    :indices for gather/scatter operations (gvlist.f)
    !i   ips0  :permutation array mapping ng0 vectors to ng vectors (lgstar)
    !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
    !i   crho  :FT coefficients of smrho(G)
    !i   wk    :complex work array of dimension (k1,k2,k3)
    !i   smrho :smooth density that generated the hamiltonian
    !i   orhold:local  density that generated the hamiltonian,
    !i         :a portion of which which has been linearly mixed (pvmix4)
    !i         :orhold(1) contains rho1+rho2;
    !i         :orhold(2) contains rho1-rho2; see pvmix9
    !o Outputs
    !o   smrho :overwritten by mixed smooth density
    !o   orhold:mixed local density is returned, in rho1+rho2,rho10rho2 form
    !r Remarks
    !u Updates
    ! ----------------------------------------------------------------------
    implicit none
    ! ... Passed parameters
    integer :: nsp,n1,n2,n3,k1,k2,k3,ng,ng02,nda,na,nr,nbas,locmix,k9, &
         kv(ng,3),ips0(ng),kmxr,nlm0,ng2
    type(s_rv1) :: sv_p_orhold(3,1)

    real(8):: gv(ng,3) , a(nda,nsp) , qkl(0:kmxr,nlm0,nsp,4,nbas) &
         , rf , wt(2), wgtsmooth
!    type(s_site)::ssite(*)
!    type(s_spec)::sspec(*)

    double complex smrho(k1,k2,k3,nsp),wk(k1,k2,k3)
    real(8):: crho(ng2,nsp)
    ! ... Local parameters
    real(8) ,allocatable :: rofi_rv(:)
    real(8) ,allocatable :: rwgt_rv(:)

    integer :: ib,is,igetss,i,m,lmxl,nlml,off,np,k9l,orsm(2)
    double precision :: aat,rmt,rg,xx
    ! ... Heap
    integer ::iwdummy
    complex(8):: cdummy(1,1,1,1)
    real(8):: rdummy(1,1,1)
    real(8),allocatable:: w_orsm(:,:)
    logical:: mixrealsmooth

    ! ... Restore mixed smoothed density
    if(mixrealsmooth()) then
       do  i = 1, nsp
          call dscal(ng02,-1d0/wgtsmooth,crho(1,i),1)
          call daxpy(ng02,1d0/wgtsmooth,a(1,i),1,crho(1,i),1)
          call daxpy(k1*k2*k3,1d0,crho(1,i),1,smrho(1,1,1,i),2)
       enddo
    else
       do  i = 1, nsp
          !       Add difference of mixed, old to minimize perturbation
          ! ccccccccccccccc
          !        print *,' vvv pvmix7 TEST!!! a=0 test'
          !        a=0d0
          ! ccccccccccccc
          call dscal(ng02,-1d0,crho(1,i),1)
          call daxpy(ng02,1d0,a(1,i),1,crho(1,i),1)
          call lgstar(2,ng,1,gv,m,ips0,crho(1,i))
          call gvputf(ng,1,kv,k1,k2,k3,crho(1,i),wk)
          call fftz3(wk,n1,n2,n3,k1,k2,k3,1,0,1)
          call daxpy(2*k1*k2*k3,1d0,wk,1,smrho(1,1,1,i),1)
       enddo
    endif

    ! ... Update local densities
    na = 1 + ng02
    k9l = k9 - mod(k9,10)
    do  ib = 1, nbas
       is = ispec(ib)!int(ssite(ib)%spec)

       aat=sspec(is)%a
       nr=sspec(is)%nr
       rmt=sspec(is)%rmt
       lmxl=sspec(is)%lmxl

       if (lmxl == -1) cycle
       rf = rmt/3
       rg = sspec(is)%rg
       nlml = (lmxl+1)**2
       allocate(rofi_rv(nr))
       allocate(rwgt_rv(nr))
       call radmsh ( rmt , aat , nr , rofi_rv)
       call radwgt ( rmt , aat , nr , rwgt_rv)

       !       Scale rho1+rho2 to match scaled spherical parts and sm parts
       !       call prrmsh('1 mix7a',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
       call pvmix9 ( k9l , 0 , nr , nlml * nsp , 0 , rf , rofi_rv , &
            sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )


       !       call prrmsh('1 mix7b',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)

       !       Overwrite sph. rhold with scaled mixed rho; do not unscale
       if (locmix <= 1 .OR. locmix == 3) then
          do  i = 1, nsp
             off = 1+nr*nlml*(i-1)

             call dpscop ( a ( na + 00 , i ) , sv_p_orhold( 1 , ib )%v , nr &
                  , 1 , off , 1d0 )

             call dpscop ( a ( na + nr , i ) , sv_p_orhold( 2 , ib )%v , nr &
                  , 1 , off , 1d0 )

             !            call pvmix9(k9l,-1,nr,1,off-1,rf,w(orofi),w(orhold(1,ib)),
             !     .        w(orhold(2,ib)))
             !          call prrmsh('1 mix7c',w(orofi),w(orhold(1,1)),nr,nr,nlml*nsp)
             !          call prrmsh('2 mix7c',w(orofi),w(orhold(2,1)),nr,nr,nlml*nsp)
          enddo
          na = na + 2*nr
       endif

       !   ... Mixing mode 2,3: add mixed sm density to existing rhold
       if (locmix >= 2) then

          !         call prrmsh('1 scale',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
          np = (1+kmxr)*nlml
          allocate(w_orsm(nr*nlml*nsp,2))
          do  m = 1, 2
             !            call defrr(orsm(m),nr*nlml*nsp)
             do  i = 1, nsp
                call dpscop(a(na+np*(m-1),i),qkl(0,1,i,m,ib),np,1,1,1d0)
             enddo
             i = 1001
             if (wt(1) == 0) i = 11001
             if (wt(2) == 0) i = 21001
             call pkl2ro ( i , 1 , rg , kmxr , nr , nlml , nsp , rofi_rv , &
                  rwgt_rv , kmxr , nlm0 , cdummy , qkl ( 0 , 1 , 1 , m , ib ) &
                  , w_orsm ( 1 , m ) , rdummy , xx )

          enddo
          !         Don't undo scaling of smoothed density since rho1+rho2 scaled
          !          call pvmix9(k9l,-1,nr,nlml*nsp,0,rf,w(orofi),
          !     .      w(orsm(1)),w(orsm(2)))
          !         Add to rhold(1,2)
          call daxpy ( nr * nlml * nsp , 1d0 , w_orsm ( 1 , 1 ) , 1 , sv_p_orhold( 1 , ib )%v &
               , 1 )

          call daxpy ( nr * nlml * nsp , 1d0 , w_orsm ( 1 , 2 ) , 1 , sv_p_orhold( 2 , ib )%v &
               , 1 )

          deallocate(w_orsm)
          !          call rlse(orsm(2))
          !          call rlse(orsm(1))
          na = na + 2*np
       endif
       !       call prrmsh('1 mix7d',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)

       call pvmix9 ( k9l , - 1 , nr , nlml * nsp , 0 , rf , rofi_rv &
            , sv_p_orhold( 1 , ib )%v , sv_p_orhold( 2 , ib )%v )



       !      call prrmsh('rho1,mixed',w(orofi),w(orhold(1,ib)),nr,nr,nlml*nsp)
       !      call prrmsh('rho2,mixed',w(orofi),w(orhold(2,ib)),nr,nr,nlml*nsp)

       if (allocated(rwgt_rv)) deallocate(rwgt_rv)
       if (allocated(rofi_rv)) deallocate(rofi_rv)
       ! i  bug fix,  unecessary
       ! i         call rlse(orsm(1))

    enddo                     !Loop over sites
    na = na-1
    if (nda /= na) call rx('mixrho: bug in pvmix7')

  end subroutine pvmix7


  !      subroutine pvmix8(mode,nr,nlml,nsp,rho1,rho2)
  !C- Handle possible constraints for change in smooth density
  !C ----------------------------------------------------------------------
  ! i Inputs
  ! i   mode  :a compound of digits :
  ! i         :10s digit
  ! i         :  0 apply to rho1 only; rho2 is not touched
  ! i         :  1 apply to both rho1 and rho2
  ! i         :100s digit for spin polarized case
  ! i         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
  ! i         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
  ! i   nr    :number of radial mesh points
  ! i   nlml  :L-cutoff for rho1,rho2
  ! i   nsp   :2 for spin-polarized case, otherwise 1
  ! io Inputs/Outputs
  ! io  rho1  :overwritten with constraints controlled by mode
  ! io  rho2  :overwritten with constraints controlled by mode
  ! r Remarks
  ! u Updates
  ! u   16 Dec 08 First created
  !C ----------------------------------------------------------------------
  !      implicit none
  !C ... Passed parameters
  !      integer mode,nr,nlml,nsp
  !      double precision rho1(nr,nlml,nsp),rho2(nr,nlml,nsp)
  !C ... Local parameters
  !      integer np,mode0,mode1,mode2,i
  !      double precision xx

  !C ... Setup
  !      mode0 = mod(mode,10)
  !      mode1 = mod(mode/10,10)
  !      mode2 = mod(mode/100,10)
  !      np = nr*nlml
  !      if (mode2 .eq. 0 .or. nsp .ne. 2) return

  !      i = 20                   ! No core
  !      if (mode1 .eq. 0) i = 30 ! No rho2
  !      call splrho(i,nsp,nr,nlml,rho1,rho2,xx)
  !      if (mode2 .eq. 1) then   ! Zero density
  !        call dpzero(rho1(1,1,1),np)
  !        if (mode1 .ne. 0) then ! Including rho2
  !          call dpzero(rho2(1,1,1),np)
  !        endif
  !      endif
  !      if (mode2 .eq. 2) then   ! Zero spin
  !        call dpzero(rho1(1,1,nsp),np)
  !        if (mode1 .ne. 0) then ! Including rho2
  !          call dpzero(rho2(1,1,nsp),np)
  !        endif
  !      endif
  !      call splrho(i+1,nsp,nr,nlml,rho1,rho2,xx)

  !      end
  subroutine pvmix9(mode,linv,nr,nlml,off,rf,rofi,rho1,rho2)

    !- Transformation of local densities rho1,rho2 for mixing
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   mode  :transformation mode; see Remarks
    !i         : mode  transform
    !i         : 1s digit
    !i         : <=0    do nothing
    !i         :  1     rho1 <= rho1+rho2  rho2 <= rho1-rho2
    !i         : 10s digit
    !i         : 10     scale rho1 by gaussian exp(-(r/rf)**2)
    !i         : 20     scale rho1 by gaussian 1/(1+(r/rf)**2)
    !i   linv  :0  forward transform
    !i         :-1 inverse transform
    !i   nr    :number of radial mesh points
    !i   nlml  :number of L channels
    !i   off   :offset to start of first point (0 for first point)
    !i   rf    :factor used in scaling; see mode
    ! o Inputs/Outputs
    !i   rho1  :On input, local true density, or the transformation
    !i         :of it if the inverse is to be made
    !i         :On output, some linear combination of rho1,rho2.
    !i   rho2  :On input, local smoothed density, or the transformation
    !i         :of it if the inverse is to be made
    !i         :On output, some linear combination of rho1,rho2
    !r Remarks
    !r   This routine takes as input rho1,rho2 and returns in
    !r   rho1,rho2 some linear combination of them, depending on mode
    !r   If linv=1, the inverse transform is done.
    !u Updates
    !u   18 Nov 01 First created
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: mode,nr,nlml,linv,off
    double precision :: rho1(nr,nlml),rho2(nr,nlml),rofi(nr),rf
    ! ... Local parameters
    integer :: i,ilm,mode0,mode1
    double precision :: ri
    logical:: l_dummy_isanrg,isanrg

    if (mode <= 0) return
    mode0 = mod(mode,10)
    mode1 = mod(mode/10,10)
    ! ino isanrg is logical function,       call isanrg(linv,-1,0,'pvmix9:','linv', .true.)
    l_dummy_isanrg=isanrg(linv,-1,0,'pvmix9:','linv', .true.)
    ! ino isanrg is logical function,       call isanrg(mode0,0,1,'pvmix9:','1s digit mode', .true.)
    l_dummy_isanrg=isanrg(mode0,0,1,'pvmix9:','1s digit mode', .true.)
    ! ino isanrg is logical function,       call isanrg(mode1,0,2,'pvmix9:','10s digit mode', .true.)
    l_dummy_isanrg=isanrg(mode1,0,2,'pvmix9:','10s digit mode', .true.)

    ! ... Forward
    if (linv == 0) then
       if (mode0 == 1) then
          call dsumdf(nr*nlml,1d0,rho1,off,1,rho2,off,1)
       endif

       if (mode1 == 1) then
          do  ilm = 1, nlml
             do  i = 1, nr
                ri = rofi(i)/rf
                rho1(i+off,ilm) = rho1(i+off,ilm) * exp(-ri**2)
             enddo
          enddo

       elseif (mode1 == 2) then
          do  ilm = 1, nlml
             do  i = 1, nr
                ri = rofi(i)/rf
                rho1(i+off,ilm) = rho1(i+off,ilm) / (1 + ri**2)
             enddo
          enddo
       endif

       ! ... Inverse
    else
       if (mode1 == 1) then
          do  ilm = 1, nlml
             do  i = 1, nr
                ri = rofi(i)/rf
                rho1(i+off,ilm) = rho1(i+off,ilm) * exp(ri**2)
             enddo
          enddo

       elseif (mode1 == 2) then
          do  ilm = 1, nlml
             do  i = 1, nr
                ri = rofi(i)/rf
                rho1(i+off,ilm) = rho1(i+off,ilm) * (1 + ri**2)
             enddo
          enddo
       endif

       if (mode0 == 1) then
          call dsumdf(nr*nlml,0.5d0,rho1,off,1,rho2,off,1)
       endif

    endif

    !      call prrmsh('pvmix9 rho1',rofi,rho1,nr,nr,nlml)
    !      call prrmsh('pvmix9,rho2',rofi,rho2,nr,nr,nlml)

  end subroutine pvmix9



  subroutine pqsclf(mode,nda,npq,offx,off2,nx,na,mxsav,wt,a,a2,rms2)
    !- Split into (a+ + a-) and (a+ - a-); include extra data
    ! ------------------------------------------------------------------
    !i Inputs
    !i   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
    !i   nda   :leading dimension of a
    !i   npq   :number of elements to spin-split with wt(1),wt(2)
    !i   offx  :(nx>0)offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   nx    :number of extra data to weight with w3
    !i   na    :dimension of a2 and number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
    !i   a     :(na,1:2,i,1) output vector for prev. iteration i
    !i         :(na,1:2,i,2) input  vector for prev. iteration i
    !o Outputs
    !o   a2    :(*,i,1) output charge and moments, scaled by weights
    !o         :(*,i,2) input  charge and moments, scaled by weights
    !o   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
    !r Remarks
    !r   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
    !r   If wt(1) or wt(2) is zero, a2 holds q or mom only.
    !r   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
    ! ------------------------------------------------------------------
    !     implicit none
    integer :: mode,nda,npq,nx,mxsav,na,offx,off2
    double precision :: wt(3),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2), &
         rms2,ddot
    integer :: is,ia,ja

    !      print *, '!!'; wt(1) = 1 ; wt(2) = 1
    ja = 0
    if (wt(1) == 0 .AND. wt(2) == 0) goto 11
    do  10  is = 0, mxsav+1
       ja = 0
       do  12  ia = 1, npq

          !         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
          !           print *, 'hi',ia,wt(1:2)
          !           print 987, 'rhold+,-',a(ia,is,2),a(ia+off2,is,2)
          !           print 987, 'rhnew+,-',a(ia,is,1),a(ia+off2,is,1)
          !  987      format(a,2x,4f12.6)
          !C          pause
          !         endif

          if (wt(1) /= 0 .AND. mode == 0) then
             ja = ja+1
             !           Given (rhnew+ + rhnew-)*wt(1) ,  (rhold+ + rhold-)*wt(1)
             a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
             a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          elseif (wt(1) /= 0) then
             ja = ja+1
             a2(ja,is,1) = a(ia,is,1)*wt(1)
             a2(ja,is,2) = a(ia,is,2)*wt(1)
          endif
          if (wt(2) /= 0 .AND. mode == 0) then
             ja = ja+1
             !           Given (rhnew+ - rhnew-)*wt(2) ,  (rhold+ - rhold-)*wt(2)
             a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
             a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          elseif (wt(2) /= 0) then
             ja = ja+1
             a2(ja,is,1) = a(ia+off2,is,1)*wt(2)
             a2(ja,is,2) = a(ia+off2,is,2)*wt(2)
          endif
12     enddo
10  enddo
11  continue

    if (wt(3) /= 0) then
       do  20  ia = 1, nx
          ja = ja+1
          do  22  is = 0, mxsav+1
             a2(ja,is,1) = a(ia+offx,is,1)*wt(3)
             a2(ja,is,2) = a(ia+offx,is,2)*wt(3)
22        enddo
20     enddo
    endif

    rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1)     - &
         2*ddot(na,a2,1,a2(1,0,2),1) + &
         ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))

    if (ja /= na) call rx('pqsclf: element mismatch')

  end subroutine pqsclf
  subroutine pqsclb(nda,npq,offx,off2,nx,na,mxsav,wt,a,a2)
    !- Undo split into wt1*q and wt2*mom done by pqsclf
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   nda   :leading dimension of a
    !i   npq   :number of P,Q
    !i   offx  :offset to location in a of extra elements
    !i   off2  :offset to spin-down (should be 0 for nsp=1)
    !i   nx    :number of extra data
    !i   na    :dimensions a2; number of data with nonzero weight
    !i   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
    !i   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
    !o Outputs
    !o   a     :a2 is unscaled and restored into a
    !r Remarks
    !u Updates
    !u   10 Dec 08
    ! ----------------------------------------------------------------------
    !     implicit none
    integer :: nda,na,npq,nx,mxsav,offx,off2
    double precision :: wt(3),a(nda,0:mxsav+1,2), &
         a2(na,0:mxsav+1,2),sum,diff
    integer :: is,ia,ja

    if (wt(1) == 0 .AND. wt(2) == 0) then
       ja = 0
    elseif (wt(1) /= 0 .AND. wt(2) /= 0) then
       do  is = 0, mxsav+1
          ja = 1
          do  ia = 1, npq
             !          if ((ia .eq. 3221 .or. ia .eq. -3) .and. is .eq. 0) then
             !            print *, 'hi',ia,wt(1:2)
             !            print 987, 'mxold+,-',
             !     .        (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2,
             !     .        (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
             !            print 987, 'mxnew+,-',
             !     .        (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2,
             !     .        (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
             !C 987       format(a,2x,4f12.6)
             !C           pause
             !          endif
             !         mixed  rhonew+,rhold+
             a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
             a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2
             !         mixed  rhonew-,rhold-
             a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
             a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
             ja = ja+2
          enddo
       enddo
       ja = 2*npq
    elseif (wt(1) /= 0) then
       diff = 0
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+off2
             sum  = a2(ia,is,1)/wt(1)
             diff = (a(ia,is,1) - a(ja,is,1))
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             sum  = a2(ia,is,2)/wt(1)
             diff = (a(ia,is,2) - a(ja,is,2))
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    elseif (wt(2) /= 0) then
       do  ia = 1, npq
          do  is = 0, mxsav+1
             ja = ia+npq

             !         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
             !            print *, 'hi',ia,wt(1:2)
             !            print 987, 'given qold, mixed (+)-(-)',
             !     .        (a(ia,is,2) + a(ja,is,2)),a2(ia,is,2)
             !            sum  = (a(ia,is,2) + a(ja,is,2))
             !            diff = a2(ia,is,2)/wt(2)
             !            print 987, 'mixed +,-                ',
             !     .        (sum + diff)/2, (sum - diff)/2
             !  987       format(a,2x,4f12.6)
             !          endif

             !         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
             sum  = (a(ia,is,1) + a(ja,is,1))
             diff = a2(ia,is,1)/wt(2)
             a(ia,is,1) = (sum + diff)/2
             a(ja,is,1) = (sum - diff)/2
             !         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
             sum  = (a(ia,is,2) + a(ja,is,2))
             diff = a2(ia,is,2)/wt(2)
             a(ia,is,2) = (sum + diff)/2
             a(ja,is,2) = (sum - diff)/2
          enddo
       enddo
       ja = npq
    endif

    ! --- Extra mixing data ---
    if (wt(3) /= 0) then
       do  is = 0, mxsav+1
          do  ia = 1, nx
             a(ia+offx,is,1) = a2(ia+ja,is,1)/wt(3)
             a(ia+offx,is,2) = a2(ia+ja,is,2)/wt(3)
          enddo
       enddo
    endif

  end subroutine pqsclb

  subroutine pqsclc(nda,npq,nx,mxsav,a)
    !- Copy a(:,0,2) into a(:,0,1)
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   nda   :leading dimension of a
    !i   npq   :number of P,Q
    !i   nx    :number of extra data
    ! o Inputs/Outputs
    ! o  a     :On input
    ! o        :(*,0,1) mixed output vector
    ! o        :(*,0,2) mixed input vector
    ! o        :On output
    ! o        :(*,0,2) -> (*,0,1)
    !r Remarks
    !u Updates
    !u   10 Dec 08 First created
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nda,npq,nx,mxsav
    double precision :: a(nda,0:mxsav+1,2)
    integer :: is,ia

    is = 0
    do  ia = 1, npq+nx
       !        if (a(ia,is,1) .ne. a(ia,is,2)) then
       !          call rx('pqsclc: oops')
       !        endif
       a(ia,is,1) = a(ia,is,2)
    enddo
    !     stop 'here'

  end subroutine pqsclc

  subroutine pqmixa(nda,nmix,mmix,mxsav,beta,rms2,a,tj)
    !      use m_lgunit,only:stdo
    use m_amix,only: amix
    use m_ftox
    !- Anderson mixing of a vector
    !i  mmix: number of iterates available to mix
    ! o nmix: nmix > 0: number of iter to try and mix
    !i        nmix < 0: use mmix instead of nmix.
    !o  nmix: (abs)  number of iter actually mixed.
    !o        (sign) <0, intended that caller update nmix for next call.
    implicit none
    integer :: nda,nmix,mmix,mxsav
    double precision :: rms2,tj(1),a(nda,0:mxsav+1,2),beta
    integer:: im , imix , jmix , iprint , i1mach !, amix
    real(8),allocatable :: norm_rv(:)
    integer,allocatable :: kpvt_iv(:)
    real(8),allocatable :: a_rv(:)

    double precision :: tjmax
    parameter (tjmax = 10d0)
    ! heap
    !      integer w(1)
    !      common /w/ w

    ! ... default nmix
    if (nmix < 0) nmix = 2
    nmix = min(mmix,nmix)
    allocate(norm_rv(mxsav**2))

    allocate(kpvt_iv(mxsav))

    if (beta < 0) nmix = -nmix
    ! ... imix is a local copy of nmix
    imix = nmix
    if (imix < 0) imix = mmix
    ! ... save PQ array
    allocate(a_rv(nda*(mxsav+2)*2))

    call dcopy ( nda * ( mxsav + 2 ) * 2 , a , 1 , a_rv , 1 )


    ! ... for iterations 1,2,... amix needs F-x
1   continue
    do  10  jmix = 1, nmix
       call daxpy(nda,-1d0,a(1,jmix,2),1,a(1,jmix,1),1)
10  enddo

    !      call query('beta',4,beta)
    jmix = min(mmix,iabs(imix))
    imix = amix ( nda , jmix , mxsav , 0 , dabs ( beta ) , iprint &
         ( ) , tjmax  , a , tj , rms2 ) !, norm_rv , kpvt_iv

    im = imix
    !      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
    if (iabs(imix) > mmix .AND. imix /= im) &
         write(stdo,ftox)' (warning) only',mmix,'iter available'
    if (im /= imix) then
       call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

       goto 1
    endif
    nmix = imix

    ! ... Restore PQ array, updating new x
    call dpscop ( a , a_rv , nda , 1 + nda * ( mxsav + 2 ) , 1 &
         + nda * ( mxsav + 2 ) , 1d0 )

    call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

    if (allocated(a_rv)) deallocate(a_rv)
    if (allocated(kpvt_iv)) deallocate(kpvt_iv)
    if (allocated(norm_rv)) deallocate(norm_rv)


  end subroutine pqmixa
  !      subroutine pqmixb(nda,nmix,mmix,mxsav,wc,rms2,a,wctrue)
  !C- Broyden mixing of a vector, old style
  !C ------------------------------------------------------------------
  ! i  mmix: number of iterates available to mix
  ! i  a:    (*,i,1)  output values for prev. iteration i
  ! i        (*,i,2)  input  values for prev. iteration i
  ! io nmix: nmix > 0: number of iter to try and mix
  ! i        nmix < 0: use mmix instead of nmix.
  ! o  nmix: (abs)  number of iter actually mixed.
  ! o        (sign) <0, intended that caller update nmix for next call.
  ! r  Notations:
  ! r  x^(m): input vector for iteration m
  ! r  F^(m): difference between output and input vector in iteration m
  !C ------------------------------------------------------------------
  !      implicit none
  !      integer nda,nmix,mmix,mxsav
  !      double precision wc,rms2,wctrue,a(nda,0:mxsav+1,2)
  !      double precision tol,ddot,dFm,diff,dval
  !      parameter (tol=1d-12)
  !      integer im,info,i,j,iprint,i1mach,imix,jmix,
  !     .  obt,obtx,ojac,obet,ogam,okpvt,oFmp1,oxmp1,odFm,odxm
  !c heap
  !      integer w(1)
  !      common /w/ w

  !C --- Allocate some arrays ---
  !      call defdr(obt,nda)
  !      call defdr(obtx,nda)
  !      call defdr(ojac,nda**2)
  !      call defdr(obet,nda**2)
  !      call defdr(ogam,nda**2)
  !      call defdr(oFmp1,nda)
  !      call defdr(oxmp1,nda)
  !      call defdr(odFm,nda)
  !      call defdr(odxm,nda)
  !      okpvt = obt
  !      wctrue = 0
  !C ... imix is a local copy of nmix
  !      imix = nmix
  !      if (imix .lt. 0) imix = mmix

  !C --- First Jacobian matrix ---
  !C ... See Eq. A6; for beta, eq. A14; for gamma, eq. A15.
  !C ... x^(2) = x^(1) + [J^(1)]**(-1) * F^(m), so
  !C     J^(1) = F^(1) / [x^(2) - x^(1)]
  !C     Also, beta^(1) = 1 and gamma^(1) = J^(1)
  !    1 continue
  !      call dpzero(w(ojac),nda**2)
  !      call dpzero(w(obet),nda**2)
  !      call dpzero(w(ogam),nda**2)
  !      call dcopy(nda,a(1,mmix,1),1,w(odFm),1)
  !      call daxpy(nda,-1d0,a(1,mmix,2),1,w(odFm),1)
  !      call dcopy(nda,a(1,mmix-1,2),1,w(oxmp1),1)
  !      call dcopy(nda,a(1,mmix,2),1,w(odxm),1)
  !      j = 1
  !      do  20  i = 1, nda
  !        call dvset(w(ogam),j,j,1d0)
  !        call dvset(w(obet),j,j,1d0)
  !        diff = dval(w(oxmp1),i) - dval(w(odxm),i)
  !        dFm  = dval(w(odFm),i)
  !        if (dabs(diff) .gt. tol .and. dFm .ne. 0)
  !     .    call dvset(w(ogam),j,j,dFm/diff)
  !        j = j + 1 + nda
  !   20 continue

  !C --- Starting from iteration mmix, build the Jacobian matrix ---
  !      jmix = min(mmix,iabs(imix))
  !      do  10  im = jmix, 1, -1
  !C  ...  F^(m+1) -> a(*,im-1,1)  x^(m+1) -> a(*,im-1,2)
  !C  ...  dF^(m)  -> a(*,im,1)    dx^(m)  -> a(*,im,2)
  !        call dcopy(nda,a(1,im-1,2),1,w(oxmp1),1)
  !        call dcopy(nda,a(1,im-1,1),1,w(oFmp1),1)
  !        call daxpy(nda,-1d0,w(oxmp1),1,w(oFmp1),1)
  !        call dcopy(nda,w(oxmp1),1,w(odxm),1)
  !        call dcopy(nda,w(oFmp1),1,w(odFm),1)
  !        call daxpy(nda,-1d0,a(1,im,2),1,w(odxm),1)
  !        call daxpy(nda,-1d0,a(1,im,1),1,w(odFm),1)
  !        call daxpy(nda, 1d0,a(1,im,2),1,w(odFm),1)
  !        rms2 = dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/(nda-0))

  !C ---   Determine wc_true if wc < 0 ---
  !        if (wc .lt. 0) then
  !          wctrue = -wc/dsqrt(nda*rms2**2)
  !        else
  !          wctrue = wc
  !        endif

  !C ---   Broyden updates gamma,beta,J, making J^(m+1) ---
  !        call broydn(w(ojac),w(odFm),w(odxm),w(obet),w(ogam),
  !     .    w(obt),w(obtx),nda,wctrue)

  !C ---   Factor Jacobian; linear mixing if singular ---
  !        call dgefa(w(ojac),nda,nda,w(okpvt),info)
  !        if (info .ne. 0) then
  !          if (iprint() .ge. 30)
  !     .      call awrit1(' PQMIXB Broyden iter %i: Jacobian matrix '//
  !     .      'singular',' ',80,i1mach(2),jmix-im+1)
  !        else
  !C     ... Solve J^(m+1) * y = F^(m+1)  with  y = x^(m+2) - x^(m+1)
  !          call dgesl(w(ojac),nda,nda,w(okpvt),w(oFmp1),0)
  !C     ... Make x^(m+2) = y + x^(m+1)
  !          call daxpy(nda,1d0,w(oFmp1),1,w(oxmp1),1)
  !          if (iprint() .gt. 40 .or. iprint() .ge. 30 .and. im .eq. 1)
  !     .      call awrit5(' PQMIXB  Broyden iter %i:  rms(F-x)='//
  !     .      '%1;3e  rms(dx)=%1;3e  wc=%1;3g  nelts=%i',' ',80,i1mach(2),
  !     .      jmix-im+1,dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/nda),
  !     .      rms2,wctrue,nda)
  !        endif

  !   10 continue

  !C --- Check for interactive change of nmix ---
  !C NB negative sign signals request for permanent change in nmix
  !      im = imix
  !      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
  !      if (iabs(imix) .gt. mmix .and. imix .ne. im)
  !     .  call awrit1(' (warning) only %i iter available',
  !     .  ' ',80,i1mach(2),mmix)
  !      if (im .ne. imix) goto 1
  !      nmix = imix
  !C ... If no prior iter allowed, give up on nmix
  !      if (nmix .eq. 0) return

  !C --- Printout ---
  !      if (iprint() .gt. 40) then
  !        print 310
  !        do  12  i = 1, nda
  !          if (dabs(a(i,0,1)-a(i,0,2)) .ge. 5d-9)  print 311, i,
  !     .      a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(w(oxmp1),i)
  !   12   continue
  !  311   format(i5,4f14.6)
  !  310   format(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')
  !      endif

  !C --- Save x^(m+2) into a(*,0,2) and exit ---
  !      if (info .ne. 0) then
  !        nmix = 0
  !        return
  !      endif
  !      call dcopy(nda,w(oxmp1),1,a(1,0,2),1)
  !      call rlse(obt)
  !      end
  subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
    !      use m_lgunit,only:stdo
    use m_ftox
    !- Broyden mixing of a vector, Duane Johnson's approach
    ! ------------------------------------------------------------------
    !i  mmix: number of iterates available to mix
    !i  a:    (*,i,1)  output values for prev. iteration i
    !i        (*,i,2)  input  values for prev. iteration i
    ! o nmix: nmix > 0: number of iter to try and mix
    !i        nmix < 0: use mmix instead of nmix.
    !o  nmix: (abs)  number of iter actually mixed.
    !o        (sign) <0, intended that caller update nmix for next call.
    !r  Notations:
    !r  x^(m): input vector for iteration m
    !r  F^(m): difference between output and input vector in iteration m
    ! ------------------------------------------------------------------
    implicit none
    integer :: nda,nmix,mmix,mxsav
    double precision :: beta,rms2,wctrue,a(nda,0:mxsav+1,2)
    double precision :: ddot,dval,wc
    integer:: im , km , i , iprint , i1mach , imix , jmix
    real(8) ,allocatable :: xmp1_rv(:)

    integer:: broyj
    real(8) ,allocatable :: f_rv(:)
    real(8) ,allocatable :: ui_rv(:)
    real(8) ,allocatable :: vti_rv(:)
    real(8) ,allocatable :: xold_rv(:)
    real(8) ,allocatable :: df_rv(:)
    real(8) ,allocatable :: dx_rv(:)
    real(8) ,allocatable :: wk_rv(:)


    ! heap
    !      integer w(1)
    !      common /w/ w

    ! --- Allocate some arrays ---
    allocate(xmp1_rv(nda))

    allocate(f_rv(nda))

    allocate(ui_rv(nda))

    allocate(vti_rv(nda))

    allocate(xold_rv(nda))

    allocate(df_rv(nda))

    allocate(dx_rv(nda))


    ! ... imix is a local copy of nmix
    imix = nmix
    if (imix < 0) imix = mmix

    ! --- Starting from iteration mmix, build the Jacobian matrix ---
1   jmix = min(mmix,iabs(imix))
    allocate(wk_rv(nda*2*(jmix+2)))

    do  10  km = 1, jmix
       !   ... this loops from most-distant to most-recent
       im = jmix-km+1
       !   ... this loops from most-recent to most-distant
       !       im = km

       call dcopy ( nda , a ( 1 , im - 1 , 1 ) , 1 , dx_rv , 1 )

       call daxpy ( nda , - 1d0 , a ( 1 , im - 1 , 2 ) , 1 , dx_rv &
            , 1 )

       rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( &
            nda - 0 ) )


       ! ---   Determine wc_true if wc < 0 ---
       if (wc < 0) then
          wctrue = -wc/100/dsqrt(nda*rms2**2)
          wctrue = min(max(wctrue,1d0),1d4)
       else
          wctrue = wc
       endif
       if (km == 1) wctrue = .01d0

       i = iprint()
       if (km /= jmix) i = i-20
       i = broyj ( nda , a ( 1 , im - 1 , 2 ) , dx_rv , km , 0 , &
            i , beta , 0d0 , 0d0 , 0d0 , wctrue , wk_rv , nda , xmp1_rv &
            )

10  enddo

    ! --- Check for interactive change of nmix ---
    ! NB negative sign signals request for permanent change in nmix
    im = imix
    !      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
    if (iabs(imix) > mmix .AND. imix /= im) &
         write(stdo,ftox)' (warning) only ',mmix,' iter available'
    if (im /= imix) goto 1
    nmix = imix
    ! ... If no prior iter allowed, give up on nmix
    ! i#error, have return with len(w_varlist)>0 at line 769
    if ( nmix == 0 ) then
       if (allocated(wk_rv)) deallocate(wk_rv)
       if (allocated(dx_rv)) deallocate(dx_rv)
       if (allocated(df_rv)) deallocate(df_rv)
       if (allocated(xold_rv)) deallocate(xold_rv)
       if (allocated(vti_rv)) deallocate(vti_rv)
       if (allocated(ui_rv)) deallocate(ui_rv)
       if (allocated(f_rv)) deallocate(f_rv)
       if (allocated(xmp1_rv)) deallocate(xmp1_rv)
       return
    endif


    ! --- Printout ---
    if (iprint() > 60 .OR. (iprint() >= 40 .AND. nda <= 100)) then
       print 310
       do  12  i = 1, nda
          if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) >= 5d-9 ) &
               print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 &
               , 1 ) - a ( i , 0 , 2 ) , dval ( xmp1_rv , i )

12     enddo
311    format(i5,4f14.6)
310    format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
    endif

    ! --- Save x^(m+2) into a(*,0,2) and exit ---
    call dcopy ( nda , xmp1_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

    if (allocated(xmp1_rv)) deallocate(xmp1_rv)

    if (allocated(f_rv)) deallocate(f_rv)
    if (allocated(ui_rv)) deallocate(ui_rv)
    if (allocated(vti_rv)) deallocate(vti_rv)
    if (allocated(xold_rv)) deallocate(xold_rv)
    if (allocated(df_rv)) deallocate(df_rv)
    if (allocated(dx_rv)) deallocate(dx_rv)
    if (allocated(wk_rv)) deallocate(wk_rv)

  end subroutine pqmixb
  !   subroutine pqmixc(nda,nmix,mmix,mxsav,beta,rms2,a,xn)
  !     use m_gradzr,only:drgrzr
  !     !      use m_lgunit,only:stdo
  !     use m_ftox
  !     !- C. G. mixing of a vector
  !     ! ------------------------------------------------------------------
  !     !i  mmix: number of iterates available to mix
  !     !i  a:    (*,i,1)  output values for prev. iteration i
  !     !i        (*,i,2)  input  values for prev. iteration i
  !     ! o nmix: nmix > 0: number of iter to try and mix
  !     !i        nmix < 0: use mmix instead of nmix.
  !     !o  nmix: (abs)  number of iter actually mixed.
  !     !o        (sign) <0, intended that caller update nmix for next call.
  !     !o  xn:   projection along line minimization.
  !     !o        (sign) <0, new line minimization
  !     !r  Notations:
  !     !r  x^(m): input vector for iteration m
  !     !r  F^(m): difference between output and input vector in iteration m
  !     ! ------------------------------------------------------------------
  !     implicit none
  !     integer :: nda,nmix,mmix,mxsav
  !     double precision :: beta,rms2,xn,a(nda,0:mxsav+1,2)
  !     double precision :: ddot,dval,dxmx,xtoll,grfac,wk(0:26)
  !     save wk
  !     real(8) ,allocatable :: p_rv(:)
  !     real(8) ,allocatable :: dx_rv(:)
  !     integer :: ir,imix,jmix,km,iprint,i1mach,i,idx,idamax
  !     real(8):: ww(1,1) !dummy
  !     ! --- Allocate some arrays ---
  !     allocate(p_rv(nda*6))
  !     allocate(dx_rv(nda))
  !     ! ... imix is a local copy of nmix
  !     imix = nmix
  !     if (imix < 0) imix = mmix

  !     ! --- Starting from iteration mmix, build the Jacobian matrix ---
  ! 1   jmix = min(mmix,iabs(imix))
  !     ir = 0
  !     do  10  km = jmix, 0, -1

  !        call dcopy ( nda , a ( 1 , km , 2 ) , 1 , dx_rv , 1 )

  !        call daxpy ( nda , - 1d0 , a ( 1 , km , 1 ) , 1 , dx_rv , &
  !             1 )

  !        rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( &
  !             nda - 0 ) )

  !        idx = idamax ( nda , dx_rv , 1 )

  !        dxmx = beta * abs ( dval ( dx_rv , idx ) )

  !        xtoll = dxmx/10
  !        grfac = min(2d0,1/beta)
  !        call pshpr(80)
  !        wk(0) = xn
  !        call drgrzr ( nda , a ( 1 , km , 2 ) , dx_rv , p_rv , ww &
  !             , xtoll , dxmx , 1d-10 , 1d-10 , grfac , wk , ' ' , 00040 &
  !             , ir )

  !        xn = wk(0)
  !        call poppr

  ! 10  enddo
  !     if (ir == -1) xn = -xn

  !     ! --- Check for interactive change of nmix ---
  !     ! NB negative sign signals request for permanent change in nmix
  !     km = imix
  !     !      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
  !     if (iabs(imix) > mmix .AND. imix /= km) &
  !          write(stdo,ftox)' (warning) only ',mmix,' iter available'
  !     if (km /= imix) goto 1
  !     nmix = imix

  !     ! --- Printout ---
  !     if (iprint() > 40) then
  !        print 310
  !        do  12  i = 1, nda
  !           if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) >= 5d-9 ) &
  !                print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 &
  !                , 1 ) - a ( i , 0 , 2 ) , dval ( p_rv , i )

  ! 12     enddo
  ! 311    format(i5,4f14.6)
  ! 310    format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
  !     endif

  !     ! --- Save x^(m+2) into a(*,0,2) and exit ---
  !     call dcopy ( nda , p_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

  !     if (allocated(dx_rv)) deallocate(dx_rv)
  !     if (allocated(p_rv)) deallocate(p_rv)

  !   end subroutine pqmixc
  subroutine pqmxup(na,mxsav,nclass,nl,nsp,nx,lmx, &
       pnu,qnu,xnew,pold,qold,xold,cnst,nda,a,rms2)
    !- Copy from holding array into P,Q
    implicit none
    integer :: nda,mxsav,nclass,nl,nsp,nx,lmx(nclass),cnst(0:*)
    double precision :: a(nda,0:mxsav+1,2),rms2, &
         pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx), &
         pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx),ddot
    integer :: ic,isp,l,na,i
    logical :: lcnst

    lcnst = cnst(0) .gt. 0
    na = 1
    rms2 = 0
    do  110  isp = 1, nsp
       do  11  ic = 1, nclass
          if (lcnst) then
             if (cnst(ic) /= 0) goto 11
          endif
          do  12  l = 0, lmx(ic)
             !       print *, pold(l+1,isp,ic) - a(na,0,2)
             pnu(l+1,isp,ic) = a(na,0,2)
             rms2 = rms2 + (qold(1,l+1,isp,ic) - a(na+1,0,2))**2
             do  21  i = 1, 3
                !       print *, i, qold(i,l+1,isp,ic) -  a(na+i,0,2)
                qnu(i,l+1,isp,ic) = a(na+i,0,2)
21           enddo
             na = na+4
12        enddo
11     enddo
110 enddo

    call dcopy(nx,a(na,0,2),1,xnew,1)
    rms2 =  rms2 + ddot(nx,xnew,1,xnew,1) - &
         2*ddot(nx,xnew,1,xold,1) + &
         ddot(nx,xold,1,xold,1)
    na = na + nx
    rms2 = dsqrt(4*rms2/(na-0))
  end subroutine pqmxup
  subroutine pqmxio(nmix,mxsav,ifi,lbin,nclass,nl,nsp,nx,lmx, &
       pnu,pold,qnu,qold,xnew,xold,cnst,nda,a,na,rms2)
    !      use m_lgunit,only:stdo
    use m_ftox
    !- Copy P,Q into holding array, read prior P,Q from disk
    ! -----------------------------------------------------------------
    !i  nmix  number of prior iterations sought; returns no. actually read
    !i  mxsav maximum number of prior iter to save, and dimensions a
    !i  ifi   : >0, copy pnu,qnu to a(1..nda,0,1), pold,qold to a(1..nda,0,2)
    !i          read prior iter into a(1..nda,1..nmix,1..2)
    !i          <0  write a(1..nda,1..nmix,1..2) to disk
    !i          (NB: Does not update pnu,qnu from a)
    !i  lbin  :T: read prior iterations from binary file, else ascii file
    !i  nclass:number of inequivalent classes
    !i  nl    :(global maximum l) + 1
    !i  nsp   :2 for spin-polarized case, otherwise 1
    !i  nx    :number of p,q and number of extra data xnew,xold
    !i  lmx   :lmx(j) = maximum l for atom j
    !i  pnu   :boundary conditions.  If Dl = log. deriv. at rmax,
    !i         pnu = .5 - atan(Dl)/pi + (princ.quant.number).
    !i  qnu   :energy-weighted moments of the sphere charges
    !i  qold  :old moments
    !i  xnew  :additional parameters to be included in mix
    !i  xold  :additional parameters to be included in mix
    !i  cnst  :for each class, if nonzero, copy pold->pnu
    !i  nda   :leading dimension of a (must be at least na)
    ! o Inputs/Outputs
    ! o (Inputs for ifi<0, outputs for ifi>0)
    ! o  a    :array containing input,output of prior iterations.
    ! o       :a is updated with input,output from last iteration.
    ! o       :and prior iterations are read from file ifi
    ! o  na   :number of values included into mix
    !o Outputs
    !i  rms2  :rms change in parameters to be mixed.
    ! -----------------------------------------------------------------
    implicit none
    logical :: lbin
    integer :: nda,nmix,mxsav,ifi,nclass,nl,nsp,lmx(nclass),nx,cnst(0:*)
    double precision :: a(nda,0:mxsav+1,2),rms2, &
         pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx), &
         pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
    ! Local variables
    double precision :: ddot
    integer :: i1mach,ic,na,isp,i,j,k,l,iprint,mmix
    logical :: lcnst

    lcnst = cnst(0) .gt. 0

    ! --- Copy p,q to a; calc. RMS error; read prior iter from ifi ---
    if (ifi > 0) then
       na = 1
       do  100  isp = 1, nsp
          do  10  ic = 1, nclass
             if (lcnst) then
                if (cnst(ic) /= 0) then
                   do  121  l = 0, lmx(ic)
                      pnu(l+1,isp,ic) = pold(l+1,isp,ic)
                      do  21  i = 1, 3
                         qnu(i,l+1,isp,ic) = qold(i,l+1,isp,ic)
21                    enddo
121                enddo
                   goto 10
                endif
             endif
             do  11  l = 0, lmx(ic)
                a(na,0,1) = pnu(l+1,isp,ic)
                a(na,0,2) = pold(l+1,isp,ic)
                do  20  i = 1, 3
                   a(na+i,0,1) = qnu(i,l+1,isp,ic)
                   a(na+i,0,2) = qold(i,l+1,isp,ic)
20              enddo
                na = na+4
11           enddo
10        enddo
100    enddo

       !   ... Append extra vector to a
       call dcopy(nx,xnew,1,a(na,0,1),1)
       call dcopy(nx,xold,1,a(na,0,2),1)
       na = na + nx - 1
       rms2 =  dsqrt(dabs(ddot(na,a,1,a,1) - 2*ddot(na,a,1,a(1,0,2),1) &
            + ddot(na,a(1,0,2),1,a(1,0,2),1))/(na-0))
       !        call prmx('a1',a,na,na,1)
       !        call prmx('a2',a(1,0,2),na,na,1)
       mmix = 0
       if (lbin) then
          do  30  j = 1, min(nmix,mxsav)
             read(ifi,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
             mmix = j
30        enddo
       else
          do  33  j = 1, min(nmix,mxsav)
             read(ifi,333,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
             mmix = j
33        enddo
       endif
       goto 32
31     if (iprint() >= 30) &
            write(stdo,ftox)' PQMXIO:  sought ',nmix,' mixing iter from disk, but read ',mmix
32     continue
       nmix = mmix
       ! --- Save iterations to disk ---
    else
       if (lbin) then
          do  34  j = 0, min(nmix,mxsav)-1
             write(-ifi) ((a(i,j,k), i=1,na), k=1,2)
34        enddo
       else
          do  35  j = 0, min(nmix,mxsav)-1
             write(-ifi,333) ((a(i,j,k), i=1,na), k=1,2)
35        enddo
333       format(1p,4e20.13)
       endif
    endif
  end subroutine pqmxio
  ! testing ...
  !      subroutine fmain
  !      implicit none
  !      integer nclass,nl,nsp
  !      parameter (nclass=2,nl=3,nsp=2)
  !      integer lmx(nclass),fadd,mxsav,mmix,nmix,ifi,nlspc,fopn,i,wksize,
  !     .  nx,iter,fopna
  !      double precision pnu(nl,nsp,nclass),pold(nl,nsp,nclass),
  !     .  qnu(3,nl,nsp,nclass),qold(3,nl,nsp,nclass),wj(10),rms2,
  !     .  rmsdel,pwk(nl,nsp,nclass),qwk(3,nl,nsp,nclass),
  !     .  xnew(100),xold(100),dmxprm(20)
  !      character*82 mixmod
  !      parameter (wksize=250000)
  !      integer w(wksize)
  !      common /w/ w

  !      call wkinit(wksize)
  !      call finits(2,0,0,ifi)
  !      call initqu(.true.)
  !      i = 51
  !      call pshpr(i)

  !      mixmod = 'B,w=0,1,wa=1,fn=mm,k=2'
  !      mixmod = 'B,n=3,w=0,1,wa=1,fn=mm,k=3'
  !      mixmod = 'B,w=1,2,wa=1,b=.4,n=3;B,b=.02,w=2,1,n=3'
  !      dmxprm(1) = 0.0d0
  !      dmxprm(2) = 1.0d0
  !      dmxprm(3) = -1.0d0
  !      dmxprm(4) = 1.0d0
  !      dmxprm(5) = 1.0d0
  !      dmxprm(6) = 50.0d0
  !      dmxprm(7) = -1.0d0
  !      dmxprm(8) = -1.0d0
  !      dmxprm(9) = 1.0d0
  !      dmxprm(10) = -1.0d0
  !      dmxprm(11) = 0.0d0
  !      dmxprm(12) = 0.0d0
  !      dmxprm(13) = 0.0d0
  !      dmxprm(14) = 0.0d0
  !      dmxprm(15) = 0.0d0
  !      dmxprm(16) = 0.0d0
  !      dmxprm(17) = 0.0d0
  !      dmxprm(18) = 0.0d0
  !      dmxprm(19) = 0.0d0
  !      dmxprm(20) = 0.0d0
  !      print *, 'iter?'
  !      read(*,*) iter
  !*     iter = 5
  !      nx = 9*nclass

  !      ifi = fadd('LOG',10,0)
  !      nlspc = nl*nsp*nclass
  !      do  2  i = 1, nclass
  !    2 lmx(i) = 2

  !      ifi = fopna('MIXV',-1,0)
  !      do  10  i = 1, 1
  !      call dfdump(pnu,nlspc,ifi)
  !      call dfdump(pold,nlspc,ifi)
  !      call dfdump(qnu,3*nlspc,ifi)
  !      call dfdump(qold,3*nlspc,ifi)
  !      call dfdump(xnew,nx,ifi)
  !      call dfdump(xold,nx,ifi)
  !      if (i .gt. 1) then
  !        call snot(1*nl*nsp*nclass,pwk,pold)
  !        call snot(3*nl*nsp*nclass,qwk,qold)
  !      endif
  !      call pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxprm,0,
  !     .  pold,qold,xold,pnu,qnu,xnew)
  !      stop 'patch call to shoctl'
  !      call shoctl(nclass,'xx',nl,nsp,lmx,pnu,qnu,
  !     .  0,pnu,fopn('LOG'))

  !   10 continue
  !      end
  !      subroutine snot(n,f1,f2)
  !      implicit none
  !      integer n,i
  !      double precision f1(n),f2(n)

  !      write(*,110)
  !      do  12  i = 1, n
  !        if (dabs(f1(i)-f2(i)) .ge. 5d-9)
  !     .  write(*,111) i,f1(i),f2(i),f1(i)-f2(i)
  !   12 continue
  !  111 format(i5,4f14.6)
  !  110 format(14x,'OLD',11X,' NEW',9X,'DIFF',10X,'MIXED')
  !     end
  logical function parmxp(iter,strn,lstrn,broy,nmix,wgt,beta, &
       elind,mixnam,wc,nkill,betv,rmserr)
    !- Parse strng to get mixing parameters for current iteration
    ! --------------------------------------------------
    !i Inputs
    !i iter: current iteration
    !i       iter=-1 => strn parsed to check integrity of string,
    !i       and optionally to display (iprint().ge.10)
    !i       parmxp does not set parameters broy...betv in this case
    !i strn: string, parsed to extract mixing parameters for this iteration.
    ! o Inputs/Outputs
    ! o rmserr used in a conditional expression to determine whether
    ! o       mixing mode should shift (see "r<expr", Remarks)
    ! o       On output, rmserr is changed to -rmserr if a new mixing block is
    ! o       started caused by the condition rmserr<rmsc. This acts as a signal
    ! o       in the event that one may wish to kill the mix files.
    !o Outputs
    !o   Each of mixing parameters broy,nmix,wgt,beta,mixnam,wc,nkill may be
    !o   updated depending on the current iteration and strn.  Parameters
    !o   not found withing strn take default values (see Remarks).
    !o   broy   0 for linear or Anderson mixing
    !o          1 for Broyden mixing
    !o          2 for conjugate gradients mixing
    !o   nmix   number of prior iterations to include in mix
    !o   wgt    relative weights to assign; see Remarks
    !o   beta   mixing beta (Anderson and CG mixing)
    !o   elind  Lindhard screening parameter (when dielectric F can be est)
    !o   mixnam file name to read prior iterations
    !o   wc     mixing weights for Broyden mixing (see Remarks)
    !o   nkill  for periodic mixing file deletion (see Remarks)
    !o   betv   for independent potential mixing
    !o   parmxp returns false if the parse fails, otherwise true.
    !r Remarks
    !r The general syntax for strn is a sequence of groups of mixing
    !r parameters.  The syntax of one group looks like the following.
    !r   A[nmix][some-parameters--see below][;another-sequence]  or
    !r   B[nmix][some-parameters--see below][;another-sequence]
    !r   thus a ';' indicates the start of a new block in the sequence
    !r   The mixing parameters are as follows:
    !r   ,b=#:   set mixing beta=#.
    !r           (NB: for Broyden mixing, only meaningful to get started)
    !r   ,bv=#[,#2] set extra potential mixing parameter betv to #.  If
    !r           last in this block, set to #2.
    !r   ,n=#    do this mixing for # iterations
    !r   ,k=#    kill the mixing file after # iterations
    !r   ,fn=nam set the mixing file name to 'nam'
    !r   ,wc=#   set Broyden wc to #.  Smaller wc more heavily weights
    !r           most recent iterations.  wc<0 sets wc to abs(wc)*rms error.
    !r   ,w=w1,w2 (spin pol only).  Spin-pol calculations mix up+down and
    !r           up-down.  w1 and w2 are the relative weights to assign
    !r           to these two channels.  w2=0=> magnetic moments frozen;
    !r           w1=0 => total charge is frozen.
    !r   ,wa=#   weight for additonal parameters to be mixed
    !r   ,elind=# Lindhard screening parameter
    !r   ,r<expr continue this block of mixing sequence until rmserr<expr.
    !r           NB: parmxp temporarily loads into the variables table
    !r           the value of errmin, which may be used in parsing expr.
    !r           The latter is set by calling parmx0(0,0,errmin).
    !r           If r<expr is to be used then n=1 must also be set.
    !r Groups are separated by a ";".  parmxp determines which group belongs
    !r   to the current iteration (iter) by adding the number of iterations
    !r   nit for the first group, second group, etc. until their sum exceeds
    !r   the current iteration number (iter).  Thus if strn = "B,n=2;A,n=3",
    !r   the current group would be "B,n=2" for iter = 1,2,6,7,11,12,...
    !r   and would be "A,n=3" for iter = 3,4,5,8,9,10.
    !r Example value of strn : B30,n=8,w=2,1,fn=mxm,wc=11,k=3;A2,b=1
    !r   does 8 iterations of Broyden mixing, followed by Anderson mixing
    !r   The Broyden iterations weight the (up+down) double that of
    !r   (up-down) for the spin pol case, and iterations are saved in a file
    !r   which is deleted at the end of every third iteration.  WC is 11.
    !r   beta assumes the default value.
    !r   The Anderson iterations mix two prior iterations with beta of 1.
    !r Periodic file deletion (nkill):  parmxp returns nkill as -nkill when
    !r   mod(iter-nitj,nkill) is zero, as a signal that the current mixing
    !r   file is to be deleted after it is used.  Here nitj is the sum of
    !r   the number of iterations prior to the current group.
    !b Bugs:
    !b   parmxp cannot tell if this iterations is the last one in a block
    !b   if the constraint rmsc<rmserr is not satisfied.  If it is not,
    !b   betv always returns bv(1).
    !r Defaults:
    !r   nkill has hardwired defaults of -1 and 0.
    !r   nit defaults to infinity
    !r   broy,nmix,wgt,beta,mixnam,wc,betv default to their input values.
    !r   Setting input wgt(3) to -9 signals that wgt(3) is not used.
    !l Local variables
    !l   iblk:  index to current sequence of mixing parameters
    !l   nitj:  effective iter corresponding to last iteration of last
    !l          mixing block, to determine position in current mixing block
    !l   lstblk:index to block of mixing parameters of last call.  Normally
    !l          set and saved internally.  Caller may set lstblk (entry
    !l           parmx0) to fix the current place in the mixing block group.
    !l   lstitj:performs a dual function, depending on sign.
    !l          lstitj<=0: corresponds to -nitj of prior call.  parmxp sets
    !l                     lstitj internally for this mode.
    !l          lstitj>0:  (set by caller), which iteration within the
    !l                     current mixing block the next iteration will
    !l                     correspond to.
    !u Updates
    !u    20 Jul 08 (ATP) returns rmserr as -rmserr to signal new block
    !u    1  Jun 00 added argument elind
    ! --------------------------------------------------
    !     implicit none
    ! Passed parameters
    integer :: broy
    !     character strn*(*),mixnam*8
    character strn*(*),mixnam*8
    integer :: iter,lstrn,nkill,nmix
    double precision :: wgt(3),beta,elind,wc,betv,rmserr
    ! Local variables
    integer :: i,j,np,it(5),parg,nit,nmixj,jp,kp,killj,nitj, &
         iprint,i1mach,a2vec,lstblk,lstitj,iblk,nbump,k,ia0,lbroy
    logical :: lpr,lagain,cmdopt
    character outs*100,fnam*8
    double precision :: bet,elin,wt(3),wcj,rmsc,bv(2),errmin,xx
    ! ... this is the only way to create static variables in fortran
    common /parmx1/ lstblk,lstitj,errmin

    parmxp = .true.
    ia0 = -1
    call bin2a0(ia0)
    ! ... Internal defaults
    if (iter > 0) then
       nkill = 0
       nit = -1
    endif
    if (strn == ' ' .OR. lstrn <= 0) goto 9999
    ! ... Passed defaults
    call bin2a0(10)
    fnam = mixnam
    lbroy = broy
    wcj = wc
    nmixj = nmix
    bet = beta
    elin = elind
    bv(1) = betv
    bv(2) = betv
    wt(1) = wgt(1)
    wt(2) = wgt(2)
    wt(3) = wgt(3)
    nit = -1
    if (wgt(3) == -9) wt(3) = 0
    ! ... lpr: switch to determine whether to print or not
    !     lpr = .false.
    ! ... iblk,iit: current mixing block and iter within block
    iblk = 0
    nitj = 0
    np = 0
    outs = ' mixing: mode=A'

    ! --- Entry point for parsing a new set of switches ---
10  continue
    call skipbl(strn,lstrn,np)
    if (np >= lstrn) then
       if (iter < 0) goto 9999
       if (cmdopt('--nomixcycle',12,0,outs)) then
          nkill = -999
          goto 9999
       else
          np = 0
          goto 10
       endif
    endif
    ! ... Switch for Broyden or Anderson mixing
    jp = np
    call chrps2(strn,'AaBbCc',6,np,jp,it)
    if (it(1) == 0) goto 999
    iblk = iblk+1
    ! ... If iblk=lstblk, override nitj with lstitj
    if (iter > 0 .AND. iblk == lstblk) then
       nitj = -lstitj
       if (lstitj > 0) nitj = iter - lstitj
       lstitj = -nitj
       !  ...  A bug if starting iteration bigger than iter
       if (nitj > iter) call rx('parmxp: bad lstitj')
    endif
    lbroy = 0
    if (it(1) >= 3) lbroy = 1
    if (it(1) >= 5) lbroy = 2
    if (lbroy == 1) call awrit0('%a%bB',outs,len(outs),0)
    if (lbroy == 2) call awrit0('%a%bC',outs,len(outs),0)
    ! ... Pick up nmix
    jp = np+1
    call chrps2(strn,',; ',3,np+1,jp,it)
    if (it(1) == 0) then
       if (a2vec(strn,lstrn,jp,2,',; ',3,1,1,it,nmixj) < 0) goto 999
       call awrit1('%a  nmix=%i',outs,len(outs),0,nmixj)
    endif
    ! ... Pick up rmsc
    rmsc = -1
    jp = np
    ! ... set variable errmin to current value of errmin
    call getsyv('errmin',xx,j)
    call lodsyv('errmin',1,errmin,k)
    i = parg(',r<',4,strn,jp,lstrn,',; ',2,1,it,rmsc)
    ! ... Put back the original one, or remove newly created one
    if (j == k) then
       call lodsyv('errmin',1,xx,k)
    else
       call clrsyv(k-1)
    endif
    if (i < 0) goto 999
    !     if (i .gt. 0) lpr = .true.
    if (rmsc >= 0 .AND. iter < 0) &
         call awrit1('%a  err<%1;3g',outs,len(outs),0,rmsc)
    if (rmsc >= 0 .AND. iter > 0) &
         call awrit2('%a  err(%1;3g)<%1;3g',outs,len(outs),0,rmserr,rmsc)
    ! ... Pick up nit
    jp = np
    i = parg(',n=',2,strn,jp,lstrn,',; ',2,1,it,nit)
    if (i < 0) goto 999
    ! ... increment nit if rmserr>rmsc and iter>=nit+nitj
    nbump = 0
    if (nit /= -1) then
       if (iter < 0) call awrit1('%a  nit=%i',outs,len(outs),0,nit)
       if (iter > 0) then
          call awrit2('%a  it %i of %i',outs,len(outs),0,iter,nit+nitj)
          if (iblk >= lstblk .AND. iter >= nit+nitj .AND. &
               rmserr > rmsc .AND. rmsc > 0) then
             nbump = iter - (nit+nitj) + 1
             nit = nit + nbump
             call awrit0('%a(*)',outs,len(outs),0)
          endif
       endif
    endif

    ! ... ATP added this:
    if (rmserr < rmsc .AND. iblk == lstblk .AND. rmserr /= 0) &
         rmserr = -rmserr

    !      if (nit .eq. -1 .and. iter .gt. 0)
    !     .  call awrit1('%a  it %i of *',outs,len(outs),0,iter)

    !     if (i .gt. 0) lpr = .true.
    ! ... Pick up file name
    jp = np
    i = parg(',fn=',0,strn,jp,lstrn,',; ',2,0,it,0)
    if (i > 0) then
       kp = jp+1
       call chrps2(strn,',; ',3,jp+5,kp,it)
       fnam = strn(jp+1:kp)
       call awrit0('%a  fnam='//fnam,outs,len(outs),0)
       !       lpr = .true.
    endif
    ! ... Pick up mixing wc
    jp = np
    if (lbroy == 1) then
       i = parg(',wc=',4,strn,jp,lstrn,',; ',2,1,it,wcj)
       if (i < 0) goto 999
       !       if (i .gt. 0) lpr = .true.
       if (i > 0) call awrit1('%a  wc=%d',outs,len(outs),0,wcj)
    endif
    ! ... Pick up mixing beta
    jp = np
    i = parg(',b=',4,strn,jp,lstrn,',; ',2,1,it,bet)
    if (i < 0) goto 999
    !     if (i .gt. 0) lpr = .true.
    call awrit1('%a  beta=%d',outs,len(outs),0,bet)
    ! ... Pick up elind
    jp = np
    i = parg(',elind=',4,strn,jp,lstrn,',; ',2,1,it,elin)
    if (i < 0) goto 999
    !     if (i .gt. 0) lpr = .true.
    if (elin /= 0) call awrit1('%a  elind=%;3d',outs,len(outs),0,elin)
    ! ... Pick up weights
    jp = np
    i = parg(',w=',4,strn,jp,lstrn,',; ',2,2,it,wt)
    if (i < 0) goto 999
    jp = np
    j = parg(',wa=',4,strn,jp,lstrn,',; ',2,1,it,wt(3))
    if (j < 0) goto 999
    if (i > 0 .OR. j > 0) then
       call awrit2('%a  wgt=%d,%d',outs,len(outs),0,wt(1),wt(2))
       if (j > 0 .AND. wgt(3) /= -9) then
          call awrit1('%a(%d)',outs,len(outs),0,wt(3))
       elseif (j > 0) then
          call awrit0('%a(-)',outs,len(outs),0)
       endif
    endif
    !...  Pick up iteration number for file kill
    killj = -1
    jp = np
    i = parg(',k=',2,strn,jp,lstrn,',; ',2,1,it,killj)
    if (i < 0) goto 999
    !     if (i .gt. 0) lpr = .true.
    if (killj /= -1) call awrit1('%a  kill=%i',outs,len(outs), &
         0,killj)
    !...  Pick up betv
    jp = np
    i = parg(',bv=',4,strn,jp,lstrn,',; ',2,2,it,bv)
    !     if only one element found, copy 1st element to second:
    if (i == -2) then
       bv(2) = bv(1)
       i = 1
    endif
    if (i < 0) goto 999
    if (i > 0) lpr = .TRUE. 
    if (iter == nitj+nit .AND. iblk >= lstblk) bv(1) = bv(2)
    if (bv(1) /= 1) call awrit1('%a  betv=%1;3g',outs,len(outs),0,bv)
    ! ... If iter < 0, printout and parse through all strings
    if (iter < 0) then
       if (iprint() >= 10) call awrit0('%a',outs,-len(outs),-i1mach(2))
       lagain = nit .ne. -1
       outs = '         mode=A'
    endif

    ! --- If this is last pass, eg nitj <= iter <nitj+nit ---
    if (iter > 0 .AND. iblk >= lstblk .AND. nitj < iter &
         .AND. (iter <= nitj+nit .OR. nit == -1)) then
       if (iprint() >= 20) call awrit0('%a',outs,-len(outs),-i1mach(2))
       broy = lbroy
       nmix = nmixj
       wgt(1) = wt(1)
       wgt(2) = wt(2)
       if (wgt(3) == -9) wt(3) = 0
       wgt(3) = wt(3)
       beta = bet
       elind = elin
       mixnam = fnam
       wc = wcj
       nkill = max(killj,0)
       if (nkill > 1) then
          if (mod(iter-nitj,nkill) == 0) nkill=-nkill
       endif
       if (nkill == 1) nkill=-nkill
       betv = bv(1)
       lstblk = iblk
       lstitj = -nitj
       if (nbump > 0) lstitj = lstitj - (nbump-1)
       !       print *, 'exiting', lstitj,nbump
       goto 9999
    else
       nitj = nitj+nit
       lagain = .true.
       outs = ' mixing: mode=A'
    endif

    !  99 continue
    if (lagain) then
       call chrps2(strn,'; ',2,lstrn,np,it)
       np = np+1
       goto 10
    else
       goto 9999
    endif

    ! --- Error exit ---
999 outs = 'parmxp: parse failed:'//strn(1:lstrn)
    if (iprint() >= 10) call awrit0('%a',outs,-len(outs),-i1mach(2))
    parmxp = .false.
    ! --- Normal exit ---
9999 continue
    call bin2a0(ia0)
  end function parmxp

  subroutine parmx0(i1,i2,errxx)
    !- sets lstblk,lstitj and errmin
    !     implicit none
    integer :: i1,i2,lstblk,lstitj,mode
    double precision :: errxx,errmin
    ! ... this is the only way to create static variables in fortran
    common /parmx1/ lstblk,lstitj,errmin
    if (i1 > 0) lstblk = i1
    if (i2 > 0) lstitj = i2
    if (errxx >= 0d0) then
       if (errmin > 0) errmin = min(errmin,errxx)
       if (errmin == 0) errmin = errxx
    endif
    !     print *, 'errmin=',errmin
    return
    entry parms0(i1,i2,errxx,mode)
    if (mode > 0) then
       i1 = lstblk
       i2 = lstitj
       errxx = errmin
    else
       lstblk = i1
       lstitj = i2
       errmin = errxx
    endif
  end subroutine parmx0

  subroutine dpsadd(adest,asrc,nel,n1,n2,fac)
    !- shift and add. nel=number of elements, n1,n2= start in asrc,adest
    !     implicit none
    integer :: n1,n2,i,iadd,ntop,nel
    double precision :: asrc(1),adest(1),fac
    call daxpy(nel,fac,asrc(n2),1,adest(n1),1)
  end subroutine dpsadd

  subroutine dpsdmp(array,n1,n2,ifile)
    !- Binary I/O of an array segment
    integer :: n1,n2,ifile,length
    double precision :: array(n2)
    length = n2-n1+1
    if (length > 0) call dpdump(array(n1),length,ifile)
  end subroutine dpsdmp

  subroutine pkl2ro(mode,ib,rsm,kmax,nr,nlml,nsp,rofi,rwgt,k0,nlm0, &
       fklc,fklr,rho1,rho2,qmx)
    !- Put PkL or GkL expansion of a function on a radial mesh for one site
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   mode  :a compound of digits :
    !i         :1s digit
    !i         :  0 add P_kL expansion of rho to rho1 (and possibly rho2)
    !i         :    Here, fkl are coffs to P_kL expansion
    !i         :  1 add G_kL expansion of rho to rho1 (and possibly rho2)
    !i         :    Here, fkl are coffs to G_kL expansion
    !i         :10s digit
    !i         :  0 add expansion to rho1 only; rho2 is not touched
    !i         :  1 add expansion to both rho1 and rho2
    !i         :100s digit
    !i         :  0 coefficients fkl are real (uses fklr)
    !i         :  1 coefficients fkl are complex (uses fklc)
    !i         :1000s digit
    !i         :  0 do not initialize rho1,rho2 before adding expansion
    !i         :  1 initialize rho1,rho2 before adding expansion
    !i         :10000s digit for spin polarized case
    !i         :  1 zero out charge, rho1+ + rho1- (and rho2+ + rho2-)
    !i         :  2 zero out spin, rho1+ - rho1- (and rho2+ + rho2-)
    !i   ib    :site index (used in addressing fkl expansion)
    !i   rsm   :smoothing radius for P_kL (or G_kL) expansion
    !i   kmax  :k-cutoff for P_kL (or G_kL) expansion
    !i   nr    :number of radial mesh points
    !i   nlml  :L-cutoff for rho1,rho2
    !i   nsp   :2 if fkl is spin-pol; 1 if not
    !i   rofi  :radial mesh points
    !i   rwgt  :radial mesh weights
    !i   k0    :leading dimension of fkl
    !i   nlm0  :second dimension of fkl
    !i   fklc  :complex coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !i   fklr  :real coefficients to P_kL (or G_kL) expansion for this site
    !i         :(only one of fklc or fklr is used; see mode)
    !o Outputs
    !o  rho1  :fkL P_kL (or G_kL) added to local true density rho1
    !o  rho2  :fkL P_kL (or G_kL) added to local smoothed density rho2
    !i   qmx   :charge in rho1 after fkl PkL is added
    !r Remarks
    !u Updates
    !u   21 Nov 01 First created
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: mode,ib,k0,kmax,nlm0,nr,nlml,nsp
    double precision :: qmx,rsm
    double precision :: rofi(nr),rwgt(nr)
    double precision :: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp)
    double complex   fklc(0:k0,nlm0,nsp,ib)
    double precision :: fklr(0:k0,nlm0,nsp,ib)
    ! ... Local parameters
    integer :: lmx,i,ilm,isp,k,l,ll,lmxl,mode0,mode1,mode2,mode3,mode4,np
    double precision :: add,pi,r,rl,srfpi,sum1
    parameter(lmx=10)
    double precision :: fkl(0:kmax,nlm0,2),pkl(0:kmax,0:lmx)

    pi = 4d0*datan(1d0)
    srfpi = dsqrt(4*pi)
    lmxl = ll(nlml)
    mode0 = mod(mode,10)
    mode1 = mod(mode/10,10)
    mode2 = mod(mode/100,10)
    mode3 = mod(mode/1000,10)
    mode4 = mod(mode/10000,10)

    if (lmxl > lmx) call rxi('pklr2o: increase lmx, need',lmxl)
    if (nlml > nlm0) call rxi('pklr2o: increase nlm0, need',nlml)

    do  isp = 1, nsp
       do  ilm = 1, nlml
          do  k = 0, kmax
             if (mode2 == 0) then
                fkl(k,ilm,isp) = fklr(k,ilm,isp,ib)
             else
                fkl(k,ilm,isp) = dble(fklc(k,ilm,isp,ib))
             endif
          enddo
       enddo
    enddo

    if (mode3 == 1) call dpzero(rho1,nr*nlml*nsp)
    if (mode3 /= 0 .AND. mode1 /= 0) call dpzero(rho2,nr*nlml*nsp)

    do  i = 2, nr
       r = rofi(i)
       if (mode0 == 0) then
          call radpkl(r,rsm,kmax,lmxl,kmax,pkl)
       else
          call radgkl(r,rsm,kmax,lmxl,kmax,pkl)
       endif
       do  ilm = 1, nlml
          l = ll(ilm)
          rl = r**l
          do  isp = 1, nsp
             if (mode1 /= 0) then
                do  k = 0, kmax
                   add = fkl(k,ilm,isp)*pkl(k,l)*r*r*rl
                   rho1(i,ilm,isp) = rho1(i,ilm,isp) + add
                   rho2(i,ilm,isp) = rho2(i,ilm,isp) + add
                enddo
             else
                do  k = 0, kmax
                   add = fkl(k,ilm,isp)*pkl(k,l)*r*r*rl
                   rho1(i,ilm,isp) = rho1(i,ilm,isp) + add
                enddo
             endif
          enddo
       enddo
    enddo
    sum1 = 0d0
    do  isp = 1, nsp
       do  i = 1, nr
          sum1 = sum1 + rwgt(i)*rho1(i,1,isp)
       enddo
    enddo
    qmx = sum1*srfpi

    ! zero out spin or charge
    if (mode4 == 0 .OR. nsp /= 2) return
    i = 20                   ! No core
    if (mode1 == 0) i = 30 ! No rho2
    call splrho(i,nsp,nr,nlml,rho1,rho2,sum1)
    np = nr*nlml
    if (mode4 == 1) then   ! Zero density
       call dpzero(rho1(1,1,1),np)
       if (mode1 /= 0) then ! Including rho2
          call dpzero(rho2(1,1,1),np)
       endif
    endif
    if (mode4 == 2) then   ! Zero spin
       call dpzero(rho1(1,1,nsp),np)
       if (mode1 /= 0) then ! Including rho2
          call dpzero(rho2(1,1,nsp),np)
       endif
    endif
    call splrho(i+1,nsp,nr,nlml,rho1,rho2,sum1)

  end subroutine pkl2ro
end module m_mixrho

subroutine splrho(mode,nsp,nr,nlml,rho1,rho2,rhoc)
  !- Overwrite spin pol local rho+,rho- with rho,rho+ - rho-, or reverse
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   mode  :1s digit
  !i         :0 input (rho+,rho-) -> (rho+ + rho-, rho+ - rho-)
  !i         :1 input (rho+ + rho-, rho+ - rho-) -> (rho+,rho-)
  !i         :10s digit
  !i         :1 suppress splitting of rho2
  !i         :2 suppress splitting of rhoc
  !i         :3 suppress both
  !i   nsp   :2 for spin-polarized case, otherwise 1
  !i   nr    :number of radial mesh points
  !i   nlml  :L-cutoff
  !i   rho1  :local true density, tabulated on a radial mesh
  !i   rho2  :local smoothed density, tabulated on a radial mesh
  !i   rhoc  :core density
  !r Remarks
  !u Updates
  ! ----------------------------------------------------------------------
  implicit none
  integer :: mode,nsp,nr,nlml
  double precision :: rho1(nr,nlml,nsp),rho2(nr,nlml,nsp),rhoc(nr,nsp)
  double precision :: fac
  if (nsp == 1) return
  fac = 1
  if (mod(mode,10) /= 0) fac = .5d0
  call dsumdf(nr*nlml,fac,rho1,0,1,rho1(1,1,2),0,1)
  if (mod(mod(mode/10,10),2)  == 0) call dsumdf(nr*nlml,fac,rho2,0,1,rho2(1,1,2),0,1)
  if (mod(mod(mode/10,10)/2,2) == 0) call dsumdf(nr,fac,rhoc,0,1,rhoc(1,2),0,1)
end subroutine splrho

subroutine lgstar(mode,ng,n,gv,ng0,ips0,cg)
  !- Compresses F.T. of a real function, using fact it is hermitian
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   mode  :0, count number of inequivalent points ng0,
  !i             and make ips0.  cg is not used.
  !i         :1  same as mode 0, but also compress cg
  !i         :2  use ips0 to undo compression of cg
  !i   ng    :number of G-vectors
  !i   n     :cg array holds n functions;
  !i   gv    :list of reciprocal lattice vectors G (gvlist.f)
  !o   ng0   :(mode=2) number of inequivalent points
  !i   ips0  :(mode=2) permutation array.
  !i   cg    :list of g-vectors for each of n functions
  !o Outputs
  !o   ng0   :(mode=0,1) number of inequivalent points
  !o   ips0  :(mode=0,1) array of permutation indices.  A negative value
  !o         :signifies the point's hermitian counterpart falls earlier in
  !o         :the list, and points to that element.
  !r Remarks
  !r   Hacked from svgsym, using only one symmetry operation
  !r   to reduce (G,-G) pairs to a single element.
  !u Updates
  ! ----------------------------------------------------------------------
  !     implicit none
  integer :: mode,ng,n,ips0(ng),ng0,iprint
  double precision :: gv(ng,3)
  double complex cg(ng,n)
  integer :: i,i0,i00,irep,k,j,j0,lwarn,m
  double precision :: v(3),df
  if (mode < 0 .OR. mode > 2) call rxi('lgstar, bad mode',mode)
  lwarn = 0
  if (mode == 2) goto 200

  ! --- mode = 0,1 ---
  ng0 = 0
  do  5  i = 1, ng
     ips0(i) = 0
5 enddo

  ! --- Main loop: look for next unclassified vector ---
  i00 = 1
  do  10  irep = 1, ng+1
     i0 = 0
     do  12  i = i00, ng
        i0 = i
        if (ips0(i) == 0) goto 80
12   enddo
     goto 81
80   continue
     !   ... Apply all point ops, find in list, add to phase sum
     ng0 = ng0 + 1
     ips0(i0) = ng0
     if (mode == 1)  then
        do  21  m = 1, n
           cg(ng0,m) = cg(i0,m)
21      enddo
     endif
     do  20  k = 1, 1
        v(1) = gv(i0,1)
        v(2) = gv(i0,2)
        v(3) = gv(i0,3)
        do  22  j = i0+1,ng
           df = (v(1)+gv(j,1))**2+(v(2)+gv(j,2))**2+(v(3)+gv(j,3))**2
           j0 = j
           if (df < 1d-8) goto 70
22      enddo
        !     ... No matching vector here ... should only happen for G=0
        i00 = i0
        goto 10
70      continue
        ips0(j0) = -i0
        if (mode == 1) then
           if (abs(cg(i0,1)-dconjg(cg(j0,1))) > 1d-9) lwarn = lwarn+1
        endif
20   enddo
     i00 = i0
10 enddo
  call rxi('bug in lgstar, irep=',irep)
81 continue
  if (lwarn > 1 .AND. iprint() >= 10) print 345, lwarn
345 format(' lgstar (warning):',i6, ' points not hermitian')
  return
  ! --- mode = 2 ---
200 continue
  ! ... Unpack original points first
  do    m = 1, n
     do    i = ng, 1, -1
        k = ips0(i)
        if (k > 0) cg(i,m) = cg(k,m)
     enddo
  enddo
  ! ... Unpack hermitian points
  do    m = 1, n
     do    i = 1, ng
        k = -ips0(i)
        if (k > 0) cg(i,m) = dconjg(cg(k,m))
     enddo
  enddo
end subroutine lgstar


subroutine dsumdf(n,scal,a1,ofa1,l1,a2,ofa2,l2)
  !- Returns scaled sum and difference of two vectors
  ! ----------------------------------------------------------------
  !i Inputs
  !i   n    :number elements to scale and combine
  !i   scal :scale sum and difference by scal; see Outputs
  !i   a1   :first vector
  !i   ofa1 :offset to first entry in a1
  !i   l1   :skip length in a1
  !i   a2   :second vector
  !i   ofa2 :offset to first entry in a2
  !i   l2   :skip length in a2
  !o Outputs
  !o   a1   :a1 <- scal*(a1+a2)
  !o   a2   :a1 <- scal*(a1-a2)
  ! ----------------------------------------------------------------
  !     implicit none
  ! Passed parameters
  integer :: n,l1,l2,ofa1,ofa2
  double precision :: scal, a1(1), a2(1)
  ! Local parameters
  real(8) ,allocatable :: a_rv(:)
  ! --- a1-a2-> temp;  a1+a2 -> a1;  temp -> a2 ---
  allocate(a_rv(n))
  call dcopy ( n , a1 ( 1 + ofa1 ) , l1 , a_rv , 1 )
  call daxpy ( n , - 1d0 , a2 ( 1 + ofa2 ) , l2 , a_rv , 1 )
  call daxpy (n,1d0,a2(1+ofa2),l2,a1(1+ofa1),l1)
  call dcopy ( n , a_rv , 1 , a2 ( 1 + ofa2 ) , l2 )
  deallocate(a_rv)
  if (scal == 1) return
  call dscal(n,scal,a1(1+ofa1),l1)
  call dscal(n,scal,a2(1+ofa2),l1)
end subroutine dsumdf

subroutine dpdump(array,length,ifile)
  !     - Binary I/O of an array
  integer:: length,ifile
  double precision :: array(length)
  if (ifile > 0) read(ifile) array
  if (ifile < 0) write(-ifile) array
end subroutine dpdump
logical function lddump(array,length,ifile)
  !- Binary I/O of an array, returning T if I/O without error or EOF
  !     implicit none
  integer :: length,ifile
  double precision :: array(length),xx,yy
  lddump = .true.
  if (ifile > 0) then
     yy = array(length)
     !       (some random number)
     xx = -1.9283746d0*datan(1d0)
     array(length) = xx
     read(ifile,end=90,err=91) array
     if (xx /= array(length)) return
     array(length) = yy
     goto 90
90   continue
91   continue
     lddump = .false.
  else
     write(-ifile) array
  endif
end function lddump

subroutine ftlxp2(rsmv,tau,kmxvin,k0,nlm,ng,gv,g2,yl,h,cv,fkl)
  implicit none
  ! ... Passed parameters
  integer :: k0,kmxvin,ng,nlm
  double precision :: rsmv,yl(ng,1),tau(3),gv(ng,3),g2(ng)
  double complex h(ng),cv(ng),fkl(0:k0,nlm)
  ! ... Local parameters
  integer :: i,ilm,k
  double precision :: scalp,sum1,sum2,pi,gam

  pi = 4d0*datan(1d0)
  gam = 0.25d0*rsmv**2

  ! ... Init h with conjg(phase) * exponential factor * coeff
  do  i = 1, ng
     scalp = -2*pi*(tau(1)*gv(i,1)+tau(2)*gv(i,2)+tau(3)*gv(i,3))
     h(i) = dcmplx(dcos(scalp),-dsin(scalp))*dexp(-gam*g2(i))*cv(i)
  enddo

  ! ... Loop over k and ilm, do the scalar products with cv
  do  k = 0, kmxvin
     do  ilm = 1, nlm
        sum1 = 0d0
        sum2 = 0d0
        do  i = 1, ng
           sum1 = sum1 + dble(h(i))*yl(i,ilm)
           sum2 = sum2 + dimag(h(i))*yl(i,ilm)
        enddo
        fkl(k,ilm) = dcmplx(sum1,sum2)
     enddo
     !   ... Multiply h to get next k-th power of (-g2)
     do  i = 1, ng
        h(i) = -h(i)*g2(i)
     enddo
  enddo
end subroutine ftlxp2
integer function parg(tok,cast,strn,ip,lstr,sep,itrm,narg,it,res)
  !- Returns vector of binary values from a string
  ! ----------------------------------------------------------------------
  !i Inputs
  !i   tok:  token marking input
  !i  cast:  0=logical, 2=int, 3=real, 4=double
  !i  strn(ip:lstr):string to parse, from (ip=0 for first char)
  !i  lstr:  length of strn
  !i  sep:   string of characters, each of which separates arguments
  !i  itrm:  characters sep(itrm:*) signal the last argument
  !i  narg:  number of values to parse.
  ! o Inputs/Outputs
  !o   ip:   on input, position in strn where to start parsing
  !o         on ouput, position in strn on exit.
  !o Outputs
  !o   res:  Vector of numbers that were converted
  !o   it:   Vector of indices, one for each entry in res, labeling
  !o         which char in 'sep' terminated the expr. for that entry.
  !o parg:   0 if token is not matched in strn.
  !o         n if token match and converted sans error narg numbers
  !o           (for narg=0, returns 1 if token matched)
  !o        -n if error on conversion of argument n
  ! ----------------------------------------------------------------------
  !     implicit none
  ! Passed Parameters
  integer :: lstr,ip,cast,narg,itrm,it(1)
  character*(*) tok,sep,strn
  double precision :: res(narg)
  ! Local Variables
  logical :: ldum,parstr
  character term*1
  integer :: jp,np,nsep,lentok,a2vec
  nsep = len(sep)
  lentok = len(tok)
  term = tok(lentok:lentok)
  ! --- Find end of string ---
  jp = ip
  it(1) = 0
  if (itrm <= nsep) &
       call chrps2(strn,sep(itrm:nsep),nsep-itrm+1,lstr,jp,it)
  if (it(1) /= 0) then
     np = jp
  else
     np = lstr
  endif
  !     print *, 'np,lstr=',np,lstr,ip,jp
  ! --- Parse for tok within string strn, returning 0 if missing  ---
  !      print *, tok
  !      print *, strn
  if (tok /= ' ') then
     if (narg == 0 .AND. np == lentok) then
        ip = np+1
        parg = 0
        if (strn(1:np) == tok(1:np)) parg = 1
        return
     elseif ( .NOT. parstr(strn,tok,np-lentok,lentok,term,ip,jp)) then
        parg = 0
        ip = np+1
        return
     endif
  else
     jp = ip
  endif
  ! --- Parse for vector of binary values to convert
  if (narg == 0) then
     ip = jp
     parg = 1
     return
  endif
  ip = jp
  parg = a2vec(strn,np,ip,cast,sep,nsep,itrm,narg,it,res)
end function parg

