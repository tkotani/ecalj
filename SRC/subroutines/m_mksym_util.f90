module m_mksym_util !utities for m_mksym
  use m_lgunit,only:stdo
  use m_ftox
  public gensym,grpgen,symtbl, word,words,nword,splcls
  private
  real(8),parameter:: toll=1d-4,tiny=1d-4
contains
  subroutine gensym(slabl,gens,symfind,lcar,lfix,lsmall,nbas, nspec,ngmx,plat,platcv,bas,ips,nrspec,ng,g,ag, & ! Generate the space group ops
       ngen,gen,nwgens,nggen,isym,istab)  
    !i Inputs:
    !i   slabl: name of the different species.
    !i   gens:  a list of generators, in symbolic representation  NB: this list is not required; see Remarks.
    !i   symfind:0 Find any additional group operations for this basis. 0 is T.
    !i          1 Also, extra basis atoms are added as needed to guarantee the group operations created from gens are valid.
    !i          2 Do neither 0 nor 1.
    !i   lcar:  (not used)
    !i          T express ag,positions in cartesian coordinates
    !i          F express in units of conventional unit cell
    !i   lfix:  T: do not rotate or shift lattice
    !i   nspec: number of classes, atoms in same class are symmetry-related
    !i   plat:  primitive lattice vectors (scaled by alat)
    !i   platcv:Used to scale translation part of generators,
    !i         :when translation part specified as a multiple of
    !i         :lattice vectors.  Can be same as plat but
    !i         :primitive lattice vectors of "conventional unit cell"
    !i         :are sometimes used to specify these translations, e.g.
    !i         :when generated from spacegroup data in some books.
    !i   ldist: lattice deformation matrix key; see lattdf
    !i   dist:  lattice deformation matrix; see lattdf
    ! o Inputs/Outputs (altered only if symfind=F)
    ! o  nbas:  On input, number of atoms in the basis
    ! o         On output nbas may be enlarged, depending symops and symfind
    ! o  bas:   basis vectors
    ! o         On output bas may be enlarged, depending symops and symfind
    ! o  ips:   the jth atom belongs to spec ips(j)
    ! o         On output ips may be enlarged, depending symops and symfind
    !o Outputs:
    !o   istab: site ib is transformed into istab(ib,ig) by operation ig
    !o   g:     symmetry operation matrix (assumed dimensioned >=ngmx)
    !o   ag:    symmetry operation vector (assumed dimensioned >=ngmx)
    !o   ... The following are generated if symfind=F
    !o   isym:  numbers characterizing the symmetry of lattice and crystal
    !o          isym(1) produces index for underlying lattice (see symlat)
    !o   lsmall:if T: a smaller unit cell can be found
    !o   nrspec:number of atoms in the ith class
    !o   ng:    number of group operations
    !o   ngen:  number of symmetry generators
    !o   gen:   generators in matrix form
    !o   nwgens:generators in ascii form
    !o   nggen :number of group ops generated by generators.
    !o         :Usually nggen=ng; however nggen can exceed ng if
    !o         :supercell is artificial -> extra translations; see groupg
    !l Local variables
    !l   modes: 0 -> sgroup compares point and space groups
    !l          1 -> sgroup compares point groups only
    !l          (set with 'points' keyword in gens)
    !r Remarks:
    !r   gensym generates the space group, using the following prescription:
    !r     1.  Any generators supplied from input gens
    !r         are checked for consistency with the underlying lattice.
    !r     2.  The space group is made from these generators.
    !r     3.  if symfind<2, missing basis atoms are added to make
    !r         the basis consistent with the supplied symmetry.
    !r     4.  nrspec is created
    !r     ... Unless symfind is 0, nothing more is done
    !r     5.  The point group of the underlying lattice without the
    !r         basis is generated.
    !r     6.  The full space group is generated from the point group
    !r     7.  A set of generators for this group is created
    !r   This program was adapted from the Stuttgart ASA version lmto-46.
    !b Bugs:
    !b   auto symmetry finder can fail with supercells, where extra
    !b   group operations include the same point group but inequivalent
    !b   translations.  Solution: have symcry call sgroup to see
    !b   if the space group is enlarged.  If so, space group should be
    !b   enlarged.
    !u Updates
    !u   04 Jan 06 Enabled keyword 'point' in ssymgr, returns if ng>ngmx
    !u   13 Dec 03 Uses platcv when scaling translation part of symgrp
    !u   05 Apr 03 Call sgroup looking only for point group ops;see bugs
    !u   03 Nov 01 Shortened argument list, eliminating duplicate bas,ips
    implicit none
    integer :: nbas,isym(*),istab(nbas,*),nspec,ngen,ngmx, ng,nrspec(nspec),symfind,ips(nbas),nggen 
    double precision :: plat(3,3),platcv(3,3),g(3,3,*),ag(3,*),bas(3,nbas)
    character(8) ::  slabl(*), gens*(*), nwgens*(*)
    logical :: lcar,lfix
    integer:: i , j , ibas , ic , iprint , ngnmx , igen , mxint , modes,ig
    real(8) ,allocatable :: wk_rv(:)
    double precision :: qlat(3,3),vol,platt(3,3)
    logical :: lsmall!,latvec
    parameter(ngnmx=10)
    real(8) :: gen(3,3,ngnmx),agen(3,ngnmx)
    integer ::iwdummy,iwdummy1(1)
    character(8):: xn
    call rxx(.not. lcar, 'gensym not implemented lcar')
    call rxx(lfix,  'gensym not implemented lfix')
    call rxx(lsmall,'gensym not implemented lsmall')
    call dinv33(plat,1,qlat,vol) !Reciprocal lattice vectors --- 
    nwgens = gens
    modes = 0
    call words(gens,ngen)
    if (ngen > 0) then
       call word(gens,ngen,i,j)
       call psymop(gens(1:j),platcv,gen,agen,ngen)     ! Symmetry group as given by input generators ---
       nwgens = gens(1:j)
    endif
    do igen = 1, ngen
       platt=matmul(gen(:,:,igen),plat) !call grpprd(gen(1,igen),plat,platt)
       if(.NOT.latvec(3,toll,qlat,platt)) call rx('GENSYM: imcompatible with lattice generators. igen='//trim(xn(igen)))
    enddo
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111    
    !write(6,*)'goto sgroup',ngen  !  do i=1,ngen     !       write(stdo,ftox)i,' gen agen=',ftof(gen(:,i),2),' ',ftof(agen(:,i),3)    !    enddo
    call sgroup(10+modes,gen,agen,ngen, g,ag,nggen,ngmx,qlat)! ... Set up space group (g,ag,ng) given point group generators gen
    !    write(stdo,ftox)'end of sgroup ngen nggen ngmx',ngen,nggen,ngmx,ftof(ag(:,1),3)
    ng = min(nggen,ngmx)
    if (nggen > ngmx) return
    i = maxval(ips) 
    if (i /= nspec.AND.iprint() > 0)write(stdo,ftox)' GENSYM (warning)',nspec,'species supplied but only',i,'spec used ...'
    nspec = i
    nrspec=0 
    do ibas = 1, nbas
       ic = ips(ibas)
       nrspec(ic) = nrspec(ic)+1
    enddo
    if (symfind == 0) then !Complete the space group. SYMGRP find. symfind=T
       call symlat(plat,ng,g,isym(1)) !Symmetry of lattice without bas
       call symcry(bas, ips,nbas,nspec,nrspec,ng,plat,qlat,g,ag,istab ) ! Symmetry of lattice with bas
       if (ng > ngmx) return
       nwgens = ' '
       groupgblock:block !two groups compare to equal when both their point and space parts compare equal
         !i   g:symmetry operation symbol,!i   ng:number of symmetry operations as supplied by the generators
         !o Outputs:
         !o   gen,ngen:generators, and number needed to produce g
         !o   nggen :number of group ops generated by (gen,ngen)
         !o         :usually nggen=ng unless artificial translations
         !o   nwgens  :ascii representation of generators
         integer :: imax,isop,ngloc,ngmax,iprint,ngen0,ngmx,i1,i2,j1,j2,icount,ngmax2
         parameter (ngmx=48)
         character(100) :: sg,sg1,sout,sout2
         real(8)::gloc(3,3,ngmx),agloc(3,ngmx),xx,vec(3)
         call pshpr(1)
         ngen0 = ngen
         call sgroup(0,gen,agen,ngen, gloc,agloc,nggen, ngmx,qlat)
         icount=0
         ngmax2=0
         do ! a set of generators (gen,agen) to maximize number of spc operations
            icount=icount+1
            imax = 0
            ngmax = 0
            do  isop = 1, ng!   ... Run through all symops, choosing whichever adds the most ops
               gen(:,:,ngen+1)= g(:,:,isop) 
               agen(:,ngen+1) = ag(:,isop)  
               call sgroup(0,gen,agen,ngen+1, gloc,agloc,ngloc,ngmx,qlat)
               if (ngloc > ngmax) then
                  imax = isop
                  ngmax = ngloc
                  nggen = ngloc
               endif
            enddo
            if(ngmax>ngmax2) then
               ngmax2=ngmax
            else
               exit
            endif
            ngen = ngen+1
            gen(:,:,ngen)= g(:,:,imax) 
            agen(: ,ngen)= ag(: ,imax) 
            if(iprint()>0) write(6,*)'Enlarging ngen=',ngen,' ng nggen=',ng,nggen
         enddo
         call poppr
         if(iprint()>0.and. ngen0 == 0) then     ! --- Create nwgens, optionally printout ---
            write(stdo,ftox)' groupg: the following are sufficient to generate the space group:'
         elseif(iprint()>0) then
            write(stdo,ftox)' groupg:',ngen-ngen0,'generator(s) were added to complete the group:'
         endif
         sout = ''
         sout2 = ''
         do isop = 1, ngen
            call asymop(gen(1,1,isop),agen(1,isop),':',sg) !cartesian
            sout=trim(sout)//' '//trim(sg)
            call asymop(gen(1,1,isop),matmul(agen(1:3,isop),qlat(:,:)),'::',sg1) !fractional
            sout2=trim(sout2)//' '//trim(sg1) 
         enddo
         if (ngen > ngen0 .AND. iprint() >= 20) then
            write(stdo,"('  Generators:  trans(cart)= ', a)")trim(adjustl(sout)) 
            write(stdo,"('  Generators:: trans(frac)= ', a)")trim(adjustl(sout2))
         endif
         nwgens = sout2
         if(iprint()>0.and.nggen>ng)write(stdo,ftox)' (warning)ng=',ng,' ops supplied but generators create nggen=',nggen,' ops'
       endblock groupgblock
    else
       call symtbl(0,nbas,iwdummy1,bas,g,ag,ng,qlat,istab )
       nggen = ng
    endif
    if(iprint()>0) then
       write(stdo,"(a)")' gensym: site permutation table for group operations ...'
       write(stdo,"('  ib/ig:',48i3)")  [(ig,ig=1,ng)]
       do i = 1, nbas
          write(stdo,"(i7,':',48i3)") i,(istab(i,ig), ig=1,ng)
       enddo
    endif
  end subroutine gensym
  subroutine sgroup(mode,gen,agen,ngen,g,ag,ng,ngmx,qb)  !- Sets up space group ops for given generators.
    !i Inputs
    !i   mode  :a compound set of switches
    !i         :1s digit
    !i         :0 two groups compare to equal when both their point
    !i         :  and space parts compare equal
    !i         :1 two groups compare to equal when their point
    !i         :  group compares equal.  This eliminates
    !i         :  space groups that that have the same point group
    !i         :  but differing translational symmetry, which can
    !i         :  occur for artifically large supercells
    !i         :10s digit
    !i         :0 if ng>ngmx, abort with error message
    !i         :1 if ng>ngmx, return with ng=ngmx+1
    !i   gen   :rotation part of generators of the group
    !i   agen  :translation part of space group generator
    !i   ngen  :number of generators
    !i   ngmx  :maximum allowed number of group operations
    !i   qb    :vectors of a microcell in the Brillouin zone
    !o Outputs
    !o   g     :point group operations
    !o   ag    :translation part of space group
    !o   ng    :number of group operations
    !r Remarks
    !r   Operations are defined as (g,a)(v):=g*v+a
    !r   where g is a (3x3) matrix, a is a vector.
    !r   Always returns the identity operation as one group operation
    !u Updates
    !u   04 Jan 06 Added 10s digit mode
    !u   14 Mar 03 Added mode
    ! ----------------------------------------------------------------------
    implicit none
    integer:: mode,ngen,ng,ngmx
    integer:: ipr,igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,is,nnew,n,m,mode0,mode1
    real(8):: gen(3,3,ngen),g(3,3,ngmx),qb(3,3),agen(3,ngen),ag(3,ngmx), &
         h(3,3),hh(3,3),sig(3,3),asig(3),ah(3),ahh(3),ae(3)
    character:: sout*80,sg*35
    real(8),parameter:: e(9)=[1d0,0d0,0d0, 0d0,1d0,0d0, 0d0,0d0,1d0]
    data ae/0d0,0d0,0d0/
    call getpr(ipr)
    sout = ' '
    ag=0d0
    g(:,:,1)=reshape(e,[3,3])
    ng = 1
    mode0 = mod(mode,10)
    mode1 = mod(mode/10,10)
    do  80  igen = 1, ngen !For each generator, do ---  write(stdo,ftox)'do80',igen,ftof(gen(1:9,igen),3),'  ',ftof(agen(:,igen),3)
       call spgcop(gen(1,1,igen),agen(1,igen),sig,asig)
       do   ig = 1, ng ! --- Extend the group by all products with sig ----
          if (spgeql(mode0,g(1,1,ig),ag(1,ig),sig,asig,qb)) then
             if (ipr > 30) write(stdo,ftox)' Generator ',igen,' already in group as element ',ig
             cycle
          endif
       enddo
       ! ... Determine order (= power of sig that restores unit operation)
       call spgcop(sig,asig,h,ah)
       do  itry = 1, 100
          iord = itry
          if (spgeql(mode0,h,ah,e,ae,qb)) exit
          call spgprd(sig,asig,h,ah,h,ah)
       enddo
       ! ... Products of type  g1 sig**p g2
       nnow = ng
       do  8  j = 1, ng
          call spgcop(g(1,1,j),ag(1,j),h,ah)
          do  10  ip = 1, iord-1
             call spgprd(sig,asig,h,ah,h,ah)
             do  11  i = 1, ng
                call spgprd(g(1,1,i),ag(1,i),h,ah,hh,ahh)
                if(any([(spgeql(mode0,g(1,1,k),ag(1,k),hh,ahh,qb),k=1,nnow)])) cycle
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call spgcop(hh,ahh,g(1,1,nnow),ag(1,nnow))
11           enddo
10        enddo
          if (j == 1) n2 = nnow
8      enddo
       ! ... Products with more than one sandwiched sigma-factor
       m1 = ng+1
       m2 = nnow
       do  20  is = 2, 50
          nnew = 0
          do 211 n = ng+1,n2
             do 21  m = m1, m2
                call spgprd(g(1,1,n),ag(1,n),g(1,1,m),ag(1,m),h,ah)
                if(any([(spgeql(mode0,g(1,1,k),ag(1,k),h,ah,qb),k=1,nnow)])) cycle
                nnew = nnew+1
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call spgcop(h,ah,g(1,1,nnow),ag(1,nnow))
21           enddo
211       enddo
          m1 = m2+1
          m2 = nnow
          if (nnew == 0) goto 25
20     enddo
25     continue
       ng = nnow
80  enddo
    ! --- Printout ---
    if (ipr >= 30) then
       if (sout /= ' ' .AND. ipr >= 60) write(stdo,ftox)' Order of generator'//trim(sout)
       write(stdo,ftox)' sgroup: ',ng,'symmetry operations from',ngen,'generators'
       if (ipr >= 60 .AND. ng > 1) then
          write(stdo,'('' sgroup: ig op'')')
          do  ig = 1, ng
             sg=''
             call asymop(g(1,1,ig),ag(1,ig),' ',sg)
             write(stdo,'(5x,i4,2x,a)') ig,sg
          enddo
       endif
    endif
    return
99  continue
    if(mode1 == 0)call rx1('SGROUP: ng greater than ngmx=%i: probably bad translation',ngmx)
    ng = ngmx+1
  end subroutine sgroup
  subroutine grpgen(gen,ngen,symops,ng,ngmx) !Generate all point symmetry operations from the generation group
    use m_ftox
    !i Inputs
    !i   gen,ngen,ngmx
    !i   ng  (12 Sep 96): if>0 , add symops to the ng already in list.
    !o Outputs
    !o   symops,ng
    !r Remarks
    !r   This works for point groups only and is set up for integer  generators.
    implicit none
    integer :: ngen,ng,ngmx
    double precision :: gen(9,ngen),symops(3,3,ngmx)
    double precision :: h(3,3),hh(3,3),e(9),sig(3,3),ae(3)
    integer :: igen,ig,itry,iord,nnow,j,ip,i,k,n2,m1,m2,n,m
    integer :: ipr
    character(80) :: sout
    data e /1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0/, ae/0d0,0d0,0d0/
    call getpr(ipr)
    sout = ' '
    call grpcop(e,symops)
    if (ng < 1) ng = 1
    do  80  igen = 1, ngen
       call grpcop(gen(1,igen),sig)
       ! ---   Extend the group by all products with sig ---
       do  9  ig = 1, ng
          if (grpeql(symops(1,1,ig),sig) .AND. ipr > 30)  write(stdo,ftox)' Generator ',igen,' already in group as element',ig
          if (grpeql(symops(1,1,ig),sig)) goto 80
9      enddo
       ! ---   Determine order ---
       call grpcop(sig,h)
       do  1  itry = 1, 100
          iord = itry
          if (grpeql(h,e)) goto 2
          h=matmul(sig,h) !call grpprd(sig,h,h)
1      enddo
       ! --- Products of type  g1 sig**p g2 ---
2      nnow = ng
       if(ipr >= 40) write(stdo,ftox)'%a  %i is %i,',trim(sout),' ',igen,' is',iord
       do  8  j = 1, ng
          call grpcop(symops(1,1,j),h)
          do  10  ip = 1, iord-1
             ! ... h = sig**ip
             h=matmul(sig,h) !call grpprd(sig,h,h)
             do  11  i = 1, ng
                ! ... hh = symops_i sig**ip
                hh=matmul(symops(:,:,i),h) !call grpprd(symops(1,i),h,hh)
                do  12  k = 1, nnow
                   if ( grpeql(symops(1,1,k),hh) ) goto 11
12              enddo
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                call grpcop(hh,symops(1,1,nnow))
11           enddo
10        enddo
          if (j == 1) n2 = nnow
8      enddo
       ! --- Products with more than one sandwiched sigma-factor ---
       m1 = ng+1
       m2 = nnow
       do  20  i = 2, 50
          do  121  n = ng+1, n2
             do  21  m = m1, m2
                h= matmul(symops(:,:,n),symops(:,:,m)) !call grpprd(symops(1,1,n),symops(1,1,m),h)
                do  22  k = 1, nnow
                   if (grpeql(symops(1,1,k),h)) goto 21
22              enddo
                nnow = nnow+1
                if (nnow > ngmx) goto 99
                symops(:,:,nnow)=h !call grpcop(h,symops(1,nnow))
21           enddo
121       enddo
          if (m2 == nnow) goto 25
          m1 = m2 + 1
          m2 = nnow
20     enddo
25     continue
       ng = nnow
80  enddo
    if (ipr >= 30) then
       if (sout /= ' ' .AND. ipr >= 60) write(stdo,ftox)' Order of generator '//trim(sout)
       write(stdo,ftox)'GRPGEN:',ng,'symmetry operations from',ngen,'generator(s)'
    endif
    if (ipr >= 80 .AND. ng > 1) then
       write(stdo,'('' ig  group op'')')
       do  60  ig = 1, ng
          call asymop(symops(1,1,ig),ae,' ',sout)
          write(stdo,'(i4,2x,a)') ig,sout(1:35)
60     enddo
    endif
    return
99  continue
    do i=1,nnow
       write(stdo,ftox) symops(1:3,1:3,i)
    enddo   
    write(stdo,ftox) h
    call rx('GRPGEN: too many elements')
  end subroutine grpgen
  subroutine psymop(t,plat, g,ag,ng)    !- Parse symbolic representation of symmetry group operations
    !i Inputs:
    !i   t,nt  string of symmetry operations, separated by spaces
    !i   plat  lattice vectors that scale translation part ag
    !i         (if needed, i.e. if translation specified by '::')
    !o Outputs:
    !o   g,ng  group op (3x3 matrix) for each input, and number
    !r Remarks:
    !r   Symbols have two parts, first the point group part, followed
    !r   By an optional translation.  The point group part has the form
    !r   O(nx,ny,nz) where O is one of M, I or Rj for mirror, inversion
    !r   and j-fold rotations, respectively, and nx,ny,nz are a triplet
    !r   of indices specifying the axis of operation.
    !r   (nx,ny,nz) is one of (1,0,0), (0,1,0), (0,0,1) and (1,1,1),
    !r   it can be abbreviated as x,X, y,Y, z,Z and d,D, respectively.
    !r   Also permissible are products, eg I*R4X.
    !r   The translation is also of the form (n1,n2,n3)
    !r   Example: the following input
    !r     R3D(0,0,0) Mx R2(1/2,sqrt(3)/2,0)(pi,0,0) my*i'
    !r   is nonsensical, but permissible and generates four group ops.
    !r   10 Jan 1997 now generates g=transpose of prior versions.
    ! ----------------------------------------------------------------------
    !     implicit none
    character(*):: t
    real(8) :: plat(3,3),g(3,3,*),h(3,3),hh(3,3),ag(3,1),vec(3)
    integer :: nt,ng,i
    logical :: flgp
    character*1:: leftp='(' 
    nt = len(t)
    ng = 0
    i = 0
    do ! Do until no more symbolic representation, do ---
       call skipbl(t,nt,i)
       i=i+1 !  write(6,*)'  psymop:start###'//trim(t(i:)),' i=',i
       if (i >= nt) return
       ng = ng+1
       call parsop(t,i,g(1,1,ng)) !  write(6,*)'  Endof parsop1 i=',i,trim(t(i:))
       if (t(i:i) == '*') then
          i = i+1 !       write(6,*)'  psymop:ttttt222yyy###'//trim(t(i+1:)),'i=',i
          call parsop(t,i,h)
          hh=matmul(g(1:3,1:3,ng),h) !call grpprd(g(1,ng),h,hh)
          g(:,:,ng)=hh ! call dcopy(9,hh,1,g(1,1,ng),1)
       endif
       ag(:,ng)=0d0 
       flgp = .false. 
       if (t(i:i+1) == '::') then !fractional
          flgp = .true.
          i=i+2
       elseif (t(i:i) == ':') then !cartesian 
          i=i+1
       endif
       if (t(i:i) == leftp) then
          if( .NOT. parsvc(-1,t,i,ag(1:3,ng))) call rxi('psymop: failed to parse translation ig=',ng)
          if(flgp) ag(:,ng) = matmul(plat(:,:),ag(1:3,ng)) 
       endif
    enddo
  end subroutine psymop
  subroutine parsop(t,i,a)    !- Parse string for a point group operator
    double precision :: v(3),sp,c,s,pi2,a(3,3),ddot
    character(*) :: t 
    integer :: i,j,k,nrot,iii !    write(*,*)"parsopinput=@@@"//trim(t)//"@@@",i
    pi2 = 8*datan(1d0)
    if (t(i:i) == 'r' .OR. t(i:i) == 'R') then
       i = i+1
       read(t(i:i),'(i1)',err=99) nrot
       i = i+1
       if ( .NOT. parsvc(-1,t,i,v)) goto 99
       sp = ddot(3,v,1,v,1)
       sp = 1d0/dsqrt(sp)
       do  14  k = 1, 3
          v(k) = v(k)*sp
14     enddo
       c = dcos(pi2/nrot)
       s = dsin(pi2/nrot)
       do  16  k = 1, 3
          do  15  j = 1, 3
             a(k,j) = (1-c)*v(j)*v(k)
15        enddo
          a(k,k) = a(k,k) + c
16     enddo
       a(2,1) = a(2,1) + s*v(3)
       a(1,3) = a(1,3) + s*v(2)
       a(3,2) = a(3,2) + s*v(1)
       a(1,2) = a(1,2) - s*v(3)
       a(3,1) = a(3,1) - s*v(2)
       a(2,3) = a(2,3) - s*v(1)
    else if (t(i:i) == 'm' .OR. t(i:i) == 'M') then
       i = i+1
       if ( .NOT. parsvc(-1,t,i,v)) goto 99
       sp = sum(v**2)
       do  11  j = 1, 3
          do  12  k = 1, 3
             a(j,k) = -2.d0*v(k)*v(j)/sp
12        enddo
          a(j,j) = a(j,j) + 1d0
11     enddo
    else if (t(i:i) == 'i' .OR. t(i:i) == 'I') then
       i = i+1
       a=0d0
       a(1,1) = -1
       a(2,2) = -1
       a(3,3) = -1
    else if (t(i:i) == 'e' .OR. t(i:i) == 'E') then
       i = i+1
       a=0d0
       a(1,1) = 1
       a(2,2) = 1
       a(3,3) = 1
    else
       goto 99
    endif
    return
99  continue
    write(stdo,*)'PARSOP: parse error at ',i,'t=',t(i:)
    call rx('PARSOP: parse error')
  end subroutine parsop
  subroutine symlat(platcp,ngrp,grp,isym)  !- Generates the (point) symmetry operations of the lattice
    !i Inputs:
    !i   platcp:lattice vectors of most compact primitive unit cell
    !o Outputs:
    !o   ngrp  :number of allowed symmetry operations
    !o   grp   :symmetry operation matrix
    !o   isym  :index to lattice type, calculated from ngrp:
    !o          ngrp   isym    name
    !o                  0     shouldn't happen
    !o            2     1     triclinic
    !o            4     2     monoclinic
    !o            8     3     orthorhombic
    !o           16     4     tetragonal
    !o           12     5     rhombohedral
    !o           24     6     hexagonal
    !o           48     7     cubic
    !r Remarks:
    !r   symlat analyzes the primitive translations of the bravais lattice in order to supply the symmetry operations of the lattice.
    !r   It gives the number ngrp of allowed operations as well as these operations themselves.
    implicit none
    integer :: ngrp,isym
    double precision :: platcp(3,3),grp(9,*)
    integer :: i,iprint,ltmax,ll1,m,m1,m2,m3,mm
    parameter(ltmax=3,ll1=ltmax*2+1)
    double precision :: platt(3,3),qlatcp(3,3),mat(3,3),vecg(3),vol
    logical :: lirr
    character(12),parameter:: csym1(0:7)=[character(12):: &
         'indefinite','triclinic','monoclinic','orthorhombic','tetragonal','rhombohedral','hexagonal','cubic']
    integer,parameter:: nrot(4)=[2,3,4,6],ngtab(7)=[2,4,8,16,12,24,48]
    mm(i,m) = ltmax-(mod(i,ll1**m)-mod(i,ll1**(m-1)))/ll1**(m-1)
    call dinv33(platcp,1,qlatcp,vol)
    ngrp = 2 ! --- Start out with E and I ---
    call csymop(-1,grp(1,1),.false.,1,[0d0,0d0,0d0])
    call csymop(-1,grp(1,2), .true.,1,[0d0,0d0,0d0])
    ! --- Find all possible rotation axes ---
    do  10  i = 0, (ll1**3-1)/2-1
       m1 = mm(i,1)
       m2 = mm(i,2)
       m3 = mm(i,3)
       if( all([((mod(m1,m)/=0.or.mod(m2,m)/=0.or.mod(m3,m)/=0),m=2,ll1)]) ) then
          vecg(:) = matmul(platcp,[m1,m2,m3]) ! m1*platcp(:,1) + m2*platcp(:,2) + m3*platcp(:,3)
          do  16  m = 1, 4 
             call csymop(-1,mat,.false.,nrot(m),vecg)!       ... Matrix for this symmetry operation
             platt=matmul(mat,platcp)! call grpprd(mat,platcp,platt)
             if (latvec(3,toll,qlatcp,platt)) then !       ... Add it and i*symop, if allowed
                call csymop(-1,grp(1,ngrp+1),.false.,nrot(m),vecg)
                call csymop(-1,grp(1,ngrp+2),.true. ,nrot(m),vecg)
                ngrp = ngrp+2
                if (m /= 1) then
                   call csymop(-1,grp(1,ngrp+1),.false.,-nrot(m),vecg)
                   call csymop(-1,grp(1,ngrp+2),.true. ,-nrot(m),vecg)
                   ngrp = ngrp+2
                endif
             endif
16        enddo
       endif
10  enddo
    ngrp = merge(ngrp,ngtab(isym),isym==0)
    if(iprint()>=30) write(stdo,ftox)' symfind=T: symlat: Bravais system is '//csym1(isym)//' with',ngrp,'symmetry operations.'
  end subroutine symlat
  subroutine symcry(bas,ipc,nbas,nclass,nrclas, ng,plat,qlat,g,ag,istab) ! Generates the symmetry ops of the crystal from those of the lattice
    !i Inputs:
    !i   tol:   tol for which atoms are considered to be at the same site
    !i          use 0 for symtbl to pick internal default
    !i   bas   :basis vectors (scaled by alat)
    !i   ipc   :the jth atom belongs to class ipc(j)
    !i   nbas  :number of atoms in the basis
    !i   nclass:number of classes, atoms in same class are symmetry-related
    !i   nrclas:number of atoms in the ith class
    !i   plat  :primitive lattice vectors (scaled by alat)
    !i   qlat  :primitive translation vectors in reciprocal space
    !xi   bast  :work array of same dimension as bas
    ! io Inputs/Outputs:
    ! io  ng    :number of allowed symmetry operations (see Remarks)
    ! io         on input  number of symmetry operations of the lattice
    ! io         on output number of symmetry operations of the crystal
    ! io  g     :symmetry operation matrices
    !o Outputs:
    !o   ag    :symmetry operation vector
    !o   istab :site ib is transformed into istab(ib,ig) by operation ig
    !r Remarks:
    !r   symcry finds the subset of the allowed ng point operations of the
    !r   lattice without a basis (see symlat.f) that are valid for
    !r   the crystal.
    !r
    !r   This routine is based on ATFTMT written by Worlton and Warren,  CPC 3, 88 (1972).
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nbas,ng,ipc(nbas),nclass,istab(nbas,ng),nrclas(nclass)
    double precision :: plat(3,3),qlat(3,3),bas(3,nbas),bast(3,nbas), g(3,3,*),ag(3,*)
    integer :: ibas,ic,iclbsj,icmin,ig,ipr,jbas,kbas,kc, m,mbas,nj,nm,ng0
    double precision :: dbas(3),tol1
    character(135):: sg
    real(8):: rfrac(3),epsr=1d-12
    call getpr(ipr)
    tol1=toll
    ! --- Find the class with minimum number of atoms ---
    icmin = 1
    do  5  ic = 1, nclass
       if (nrclas(ic) < nrclas(icmin) .AND. nrclas(ic) > 0) icmin = ic
5   enddo
    ibas = iclbsj(icmin,ipc,nbas,1)
    ! --- For each group op, see whether it only shifts basis by some T ---
    ng0 = ng
    ng = 0
    do  30  ig = 1, ng0 !  write(stdo,ftox)'check initial generator ig=',ig
       bast= matmul(g(:,:,ig),bas)!   ... Rotate the basis by g
       do  20  nj = 1, nrclas(icmin)
          jbas = iclbsj(icmin,ipc,nbas,nj)
          ag(:,ng+1) = bas(:,jbas)-bast(:,ibas) ! This is a candidate for translation ag
          rfrac = matmul(ag(:,ng+1)-epsr,qlat)
          ag(:,ng+1) = matmul(plat,rfrac -nint(rfrac)+epsr)
          do  10  kbas = 1, nbas
             kc = ipc(kbas)
             do  12  nm = 1, nrclas(kc)
                mbas = iclbsj(kc,ipc,nbas,nm)
                dbas(:) = bas(:,mbas)-bast(:,kbas)-ag(:,ng+1)
                if (latvec(1,tol1,qlat,dbas)) then
                   istab(kbas,ng+1) = mbas
                   goto 10
                endif
12           enddo
             call asymop(g(:,:,ig),ag(1,ng+1),' ',sg) !write(stdo,ftox)' symcry: excluded candidate ig=',ig,' op=',trim(sg) !Candidate not valid
             goto 20
10        enddo
          !  --- Valid ag found; add g to list ---
          ng = ng+1
          if (ig > ng) g(:,:,ng)=g(:,:,ig) 
          goto 30
20     enddo
30  enddo
    if(ipr>=30)write(stdo,ftox)' symfind=T: symcry: crystal invariant under',ng,'following symmetry operations for tol=',ftof(tol1)
    if (ipr >= 60 .AND. ng > 1) then
       write(stdo,'('' -- ig group op: symcry'')')
       do  60  ig = 1, ng
          call asymop(g(:,:,ig),ag(1,ig),' ',sg)
          write(stdo,'(i5,2x,a)') ig,trim(sg)
60     enddo
    endif
  end subroutine symcry
  subroutine asymop(grp,ag,asep,sg)    !- Generate the symbolic representation of a group operation
    !i Inputs:
    !i  grp,ag :  space group rotation + translation matrix
    !i  asep:     If first character is 'f', rot. and trans. vectors
    !i            are not converted into small algebraic expressions.
    !i            If first char. is 'f', The second-* character are
    !i            used for the separators.
    !o Outputs:
    !o  sg  :  symbolic representation of group op
    implicit none
    double precision :: grp(3,3),ag(3)
    character(*):: sg,asep
    double precision :: vecg(3),dasum
    integer :: nrot,ip,isw,i1,i2,fmtv
    logical :: li
    call csymop(1,grp,li,nrot,vecg) !Get consitutents of grp ---
    ! --- Rotational part ---
    i1 = 1
    fmtv = 0
    if (asep(1:1) == 'f') then
       fmtv = 4
       i1 = 2
    endif
    sg = ' '
    if (nrot == 1) then
       sg = 'i*i'
       ip = 3
       if (li) sg = 'i'
       if (li) ip = 1
    else
       if (li .AND. nrot == 2) then
          sg = 'm'
          ip = 1
       else
          if(  li   ) sg='i*r'//char(48+nrot)
          if( .NOT. li) sg='r'//char(48+nrot)
          ip =len(trim(sg))
       endif
       ip=ip+1
       call rxx(.not. parsvc(2+fmtv,sg,ip,vecg),'bug in asymop 2+fmtv')
    endif!    write(6,*)'nrot=',nrot,trim(sg)
    if (dasum(3,ag,1) > tiny) then !Translational part ---
       if (asep(i1:i1) /= ' ') then
          call nword(asep,1,i1,i2)
          sg(ip+1:) = asep(i1:i2)
          ip = ip+i2-i1+1
       endif
       ip=ip+1
       call rxx(.not. parsvc(1+fmtv,sg,ip,ag),'bug in asymop 1+fmtv')
    endif
  end subroutine asymop
  subroutine csymop(iopt,grp,li,nrot,vecg) !Decomposes a group operation into its consitutents, or vice-versa
    use m_ftox
    !i Inputs:
    !i   iopt  := -1 to convert (nrot,vecg,li) to grp
    !i          =  1 to convert grp to to (nrot,vecg,li)
    !o Inputs/Outputs:
    ! o grp   :group operation matrix
    ! o li    :if T: inversion or rotoinversion
    ! o nrot  :rotation angle = 2*pi/nrot
    ! o vecg  :rotation axis
    !r Remarks
    !r   for nrot > 2 the matrix is non-symmetric and the rotation
    !r   axis can be calculated from the antisymmetric part.
    !r   For nrot = 2 this not possible.  However, the squared vector
    !r   components are given by:  mat(i,i) = 2 v_i * v_i - 1.
    !r   This is used for the largest component. The others are taken
    !r   from: mat(i,j) = 2 v_i * v_j for i ne j.  This way we also
    !r   get the right phases between the components.
    ! ----------------------------------------------------------------------
    implicit none
    integer :: nrot,iopt
    double precision :: vecg(3),grp(3,3)
    logical :: li
    integer :: i,idamax,j,in
    double precision :: costbn,detop,ddet33,dnrm2,sinpb3,twopi,vfac, wk(9),sintbn,omcos,ddot
    character(8):: xt
    twopi = 8*datan(1d0)
    ! --- Make grp from (nrot,vecg,li) ---
    if (iopt == -1) then
       in = iabs(nrot)
       if(in <= 0 .OR. in == 5 .OR. in > 6)call rx('CSYMOP: abs(nrot) must 1,2,3,4 or 6, but is '//trim(xt(in)))
       if(in == 1) then
          grp=reshape([1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0],[3,3])
       else
          call rxx(dnrm2(3,vecg,1).lt.tiny, 'CSYMOP: zero rotation vector')
          sintbn = sin(twopi/nrot)
          costbn = cos(twopi/nrot)
          omcos  = 1d0-costbn
          vecg= 1d0/sum(vecg**2)**.5 *vecg  !call dscal(3,1/sqrt(ddot(3,vecg,1,vecg,1)),vecg,1)
          grp(1,1:3) = omcos*vecg(1)*vecg(:) + [costbn,         -sintbn*vecg(3),  sintbn*vecg(2)]
          grp(2,1:3) = omcos*vecg(2)*vecg(:) + [sintbn*vecg(3),          costbn, -sintbn*vecg(1)]
          grp(3,1:3) = omcos*vecg(3)*vecg(:) + [-sintbn*vecg(2), sintbn*vecg(1),  costbn]
       endif
       if (li) grp=-grp !call dscal(9,-1d0,grp(1,1),1)
       ! --- Make (nrot,vecg,li) from grp ---
    else if (iopt == 1) then        ! ... Require |determinant=1|
       call dinv33(grp,0,wk,detop)
       if(dabs(dabs(detop)-1.0d0)>tiny) call rx('Exit -1 ASYMOP: determinant of group op must be +/- 1, but is '//trim(ftof(detop)))
       detop = dsign(1.d0,detop)
       li = detop<0d0 !   ... li is T if to multiply by inversion
       grp= detop*grp !Multiply operation grp with detop to guarantee pure rotation 
       costbn = 0.5d0*(-1 + grp(1,1) + grp(2,2) + grp(3,3))
       if (dabs(costbn-1d0) < tiny) then
          nrot = 1
          vecg=0d0 
       else
          nrot = idnint(twopi/dacos(dmax1(-1d0,costbn)))
          if (nrot == 2) then
             vecg = 0.5d0*[((grp(i,i)+1.0d0),i=1,3)]
             j = idamax(3,vecg,1)
             if(vecg(j) < 0d0)call rx('ASYMOP: bad operation j='//trim(xt(j))//'. Diagonal element is '//ftof(grp(j,j)))
             vecg(j) = dsqrt(vecg(j))
             vfac = 0.5d0/vecg(j)
             do  12  i = 1, 3
                if (i /= j) vecg(i) = vfac*grp(i,j)
12           enddo
          else
             vecg=[grp(3,2)-grp(2,3), grp(1,3)-grp(3,1), grp(2,1)-grp(1,2)]
          endif
          sinpb3 = dsqrt(.75d0) 
          if (dabs((sinpb3-dabs(vecg(1)))*(sinpb3-dabs(vecg(2)))*(sinpb3-dabs(vecg(3)))) > tiny) then
             do  j = 3, 1,-1 !Renormalize at least one component to 1 to allow for abbreviations as 'D', 'X', 'Y' or 'Z'
                vfac = dabs(vecg(j))
                if(vfac > tiny) vecg=1d0/vfac*vecg! call dscal(3,1.d0/vfac,vecg,1)
             enddo
          endif
       endif
       grp = detop*grp !call dscal(9,detop,grp(1,1),1)
    endif
  end subroutine csymop
  subroutine symtbl(mode,nbas,ipc,pos,g,ag,ng,qlat,istab) ! Make symmetry transformation table for posis atoms; check classes
    !i Inputs
    !i   mode  :1st digit
    !i         :0  site ib is transformed into istab(ib,ig) by grp op ig
    !i         :1  site istab(i,ig) is transformed into site i by grp op ig
    !i         :   (NB: old routine gpfndx used this convention)
    !i         :10s digit
    !i         :1  check atom classes
    !i   tol   :tol for which atoms are considered to be at the same site
    !i         :use 0 for symtbl to pick internal default
    !i   nbas  :size of basis
    !i   ipc   :class index: site ib belongs to class ipc(ib) (mksym.f)
    !i   pos   :pos(i,j) are Cartesian coordinates of jth atom in basis
    !i   g     :point group operations
    !i   ag    :translation part of space group
    !i   ng    :number of group operations
    !i   qlat  :primitive reciprocal lattice vectors, in units of 2*pi/alat
    !o Outputs
    !o   istab :table of site permutations for each group op; see mode
    implicit none
    integer :: nbas,ng,mode
    integer :: ipc(1),istab(nbas,1)
    double precision :: pos(3,1),g(3,3,1),ag(3,1),qlat(9)
    integer :: ib,ic,ig,jb,jc,mode1,mode10,ka
    double precision :: tol1
    character(200)::aaa
    integer,allocatable:: w_oiwk(:)
    character(8):: xt,xn
    if (ng == 0) return
    mode1 = mod(mode,10)
    mode10 = mod(mode/10,10)
    tol1=toll
    do  20  ig = 1, ng !Make atom transformation table ---
       do   ib = 1, nbas          
          jb=findloc( [(latvec(1,tol1,qlat, matmul(g(:,:,ig),pos(:,ib))+ag(:,ig)-pos(:,ka)), ka=1,nbas)],dim=1,value=.true.)!ib is mapped to jb by g,ag 
          if(jb == 0) call rx("SYMTBL: no map for atom ib="//trim(xn(ib))//"ig="//trim(xn(ig)))
          if(mode10 /= 0) then
             ic = ipc(ib)
             jc = ipc(jb)
             if(ic/=jc)call rx('SYMTBL:site '//trim(xn(ib))//' not in same class '//trim(xn(jb))//' ig='//trim(xn(ig)))
          endif
          if (mode1 == 0) then
             istab(ib,ig) = jb
          else
             istab(jb,ig) = ib
          endif
       enddo
20  enddo
  end subroutine symtbl
  logical function parsvc(iopt,t,ip,v)  !- Parses string, converting to a vector, or vice-versa
    ! We now handle only v=(num,num,num),d,x,y,z only, where num is not fractional number.
    !i Inputs:
    !i   iopt   -1 to convert string t to vector,
    !i           1 to convert vector v to string t
    !i           2 same as 1, but use shorthand 'D', 'X', 'Y', 'Z'.
    !i   ip      position in t first char (0 for first char)
    !i Inputs/Outputs:
    !o  t       string representation of vector (see Remarks)
    !o  v       vector
    !o Outputs:
    !o   ip      position after last char: t(ip-1) is last char
    !o   parsvc  T if parse was successful; F if not.
    !
    !r   The following shorthand notations are allowed:
    !r   'D' for  (1,1,1)  'X', 'Y', 'Z' for (1,0,0), (0,1,0), (0,0,1).
    implicit none
    integer :: ip,tlen
    double precision :: v(3)
    character(*) :: t
    double precision :: x,y,z,d
    character sout*50, add*1,soutx*50
    integer :: itrm,ix(3),ich,iopt,m,i,iz,id,mx !,awrite !,a2vec
    logical :: lveq0(3),lveq1(3)!,a2bin
    character(9),parameter:: rchr='(XxYyZzDd'
    integer:: mmm
    ! --- Convert t to vec ---
    tlen=len(t) !    write(6,*) 'Startparsvc:###'//t//'###xxxx',iopt
    if (iopt == -1) then
       v=0d0
       ich = 0
       call chrps2(t(ip:),rchr,len(rchr),ich,ich,itrm)
       parsvc = .false.
       if (itrm == 0) return
       if (itrm == 1) then !   '(' is found. We expect t(ip:)='(..., ..., ...)
          ip = ip+1
          mmm=index(t(ip:),')')
          if(mmm<=0) call rx('cannot find right parensis for vector')
          if(verify(t(ip:ip+mmm-2),'0123456789.Dde-, ')>0) then
             write(stdo,ftox)'t=',t(ip:ip+mmm-2)
             call rx('translation of symops should be numerical w/o math operations')
          endif   
          read(t(ip:ip+mmm-2),*) v 
          ip=ip+mmm-2+2
          parsvc = .true.
          return
       else
          if (itrm >= 8) then!         ... 'd'
             v(1:3) = 1d0
          else!         ... 'x' 'y' or 'z'
             v(itrm/2) = 1d0
          endif
          parsvc = .true.
          ip = ip+1 
       endif
       return
    elseif (mod(iopt,4) == 1 .OR. mod(iopt,4) == 2) then ! --- Convert vec to t ---
       parsvc = .true.
       t(ip:ip)=' '
       if(mod(iopt,4) == 2) then
          if( all(v(:)-[1d0,1d0,1d0]<tiny) ) t(ip:ip)='d'
          if( all(v(:)-[1d0,0d0,0d0]<tiny) ) t(ip:ip)='x'
          if( all(v(:)-[0d0,1d0,0d0]<tiny) ) t(ip:ip)='y'
          if( all(v(:)-[0d0,0d0,1d0]<tiny) ) t(ip:ip)='z'
       endif   
       if(t(ip:ip)==' ') then
          t(ip:ip)='('
          do i = 1, 3
             write(sout,ftox) ftof(v(i))
             if(abs(nint(v(i))-v(i))<1d-6) write(sout,ftox) nint(v(i))
             sout = trim(adjustl(sout))//merge(')',',',i==3)
             m= len_trim(sout)
             t(ip+1:ip+m)=trim(sout) 
             ip = ip+m
          enddo
       endif
       ip = ip+1
    endif
  end function parsvc
  subroutine splcls(nosplt,bas,nbas,ng,istab,nspec,slabl,nclass,ipc, ics,nrclas) !- Splits species into classes
    use m_lgunit,only:stdo
    !i   nosplt:   T copy class and species
    !i   bas,nbas: dimensionless basis vectors, and number
    !i   nspec:    number of species
    !i   ipc:      on input, site j belongs to species ipc(j)
    !i   slabl:    on input, slabl is species label
    !i   ng:       number of group operations
    !i   istab:    site ib is transformed into istab(ib,ig) by grp op ig
    !o  Outputs:
    !o   slabl:    class labels
    !o   ipc:      on output, site j belongs to class ipc(j)
    !o   ics:      class i belongs to species ics(i)
    !o   nclass:   number of classes
    !o   nrclas:   number of classes per each species
    !u Updates
    !u   04 Apr 03 Search for equivalent classes more thorough
    implicit none
    logical :: nosplt
    integer :: nbas,nspec,nclass,ng,istab(nbas,ng),ipc(nbas), ics(nbas),nrclas(nspec)
    double precision :: bas(3,*)
    character(8) :: slabl(*)
    integer :: ib,ic,icn,iclbsj,ig,jb,m,i,is,ipr,idx,ispec,j
    logical :: lyetno
    character(80) :: outs,clabl=''
    call getpr(ipr)
    nclass = nspec
    ics = [(i,i=1,nspec)]
    if (.not.nosplt) then ! --- For each species, split to make equivalent classes ---
       ic = 1
       do while(ic <= nclass) 
          is = ics(ic)
          ib = iclbsj(ic,ipc,-nbas,1)
          if (ib < 0) goto 11 !   ... No sites of this class ... skip
          lyetno = .true.
          do 20  jb = 1, nbas !For each basis atom in this class, do
             if (ipc(jb) == ic) then !class of jb
                if(  any(istab(ib,1:ng) == jb).or.&                    !If there is a g mapping ib->jb, sites are equivalent
                     any(istab(jb,1:ng) == ib).or.&                    !If there is a g mapping jb->ib, sites are equivalent
                     any([(istab(istab(ib,ig),ig)== jb,ig=1,ng)]).or.&   !If there is a g mapping ib->kb,jb, sites are equivalent
                     any([(istab(istab(jb,ig),ig)== ib,ig=1,ng)])) cycle !If there is a g mapping jb->kb,ib, sites are equivalent
                if (lyetno) then !If the classes haven't been split yet, do so
                   nclass = nclass+1
                   icn  =  nclass
                   ics(icn) = is
                   nrclas(is) = nrclas(is)+1
                   lyetno = .false.
                endif
                if(nclass > nbas) call rx('splcls:  problem with istab')
                icn  =  nclass
                ipc(jb)=  icn !class index
             endif
20        enddo
11        continue
          ic = ic + 1
       enddo
    endif
    if(ipr>=30) then
       write(stdo,"(a)")' splcls:  ibas iclass ispec label(ispec)'
       do j=1,nbas
          ic   = ipc(j) !class
          ispec= ics(ic)!spec
          write(stdo,"(a,3i5,a)")"       ",j,ic,ispec,'     '//trim(slabl(ispec))
       enddo
    endif
  end subroutine splcls
  subroutine spgcop(g,ag,h,ah)
    real(8):: h(9),g(9),ag(3),ah(3)
    h = merge(0d0, g, dabs(g) <1d-10)
    ah= merge(0d0,ag, dabs(ag)<1d-10)
  end subroutine spgcop
  subroutine grpcop(g,h)
    double precision :: h(9),g(9)
    h=g
  end subroutine grpcop
  subroutine spgprd(g1,a1,g2,a2,g,a)
    implicit none
    real(8) :: g1(3,3),g2(3,3),g(3,3),sum,a1(3),a2(3),a(3),h(3,3),ah(3)
    integer :: i,j,k
    h=matmul(g1,g2)
    g=h !tk does not know why g=matmul(g1,g2) fails for gfortran gcc9.4.0 2023march
    ah=a1+matmul(g1,a2)
    a=ah
  end subroutine spgprd
  logical function spgeql(mode,g1,a1,g2,a2,qb) !- Determines whether space group op g1 is equal to g2
    !i   g1,a1 :first space group,   !i   g2,a2 :second space group, !i   qb    :reciprocal lattice vectors
    implicit none
    integer :: mode,m,iq,iac
    double precision :: g1(9),g2(9),a1(3),a2(3),qb(3,3),adiff(3)
    spgeql=.true.
    if(any(dabs(g1-g2) > toll)) then
       spgeql=.false.
       return
    endif   
    if(mode==1) return ! only point group is compared for mode=1
    adiff=matmul(a1-a2,qb)
    if(any(abs(adiff-nint(adiff))>toll)) spgeql=.false.
  end function spgeql
  logical function grpeql(g1,g2)    !- Checks if G1 is equal to G2
    implicit none
    real(8):: g1(9),g2(9)
    grpeql=.false.
    if(all(dabs(g1-g2)<toll)) grpeql=.true. !2023march, grpeql = merge(all(dabs(g1-g2)<toll),.true.,.false.) did not work in gfrotran gcc 9.4.0 
  end function grpeql
  logical function latvec(n,tol,qlat,vec) !- Checks whether a set of vectors are lattice vectors
    !i n:number of vectors, tol:tolerance, qlat:, vec:double-precision vector !Outputs: latvec=T if all vectors are lattice vectors within tol
    implicit none
    integer:: n
    real(8):: qlat(3,3),vec(3,n),tol, vdiff(n,3)
    vdiff  = matmul(transpose(vec(:,:)),qlat(:,:))
    latvec = all(abs(vdiff-nint(vdiff)) < tol)
  end function latvec
!=======================================  
  subroutine words(str,nw) !- Count blank-delimited words in str
    !i   str   :string
    !o Outputs
    !o   nw    :number of blank-delimited words in str
    character*(*) str
    integer :: nw
    integer :: i1,i2,i0,i
    nw = 0
    i1 = 0
    i2 = 0
    i0 = 1
99  do  10  i = i0, len(str)
       if(str(i:i) /= ' ') then
          i1 = i
          goto 90
       endif
10  enddo
    return
90  nw = nw+1
    do  20  i = i1,len(str)
       if(str(i:i) == ' ') then
          i2 = i
          goto 91
       endif
20  enddo
    return
91  i0 = i2
    goto 99
  end subroutine words
  subroutine word(str,iw,j1,j2) !- Returns j1,j2 so that str(j1:j2) is the iw-th word from beginning
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   str   :string
    !i   iw    :find iw-th word
    !o Outputs
    !o   j1    :str(j1:j2) is iw-th word
    !o   j2    :-//-
    !u Updates
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    character*(*) str
    integer :: iw,j1,j2
    ! ... External calls
    !external nword
    j1 = 1
    call nword(str,iw,j1,j2)
  end subroutine word
  subroutine nword(str,iw,j1,j2)    !- Returns j1,j2 so that str(j1:j2) is the iw-th word from current pos
    ! ----------------------------------------------------------------------
    !i Inputs
    !i   str   :string
    !i   iw    :find iw-th word
    !i   j1    :start search from str(j1:)
    !o Outputs
    !o   j1    :str(j1:j2) is iw-th word
    !o   j2    :-//-
    !u Updates
    ! ----------------------------------------------------------------------
    !     implicit none
    ! ... Passed parameters
    integer :: iw,j1,j2
    character*(*) str
    ! ... Local parameters
    integer :: nw,i1,i2,i0,i
    nw = 0
    i1 = 0
    i2 = 0
    i0 = j1
    j2 = -1
99  do  10  i = i0, len(str)
       !   ... skip until nonblank char
       if(str(i:i) /= ' ') then
          i1 = i
          goto 90
       endif
10  enddo
    return
    !   ... skip until a blank char
90  nw = nw+1
    if (nw == iw) j1 = i1
    do  20  i = i1, len(str)
       if(str(i:i) == ' ') then
          i2 = i
          goto 91
       endif
20  enddo
    ! ... We have reached the end of the string
    if (nw == iw) j2 = len(str)
    return
    ! ... cleanup: exit if word soguht, else try again
91  i0 = i2
    if (nw == iw) then
       j2 = i2-1
       return
    endif
    goto 99
  end subroutine nword
end module m_mksym_util
