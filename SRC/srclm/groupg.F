      subroutine groupg(mode,ng,g,ag,plat,ngen,gen,agen,gens,ngout)
      use m_globalvariables
C- Finds a set of generators for the symmetry group
C ----------------------------------------------------------------------
Ci Inputs:
Ci   mode  :0 two groups compare to equal when both their point
Ci         :  and space parts compare equal
Ci         :1 two groups compare to equal when their point
Ci         :  group compares equal.  This eliminates
Ci         :  space groups that that have the same point group
Ci         :  but differing translational symmetry, which can
Ci         :  occur for artifically large supercells.
Ci   plat  :primitive translation vectors in real space
Ci   qlat  :primitive translation vectors in reciprocal space
Ci   g:symmetry operation symbol
Ci   ng:number of symmetry operations as supplied by the generators
Co Outputs:
Co   gen,ngen:generators, and number needed to produce g
Co   ngout :number of group ops generated by (gen,ngen)
Co         :usually ngout=ng unless artificial translations
Co   gens  :ascii representation of generators
Cr Remarks:
Cr   The smallest set of generators is sought.
Cr   This subroutine performs the inverse function of sgroup.
Cu Updates
Cu   09 Jul 08 Extra check to find new generators beyond
Cu             the given ones.
Cu   12 May 07 Always returns gens, independent of verbosity
Cu   04 Jan 06 Returns ngout
C ----------------------------------------------------------------------
C     implicit none
C Passed parameters:
      integer mode,ngen,ng,ngout
      double precision plat(9)
      double precision gen(9,*),agen(3,*),g(9,*),ag(3,*)
      character*(*) gens
C Local parameters:
      integer imax,isop,ngloc,ngmax,iprint,ngen0,ngmx
      integer i1,i2,j1,j2,stdo,nglob
      parameter (ngmx=48*64)
      character*100 sg,sg1,sout,sout2
      double precision gloc(3,3,ngmx),agloc(3,ngmx),qlat(9),xx,vec(3)

Changenglob      stdo = nglob('stdo')
      stdo = globalvariables%stdo

C --- Starting number of group ops ---
      call mkqlat(plat,qlat,xx)
      call pshpr(1)
      ngen0 = ngen
      call sgroup(0,gen,agen,ngen,gloc,agloc,ngout,ngmx,qlat)

   10 continue
C --- Do until enough generators added to make whole group ---
      if (ngout .lt. ng) then
C   ... Run through all symops, choosing whichever adds the most ops
        imax = 0
        ngmax = 0
        do  isop = 1, ng
          call dcopy(9,g(1,isop),1,gen(1,ngen+1),1)
          call dcopy(3,ag(1,isop),1,agen(1,ngen+1),1)
C         call pshpr(61)
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
C         call poppr
          if (ngloc .gt. ngmax) then
            imax = isop
            ngmax = ngloc
            ngout = ngloc
          endif
        enddo
        ngen = ngen+1
        call dcopy(9,g(1,imax),1,gen(1,ngen),1)
        call dcopy(3,ag(1,imax),1,agen(1,ngen),1)
        goto 10
      endif

C     One last pass in case extra generators
      if (.true.) then
C   ... Run through all symops, choosing whichever adds the most ops
        imax = 0
        ngmax = ngout
        do  isop = 1, ng
          call dcopy(9,g(1,isop),1,gen(1,ngen+1),1)
          call dcopy(3,ag(1,isop),1,agen(1,ngen+1),1)
C         call pshpr(61)
          call sgroup(mode,gen,agen,ngen+1,gloc,agloc,ngloc,ngmx,qlat)
C         call poppr
          if (ngloc .gt. ngmax) then
            imax = isop
            ngmax = ngloc
            ngout = ngloc
          endif
        enddo
        if (ngout .gt. ngmax) then
          ngen = ngen+1
          call dcopy(9,g(1,imax),1,gen(1,ngen),1)
          call dcopy(3,ag(1,imax),1,agen(1,ngen),1)
        endif
      endif

      call poppr

C --- Create gens, optionally printout ---
C     if (iprint() .ge. 20)  then
      if (ngen0 .eq. 0) then
        call info0(20,0,0,' GROUPG: the following '//
     .  'are sufficient to generate the space group:')
      else
        call info2(20,0,0,' GROUPG: %i generator(s) were added to '//
     .  'complete the group%?#n#:',ngen-ngen0,ngen-ngen0)
      endif
      sout = ' '
      sout2 = ' '
      do  20  isop = 1, ngen
        call asymop(gen(1,isop),agen(1,isop),':',sg)
        call awrit0('%a '//sg,sout(9:),len(sout)-9,0)
        call dcopy(3,agen(1,isop),1,vec,1)
        call dgemm('N','N',1,3,3,1d0,agen(1,isop),1,qlat,3,0d0,vec,1)
        call asymop(gen(1,isop),vec,'::',sg1)
        call word(sg1,1,i1,i2)
        call shorbz(vec,vec,plat,qlat)
        call asymop(gen(1,isop),vec,'::',sg)
        call word(sg,1,j1,j2)
        if (i2-i1 .lt. j2-j1) sg = sg1
        call awrit0('%a '//sg,sout2(9:),len(sout2)-9,0)
        !print *,'len(sout2)=',isop,len(sout2)
   20 continue
      if (ngen .gt. ngen0 .and. iprint() .ge. 20) then
        write(stdo,"(' Generator(cart): ', a)") trim(adjustl(sout))  ! call awrit0('%a',sout,len(sout),-stdo)
        write(stdo,"(' Generator(frac): ', a)") trim(adjustl(sout2)) ! call awrit0('%a',sout2,len(sout2),-stdo)
      endif
      gens = sout2
C     endif
      if (ngout .gt. ng) then
        call info2(20,0,0,
     .  '%9f(warning) %i group ops supplied but generators create'//
     .  ' %i ops',ng,ngout)
      endif

      end

