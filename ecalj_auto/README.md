# Automatic computational system in QSGW method for crystal structures taken from the material project

With this package, we can apply QSGW implemented in ecalj package to the crystal structures taken from the material project (MP). 

This package is useful for systematic calculations for many materials.
For this purpose, we expect a machine with many cores for MPI with qsub system. 
After collecting POSCAR files in MP, we submit a job for completing QSGW calculations for all the POSCAR files, where we use the cores efficiently.

## __Requirements:__  
We need following tools. Higher version should work.
>  python==3.9  
   pymatgen==2024.5.1  
   mp-api==0.41.2  
   spglib
   seekpath

OPTIONAL: 
   If you run a part for machine learning, we need
>  tensorboard==2.14.1  
   keras==2.12.0  
   numpy==1.26.4  
   scikit_learn==1.3.0  

## __Structure of this package__

```
├── README.md           ! This file
├── INPUT               ! Directories containing PROCAR files obtained by query.sh
│   ├── gw1000
│   ├── mag
│   ├── mag_all
│   ├── testSGA
│   └── w4f
├── jobgw1000.sh    ! auto qsub submission for INPUT/gw1000
├── jobtestSGA.sh   ! auto qsub submission for INPUT/testSGA
├── OUTPUT              ! Calculated results by qsub. jobfoobar.sh generates this. 
│   └── testSGA             
├── auto/           ! Python scripts for ecalj_auto
├── config.ini      ! Setting file for jobsubmit.py
├── jobtemplate     ! Setting for your qsub system
├── query.sh        ! A sample of query to MP for getting POSCAR, results are in INPUT/.
├── packoutput.py   ! Only minimum files in OUTPUT are copied to OUTPUT_pack/OUTPUT by >packoutput.py OUTPUT
└── testchk.py      ! Compare your results with previous results. >testchk.py dir1 dir2

```

## __Install:__
We have to install ecalj at first. Since ecalj_auto is in python, we do not need build process. In config.init, set following default values
>   - api_key : API-KEY for Materials Project
>   - epath   : Path of ecalj bin, where ecalj binaries are.
>   - nqsub   : number of qsub jobs.
>   - ncore   : Number of cores per qsub jobs.
>   - niter   : Number of QSGW iteration (We stop after niter times QSGW iteration. Not until converged)
>   - bnd4all : If True, calculate band dispersions for every QSGW iterations.
>   - gw80    : If True, run QSGW80 ($V_{xc} = 0.8V_{xc}^{QSGW} + 0.2V_{xc}^{LDA}$)

The number of used MPI cores is 'nqsub x ncore'. We will occupy the number of cores during calculations.

In addition, we have to modify job_template for your system. I think we need to modify -q section only.


## __Usage:__
We explain how to use this package step by step.

### 1. Get POSCAR files from Materials Project: 
`query.sh` 
contains several examples to make a query to MP for getting POSCAR.
   > --nsite A B: Number of sites is between A and B 
   > --include :  Set atomid or LN(lantanoid),AC() 
   > --mag A: A is True for magnetic system 
   > --theoretical: Theoretical materials
   > --metal: Theoretical materials
`query.sh` will prepare joblist file in addition to POSCAR files. 

After we performed query.sh, we should have INPUT/

### 2. Run QSGW jobs:   
`jobtestSGA.sh` and `jobgw1000.sh` are examples to run job via qsub.
`jobtestSGA.sh` contains a line as
```bash
./auto/jobsubmit.py --inpath INPUT/testSGA --epath /home/stakano/ecalj/bin/ --nqsub 2 --niter 2 --ncore 32 --bnd4all True
```
, where
- --inpath <input_path>   
   <input_path> is the directory of the input data generated by query.sh. 
- --epath, --nqsub --niter --ncore --bnd4all:  See query.sh above. 

* jobsubmit read ./<input_path>/joblist, which specifies mp-foobar we will calculate.

Output:
* We will have results in OUTPUT/foobar where, foobar is the the name replacing INPUT/ to OUTPUT/. OUTPUT/foobar can be created or overwritten.

* job*.sh create out

* To monitor current runnning job, see ./OUTPUT/foobar/job1.out (jobX.out is for the Xth qsub job).

* QSGW iteration console output are in mp-foobar/osgw.out

- At each mp*/RUN.foobar, we have 
   - bandplot.*.glt   : gnuplot for band plot
   - tdos.*.glt       : gnuplot for total dos
   - pdos*.site*.glt  : PDOS for each sites (See SiteInfo.chk) 




## __Test__: comparison with previous results

`testchk.py` compares eigenvalues.
```bash
./testchk.py <dir1> <dir2>
```
AAA compares the results of directories (e.g. mp-xxx) in dir1 with the results of calculations in dir2.


## __packing__: 
It may be helpful to extract only important files from your calculated results. Run
```bash
./packoutput.py OUTPUT
```
create a replica of OUTPUT_pack/OUTPUT but with minimum files. Look into packoutput.py.

## __Database__


## References:


## MEMO
ecalj_auto/auto/ contains
 jobsubmit.py: main module. Run qsub in it. joblist is divided into joblist.id. It uses jobtemplate as a template for qsub.
 job_mp.py   : this is invoked from jobx.1... which are qsub scripts.
 creplot.py  : Called from job_mp.py. Core part to perform ecalj calculations.