      program lmf2gw
c- Files, gwa.* gwb.* gw1.* gw2.* gw3.*, generated by ng0
c  are converted to DATA4GW
c ---------
c Input files
c   gwa.* : atomic data
c   gwb.* : band data
c   gw1.* : <psi|H|psi>
c   gw2.* : <psi|H(without Vxc)|psi>
c   Not used now ---> gw3.* : <psi|H(where Vxc(nval))|psi> !used only for NoCore case  
c
c   Q0P  ; q points near q=0 instead of q=0
c   GWIN0; required inputs for GW only read its nband.
c   CLASS:  CLASS information.
c
c Output files
c  DATA4GW_V2 :
Cu Updates
Cu             Uses CLASS rather than EFCLASSin
c------------------------------------------------------------------
C     implicit none
C     implicit real*8 (a-h,o-z)
      integer icor1,icorex,nphimx,i,i1,i2,ibas,ibasx,ibx,ic,icore,
     .ifichkv,ifigw0,ifigwa,ifigwb,ifigwx1,ifigwx2,ifigwx3,isp,ispx,
     .ispxx,ix,kkk,kkkdummy,l,ldummy,lmxa,lxx,n1q,n2q,n3q,nclassx,m,n,
     .ncore,ndimh,ngp,nnc,nq0i,nqbz,nspdummy,IKP,NR_A !takao feb2012 ngc,ngcmx,
      real(8) qlat(3,3),ovv(20),ef0,qpgcut_phi,qpgcut_cou,z,
     .a_a,b_a,rofi_anr
      character*120  ext0*256, ext*256
      real(8):: qqq(3),plat(3,3)
      integer:: ifi,ifefclass,fopnx,fopna,fext,icors(2)
      complex(8),allocatable:: zegf(:,:) ,geig(:,:)
      complex(8),allocatable:: cphi(:,:),cphi_d(:,:,:,:)
      real(8),allocatable:: evl(:), vvv1(:),vvv2(:),vvv3(:),rofi_A(:)
     &,gcore_A(:,:), ec_A(:), bas(:,:)
      integer,allocatable:: konf(:,:),lmxaa(:),nncx(:,:),ngvecp(:,:)
      real(8),allocatable :: qbze(:,:)
      real(8),parameter ::  rydberg=13.6058d0
      logical :: nocore  ! Flag file NoCore exist or not.
      ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
      ! If nocore exist. you have to supply
      !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
      ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
      real(8),allocatable :: wt(:),q0i(:,:)
c----------------------------------------------
      integer ::
     &nsp,      ! =1 or 2, corresponding to para or ferro.
     &nbas,     ! Number of atom in the primitive cell
     &nclass,   ! Number of atomic class (or type) for in the primitive cell
     &nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
     &ncoremx,  ! = maxval(ncore(1:nclass))
c
     &lmxamx,   ! = maxval(lmxa(1:nclass))
     &ngpmx,    ! Maximum number of G vector.
     &nband,    ! Number of bands given by GWIN0
     &ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
     &ldim2,    ! = total number of augmentation functions nRlm
     &nphi,     ! = total number of augmentation functions nRl
     &nqbze     ! = nqbz*(1+nq0i). Number of q points given by qg4gw
      real(8) ::
     &alat,    ! Lattice constant in a.u.
     &efermi = 1d99   ! This is dummy now .
      integer,allocatable::
     &iclass(:),
     &lmxa_d  (:),
     &nr(:),
     &konf_d(:,:),
     &ncore_d(:)
      real(8),allocatable ::
     &zz(:),
     &aa(:),bb(:),
     &ec_d (:,:,:),
     &evl_d(:,:,:),
     &vxclda (:,:,:),
     &gx_d(:,:,:,:,:),
     &gcore_d(:,:,:,:)
      complex(8),allocatable::
     &geig_d(:,:,:,:)
      integer,allocatable:: nindx(:),lindx(:),ibasindx(:)
      integer:: ificg
      integer:: procid,nrank,ifigwb_,ifigwx1_,ifigwx2_
      character*256:: extn,aaa
      character*256,allocatable:: extp(:)
      integer,parameter :: nsize= 1 000 000
      integer:: ifiproc,nqixx,nspxx,numprocxx,ixxx
      integer,allocatable:: iprocq(:,:),iantiferro(:)
      character(8),allocatable:: spid(:)
!!
      call show_programinfo(6)

!! === readin lmfgw_kdivider, and get extensions === apr2013
      ifiproc = fopnx('lmfgw_kdivider',2,1,-1)
      read(ifiproc,*) ext  !extension is read here
      ifi = fext(trim(ext))
      read(ifiproc,*) nqixx, nspxx, nrank
      allocate(iprocq(nqixx,nspxx))
      do isp=1,nspxx
      do iqq=1,nqixx
        read(ifiproc,*) iqqxx, ispxx, ixxx
        if(iqqxx/=iqq) stop 'iqqxx/=iqq'
        if(ispxx/=isp) stop 'ispxx/=isp'
        iprocq(iqq,isp) = ixxx
        write(6,"('iqq isp irank=',i8,i2,i6)") iqq,isp, iprocq(iqq,isp)
      enddo
      enddo
      call fclose(ifiproc)
!! for mpi files.
      allocate(extp(0:nrank-1))
      extp(0) = trim(ext)
      write(6,"('  0 ext= ',a,a)") trim(extp(0)),' ----------'
      do procid=1,nrank-1
        write(extn,"(i10)") procid
        extp(procid)=trim(adjustl(ext))//'_'//trim(adjustl(extn))
        write(6,"(i3,' ext= ',a,a)") procid,trim(extp(procid)),' ----------'
      enddo
!! --------------------------------------

      nocore=.false.
      ifichkv = 8485
      call setpr(30)
      ifigwa = fopna('gwa',-1,4)
      ifigwb = fopna('gwb',-1,4)
      ifigwx1 = fopna('gw1',-1,4)
      ifigwx2 = fopna('gw2',-1,4)
      open(ifichkv,file='VXCFP.chk')
      write(ifichkv,"(a)") '### LDA exchange correlation ###'
      write(ifichkv,"(a)")'#   qvec                 ikp iband    eigen VXC(ntotal)     VXC(nvalence)'
      read (ifigwb) nbas,nsp,ldim2,ndimh,alat,qlat,ef0,nqbz,plat(1:3,1:3),nqbze, nqirr !feb2012takao
      nqbze=nqirr    !nqbze means number of calculated bands (irreducible only)         feb2012takao
      allocate(lmxaa(1:nbas), bas(1:3,1:nbas))
      read (ifigwb) lmxaa(1:nbas), bas(1:3,1:nbas)
      read (ifigwb) ngpmx !, ngcmx
      lmxamx = maxval(lmxaa(1:nbas))
      allocate( iclass(nbas) )

!! readin CLASS
      ifefclass = 321
      open(ifefclass,file='CLASS')
      nclass=0
      do ibas = 1,nbas
        read(ifefclass,*)  ibasx,  nclassx
        if(nclassx>nclass) nclass= nclassx
      enddo

      write(6,'('' File CLASS:  nclass ='',i4)') nclass
      allocate( qbze(3,nqbze), lmxa_d(nclass), nr(nclass),
     &  ncore_d(nclass), konf_d(0:lmxamx,nclass), zz(nclass),
     &  aa(nclass), bb(nclass) )
!!
      ificg=421
      open(ificg,file='CphiGeig',form='unformatted')
      rewind ifefclass
      do ibas=1,nbas
        read(ifefclass,*) ix,iclass(ibas)
        lmxa_d(iclass(ibas)) =lmxaa(ibas)
      enddo
      close(321)

!! Band Part
      nbandmx = ndimh
      write(6,'(" nqbze nqpz ndimh(max)=",3i5)') nqbze,nqbz,ndimh
      allocate( evl_d (nbandmx, nqbze, nsp),vxclda(nbandmx, nqbze, nsp),
     &  vvv1(nbandmx),vvv2(nbandmx),vvv3(nbandmx),cphi(ldim2, nbandmx), evl(nbandmx) )
      evl_d=1d20
      vxclda=1d20
      iqq=0
      do ikp = 1,nqbze
        iqq=iqq+1
        do isp = 1, nsp
          ifigwb_= fopnx('gwb'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          read (ifigwb_) qbze(:,ikp),nband,iq
          write(6,"(a,3i6,3x,3f11.6,$)") 'ikp isp nband q=',ikp,isp,nband, qbze(:,ikp)
          evl =1d20
          cphi=1d20
          read (ifigwb_) evl(1:nband), cphi(:,1:nband)
          write(ificg) cphi(1:ldim2,1:nbandmx)
          evl_d (1:nband, ikp,isp) = evl (1:nband)

!! Plane wave part
          read (ifigwb_) ngp !,ngc
          allocate( geig(ngp, nbandmx),
     &    ngvecp(3,ngp) )!takao feb2012 ,ngvecc(3,ngc) )
          geig=1d20
          read(ifigwb_) ngvecp,geig(:,1:nband)
          write(ificg) ngp
          write(ificg) geig(1:ngp,1:nbandmx)
          write(6,'("  geig sumcheck= ",2d13.6)') sum(geig(1:ngp,1:nband))
          deallocate( geig,ngvecp)!takao feb2012 ,ngvecc )

!! --- VXCFP
          ifigwx1_= fopnx('gw1'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          ifigwx2_= fopnx('gw2'//trim(extp(iprocq(iqq,isp))),2,4,-1)
          read (ifigwx1_ ) qqq, (vvv1(i),i=1,nband)
          read (ifigwx2_ ) qqq, (vvv2(i),i=1,nband)
          vxclda (1:nband, ikp,isp)= vvv1(1:nband)-vvv2(1:nband)
          vvv3=vvv2
          do ibx =1,nband
             write(ifichkv,"(3f8.4,2i3,6f16.8)") qqq,ikp,ibx,
     &            vvv1(ibx),vvv1(ibx)-vvv2(ibx),vvv3(ibx)-vvv2(ibx),
     &            rydberg*vvv1(ibx),rydberg*(vvv1(ibx)-vvv2(ibx)),
     &            rydberg*(vvv3(ibx)-vvv2(ibx))
          enddo
 888      continue
       enddo
      enddo
      close(ificg)
      deallocate( cphi,evl, vvv1,vvv2,vvv3)

!! GET nrxx and ncoremx ----------------------
      nrmx    = 0
      ncoremx = 0
      allocate(nncx(0:lmxamx,nbas),konf(lmxamx+1,nbas),spid(nbas))
      do  ibas = 1, nbas
        read(ifigwa) z, nr_A, a_A, b_A, rofi_Anr
     &  ,lmxa,nspdummy,ncore,spid(ibas)
        allocate(rofi_A(nr_A),ec_A(ncore))
        read(ifigwa) konf(1:lmxa+1,ibas)
        read(ifigwa) rofi_A(1:nr_A)
        do  l = 0, lmxa
          do  isp = 1, nsp
            read(ifigwa) lxx,ispx  !!!ibas==ic,l,n=1
            read(ifigwa)
            read(ifigwa)
            if (konf(l+1,ibas) .ge. 10) read(ifigwa)
          enddo
        enddo
        do  l = 0, lmxa
          do  isp = 1, nsp
            nncx(l,ibas) = mod(konf(l+1,ibas),10)-1 -(l+1) +1
            nnc          = max(nnc,nncx(l,ibas))
            do  kkk = l+1, mod(konf(l+1,ibas),10)-1
              icore = icore+1
              read(ifigwa) icore,ldummy,ispx,kkkdummy,ec_A(icore)
              read(ifigwa)
            enddo
          enddo
        enddo
        deallocate(rofi_A,ec_A)
        if(nr_A   >nrmx   ) nrmx    = nr_A
        if(ncore  >ncoremx) ncoremx = ncore
      enddo

!! == ATOMIC PART ic = ibas scheme ==
!! ... augmentation indexing information
      ifi = fopnx('NLAindx',2,1,-1)
      rewind ifi
      allocate(nindx(ldim2),lindx(ldim2),ibasindx(ldim2))
      call rdibasindx2(ldim2,nphi,nphimx,nindx,lindx,ibasindx,ifi)
      ncoremx = ncoremx/nsp
      allocate(ec_d(ncoremx, nclass, nsp),gx_d (nrmx, 0:lmxamx, nphimx,  nclass,nsp),
     & gcore_d(nrmx, ncoremx, nclass,nsp)  )
      gx_d = 0
      rewind ifigwa
      nnc =0
      konf =0
      write(6,'(/'' File gwa: reading atom data'')')
      do 3001 ibas = 1, nbas
        read(ifigwa) z, nr_A, a_A, b_A, rofi_Anr,lmxa,nspdummy,ncore
        allocate(rofi_A(nr_A),
     &  gcore_A(nr_A,ncore),ec_A(ncore))
        read(ifigwa) konf(1:lmxa+1,ibas)
        read(ifigwa) rofi_A(1:nr_A)
        write(6,369) ibas,z,rofi_A(nr_A),lmxa,konf(1:lmxa+1,ibas)
  369   format(' site',i3,'  z=',f5.1,'  rmax=',f8.5,'  lmax=',i1,'  konf=',10i1)
!!       A bit rough treatment
        ic    = iclass(ibas)
        zz(ic)= z
        aa(ic)= a_A
        bb(ic)= b_A
        nr(ic)= nr_A
        ncore_d(ic) = ncore/nsp
        konf_d(0:lmxa,ic) = konf(1:lmxa+1,ibas)
        write(6,371)
  371   format('  l    g(rmax)    gp(rmax)',4x,'<g g>',9x,'<gp gp>',9x,'<g gp>')
!! --- PHIU
        do  l = 0, lmxa
          do  isp = 1, nsp
            read(ifigwa) lxx,ispxx  !!!ibas==ic,l,n=1
            if(lxx /= l .or. isp /=ispxx) stop 'hhbecfp:lxx or isp wrong'
            read(ifigwa) gx_d(1:nr_A,l,1,ic,isp)
            read(ifigwa) gx_d(1:nr_A,l,2,ic,isp)
            if (konf_d(l,ic) .ge. 10) read(ifigwa) gx_d(1:nr_A,l,3,ic,isp)

            m = 2
            if (konf_d(l,ic) .ge. 10) m = 3
            n = 0
            do  i1 = 1, m
              do  i2 = 1, i1
                n = n+1
                call gintxx(gx_d(1:nr_A,l,i1,ic,isp),
     .          gx_d(1:nr_A,l,i2,ic,isp),a_A,b_A,nr_A,ovv(n))
              enddo
            enddo
            write(6,'(i3,2f11.5,2f15.10,f12.6)')
     .      l,gx_d(nr_A,l,1,ic,isp),gx_d(nr_A,l,2,ic,isp),
     .      ovv(1),ovv(3),ovv(2)
            if (m .eq. 3) write(6,321) gx_d(nr_A,l,3,ic,isp),
     .      ovv(6),ovv(4),ovv(5)
  321       format('  gz(rmax); <gz gz> <gz g> <gz gp> = ',f8.5,
     .      f15.10,2f12.7)

          enddo
        enddo
!! --- ECORE PHICU
        if (ncore .ne. 0)
     .  write(6,'(''  l  k isp       ecore      gc(rmax)     <gc gc>'')')
        icore = 0
        icors = 0
        do isp = 1, nsp
          do l = 0, lmxa
            nncx(l,ibas) = mod(konf(l+1,ibas),10)-1 -(l+1) +1
            nnc          = max(nnc,nncx(l,ibas))
            do  kkk = l+1, mod(konf(l+1,ibas),10)-1
              icore = icore+1
              icors(isp) = icors(isp) +1
              icor1=icors(isp)
              read(ifigwa) icorex,ldummy,ispx,kkkdummy,ec_A(icore)
              if(icore/=icorex)  stop 'lmf2gw:icore/=icorex'
              read(ifigwa) gcore_A(1:nr_A,icore)
              ec_d(icor1, ic, isp) = ec_A(icore)
              gcore_d(1:nr_A,icor1,ic,isp)  = gcore_A(1:nr_A,icore)
              call gintxx(gcore_A(1,icore),gcore_A(1,icore), a_A,b_A,nr_A,ovv(1))
              write(6,'(3i3,f15.6,f12.6,f15.10,3i3)')
     &        l,kkk,isp,ec_A(icore),gcore_A(nr_A,icore),ovv(1),icore,icor1
            enddo
          enddo
        enddo
        deallocate(rofi_A,gcore_A,ec_A)
 3001 continue
      allocate(iantiferro(nbas))
      read(ifigwa)iantiferro(1:nbas)      !iantiferro may2015

      ifi=501
      open (ifi,file='DATA4GW_V2',form='unformatted')
      call gwinput_v2x(-ifi,
     & nsp,   nbas,   nclass, nrmx,   ncoremx,
     & lmxamx, ngpmx,  nbandmx,  ldim2,   nqbze ,
     & nphi,nphimx, nindx, lindx, ibasindx,
     & iclass,lmxa_d,nr,konf_d,ncore_d,
     & zz,aa,bb,bas,alat,plat,
     & qbze,efermi,ec_d,evl_d,vxclda,gx_d,gcore_d,cphi_d,geig_d,nocore)
      write(ifi) iantiferro(1:nbas) !may2015
      write(ifi) spid(1:nbas) !nov2015
      close(ifi)
      write(6,"(a,100i4)") ' antiferro index=',iantiferro(1:nbas)
      do ibas=1,nbas
        write(6,"(a,i4,a)") ' i spid=',ibas,' '//trim(spid(ibas))
      enddo

c      stop ' OK! lmf2gw: end --- DATA4GW_V2 is written '
      call rx0( ' OK! lmf2gw: end --- DATA4GW_V2 is written ')
      end program lmf2gw

c$$$      subroutine rx0(string)
c$$$c  write extra information before error exit in standard format
c$$$      character*(*) string
c$$$      write(6,892) string
c$$$  892 format(/' ---- ',a,a)
c$$$      call exit(0)
c$$$      end
c$$$!!--------------------------------------------------------------------------------
c$$$
c$$$
c$$$      subroutine strip(str,i1,i2)
c$$$C!  strip(str,i1,i2) -- Returns i1,i2 so that str(i1:i2) stripped.
c$$$      character*(*) str
c$$$      i1=0
c$$$      do 1 i=1,len(str)
c$$$        if(str(i:i).ne.' ') then
c$$$          i1=i
c$$$          goto 2
c$$$        endif
c$$$  1   continue
c$$$      i1=1
c$$$      i2=0
c$$$      return
c$$$  2   i2=len(str)+1
c$$$      do 3 i=len(str),1,-1
c$$$        if(str(i:i).ne.' ') then
c$$$          i2=i
c$$$          goto 4
c$$$        endif
c$$$  3   continue
c$$$  4   continue
c$$$      end
c$$$
c$$$      subroutine words(str,nw)
c$$$C- Count blank-delimited words in str
c$$$C ----------------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   str   :string
c$$$Co Outputs
c$$$Co   nw    :number of blank-delimited words in str
c$$$Cu Updates
c$$$C ----------------------------------------------------------------------
c$$$C     implicit none
c$$$C ... Passed parameters
c$$$      character*(*) str
c$$$      integer nw
c$$$C ... Local parameters
c$$$      integer i1,i2,i0,i
c$$$
c$$$      nw = 0
c$$$      i1 = 0
c$$$      i2 = 0
c$$$      i0 = 1
c$$$   99 do  10  i = i0, len(str)
c$$$        if(str(i:i) .ne. ' ') then
c$$$          i1 = i
c$$$          goto 90
c$$$        endif
c$$$   10 continue
c$$$      return
c$$$   90 nw = nw+1
c$$$      do  20  i = i1,len(str)
c$$$        if(str(i:i) .eq. ' ') then
c$$$          i2 = i
c$$$          goto 91
c$$$        endif
c$$$   20 continue
c$$$      return
c$$$   91 i0 = i2
c$$$      goto 99
c$$$      end
c$$$      subroutine word(str,iw,j1,j2)
c$$$C- Returns j1,j2 so that str(j1:j2) is the iw-th word from beginning
c$$$C ----------------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   str   :string
c$$$Ci   iw    :find iw-th word
c$$$Co Outputs
c$$$Co   j1    :str(j1:j2) is iw-th word
c$$$Co   j2    :-//-
c$$$Cu Updates
c$$$C ----------------------------------------------------------------------
c$$$C     implicit none
c$$$C ... Passed parameters
c$$$      character*(*) str
c$$$      integer iw,j1,j2
c$$$C ... External calls
c$$$      external nword
c$$$      j1 = 1
c$$$      call nword(str,iw,j1,j2)
c$$$      end
c$$$
c$$$      subroutine nword(str,iw,j1,j2)
c$$$C- Returns j1,j2 so that str(j1:j2) is the iw-th word from current pos
c$$$C ----------------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   str   :string
c$$$Ci   iw    :find iw-th word
c$$$Ci   j1    :start search from str(j1:)
c$$$Co Outputs
c$$$Co   j1    :str(j1:j2) is iw-th word
c$$$Co   j2    :-//-
c$$$Cu Updates
c$$$C ----------------------------------------------------------------------
c$$$C     implicit none
c$$$C ... Passed parameters
c$$$      integer iw,j1,j2
c$$$      character*(*) str
c$$$C ... Local parameters
c$$$      integer nw,i1,i2,i0,i
c$$$      nw = 0
c$$$      i1 = 0
c$$$      i2 = 0
c$$$      i0 = j1
c$$$      j2 = -1
c$$$  99  do  10  i = i0, len(str)
c$$$C   ... skip until nonblank char
c$$$        if(str(i:i) .ne. ' ') then
c$$$          i1 = i
c$$$          goto 90
c$$$        endif
c$$$  10  continue
c$$$      return
c$$$C   ... skip until a blank char
c$$$  90  nw = nw+1
c$$$      if (nw .eq. iw) j1 = i1
c$$$      do  20  i = i1, len(str)
c$$$        if(str(i:i) .eq. ' ') then
c$$$          i2 = i
c$$$          goto 91
c$$$        endif
c$$$   20 continue
c$$$C ... We have reached the end of the string
c$$$      if (nw .eq. iw) j2 = len(str)
c$$$      return
c$$$C ... cleanup: exit if word sought, else try again
c$$$   91 i0 = i2
c$$$      if (nw .eq. iw) then
c$$$        j2 = i2-1
c$$$        return
c$$$      endif
c$$$      goto 99
c$$$      end
c$$$
c$$$
      SUBROUTINE GINTxx(G1,G2,A,B,NR,SUM)
C- Integrate product of two wave functions, Simpson rule
C ----------------------------------------------------------------
c takao \sum_i g(i)*g(i) drdi
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      double precision G1(NR),G2(NR),a,b
      EA2 = DEXP(A + A)
      SUM = 0D0
      DRDI = (A*B)*DEXP(A)
      DO  10  IR = 2, NR-1, 2
        SUM = SUM + G1(IR)*G2(IR)*DRDI
        DRDI = DRDI*EA2
  10  CONTINUE
      SUM = SUM + SUM
      DRDI = (A*B)*EA2
      DO  11  IR = 3, NR-2, 2
        SUM = SUM + G1(IR)*G2(IR)*DRDI
        DRDI = DRDI*EA2
  11  CONTINUE
      RMPB = B*DEXP(A*(NR-1))
      SUM = (2*SUM+ G1(1)*G2(1)*(A*B) + G1(NR)*G2(NR)*(A*RMPB))/3d0
      END

c$$$      integer function fopna(fnam,lunit,ista)
c$$$C- File opening
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci    fnam:  file name
c$$$Ci   lunit:  file logical lunit.  If passed lunit is -1, program finds
c$$$Ci           the next available logical unit; see Remarks.
c$$$Ci   ista:   status switches governing mode of file opening; see Remarks
c$$$Co Outputs
c$$$Co   fopna returns logical lunit number for file name
c$$$Cr Remarks
c$$$Cr   fopnx, below, is an all-purpose file-handling routine that
c$$$Cr   keeps an internal table that maintains an association of filenames
c$$$Cr   with their logical unit and status.  It is intended
c$$$Cr   to facilitate reference to files without carrying around
c$$$Cr   the logical unit number or file status.  Several 'front end'
c$$$Cr   routines listed here call fopnx with special arguments.
c$$$Cr
c$$$Cr   fopng(fnam,lunit,ista):
c$$$Cr     opens file 'fnam' with attributes set by 'ista',
c$$$Cr     assigns logical unit 'lunit', and returns the logical unit.
c$$$Cr     If lunit<0, fopnx will assign the logical unit
c$$$Cr     If fopnx has no record of this file name or logical unit in its
c$$$Cr     internal table, the file name and lunit are added to the table.
c$$$Cr     If fopnx does has a record of the logical unit, that unit and
c$$$Cr     the corresponding filename are used for file handling.  Else:
c$$$Cr     If fopnx does has a record of the file name, that name and
c$$$Cr     corresponding lunit are used for file handling.
c$$$Cr
c$$$Cr      Ista is a composite of integers a, b, c, d, stored as digits
c$$$Cr      abcd, base 2.
c$$$Cr      Bits 01: 0, open the file as 'UNKNOWN'
c$$$Cr               1, open the file as 'OLD'
c$$$Cr               2, open the file as 'NEW'
c$$$Cr      Bit 2:   1, open file as unformatted.
c$$$Cr      Bit 3:   1, do not add this file to the file table
c$$$Cr      Thus ista=5 opens file unformatted, status='old'
c$$$Cr
c$$$Cr   fopna(fnam,lunit,ista):
c$$$Cr     is identical to fopng, except that 'fnam' a path is prepended
c$$$Cr     to, and extension is appended to 'fnam'.  'path' and 'ext'
c$$$Cr     are set and recovered with:
c$$$Cr
c$$$Cr   fext(ext)     sets extension
c$$$Cr   fpath(path)   sets path
c$$$Cr   fextg(ext)    recovers extension
c$$$Cr   fpathg(ext)   recovers path
c$$$Cr
c$$$Cr   fadd(fnam,lunit,ista) adds 'fnam' to the internal table.
c$$$Cr
c$$$Cr   fopn(fnam)  is equivalent to fopna(fnam,0,-1)
c$$$Cr
c$$$Cr   fopnn(fnam)   same as fopn, but open with status='NEW'
c$$$Cr   fopno(fnam)   same as fopn, but open with status='OLD'.
c$$$Cr
c$$$Cr   fxst(fnam)    inquires as to whether file exists
c$$$Cr
c$$$Cr   ffnam(fnam,fnam) returns full file name
c$$$Cr
c$$$Cr   fhndl(fnam) returns with logical lunit associated with name,
c$$$Cr     and -1 if none exists.
c$$$Cr
c$$$Cr   fclr(fnam,unit) clears the file name from the internal table,
c$$$Cr     and closes the file if open.
c$$$Cr
c$$$Cr   ftflsh(unit) flushes output buffer of logical unit.
c$$$Cr     This routine is nonstandard, and works only some some machines.
c$$$Cr     unit = stdout calls a C-language routine that flushes stdout
c$$$Cr     unit < 0 calls a C-language routine that flushes all buffers
c$$$Cr
c$$$Cr   fshow lists the internal table
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$C Passed parameters
c$$$      character*(*) fnam
c$$$      integer ista,lunit
c$$$C Local parameters
c$$$      integer fext,fextg,fopn,fopno,fopnn,fhndl,
c$$$     .fadd,fxst,fpath,fpathg,fopng,fopnx
c$$$      integer mode
c$$$C#ifndef AIX
c$$$      mode = 100 + 70*mod(ista/8,2)
c$$$      fopna = fopnx(fnam,mode,mod(ista,8),lunit)
c$$$      return
c$$$
c$$$      entry fopng(fnam,lunit,ista)
c$$$      mode =   2 + 70*mod(ista/8,2)
c$$$      fopng = fopnx(fnam,mode,mod(ista,8),lunit)
c$$$      return
c$$$
c$$$      entry fadd(fnam,lunit,ista)
c$$$      mode = 114 + 70*mod(ista/8,2)
c$$$      if (lunit .lt. 0) mode = mode-4
c$$$      fadd = fopnx(fnam,mode,mod(ista,8),lunit)
c$$$      return
c$$$
c$$$      entry fopn(fnam)
c$$$      fopn = fopnx(fnam,100,0,-1)
c$$$      return
c$$$
c$$$      entry fopno(fnam)
c$$$      fopno = fopnx(fnam,100,8+1,-1)
c$$$      return
c$$$
c$$$      entry fopnn(fnam)
c$$$      fopnn = fopnx(fnam,100,8+2,-1)
c$$$      return
c$$$
c$$$      entry fxst(fnam)
c$$$      fxst = fopnx(fnam,170,-1,-1)
c$$$      return
c$$$
c$$$      entry fhndl(fnam)
c$$$      fhndl = fopnx(fnam,184,-1,-1)
c$$$      return
c$$$
c$$$      entry fext(fnam)
c$$$      fext = fopnx(fnam,120,0,-1)
c$$$      return
c$$$
c$$$      entry fpath(fnam)
c$$$      fpath = fopnx(fnam,140,0,-1)
c$$$      return
c$$$
c$$$      entry fextg(fnam)
c$$$      fextg = fopnx(fnam,130,0,-1)
c$$$      return
c$$$
c$$$      entry fpathg(fnam)
c$$$      fpathg = fopnx(fnam,150,0,-1)
c$$$      return
c$$$      end
c$$$
c$$$      subroutine fclr(fnam,lunit)
c$$$C     implicit none
c$$$C Passed parameters
c$$$      character*(*) fnam
c$$$      integer lunit,fopnx,i
c$$$
c$$$      i = fopnx(fnam,111,0,lunit)
c$$$      return
c$$$
c$$$      entry fshow()
c$$$      i = fopnx(' ',190,0,-1)
c$$$      end
c$$$      subroutine ffnam(fnam,filnam)
c$$$C- Appends extension to fnam
c$$$C     implicit none
c$$$      character*(*) fnam,filnam
c$$$      integer i,fopnx
c$$$      filnam = fnam
c$$$      i = fopnx(filnam,160,0,-1)
c$$$      end
c$$$
c$$$      integer function fopnx(pnam,mode,ista,lunit)
c$$$C- Kernel called by fopna, etc to open files
c$$$C  THIS IS A STRIPPED DOWN VERSION OF slatsm/fopna.f.
c$$$C  IT DOES NOT PRINT ANYTHING OUT; CONVERSION TO LOWER CASE SUPPRESSED.
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   pnam:   file name, or portion of file name, depending on mode
c$$$Ci   mode:   1s digit (for 10s digit 0)
c$$$Ci           0  Find lunit, ista from name.
c$$$Ci              pnam is name sans path, extension
c$$$Ci              If name does not exist, add to table, assign lunit.
c$$$Ci              Subsequent file handling depends on ista.
c$$$Ci           1  Remove name from internal table.  Close file if open.
c$$$Ci              Error if name is missing from table.
c$$$Ci          ... Add 2 if pnam is already full name
c$$$Ci          ... Add 4 to require lunit match internal table
c$$$Ci                    returns -1 if lgunit<0 and pnam missing from table
c$$$Ci          10s digit:
c$$$Ci           ... 1..6,8,9 suppress file handling
c$$$Ci           ... 1..9 suppresses messing with tables.
c$$$Ci           1  Suppress any file handling
c$$$Ci           2  copy pnam to extension
c$$$Ci           3  copy extension into pnam
c$$$Ci           4  copy pnam to path
c$$$Ci           5  copy path into pnam
c$$$Ci           6  copy full file name into pnam.
c$$$Ci         7,8  Do not alter internal tables
c$$$Ci           8  Suppress any file handling
c$$$Ci           9  Show internal tables
c$$$Ci          100s digit
c$$$Ci           1  convert pnam to lower case
c$$$Ci   ista:  -1  return 1 if file exists, 0 otherwise
c$$$Ci         >=0  sets flags file file status on opening.  This status
c$$$Ci              is kept and used along with the file table.  Internal
c$$$Ci              values are used except when missing or preempted:
c$$$Ci           ...The following bits work as independent switches:
c$$$Ci           ...bits 0,1:
c$$$Ci           0  open the file as 'UNKNOWN', if not open already
c$$$Ci           1  open the file as 'OLD'
c$$$Ci           2  open the file as 'NEW'
c$$$Ci           ...bit 2:
c$$$Ci           4  open the file as 'UNFORMATTED'
c$$$Ci           ...bit 3:
c$$$Ci           8  Override internal ista for bits 0,1
c$$$Ci          16  Override internal ista for bit 2
c$$$Ci   lunit:  (lunit>0) if in table, uses lunit to match instead of name
c$$$Ci              UNLESS mode, 10s digit set.
c$$$Cr Remarks
c$$$Cr   mxnam is maximum number of files that may be open at one time.
c$$$Cr   All file closings should be made through entry fclose
c$$$Cr   17 June 97 internal ista bits 0,1 ALWAYS 0,
c$$$Cr              making default file opening 'unknown'
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$C Passed Parameters
c$$$      integer ista,lunit,mode
c$$$      character*(*) pnam
c$$$      character*11 ftnfmt
c$$$C Local variables
c$$$      logical bittst,isopen,ldum,mod100
c$$$      integer bit,bitand,getdig,i,i1,i2,iprint,locuni,lsta,matchn,
c$$$     .matchu,mode1,mode10,n,IDBG,isw
c$$$      character ftnsta*7, outs*80
c$$$C Parameters concerning limits to string size in filenames:
c$$$C plen: path length; extlen: ext length; maxsiz: name (including ext)
c$$$      integer maxsiz,extlen,plen
c$$$      parameter (extlen=20, plen=80, maxsiz=100)
c$$$      parameter (IDBG=110)
c$$$      integer mxnam
c$$$      parameter (mxnam=3000)
c$$$      character*(maxsiz) tabnam(mxnam),pfnam,fnam
c$$$      character*(extlen) ext
c$$$      character*(plen) path
c$$$      integer tabsw(mxnam), tabuni(mxnam),nnam,lgunit
c$$$      save tabnam, tabsw, tabuni, nnam, ext, path
c$$$      data nnam /0/
c$$$C#ifdef FEXTENS
c$$$      data ext /'.dat'/
c$$$C#elseC
c$$$C      data ext /' '/
c$$$C#endif
c$$$      data path /' '/
c$$$
c$$$      bittst(n,bit) = (mod(n,bit+bit) - mod(n,bit) .eq. bit)
c$$$
c$$$      mode1   = getdig(mode,0,10)
c$$$      mode10  = getdig(mode,1,10)
c$$$      mod100 = getdig(mode,2,10) .ne. 0
c$$$
c$$$C --- Cases handling partial file names ---
c$$$      fopnx = 0
c$$$C ... Change extension
c$$$      if (mode10 .eq. 2) then
c$$$        call namcat(ext,pnam,' ',mod100)
c$$$C        if (iprint() .ge. IDBG) call awrit0(
c$$$C     .    ' FOPNX: set ext to "'//ext//'%a"',' ',80,lgunit(1))
c$$$        return
c$$$C ... Copy extension into pnam
c$$$      elseif (mode10 .eq. 3) then
c$$$        call namcat(pnam,ext,' ',.false.)
c$$$        return
c$$$C ... Change path
c$$$      elseif (mode10 .eq. 4) then
c$$$        call word(pnam,1,i1,i2)
c$$$        if (i2 .le. 0) then
c$$$          path = ' '
c$$$C        elseif (pnam(i2:i2) .eq. '/') then
c$$$C          call namcat(path,pnam,' ',mod100)
c$$$C        else
c$$$C          call namcat(path,pnam,'/',mod100)
c$$$        else
c$$$          call namcat(path,pnam,' ',mod100)
c$$$        endif
c$$$C        if (iprint() .ge. IDBG) call awrit0(
c$$$C     .    ' FOPNX: set path to "'//path//'%a"',' ',80,lgunit(1))
c$$$        return
c$$$C ... Copy path into pnam
c$$$      elseif (mode10 .eq. 5) then
c$$$        call namcat(pnam,path,' ',.false.)
c$$$        return
c$$$C ... Show internal table
c$$$      elseif (mode10 .eq. 9) then
c$$$C        call awrit3('%N fopen:  %i files in table.'//
c$$$C     .    '%?;n;  path='''//path//'%a'';;'//
c$$$C     .    '%?;n;  ext='''//ext//'%a'';;',' ',-80,lgunit(1),nnam,
c$$$C     .    isw(path.ne.' '),isw(ext.ne.' '))
c$$$C        n = 0
c$$$C        do  10  i = 1, nnam
c$$$C          call word(tabnam(i),1,i1,i2)
c$$$C          n = max(n,i2)
c$$$C   10   continue
c$$$C        n = n+2
c$$$C        call awrit1(' file%npunit   mode  open',' ',80,lgunit(1),n)
c$$$C        call pshpr(0)
c$$$C        do  11  i = 1, nnam
c$$$C          call awrit4(' '//tabnam(i)//
c$$$C     .      '%np%,2i    %?;n==0;  fmt;unfmt;   %l',' ',80,lgunit(1),n,
c$$$C     .      tabuni(i),bitand(tabsw(i),4),isopen(tabuni(i),.false.))
c$$$C   11   continue
c$$$C        call poppr
c$$$C        print *, ' '
c$$$        return
c$$$
c$$$      endif
c$$$
c$$$C --- Make full file name ---
c$$$      if (bittst(mode1,2)) then
c$$$        call namcat(pfnam,pnam,' ',mod100)
c$$$      else
c$$$        call namcat(pfnam,pnam,' ',mod100)
c$$$        call namcat(fnam,pfnam,ext,.false.)
c$$$        call namcat(pfnam,path,fnam,.false.)
c$$$      endif
c$$$
c$$$C ... Return full file name in pnam
c$$$      if (mode10 .eq. 6) then
c$$$        call namcat(pnam,pfnam,' ',.false.)
c$$$        return
c$$$      endif
c$$$
c$$$C --- Match lunit with table.  matchu=-1 unless a match exists ---
c$$$      matchu = -1
c$$$      if (lunit .gt. 0) then
c$$$        do  110  i = 1, nnam
c$$$          matchu = i
c$$$          if (tabuni(i) .eq. lunit) goto 111
c$$$  110   continue
c$$$        matchu = -1
c$$$  111   continue
c$$$      endif
c$$$
c$$$C --- If no match, get next available unit number => locuni ---
c$$$      locuni = lunit
c$$$      if (matchu .eq. -1 .and. lunit .lt. 0) then
c$$$        locuni = 7
c$$$   12   locuni = locuni+1
c$$$        if (isopen(locuni,.false.)) goto 12
c$$$        do  14  i = 1, nnam
c$$$          if (tabuni(i) .eq. locuni) goto 12
c$$$   14   continue
c$$$      endif
c$$$
c$$$C --- Match pfnam with table, unless not needed ---
c$$$      matchn = matchu
c$$$      if (matchu .le. 0 .or. bittst(mode1,4)) then
c$$$        do  30  i = 1, nnam
c$$$          matchn = i
c$$$          if (tabnam(i) .eq. pfnam) goto 31
c$$$   30   continue
c$$$        matchn = -1
c$$$   31   continue
c$$$      endif
c$$$      if (lunit .lt. 0 .and. matchn .gt. 0) then
c$$$        matchu = matchn
c$$$        locuni = tabuni(matchn)
c$$$      elseif (lunit .lt. 0 .and. bittst(mode1,4)) then
c$$$C        call rxs('fopnx: no unit or name specified, file ',pnam)
c$$$        fopnx = -1
c$$$        return
c$$$      endif
c$$$
c$$$      fopnx = locuni
c$$$
c$$$C ... Force match between name and unit, or error
c$$$C      call awrit1('%xFOPNX: file '//pfnam//'%a, unit %i, '//
c$$$C     .  'conflicts with prior use',outs,80,0,locuni)
c$$$      if (matchu .ne. matchn .and. bittst(mode1,4)) then
c$$$C        if (matchu .gt. 0)
c$$$C     .    call awrit0('%a%10b file '//tabnam(matchu),outs,80,0)
c$$$        call rx(outs)
c$$$      endif
c$$$
c$$$C --- Add a file to internal table ---
c$$$      if (matchu .lt. 0 .and. mode10 .le. 6) then
c$$$        if (mod(mode1,2) .eq. 1) then
c$$$          if (lunit .gt. 0)
c$$$     .    call rxi('FOPNX: attempt to remove nonexistent unit',lunit)
c$$$          call rx('FOPNX: attempt to remove nonexistent name ')
c$$$        endif
c$$$        nnam = nnam+1
c$$$        if (nnam .gt. mxnam) call
c$$$     .  rxi('FOPNX: too many file names.  max=',mxnam)
c$$$        tabnam(nnam) = pfnam
c$$$        tabuni(nnam) = locuni
c$$$        tabsw(nnam)  = mod(ista,8) - mod(ista,4)
c$$$        matchu = nnam
c$$$C --- Remove a file entry from the internal table ---
c$$$      elseif (mod(mode1,2) .eq. 1 .and. mode10 .le. 7) then
c$$$        i = tabuni(matchu)
c$$$        if (isopen(i,.false.)) call fclose(i)
c$$$        do  130  i = matchu+1, nnam
c$$$          tabnam(i-1) = tabnam(i)
c$$$          tabuni(i-1) = tabuni(i)
c$$$          tabsw(i-1)  = tabsw(i)
c$$$  130   continue
c$$$        nnam = nnam-1
c$$$        return
c$$$      endif
c$$$
c$$$C#ifdefC DEBUG
c$$$C      if (iprint() .ge. IDBG) then
c$$$C        call pshpr(0)
c$$$C        call awrit3(' FOPEN: file '//pfnam//'%a unit %i  status %i'//
c$$$C     .  ' open=%l',' ',80,lgunit(1),locuni,ista,isopen(locuni,.false.))
c$$$C        call poppr
c$$$C      endif
c$$$C#endif
c$$$
c$$$C --- Cases ista=-2,-1 ---
c$$$      if (ista .eq. -2 .or. mode10 .ne. 0 .and. mode10 .ne. 7) return
c$$$      if (ista .eq. -1) then
c$$$C#ifdefC PRECONNECTED_UNITS | IBM_VM
c$$$C        INQUIRE(UNIT=lunit,EXIST=ldum)
c$$$C#else
c$$$        INQUIRE(FILE=pfnam,EXIST=ldum)
c$$$C#endif
c$$$        fopnx = 0
c$$$        if (ldum) fopnx = 1
c$$$        return
c$$$      else
c$$$      endif
c$$$
c$$$C ... Format status
c$$$      lsta = ista
c$$$      if (matchu .gt. 0) then
c$$$C        lsta = tabsw(matchu)
c$$$C        if (bittst(ista,8))  lsta = bitand(lsta,1023-3) + bitand(ista,3)
c$$$C        if (bittst(ista,16)) lsta = bitand(lsta,1023-4) + bitand(ista,4)
c$$$C        tabsw(matchu) = lsta - mod(lsta,4)
c$$$        lsta = bitand(lsta,1023-4) + bitand(tabsw(matchu),4)
c$$$        if (bittst(ista,16)) then
c$$$          lsta = bitand(lsta,1023-4) + bitand(ista,4)
c$$$          tabsw(matchu) = bitand(tabsw(matchu),1023-4) + bitand(ista,4)
c$$$        endif
c$$$      endif
c$$$      ftnfmt = 'FORMATTED'
c$$$      if (bittst(lsta,4)) ftnfmt = 'UNFORMATTED'
c$$$
c$$$C ... Handle fortran status (slow, but apparently stable)
c$$$      ftnsta = 'UNKNOWN'
c$$$      if (mod(lsta,4) .eq. 1) ftnsta = 'OLD'
c$$$      if (mod(lsta,4) .eq. 2) then
c$$$        ftnsta = 'NEW'
c$$$        call fclose(locuni)
c$$$C#ifdefC PRECONNECTED_UNITS | IBM_VM
c$$$C        open(locuni,FORM=ftnfmt,STATUS='UNKNOWN')
c$$$C#else
c$$$        open(locuni,FILE=pfnam,FORM=ftnfmt,STATUS='UNKNOWN')
c$$$C#endif
c$$$        close(unit=locuni,status='DELETE')
c$$$      endif
c$$$
c$$$c      print *, 'dbg: fopn',pfnam,locuni,lsta,ftnfmt,ftnsta
c$$$
c$$$      if (.not. isopen(locuni,.true.)) then
c$$$        call word(pfnam,1,i1,i2)
c$$$        call chrpos(pfnam,' ',plen+maxsiz,i)
c$$$        if (iprint() .ge. IDBG) print *, 'FOPEN: opening ',ftnfmt,
c$$$     .  ' file ''',pfnam(1:i2),''', status=',ftnsta,', unit=',locuni
c$$$C#ifdefC PRECONNECTED_UNITS | IBM_VM
c$$$C        open(locuni,FORM=ftnfmt,STATUS=ftnsta)
c$$$C#else
c$$$        open(locuni,FILE=pfnam(i1:i2),FORM=ftnfmt,STATUS=ftnsta)
c$$$        rewind locuni
c$$$C#endif
c$$$      endif
c$$$
c$$$      end
c$$$      logical function isopen(unit,sw)
c$$$C- Returns whether unit aleady open; optionally adds unit to list if not
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   unit: if unit not among list of open files, add to list
c$$$Ci   sw:   if false, return isopen but do not add to list
c$$$Co Outputs
c$$$Co   isopen
c$$$Cr Remarks
c$$$Cr   maxfil is maximum number of files that may be open at one time
c$$$Cr   All file closings should be made through entry fclose
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$      integer unit
c$$$      logical sw
c$$$      integer i,iprint
c$$$      integer maxfil
c$$$      parameter (maxfil=3000)
c$$$      integer unitab(0:maxfil-1),nopen
c$$$      common /funits/ unitab,nopen
c$$$
c$$$      if (iprint() .gt. 110) print 20, unit, (unitab(i), i=0, nopen-1)
c$$$   20 format(/' ISOPEN: check logical unit',i3,
c$$$     .' among open units: ',15i3)
c$$$
c$$$      isopen = .true.
c$$$      do  10  i = nopen-1, 0, -1
c$$$        if (unitab(i) .eq. unit) return
c$$$   10 continue
c$$$
c$$$      isopen = .false.
c$$$      if (.not. sw) return
c$$$      unitab(nopen) = unit
c$$$      nopen = nopen+1
c$$$      if (nopen .gt. maxfil) call rx('ISOPEN: too many files')
c$$$      end
c$$$      subroutine fclose(unit)
c$$$C- Closes an open file, removing unit from the stack
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   unit
c$$$Co Outputs
c$$$Co   none
c$$$Cr Remarks
c$$$Cr   use in conjunction with isopen
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$      integer unit
c$$$      integer i,iprint
c$$$      character*6 clstat
c$$$      integer maxfil
c$$$      parameter (maxfil=3000)
c$$$      integer unitab(0:maxfil-1),nopen
c$$$      common /funits/ unitab,nopen
c$$$
c$$$      clstat = 'KEEP'
c$$$      goto 10
c$$$
c$$$   10 continue
c$$$      if (iprint() .ge. 100) print 20, unit
c$$$   20 format(' FCLOSE: closing',i3)
c$$$
c$$$      do  30  i = nopen-1, 0, -1
c$$$        if (unitab(i) .eq. unit) unitab(i) = 999
c$$$   30 continue
c$$$      call ishell(nopen,unitab)
c$$$      if (nopen .eq. 0 .or. unitab(max(nopen-1,0)) .ne. 999) then
c$$$        if (iprint() .ge. 100)
c$$$     .  print *, 'FCLOSE: attempt to close unopened file'
c$$$      else
c$$$        close(unit=unit,status=clstat)
c$$$        nopen = nopen-1
c$$$      endif
c$$$      return
c$$$
c$$$      entry dfclos(unit)
c$$$      clstat = 'DELETE'
c$$$      goto 10
c$$$
c$$$C --- Close all open files ---
c$$$      entry closea()
c$$$      do  50  i = 0, nopen-1
c$$$        if (iprint() .ge. 100) print *,'CLOSEA: closing file ',unitab(i)
c$$$        close(unit=unitab(i),status='KEEP')
c$$$        unitab(i) = 999
c$$$   50 continue
c$$$      nopen = 0
c$$$      return
c$$$      end
c$$$      integer function lgunit(i)
c$$$C- Returns stdout for i=1, log for i=2
c$$$C     implicit none
c$$$      integer i, fopn, i1mach, fhndl
c$$$C     lgunit = i1mach(2)
c$$$      lgunit = 6
c$$$      if (i .eq. 1) return
c$$$      lgunit = -1
c$$$      if (fhndl('LOG') .lt. 0) return
c$$$      lgunit = fopn('LOG')
c$$$      end
c$$$      subroutine namcat(dest,fnam1,fnam2,lcase)
c$$$C- Concatenates two names, optionally lowering the case
c$$$C     implicit none
c$$$      logical lcase
c$$$      character*(*) fnam1,fnam2,dest
c$$$      integer iprint,i1,i2,j1,j2
c$$$
c$$$      call word(fnam1,1,i1,i2)
c$$$      call word(fnam2,1,j1,j2)
c$$$      i2 = max(i1-1,i2)
c$$$      j2 = max(j1,j2)
c$$$      dest = fnam2(j1:j2)
c$$$      if (i2 .ge. i1) dest = fnam1(i1:i2)//fnam2(j1:j2)
c$$$      if (i2-i1+j2-j1+2 .gt. len(dest) .and. iprint() .gt. 0) then
c$$$        print *, 'namcat: string "',fnam1(i1:i2),fnam2(j1:j2),
c$$$     .  '" was truncated to "',dest,'"'
c$$$      endif
c$$$
c$$$C#ifdef unix
c$$$C     if (lcase) call locase(dest)
c$$$C#endif
c$$$
c$$$      end
c$$$      subroutine ftflsh(ifi)
c$$$C- Flushes output buffer for file ifi
c$$$C  NB: this routine is nonstandard, and machine-dependent.
c$$$C     implicit none
c$$$      integer ifi
c$$$      character fname*101,fmt*33
c$$$      integer i1mach,j1,j2
c$$$      logical open
c$$$
c$$$C      if (ifi .eq. i1mach(2)) then
c$$$C        call flushs(1)
c$$$C      elseif (ifi .lt. 0) then
c$$$C        call flushs(-1)
c$$$CC#ifdefC AIX
c$$$CC      else
c$$$CC        inquire (UNIT=ifi,OPENED=open,NAME=fname,FORM=fmt)
c$$$CC        call word(fname,1,j1,j2)
c$$$CCC        write (6,220) ifi,open,fname(j1:j2),fmt
c$$$CCC  220   format(' unit',i3,' open=',l1,'  name=',a,'  fmt=',a)
c$$$CC        if (open) then
c$$$CC          close(ifi)
c$$$CC          open(ifi, file=fname, form=fmt, status='old')
c$$$CC        endif
c$$$CC#endif
c$$$C      endif
c$$$      end
c$$$
c$$$      subroutine chrpos(s,ch,maxch,ich)
c$$$C- Finds position of character in string
c$$$C ----------------------------------------------------------------
c$$$Ci Inputs
c$$$Ci   s:   string (declared as s(0:*)
c$$$Ci   ch:  character sought
c$$$Ci   ich: start search at s(ich)
c$$$ci   maxch: see ich
c$$$Co Outputs
c$$$Co   ich: position of character ch, not to exceed maxch
c$$$Cr Remarks
c$$$Cr    seeks match at string(i0), string(i0+1) until ch is found or until
c$$$Cr    ich = maxch.
c$$$C ----------------------------------------------------------------
c$$$C     implicit none
c$$$      integer ich,maxch
c$$$      character*1 ch,s(0:*)
c$$$
c$$$   10 if (ich .eq. maxch  .or.  s(ich) .eq. ch) return
c$$$      ich = ich+1
c$$$      goto 10
c$$$      end
c$$$
c$$$C --- Verbosity stack functions ---
c$$$C Functions are:
c$$$C iprint(): return value from top of stack
c$$$C pshprt(vb): push value onto top of stack
c$$$C popprt:     pop verbosity stack
c$$$C togprt:     exhanges position of top two values on stack
c$$$C setpr(vb):  replace top of stack with vb
c$$$C getpr(vb):  set vb to value at top of stack
c$$$C iprt(istk): return verbosity istk levels down
c$$$C sprt(istk,vb): sets verbosity istk levels down
c$$$C --- iprint, iprt ---
c$$$      integer function iprint()
c$$$C- get last integer off print priority stack
c$$$C     implicit none
c$$$      integer nstack,istk,iprt
c$$$      parameter (nstack=6)
c$$$      integer vstack(0:nstack-1),stackp
c$$$      common /iprnt/ vstack,stackp
c$$$      iprint = vstack(stackp)
c$$$      return
c$$$
c$$$      entry iprt(istk)
c$$$      iprt = vstack(mod(stackp+istk,nstack))
c$$$c      print*, istk,iprt,stackp,vstack
c$$$      end
c$$$C --- pshprt, pshpr, setpr, getpr, popprt, poppr --
c$$$      subroutine pshprt(vb)
c$$$C     implicit none
c$$$      entry pshpr(vb)
c$$$      integer vb,istk,j
c$$$      integer nstack
c$$$      parameter (nstack=6)
c$$$      integer vstack(0:nstack-1),stackp
c$$$      common /iprnt/ vstack,stackp
c$$$      stackp = mod(stackp+(nstack-1),nstack)
c$$$
c$$$      entry setpr(vb)
c$$$      vstack(stackp) = vb
c$$$      return
c$$$
c$$$      entry getpr(vb)
c$$$      vb = vstack(stackp)
c$$$      return
c$$$
c$$$      entry popprt()
c$$$      entry poppr()
c$$$      stackp = mod(stackp+1,nstack)
c$$$      return
c$$$
c$$$      entry sprt(istk,vb)
c$$$      vstack(mod(stackp+istk,nstack)) = vb
c$$$      return
c$$$
c$$$      entry shopr()
c$$$      print 333, (vstack(mod(stackp+j,nstack)), j=0,nstack-1)
c$$$  333 format(' vb stack',10i4)
c$$$      end
c$$$
c$$$C --- togprt ---
c$$$      subroutine togprt
c$$$C     implicit none
c$$$      integer nstack
c$$$      parameter (nstack=6)
c$$$      integer vstack(0:nstack-1),stackp
c$$$      common /iprnt/ vstack,stackp
c$$$      integer itmp,jtmp
c$$$
c$$$      entry togpr()
c$$$      itmp = vstack(stackp)
c$$$      call popprt
c$$$      jtmp = vstack(stackp)
c$$$      call popprt
c$$$      call pshprt(itmp)
c$$$      call pshprt(jtmp)
c$$$      end
c$$$C --- Defaults ---
c$$$      block data iprntb
c$$$C     implicit none
c$$$      integer nstack
c$$$      parameter (nstack=6)
c$$$      integer vstack(0:nstack-1),stackp
c$$$      common /iprnt/ vstack,stackp
c$$$      data vstack /30,30,30,30,30,30/, stackp /0/
c$$$      end
c$$$
c$$$c$$$      subroutine gwinput(ifi,
c$$$c$$$     &  nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$c$$$     &  lmxamx,ngpmx,  nband,  ldim,   nqbze ,
c$$$c$$$c
c$$$c$$$     &  iclass,lmxa,nr,konf,ncore,
c$$$c$$$     &  zz,aa,bb,bas,alat,plat,
c$$$c$$$     &  qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore )
c$$$c$$$c- Read and Write the informations required for GW calculations.
c$$$c$$$c
c$$$c$$$cr When you write these data, you first have to open a file DATA4GW with the file handle ifi>0.
c$$$c$$$cr ,e.g,  open(ifi ,file='DATA4GW',form='unformatted')
c$$$c$$$cr
c$$$c$$$cr Radial mesh is specified from, nr, aa, and bb; mesh is r(i) = bb*(exp(aa*(i-1)) -1) ,i=1,nr
c$$$c$$$cr
c$$$c$$$cr When you read these data, you first need to read the sizes by the subbroutine gwinput0
c$$$c$$$cr in order to allocate required arrays.
c$$$c$$$cr
c$$$c$$$c----------------------------------------------------------------------------------------------
c$$$c$$$C     implicit none
c$$$c$$$      integer :: ifi, !File handle. Write for ifi<0. Read for ifi>0.
c$$$c$$$     &  nsp,      ! =1 or 2, corresponding to para or ferro.
c$$$c$$$     &  nbas,     ! Number of atom in the primitive cell
c$$$c$$$     &  nclass,   ! Number of atomic class (or type) for in the primitive cell
c$$$c$$$     &  nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
c$$$c$$$     &  ncoremx,  ! = maxval(ncore(1:nclass))
c$$$c$$$c
c$$$c$$$     &  lmxamx,   ! = maxval(lmxa(1:nclass))
c$$$c$$$     &  ngpmx,    ! Maximum number of G vector.
c$$$c$$$     &  nband,    ! Number of bands given by GWIN0
c$$$c$$$     &  ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
c$$$c$$$     &  nqbze,    ! = nqbz*(1+nq0i). Number of q points given by qg4gw
c$$$c$$$c----
c$$$c$$$     &  iclass(nbas),   ! class is starting from 1.
c$$$c$$$     &  lmxa  (nclass), ! Maximum l number for each atom for argumentation.
c$$$c$$$     &  nr(nclass),     ! Size of radial mesh.
c$$$c$$$     &  konf(0:lmxamx,nclass),! Principle quantum numbers of valence electron.
c$$$c$$$                              ! For example, 4s4p3d means konf(0)=4, konf(1)=4, konf(2)=3.
c$$$c$$$                              ! Core orbitals are specified by
c$$$c$$$                              !   1, 2,... konf(0)-1 for s
c$$$c$$$                              !   2, 3,... konf(1)-1 for p
c$$$c$$$                              !   3, 4,... konf(2)-1 for d, and so on.
c$$$c$$$                              ! The 10s digit is used as a separate
c$$$c$$$                              ! number to mark whether this channel
c$$$c$$$                              ! contains a local orbital:
c$$$c$$$                              ! 10s digit
c$$$c$$$                              ! 0 -> no local orbital in this channel
c$$$c$$$                              ! 1 -> local orbital with energy below valence
c$$$c$$$                              ! 2 -> local orbital with energy above valence
c$$$c$$$     &  ncore(nclass)   ! ncore = \sum_l  (konf(l)-1) - l
c$$$c$$$                        ! Number of different core orbitals for each atom.
c$$$c$$$      real(8) ::
c$$$c$$$     &  zz(nclass),     ! Atomic number.
c$$$c$$$     &  aa(nclass),bb(nclass),! Radial mesh are specified by these parameters with nr.
c$$$c$$$     &  bas(3,nbas),    ! Atomic posion in the Cartesian coordinate (alat unit),.
c$$$c$$$     &  alat,           ! Lattice constant in a.u.
c$$$c$$$     &  plat(3,3),      ! Primitive translation vector in the unit of alat. plat(1:3,1) is 1st vector, ans so on.
c$$$c$$$     &  qbze(3,nqbze),  ! q points given by qg4gw
c$$$c$$$     &  efermi,         ! Fermi energy. It should be calculated for n1 n2 n3 given by GIWN0.
c$$$c$$$c----
c$$$c$$$     &  ec(ncoremx, nclass, nsp),   ! Eigenvalues for core
c$$$c$$$     &  evl    (nband, nqbze, nsp), ! Eigenvalues
c$$$c$$$     &  vxclda (nband, nqbze, nsp), ! Lda XC potential <psi|Vxc(n_total)  |psi>
c$$$c$$$                                    !  or   <psi|Vxc(n_valence)|psi>. See nocore.
c$$$c$$$     &  gx (nrmx, 0:lmxamx, 2,  nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
c$$$c$$$                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
c$$$c$$$     &  gcore(nrmx, ncoremx, nclass,nsp)  ! Core radial function.
c$$$c$$$c
c$$$c$$$c     These radial functions are only the major part given by the scalar relativistic calculations.
c$$$c$$$c     gx and gcore = r \phi(r) = u(r), where \phi is the major part of the true radial functions.
c$$$c$$$c     gx is normalized as 1 = \int dr gx**2
c$$$c$$$c     gcore is the major part of the true radial functions.
c$$$c$$$c
c$$$c$$$      complex(8)::
c$$$c$$$     &  cphi(ldim, 2, nband, nqbze,nsp),! Coefficients of eigenfunction
c$$$c$$$                                        ! for phi    = cphi(ldim, 1, nband, nqbze), and
c$$$c$$$                                        ! for phidot = cphi(ldim, 2, nband, nqbze).
c$$$c$$$     &  geig(ngpmx,   nband, nqbze,nsp) ! Coefficients of eigenfunction for IPW.
c$$$c$$$      logical ::
c$$$c$$$     &   nocore  ! Flag file NoCore exist or not.
c$$$c$$$                 ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
c$$$c$$$                 ! If nocore exist. you have to supply
c$$$c$$$                 !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
c$$$c$$$                 ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
c$$$c$$$c----
c$$$c$$$      if(ifi>0) then
c$$$c$$$        read(ifi)
c$$$c$$$     &              iclass,lmxa,nr,konf,ncore,
c$$$c$$$     &              zz,aa,bb,bas,alat,plat,
c$$$c$$$     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
c$$$c$$$      elseif(ifi<0) then
c$$$c$$$        write(-ifi)
c$$$c$$$     &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$c$$$     &              lmxamx,ngpmx,  nband,  ldim,   nqbze
c$$$c$$$c
c$$$c$$$        write(6,*)
c$$$c$$$        write(6,*)' *** DATA4GW size=', nsp,  nbas, nclass, nrmx,ncoremx
c$$$c$$$        write(6,*)'                 =', lmxamx,ngpmx, nband, ldim, nqbze
c$$$c$$$
c$$$c$$$        write(-ifi)
c$$$c$$$     &              iclass,lmxa,nr,konf,ncore,
c$$$c$$$     &              zz,aa,bb,bas,alat,plat,
c$$$c$$$     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
c$$$c$$$      else
c$$$c$$$        stop 'gwinput: wrong ifi'
c$$$c$$$      endif
c$$$c$$$      end
c$$$c----------------------------------------------------------------------
c$$$C       subroutine gwinput0(ifi,
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze    )
c$$$C c  Read dimensions only.
c$$$C C     implicit none
c$$$C       integer::  ifi,
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze
c$$$C       read(ifi)
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim,   nqbze
c$$$C c    write(6,*)' 0 DATA4GW size=', nsp,   nbas, nclass, nrmx,ncoremx
c$$$C c    write(6,*)'                 =', lmxamx,ngpmx,  nband,  ldim, nqbze
c$$$C       end
c$$$      subroutine ishell(n,iarray)
c$$$      integer n
c$$$      integer iarray(1)
c$$$      integer lognb2,i,j,k,l,m,nn,it
c$$$
c$$$      if (n .le. 1) return
c$$$      lognb2 = int(log(float(n+1))*1.4426950)
c$$$      m = n
c$$$      do  12  nn = 1, lognb2
c$$$        m = m/2
c$$$        k = n - m
c$$$        do  11  j = 1, k
c$$$          i = j
c$$$    3     continue
c$$$          l = i + m
c$$$          if (iarray(l) .lt. iarray(i)) then
c$$$            it = iarray(i)
c$$$            iarray(i) = iarray(l)
c$$$            iarray(l) = it
c$$$            i = i - m
c$$$            if (i .ge. 1) goto 3
c$$$          endif
c$$$   11   continue
c$$$   12 continue
c$$$      return
c$$$      end
c$$$c----------------------------------------------------------------------
c$$$
      subroutine gwinput_v2x(ifi,
     &nsp,   nbas,   nclass, nrmx,   ncoremx,
     &lmxamx,ngpmx,  nband,  ldim2,   nqbze ,
     &nphi,nphimx,nindx,lindx,ibasindx,
     &iclass,lmxa,nr,konf,ncore,
     &zz,aa,bb,bas,alat,plat,
     &qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore)
c
c     &  ifomit ) !If ifomit=T, omit to store cphi and geig
c- Read and Write the informations required for GW calculations.
c
cr When you write these data, you first have to open a file DATA4GW with the file handle ifi>0.
cr ,e.g,  open(ifi ,file='DATA4GW',form='unformatted')
cr
cr Radial mesh is specified from, nr, aa, and bb; mesh is r(i) = bb*(exp(aa*(i-1)) -1) ,i=1,nr
cr
cr When you read these data, you first need to read the sizes by the subbroutine gwinput0
cr in order to allocate required arrays.
cr
cr NLAindx file should be written by echo 0|lmfgw -------
cr   It should be
cr----NLAindx start---------------
cr     ldim2
cr     n l ibas for each line --- Repeat this line for the number of ldim2.
cr                            --- nphimx=maximum value of n.
cr
c----------------------------------------------------------------------------------------------
C     implicit none
      integer :: ifi, !File handle. Write for ifi<0. Read for ifi>0.
     &nsp,      ! =1 or 2, corresponding to para or ferro.
     &nbas,     ! Number of atom in the primitive cell
     &nclass,   ! Number of atomic class (or type) for in the primitive cell
     &nrmx,     ! = maxval(nr(1:nclass))  Maximum number of nr
     &ncoremx,  ! = maxval(ncore(1:nclass))
c
     &lmxamx,   ! = maxval(lmxa(1:nclass))
     &ngpmx,    ! Maximum number of G vector.
     &nband,    ! Number of bands given by GWIN0
cv2     &  ldim,     ! = sum ( (lmxa(1:nbas)+1)**2 )
     &nqbze,    ! = nqbz*(1+nq0i). Number of q points given by qg4gw
c----
     &iclass(nbas),   ! class is starting from 1.
     &lmxa  (nclass), ! Maximum l number for each atom for augmentation.
     &nr(nclass),     ! Size of radial mesh.
     &konf(0:lmxamx,nclass),! Principle quantum numbers of valence electron.
c                              ! For example, 4s4p3d means konf(0)=4, konf(1)=4, konf(2)=3.
c                              ! Core orbitals are specified by
c                              !   1, 2,... konf(0)-1 for s
c                              !   2, 3,... konf(1)-1 for p
c                              !   3, 4,... konf(2)-1 for d, and so on.
c                              !
     &ncore(nclass)   ! ncore = \sum_l  (konf(l)-1) - l
c                        ! Number of different core orbitals for each atom.
c
cv2
      integer:: nphi,          ! number of augmentation nRl channels, as distinct from:
     &ldim2,         ! number of nRLm channels = 2*ldim for phi+phidot case.
     &nphimx,        ! Maxmum number of phi for all l ---  2 for phi+phidot case.
     &nindx(ldim2),  ! n    index
     &lindx(ldim2),  ! l    index
     &ibasindx(ldim2)! ibas index
c
      real(8) ::
     &zz(nclass),     ! Atomic number.
     &aa(nclass),bb(nclass),! Radial mesh are specified by these parameters with nr.
     &bas(3,nbas),    ! Atomic posion in the Cartesian coordinate (alat unit),.
     &alat,           ! Lattice constant in a.u.
     &plat(3,3),      ! Primitive translation vector in the unit of alat. plat(1:3,1) is 1st vector, ans so on.
     &qbze(3,nqbze),  ! q points given by qg4gw
     &efermi,         ! Fermi energy. It should be calculated for n1 n2 n3 given by GIWN0.
c----
     &ec(ncoremx, nclass, nsp),   ! Eigenvalues for core
     &evl    (nband, nqbze, nsp), ! Eigenvalues
     &vxclda (nband, nqbze, nsp), ! Lda XC potential <psi|Vxc(n_total)  |psi>
c                                    !  or   <psi|Vxc(n_valence)|psi>. See nocore.
c
cv2     &  gx (nrmx, 0:lmxamx, 2,  nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
cv2                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
     &gx (nrmx, 0:lmxamx, nphimx, nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
c                                          !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
     &gcore(nrmx, ncoremx, nclass,nsp)  ! Core radial function.
c
c     These radial functions are only the major part given by the scalar relativistic calculations.
c     gx and gcore = r \phi(r) = u(r), where \phi is the major part of the true radial functions.
c     gx is normalized as 1 = \int dr gx**2
c     gcore is the major part of the true radial functions.
c

      complex(8)::
cv2     &  cphi(ldim, 2, nband, nqbze,nsp), ! Coefficients of eigenfunction
cv2                                         ! for phi    = cphi(ldim, 1, nband, nqbze), and
cv2                                         ! for phidot = cphi(ldim, 2, nband, nqbze).
     &cphi(ldim2,  nband, nqbze,nsp),     ! Coefficients of eigenfunction
c
     &geig(ngpmx,  nband, nqbze,nsp)  ! Coefficients of eigenfunction for IPW.


      logical ::
     &nocore  ! Flag file NoCore exist or not.
      ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
      ! If nocore exist. you have to supply
      !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqbze).
      ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
c      logical :: ifomit
c----
      if(ifi>0) then
c        if(ifomit) then
        read(ifi)
     &  iclass,lmxa,nr,konf,ncore,
     &  zz,aa,bb,bas,alat,plat,
     &  qbze,efermi,ec,evl,vxclda,gx,gcore,nocore !omit cphi and geig
cv2
     &  ,nindx,lindx,ibasindx
c        else
c          read(ifi)
c     &              iclass,lmxa,nr,konf,ncore,
c     &              zz,aa,bb,bas,alat,plat,
c     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
ccv2
c     &              ,nindx,lindx,ibasindx
c        endif
ccccccccccccccccc
        write(6,*)'gwinput_v2x: DATA4GW_V2 readin size=',
     &  nsp,nbas, nclass, nrmx,ncoremx
        write(6,*)'                 =', lmxamx,ngpmx,nband,ldim2, nqbze
        write(6,*)'ncoremx=',ncoremx
        write(6,*)'ecup=',ec(1:ncoremx, 1, 1)
        if(nsp==2) write(6,*)'ecdn=',ec(1:ncoremx, 1, 2)
ccccccccccccccccc

ccccccccccccccccccccccc
c--- This is a swap test ---
c      call swapc(cphi(5:9,    1:nband,1:nqbze,1:nsp)
c     &          ,cphi(201:205,1:nband,1:nqbze,1:nsp),5*nband*nqbze*nsp)
c      call swapr(gx(1:nrmx,2,1,1,1:nsp),gx(1:nrmx,2,3,1,1:nsp),nrmx*nsp)
c      print *,' ----swap test------'
ccccccccccccccccccccccc


ccccccccccccccccccccccc
c       cphi(201:205,1:nband,1:nqbze,1:nsp) = 0d0
c       print *,' --- skip 4d test ---'
ccccccccccccccccccccccc


c---------------------------
      elseif(ifi<0) then
        write(-ifi)
     &  nsp,   nbas,   nclass, nrmx,   ncoremx,
     &  lmxamx,ngpmx,  nband,  ldim2,   nqbze,
cv2
     &  nphi,nphimx
c
        write(6,*)
        write(6,*)' *** DATA4GW_V2 size=', nsp,nbas,nclass,nrmx,ncoremx
        write(6,*)'                 =', lmxamx,ngpmx, nband,ldim2, nqbze
        write(6,*)'                 =', nphi, nphimx

c        if(ifomit) then
        write(-ifi)
     &  iclass,lmxa,nr,konf,ncore,
     &  zz,aa,bb,bas,alat,plat,
     &  qbze,efermi,ec,evl,vxclda,gx,gcore,nocore !omit cphi and geig
cv2
     &  ,nindx,lindx,ibasindx
c        else
c          write(-ifi)
c     &              iclass,lmxa,nr,konf,ncore,
c     &              zz,aa,bb,bas,alat,plat,
c     &              qbze,efermi,ec,evl,vxclda,gx,gcore,cphi,geig,nocore
ccv2
c     &              ,nindx,lindx,ibasindx
c        endif
      else
        stop 'gwinput: wrong ifi'
      endif
      end
c$$$c----------------------------------------------------------------------
c$$$C       subroutine gwinput0_v2(ifi,
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze,
c$$$C      &              nphi, nphimx)
c$$$C c  Read dimensions only.
c$$$C C     implicit none
c$$$C       integer::  ifi,
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze ,
c$$$C      &              nphi, nphimx
c$$$C       read(ifi)
c$$$C      &              nsp,   nbas,   nclass, nrmx,   ncoremx,
c$$$C      &              lmxamx,ngpmx,  nband,  ldim2,   nqbze,
c$$$C      &              nphi, nphimx
c$$$C       end
c$$$c--------------------
c$$$
      subroutine rdibasindx2(ldim2,nphi,nphimx,nindx,lindx,ibasindx,ifi)
C- Reads indexing data for augmentation functions
C ----------------------------------------------------------------------
Ci Inputs
Ci   ldim2 :number of augmentation functions nRlm in unit cell
Ci         :(used here as a sanity check)
Ci   ifi   :file handle ifi>0 for file read
Co Outputs
Co   nphi  :number of augmentation functions nRl  in unit cell
Co   nphimx:maximum number of aug. functions in a single Rl channel
Co   nindx :nindx(i) type of augm. function for the ith Rl channel
Co         :e.g. nindx=1 : phi, nindx=2 : phidot,  nindx=3 : loc. orb
Co   lindx :l quantum number for the ith Rl channel
Co ibasindx:site index for the ith Rl channel
Cr Remarks
Cu Updates
Cu   05 Mar 02 First created
C ----------------------------------------------------------------------
C     implicit none
      integer ldim2,nphi,nphimx,ifi,
     .nindx(ldim2),           ! n    index
     .lindx(ldim2),           ! l    index
     .ibasindx(ldim2)         ! ibas index

      character*80 outs
      integer i,ipqn,l,ib,ii,nn,m

C --- File read ---
      if (ifi .gt. 0) then
        rewind ifi
        read(ifi,'(a)') outs
        read(ifi,*) i
C       If passed ldim2>0, check that it matches file value
        if (ldim2 .gt. 0 .and. i .ne. ldim2)
     .  call rx('rdibasindx: file mismatch ldim2')
        ldim2 = i
        nphimx = 0
c        do  i = 1, ldim2
        nn = 0
        do
          read(ifi,'(a)',err=101,end=101) outs
          read(outs,*) ipqn,l,ib,ii
          do m=1,2*l+1
            nn = nn+1
            nindx   (nn) = ipqn
            lindx   (nn) = l
            ibasindx(nn) = ib
          enddo
          nphimx = max(nphimx,ipqn)
          nphi = i
        enddo
  101   continue

C --- File read ---
      else
        call rx('ioaindx: file write not implemented')
      endif

      end
c$$$
c$$$      subroutine readin000(ifi,i0,e1)
c$$$c! readin i0,i1,e1,e2; defaults value are 0.
c$$$      character(len=100):: recxxx=' '
c$$$      character(len=108):: recxxx2
c$$$      real(8)::d0e1
c$$$      integer::i1
c$$$      i0=999999
c$$$      e1=99999
c$$$      read (ifi,"(a100)",err=1001,end=1001) recxxx
c$$$ 1001 continue
c$$$      recxxx2 = recxxx//' 0 0'
c$$$      read(recxxx2,*,err=1002,end=1002) i0
c$$$ 1002 continue
c$$$      read(recxxx2,*,err=1003,end=1003) i0 ,e1
c$$$ 1003 continue
c$$$      end
