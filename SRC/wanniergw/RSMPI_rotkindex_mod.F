c     MPI version of FPLMTO-GW code
c     R. Sakuma 2007
c
c     In program hsfp0, k-points in FULL B.Z. are generated by
c     performing symmetry operations(rotations)
c                       to k'-points which lie in irreducible B.Z.
c
c
c     For each k-point (in F.B.Z.) this module calculates the correct indexes
c     of correspoinding irot(rotation index) and k'-point (in ir.B.Z.),
c     which is used for k-point parallelization in program hsfp0
c     with "module RSMPI_qkgroup"
c     without modifying gwsrc/RSMPI_qkgroup_mod.F.
c
c
      module RSMPI_rotkindex
      use rsmpi
      use rsmpi_qkgroup
      implicit none

c number of rotation operators for the current process
      integer :: nrot_local_rotk
      integer,allocatable :: irot_index_rotk(:) ! irot index


c number of k-points (in irr. BZ) for the current process
c used in gwsrc/sxcf_fal2_RSMPI.F
      integer,allocatable :: nk_local_rotk(:) ! nk_local_rotk(ngrp)
      integer,allocatable :: ik_index_rotk(:,:)

      contains

      subroutine setup_rotkindex(ngrp,irk,wgt0,
     &     bzcase_in,nqibz,nq0i,nq_calc)
      implicit none
      integer,intent(in) :: ngrp,bzcase_in,nqibz,nq0i,nq_calc
      integer,intent(in) :: irk(nqibz,ngrp)
      real(8),intent(in) :: wgt0(nq0i,ngrp)
c local
      integer :: iqini,iqend
      integer :: nrotk_total
      integer :: kr
      integer,allocatable :: nrotktmp(:,:)
c counter
      integer :: i,j,irot,kx


      if (Is_IO_Root_RSMPI()) then
        write(6,*) "--- setup_rotkindex ---"
      endif

c calculate total number of rotation  operators and k'-points
c that generate k-points
c
c this part is taken from gwsrc/sxcf_fal2.F
c      iqini = 2
c      if (bzcase_in .eq. 2) iqini = 1
cccccccccccccccccc
c takao
      iqini=1
cccccccccccccccccc
      iqend = nqibz + nq0i
      
      allocate(nrotktmp(ngrp*(iqend-iqini+1),2))
      nrotk_total = 0
      do irot=1,ngrp ! from main/hsfp0.m.F
        if( sum(abs( irk(:,irot) )) ==0 .and.
     &       sum(abs( wgt0(:,irot))) == 0d0 ) then
          cycle
        endif
        do kx=iqini,iqend
          if( kx <= nqibz ) then
            kr = irk(kx,irot)
            if (kr == 0)    then
              cycle
            endif
          else
            if( wgt0(kx-nqibz,irot) == 0d0 ) then 
              cycle
            endif
          endif
          nrotk_total = nrotk_total + 1
          nrotktmp(nrotk_total,1)=irot
          nrotktmp(nrotk_total,2)=kx
        enddo ! do kx
      enddo  ! do irot

      if (Is_IO_Root_RSMPI()) then
        write(6,*) "RSMPI_rotk: nrotk_total = ",nrotk_total
      endif

c calculate correct indexes of q- and k-point parallelization
c for each process
c (nq_local,iq_index, nk_local, ik_index)
      call RSMPI_qkgroup_Init(nq_calc,nrotk_total)

c For each ik_index(calculated above)
c correspoinding irot and ik'-index is set
      call set_nrot_nk_local(nrotk_total,
     &     nrotktmp(1:nrotk_total,1:2),ngrp,iqend-iqini+1)
      
      if (Is_IO_Root_RSMPI()) then
        write(6,*) "--- setup_rotkindex end ---"      
      endif
      end subroutine setup_rotkindex

      subroutine set_nrot_nk_local(nrotk_total,nrotktmp,ngrp,nk)
      implicit none
      integer,intent(in) :: nrotk_total
      integer,intent(in) :: nrotktmp(nrotk_total,2)
      integer,intent(in) :: ngrp,nk
c local
      integer,allocatable :: irot_index_tmp(:)
      integer :: irotk,irot_tmp,ir
      logical :: newrot

c nk_local_qkgroup is defined in module RSMPI_qkgroup
      if (nk_local_qkgroup .gt. 0) then
        allocate(irot_index_tmp(nk_local_qkgroup))
      endif

      allocate(nk_local_rotk(ngrp))
      allocate(ik_index_rotk(ngrp,nk))
c set nrot_local_rotk and nk_local_rotk(1:ngrp),ik_index_rotk(1:ngrp,1:nk)
      nrot_local_rotk = 0
      if (nk_local_qkgroup .gt. 0) irot_index_tmp(:) = 0
      nk_local_rotk(:) = 0
      ik_index_rotk(:,:) = 0

      do irotk=1,nk_local_qkgroup
        irot_tmp = nrotktmp(ik_index_qkgroup(irotk),1)
        nk_local_rotk(irot_tmp) = 
     &       nk_local_rotk(irot_tmp) + 1
        ik_index_rotk(irot_tmp,nk_local_rotk(irot_tmp)) =
     &       nrotktmp(ik_index_qkgroup(irotk),2)
        newrot = .true.
        do ir=1,nrot_local_rotk
          if (nrotktmp(ik_index_qkgroup(irotk),1) .eq. irot_index_tmp(ir)) then
            newrot = .false.
          endif
        enddo
        if (newrot) then
          nrot_local_rotk = nrot_local_rotk + 1
          irot_index_tmp(nrot_local_rotk) = 
     &         nrotktmp(ik_index_qkgroup(irotk),1)
        endif
      enddo

c set irot_index_rotk(1:nrot_local)
c     and ik_index_rotk(1:ngrp,1:nk_local)
      
      if (nrot_local_rotk .gt. 0) then
        allocate(irot_index_rotk(nrot_local_rotk))
        irot_index_rotk(1:nrot_local_rotk) =
     &       irot_index_tmp(1:nrot_local_rotk)
      endif

      if (nk_local_qkgroup .gt. 0) deallocate(irot_index_tmp)

      write(buf_rsmpi,*) "RS: ", myrank_id_rsmpi,
     &     " nrot_local = ",nrot_local_rotk
      call RSMPI_Write(6)
      end subroutine set_nrot_nk_local
      end module RSMPI_rotkindex
