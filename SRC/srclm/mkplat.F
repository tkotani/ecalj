      subroutine mkplat(alat,csym,isym,lscr,plat)
C- Makes different sets of lattice vectors
C ----------------------------------------------------------------------
Ci Inputs
Ci   lscr  :calculate platcv from scratch
Ci Inputs/Outputs:
Cio  alat  :length scale
Cio         alat(1) = input length scale
Cio         alat(2) = b = a standard  length scale
Cio  isym  :numbers characterizing the symmetry of lattice and crystal
Cio         first,second and third component is supplied on output.
Cio         for rhombohedral lattice, isym(3) is needed on input
Cio         (see gengrp.f for description)
Cio  plat  :primitive lattice vectors (scaled by alat)
Cio         on output further sets of lattice vectors are supplied
Co Outputs:
Co   csym  :names characterizing the symmetry of lattice and crystal
Co Remarks:
Cr   plat contains four sets of translation vectors:
Cr        1.  those supplied by the CTRL-file
Cr        2.  the most compact one (generated by CPPLAT)
Cr        3.  the conventional set (generated by CVPLAT)
Cr            = that with maximum number of right angles
Cr            this set can be non-primitive!!
Cr            for monoclinic, orthorhombic, tetragonal and cubic
Cr            systems.
Cr        4.  the standard set (generated by STPLAT)
Cr        5.  the standard set, possibly rotated in space
Cr            (generated by ROPLAT)
Cr   For rhombohedral lattice, isym(3) is needed on input
Cr   to select between the primitive rhombohedral cell (isym(3)=1)
Cr   and the triple hexagonal cell (isym(3)=7) as the conventional cell.
Cu Updates
Cu   07 Nov 01 Apapted from Stuttgart lmto56
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer isym(*)
      double precision alat(*),plat(9,*)
      character*30 csym(*)
C Local variables:
      double precision a,alpha,b,beta,c,gamma,platwk(9)
      logical lscr
C ... External calls
      external bravsy,cpplat,cvplat,gtcsym,latpar,roplat,stplat

C --- Make most compact unit cell -> platcp = plat(*,2) ---
      call cpplat(plat(1,1),plat(1,2))

C --- Get Bravais system number -> isym(1) ---
      call bravsy(isym(1),plat(1,2))

C --- Make conventional unit cell -> platcv = plat(*,3) ---
      call cvplat(isym(1),isym(3),lscr,plat(1,1),plat(1,2),plat(1,3))
      call latpar(a,alat(1),alpha,b,beta,c,gamma,plat(1,3))

C --- Make standard primitive unit cell -> platst = plat(*,4) ---
      call stplat(alat,isym,plat(1,2),plat(1,3),plat(1,4))

C --- Rotated coordinate system -> platro = plat(*,5) ---
      call roplat(a,alat(2),alpha,b,beta,c,gamma,isym,platwk,plat(1,5))

      call gtcsym(csym,isym)

      end

      subroutine bravsy(isym1,platcp)
C- Gets Bravais system number
C ----------------------------------------------------------------------
Ci Inputs:
Ci   platcp:lattice vectors of most compact primitive unit cell
Co Outputs:
Co   isym1 :Bravais system number
Cr Remarks:
Cr  this subroutine counts nsymop = number of symmetry operations
Cr  which leave the lattice invariant. Each Bravais lattice type
Cr  has a different nsymop: 2 -> triclinic; 4 -> monoclinic;
Cr  8 -> orthorombic; 16 -> tetragonal; 12 -> rhombohedral;
Cr  24 -> hexagonal and 48 -> cubic.
Cr  Possible rotation axes are linear combiations of the platcp-vectors:
Cr
Cr  rrot = n1 * platcp_1 + n2 * platcp_2 + n3 * platcp_3
Cr
Cr  with -3 <= n1,n2,n3 <= 3
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer isym1
      double precision platcp(3,3)
C Local variables:
      integer ii,iprint,is1,ltmax,ll1,lgunit,m,m1,m2,m3,mm,nrot(4),
     .nsym0(7),nsymop,lenvec,iwgt(4),stdo,ip
      parameter(ltmax=3,ll1=ltmax*2+1)
      logical latvec,lirr,lv,ltmp,parsvc
      double precision platt(3,3),qlatcp(3,3),mat(9),vecg(3),vol
      character*200 symops
C External calls:
      external dinv33,dmpy,rotmat,rx
C Statement functions:
      mm(ii,m)=ltmax-(mod(ii,ll1**m)-mod(ii,ll1**(m-1)))/ll1**(m-1)
C Data statements:
      data nrot /2,3,4,6/, iwgt /2,4,4,4/, nsym0/2,4,8,16,12,24,48/

      stdo = lgunit(1)
      if (iprint().ge.110) write(stdo,*)
      call dinv33(platcp,1,qlatcp,vol)
      nsymop=2
C --- find all possible rotation axis
      do ii=0,(ll1**3-1)/2-1
        m1=mm(ii,1)
        m2=mm(ii,2)
        m3=mm(ii,3)
        lirr=.true.
        do m=2,ll1
          lirr=lirr.and.(mod(m1,m).ne.0.or.mod(m2,m).ne.0.or.
     .    mod(m3,m).ne.0)
        enddo
        if (lirr) then
          do m=1,3
            vecg(m)=m1*platcp(m,1)+m2*platcp(m,2)+m3*platcp(m,3)
          enddo
          do m=1,4
C --------- create the matrix of the symmetry operation
            call rotmat(-1,.false.,nrot(m),mat,vecg)
            call dmpy(mat,3,1,platcp,3,1,platt,3,1,3,3,3)
C --------- check the primitive translations for the symmetry operations
            lv = latvec(3,1d-5,qlatcp,platt)
            if (lv) nsymop=nsymop+iwgt(m)
            if (lv) then
              write(symops,fmt='(a1,i1)')'R',nrot(m)
              call word(symops,1,ip,lenvec)
C             call cnvvec(symops(3:),ierr,1,lenvec,vecg)
              ip = 2
              ltmp = parsvc(1,symops,ip,vecg)
              if (lv.and.iprint().ge.120) 
     .        write(stdo,301) symops(1:lenvec+2)
            endif
          enddo
        endif
      enddo

C --- set isym1 depending on number of valid symmetry operations
      isym1=0
      do is1=1,7
        if (nsymop.eq.nsym0(is1))  isym1=is1
      enddo
      if (iprint().ge.100) write(stdo,300) nsymop

      if (isym1.eq.0) call rx('BRAVSY: bad nsymop')

  300 format(/' BRAVSY: nsymop=',i2)
  301 format( ' BRAVSY: ',a)
  401 format(' BRAVSY: Operation ',a,' is rejected (doubtful),',
     .'|        but maybe it should be accepted.',
     .'|        -> symmetry of lattice may not be recognized$')
  402 format(' BRAVSY: Operation ',a,' is accepted (doubtful),',
     .'|        but maybe it should be rejected.',
     .'|        -> symmetry of lattice may not be recognized$')
      end

      subroutine cvplat(isym1,isym3,lscr,platin,platcp,platcv)
C- Finds the conventional unit cell
C ----------------------------------------------------------------------
Ci Inputs:
Ci   isym1 :Bravais system number
Ci   lscr  :T: search platcv from scratch (starting from platcp)
Ci          F: first try to get platcv from platin assuming
Ci             that platin is in a standard form.
Ci   platin:any primitive lattice vectors
Ci   platcp:lattice vectors of most compact primitive unit cell
Cio Inputs/Outputs
Cio  isym3 :Centring type
Ci          is needed as input only for rhombohedral lattices
Co Outputs:
Co   platcv:lattice vectors of conventional unit cell
Cr Remarks:
Cr   The conventional cell is the unit cell which the chemists use
Cr   and which may not be a primitive cell.
Cr
Cr   For cubic, tetragonal and orthorhombic lattices, the conventional
Cr   unit cell is the smallest unit cell having three right angles.
Cr
Cr
Cr   For monoclinic lattices, the conventional unit cell
Cr   is the smallest unit cell having two right angles.
Cr
Cr
Cr   For rhombohedral lattices the conventional unit  depends on isym3:
Cr   it can either be the smallest primitive unit cell, fullfilling
Cr   a=b=c and alpha=beta=gamma (primitive rhombohedral cell, isym3=1)
Cr   the space groups are then called:
Cr     P3(146), P-3(148), P32(155), P3m(160), P3c(161),
Cr     P-3m(166) and P-3c(167).
Cr   (this choice corresponds to 'rhombohedral axes')
Cr
Cr   or it can be the smallest (nonprimitive) cell fullfilling:
Cr   a=b alpha=beta=90,gamma=120 (triple hexagonal cell,isym3=7).
Cr   the space groups are then called:
Cr      R3(146), R-3(148), R32(155), R3m(160), R3c(161),
Cr      R-3m(166) and R-3c(167).
Cr   (this choice corresponds to 'hexagonal axes')
Cr
Cr
Cr   For hexagonal lattices, the conventional unit cell is the smallest
Cr   primitive unit cell with angle of 90,90,120 degrees.
Cr
Cr
Cr   For triclinic lattices, the conventional unit cell should be
Cr   primitive.
Cr
Cr
Cr   In general there is no unique choice, and one has to introduce
Cr   metric conditions to make the choice unique.
Cr
Cr   If lscr=false the program takes the input unit cell platin,
Cr   and build out of it a few number of new cells. (this is done
Cr   by multiplying platin with a set of matices t). If the unit cell
Cr   thus obtained fulfills the upper conditions, it will be used as
Cr   platcv.
Cr   If this attempt was not successful, or if lscr=.true., the
Cr   program generates a set of lattice vectors, and out of this set
Cr   are selected those three which fulfill the upper conditions plus
Cr   the following metric conditions:
Cr
Cr   triclinic   :  c < a < b ,
Cr                  90 < alpha,beta < 120 ,
Cr                  60 <  gamma     < 120 , det > 0
Cr   monoclinic  :  c < a ,
Cr                  b = unique axis <-> alpha = gamma = 90
Cr                  90 < beta < 120   , det > 0
Cr   orthorhombic:  c < a < b , det > 0
Cr   tetragonal  :  a = b , det > 0
Cr   hexagonal   :  a = b gamma = 120 , det > 0
Cr   rhombohedral:  det > 0
Cr   cubic       :  det > 0
Cr   with a = length of first vector in platcv
Cr   with b = length of second vector in platcv
Cr   with c = length of third vector in platcv
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer isym1,isym3
      double precision platin(3,3),platcp(3,3),platcv(3,3)
      logical lscr
C Local variables:
      integer i,j,i1,i2,ikd,ikd1,ikd2,ikd3,iprint,k,l,ll1,ltmax,lgunit,
     .m,mn,n(7),nkd,isym32(5),isym33(6),isym34(2),isym37(3),stdo
      parameter(ltmax=2,ll1=ltmax*2+1)
      double precision cosvec,danrm2,d1mach,d2(ll1**3),ddd,ddot,ddet33,
     .dlat(3,ll1**3),dm2,dm3,pdp,qlatcv(3,3),r(3),
     .platwk(3,3),tollat,volin,volcv,t(9,7),iprm(3)
      logical lra1,lsl1,lsma1,lra2,lsl2,lsma2
      parameter(tollat=1.d-5)
C External calls:
      external cross,dcopy,dinv33,dmpy,dscal,dswap,dvheap,dvprm,iinit,
     .rx,rxi
C Intrinsic functions:
      intrinsic  dabs,iabs,idnint,mod
C Statement functions:
      mn(ikd,m)=(mod(ikd+(ll1/2)*ll1**(m-1),ll1**m)
     .-mod(ikd+(ll1/2)*ll1**(m-1),ll1**(m-1)))/ll1**(m-1)-ltmax
      pdp(i,j)=ddot(3,platcv(1,i),1,platcv(1,j),1)
      ddd(i,j)=ddot(3,dlat  (1,i),1,dlat  (1,j),1)
      lra1(i,j)=dabs(pdp(i,j))        .lt.tollat
      lsl1(i,j)=dabs(pdp(i,i)-pdp(j,j)).lt.tollat
      lra2(i,j)=dabs(ddd(i,j))        .lt.tollat
      lsl2(i,j)=dabs(ddd(i,i)-ddd(j,j)).lt.tollat
      lsma1(i,k,j)=dabs(pdp(i,j)-pdp(j,k)).lt.tollat.and.
     .dabs(pdp(j,k)-pdp(k,i)).lt.tollat
      lsma2(ikd1,ikd2,ikd3)=
     .dabs(ddd(ikd1,ikd2)-ddd(ikd2,ikd3)).lt.tollat.and.
     .dabs(ddd(ikd2,ikd3)-ddd(ikd3,ikd1)).lt.tollat
C Data statements:
      data isym32/1,2,3,4,5/,isym33/1,2,3,4,5,6/,isym34/1,5/,
     .isym37/1,5,6/
      data n/1,5,6,2,1,1,3/
      data t/ 1.d0, 0.d0, 0.d0, 0.d0, 1.d0, 0.d0, 0.d0, 0.d0, 1.d0,
     .1.d0, 1.d0, 0.d0,-1.d0, 1.d0, 0.d0, 0.d0, 0.d0, 1.d0,
     .1.d0, 0.d0, 1.d0, 0.d0, 1.d0, 0.d0,-1.d0, 0.d0, 1.d0,
     .1.d0, 0.d0, 0.d0, 0.d0, 1.d0, 1.d0, 0.d0,-1.d0, 1.d0,
     .0.d0, 1.d0, 1.d0, 1.d0, 0.d0, 1.d0, 1.d0, 1.d0, 0.d0,
     .-1.d0, 1.d0, 1.d0, 1.d0,-1.d0, 1.d0, 1.d0, 1.d0,-1.d0,
     .1.d0,-1.d0, 0.d0, 0.d0, 1.d0,-1.d0, 1.d0, 1.d0, 1.d0/

      stdo = lgunit(1)
      if (lscr) call iinit(n,7)
      volin=dabs(ddet33(platin))
      dm2=d1mach(2)
      dm3=d1mach(2)

C --- generate relevant lattice vectors
      nkd=ll1**3-1
      do ikd=1,nkd
        do m = 1, 3
          dlat(m,ikd)=mn(ikd,1)*platcp(m,1)
     .    +mn(ikd,2)*platcp(m,2)
     .    +mn(ikd,3)*platcp(m,3)
        enddo
        d2(ikd)=danrm2(dlat(1,ikd))
      enddo

      if     (isym1.eq.1) then
C ----- triclinic
        call dcopy(9,platcp,1,platcv,1)
        call dvheap(3,3,platcv,iprm,0d0,11)
        call dvprm(3,3,platcv,platwk,iprm,.true.)
C       call bsort2(platcv)
        call dswap(3,platcv(1,1),1,platcv(1,2),1)
        call dswap(3,platcv(1,2),1,platcv(1,3),1)
        if (pdp(2,3).gt.0.d0) call dscal(3,-1.d0,platcv(1,3),1)
        if (pdp(1,3).gt.0.d0) call dscal(3,-1.d0,platcv(1,1),1)
        if (ddet33(platcv).lt.0.d0) call dscal(9,-1.d0,platcv,1)
      elseif (isym1.eq.2) then
C ----- monoclinic
        do i=1,n(2)
          isym3=isym32(i)
          call dmpy(platin,3,1,t(1,isym3),3,1,platcv,3,1,3,3,3)
          if (lra1(1,2).and.lra1(2,3)) goto 8
        enddo
C ----- No standard choice  -> b-unique axis; fully reduced mesh
        do i1=1,nkd
          do i2=i1+1,nkd
            if (lra2(i1,i2).and.d2(i1)*d2(i2).lt.dm2) then
              ikd1=i1
              ikd2=i2
              dm2=d2(i1)*d2(i2)
            endif
          enddo
        enddo
        call cross(dlat(1,ikd1),dlat(1,ikd2),r)
C ----- now dlat(1) and dlat(2) are the shortest orthogonal latice vec's
        do ikd3=1,nkd
          volcv=dabs(ddot(3,dlat(1,ikd3),1,r,1))
          if (idnint(volcv/volin).ge.1) then
            if(lra2(ikd3,ikd1))call dswap(3,dlat(1,ikd1),1,dlat(1,ikd2),1)
            if(lra2(ikd2,ikd3).and.d2(ikd1)*d2(ikd2)*d2(ikd3).lt.dm3)then
              call dcopy(3,dlat(1,ikd1),1,platcv(1,1),1)
              call dcopy(3,dlat(1,ikd2),1,platcv(1,2),1)
              call dcopy(3,dlat(1,ikd3),1,platcv(1,3),1)
              dm3=d2(ikd1)*d2(ikd2)*d2(ikd3)
            endif
          endif
        enddo
        if (pdp(3,3).gt.pdp(1,1))
     .  call dswap(3,platcv(1,1),1,platcv(1,3),1)
        if (pdp(1,3).gt.0.d0)        call dscal(3,-1.d0,platcv(1,3),1)
        if (ddet33(platcv).lt.0.d0) call dscal(3,-1.d0,platcv(1,2),1)
      elseif (isym1.eq.3) then
C ----- orthorhombic -> try finding shortest pair with 3 right angles
        do i=1,n(3)
          isym3=isym33(i)
          call dmpy(platin,3,1,t(1,isym3),3,1,platcv,3,1,3,3,3)
          if (lra1(1,2).and.lra1(2,3).and.lra1(3,1)) goto 8
        enddo
C ----- No standard choice of unit cell
        do ikd1=1,nkd
          do ikd2=ikd1+1,nkd
            if (lra2(ikd1,ikd2)) then
              do ikd3=ikd2+1,nkd
                if(lra2(ikd2,ikd3).and.lra2(ikd3,ikd1).and.
     .          d2(ikd1)*d2(ikd2)*d2(ikd3).lt.dm3)then
                  call dcopy(3,dlat(1,ikd1),1,platcv(1,1),1)
                  call dcopy(3,dlat(1,ikd2),1,platcv(1,2),1)
                  call dcopy(3,dlat(1,ikd3),1,platcv(1,3),1)
                  dm3=d2(ikd1)*d2(ikd2)*d2(ikd3)
                endif
              enddo
            endif
          enddo
        enddo
        call dvheap(3,3,platcv,iprm,0d0,11)
        call dvprm(3,3,platcv,platwk,iprm,.true.)
C       call bsort2(platcv)
        call dswap(3,platcv(1,1),1,platcv(1,2),1)
        call dswap(3,platcv(1,1),1,platcv(1,3),1)
      elseif (isym1.eq.4) then
C ----- tetragonal -> try finding shortest pair with 3 right angles
        do i=1,n(4)
          isym3=isym34(i)
          call dmpy(platin,3,1,t(1,isym3),3,1,platcv,3,1,3,3,3)
          if (lra1(1,2).and.lra1(2,3).and.lra1(3,1).and.lsl1(1,2))goto 8
        enddo
C ----- No standard choice of unit cell
        do ikd1=1,nkd
          do ikd2=ikd1+1,nkd
            if (lra2(ikd1,ikd2)) then
              do ikd3=ikd2+1,nkd
                if(lra2(ikd2,ikd3).and.lra2(ikd3,ikd1).and.
     .          d2(ikd1)*d2(ikd2)*d2(ikd3).lt.dm3) then
                  call dcopy(3,dlat(1,ikd1),1,platcv(1,1),1)
                  call dcopy(3,dlat(1,ikd2),1,platcv(1,2),1)
                  call dcopy(3,dlat(1,ikd3),1,platcv(1,3),1)
                  dm3=d2(ikd1)*d2(ikd2)*d2(ikd3)
                endif
              enddo
            endif
          enddo
        enddo
        if (lsl1(2,3)) call dswap(3,platcv(1,1),1,platcv(1,3),1)
        if (lsl1(1,3)) call dswap(3,platcv(1,2),1,platcv(1,3),1)
      elseif (isym1.eq.5) then
C ----- rhombohedral
        if (isym3.ne.1.and.isym3.ne.7)
     .  call rxi('CVPLAT: isym3 must be 1 or 7, but is',isym3)
        call dcopy(9,platin,1,platcv,1)
        if (lsma1(1,2,3).and.lsl1(1,2).and.lsl1(1,3))goto 5
C ----- No standard choice of unit cell
        do ikd1=1,nkd
          do ikd2=ikd1+1,nkd
            if (lsl2(ikd1,ikd2)) then
              call cross(dlat(1,ikd1),dlat(1,ikd2),r)
              do ikd3=ikd2+1,nkd
                if (lsl2(ikd2,ikd3).and.lsma2(ikd1,ikd2,ikd3)) then
                  volcv=dabs(ddot(3,dlat(1,ikd3),1,r,1))
                  if (idnint(volcv/volin).eq.1) then
                    if (d2(ikd1)*d2(ikd2)*d2(ikd3).lt.dm3) then
                      call dcopy(3,dlat(1,ikd1),1,platcv(1,1),1)
                      call dcopy(3,dlat(1,ikd2),1,platcv(1,2),1)
                      call dcopy(3,dlat(1,ikd3),1,platcv(1,3),1)
                      dm3=d2(ikd1)*d2(ikd2)*d2(ikd3)
                    endif
                  endif
                endif
              enddo
            endif
          enddo
        enddo
        call dswap(3,platcv(1,1),1,platcv(1,3),1)
    5   if(ddet33(platcv).lt.0.d0)
     .  call dswap(3,platcv(1,2),1,platcv(1,3),1)
        call dcopy(9,platcv,1,platwk,1)
        call dmpy(platwk,3,1,t(1,isym3),3,1,platcv,3,1,3,3,3)
      elseif (isym1.eq.6) then
C ----- hexagonal
        call dcopy(9,platcp,1,platcv,1)
        if (.not.lra1(2,3)) call dswap(3,platcv(1,1),1,platcv(1,3),1)
        if (.not.lra1(1,3)) call dswap(3,platcv(1,2),1,platcv(1,3),1)
        if (pdp(1,2).gt.0.d0)call daxpy(3,-1.d0,platcv,1,platcv(1,2),1)
        if (ddet33(platcv).lt.0.d0)call dswap(3,platcv,1,platcv(1,2),1)
      elseif (isym1.eq.7) then
C ----- cubic -> find shortest pair of same length with 3 right angles
        do i=1,n(7)
          isym3=isym37(i)
          call dmpy(platin,3,1,t(1,isym3),3,1,platcv,3,1,3,3,3)
          if (lra1(1,2).and.lra1(2,3).and.lra1(3,1).and.lsl1(1,2).and.
     .    lsl1(2,3)) goto 8
        enddo
C ----- No standard choice of unit cell
        do ikd1=1,nkd
          do ikd2=ikd1+1,nkd
            if (lra2(ikd1,ikd2).and.lsl2(ikd1,ikd2)) then
              do ikd3=ikd2+1,nkd
                if(lra2(ikd2,ikd3).and.lra2(ikd3,ikd1).and.
     .          lsl2(ikd2,ikd3).and.d2(ikd1)*d2(ikd2)*d2(ikd3).lt.dm3) then
                  call dcopy(3,dlat(1,ikd1),1,platcv(1,1),1)
                  call dcopy(3,dlat(1,ikd2),1,platcv(1,2),1)
                  call dcopy(3,dlat(1,ikd3),1,platcv(1,3),1)
                  dm3=d2(ikd1)*d2(ikd2)*d2(ikd3)
                endif
              enddo
            endif
          enddo
        enddo
        call dvheap(3,3,platcv,iprm,0d0,11)
        call dvprm(3,3,platcv,platwk,iprm,.true.)
C       call bsort2(platcv)
      else
        call rxi('CVPLAT: bad isym1:',isym1)
      endif

    8 volcv=ddet33(platcv)
      if (volcv.lt.0.d0) call dscal(3,-1.d0,platcv(1,3),1)
      if (idnint(dabs(volcv/volin)).lt.1)
     .call rx(' CVPLAT: could not calculate platcv')

      call dinv33(platcv,1,qlatcv,volcv)
      if (iprint().ge.50) write(stdo,301)
     .((platcv(m,l),m=1,3),(qlatcv(m,l),m=1,3),l=1,3)
      if (iprint().ge.60) write(stdo,303)
     .((cosvec(platcv(1,i),platcv(1,j)),i=1,3),j=1,3)

  301 format(/' CVPLAT: conventional unit cell:',
     ./17x,'Platcv',32x,'Qlatcv',3(/2x,3f11.7,5x,3f11.7))
  303 format(/'             cos(platcv,platcv):',3(/2x,3f11.7))
      end

      subroutine latpar(a,alat,alpha,b,beta,c,gamma,platcv)
C- Obtains lattice parameters from conventional unit cell
C ----------------------------------------------------------------------
Ci Inputs:
Ci   alat  :length scale
Ci   platcv:primitive lattice vectors (scaled by alat)
Co Outputs:
Co   a     :lattice parameter
Co   b     :lattice parameter
Co   c     :lattice parameter
Co   alpha :angle(b,c)
Co   beta  :angle(c,a)
Co   gamma :angle(a,b)
Cr Remarks:
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      double precision a,alat,b,c,alpha,beta,gamma,platcv(*)
C Local variables:
      integer iprint,lgunit,stdo
      double precision cosvec,facdeg,pi,ddot
      parameter(pi=3.14159265358979324d0,facdeg=180.d0/pi)
C External calls:
      external cosvec,ddot,iprint,lgunit

      stdo  = lgunit(1)
      a     = alat*dsqrt(ddot(3,platcv(1),1,platcv(1),1))
      b     = alat*dsqrt(ddot(3,platcv(4),1,platcv(4),1))
      c     = alat*dsqrt(ddot(3,platcv(7),1,platcv(7),1))
      alpha = dacos(cosvec(platcv(4),platcv(7)))*facdeg
      beta  = dacos(cosvec(platcv(7),platcv(1)))*facdeg
      gamma = dacos(cosvec(platcv(1),platcv(4)))*facdeg

      if (iprint().ge.30) write(stdo,300) a,b,c,alpha,beta,gamma

  300 format(/' LATPAR:     A=',f9.5,'     B=',f9.5,'      C=',f9.5,
     ./,9x,'ALPHA=',f9.4,'  BETA=',f9.4,'  GAMMA=',f9.4)
      end

      subroutine stplat(alat,isym,platcp,platcv,platst)
C- Rotates the conventional unit cell to the standard one
C ----------------------------------------------------------------------
Ci Inputs:
Ci   alat  :length scale
Ci   platcp:lattice vectors of most compact primitive unit cell
Ci   platcv:lattice vectors of conventional unit cell
Cio Inputs/Outputs:
Ci   isym1 :Bravais system number
Co   isym2 :Bravais lattice number
Co   isym3 :Centring type
Ci Outputs:
Co   platst:lattice vectors of standard primitive unit cell
Cr Remarks:
Cr
Cr            platst =  platcv * TB(centring-type)
Cr
Cr   with:
Cr
Cr            1    0    0           1/2  1/2   0            1/2   0  1/2
Cr    TB(P)=  0    1    0   TB(C)= -1/2  1/2   0    TB(B)=   0    1   0
Cr            0    0    1            0    0    1           -1/2   0  1/2
Cr
Cr            1    0    0          -1/2  1/2  1/2           0   1/2 1/2
Cr    TB(A)=  0   1/2  1/2  TB(I)=  1/2 -1/2  1/2   TB(F)= 1/2   0  1/2
Cr            0  -1/2  1/2          1/2  1/2 -1/2          1/2  1/2  0
Cr
Cr           2/3 -1/3 -1/3
Cr    TB(R)= 1/3  1/3 -2/3
Cr           1/3  1/3  1/3
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer isym(*)
      double precision alat(2),platcp(3,3),platcv(3,3),platst(3,3)
C Local variables:
      integer i,isym2(7,7),isym3,iprint,k,lgunit,m,stdo
      double precision d1mach,ddet33,qlatst(3,3),qlatcp(3,3),tb(9,7),
     .vol,volst
      logical latvec
C ... External calls
      external dinv33,dmpy,dscal
C Intrinsic functions:
      intrinsic dabs
C Data statements:
      data tb/1.0d0, .0d0, .0d0,  .0d0, 1.0d0, .0d0,  .0d0,.0d0, 1.0d0,
     .0.5d0,-.5d0, .0d0,  .5d0, 0.5d0, .0d0,  .0d0,.0d0, 1.0d0,
     .0.5d0, .0d0,-.5d0,  .0d0, 1.0d0, .0d0,  .5d0,.0d0, 0.5d0,
     .1.0d0, .0d0, .0d0,  .0d0, 0.5d0,-.5d0,  .0d0,.5d0, 0.5d0,
     .-0.5d0, .5d0, .5d0,  .5d0,-0.5d0, .5d0,  .5d0,.5d0,-0.5d0,
     .0.0d0, .5d0, .5d0,  .5d0, 0.0d0, .5d0,  .5d0,.5d0, 0.0d0,
     .0.6666666666667d0,  0.3333333333333d0,  0.3333333333333d0,
     .-0.3333333333333d0,  0.3333333333333d0,  0.3333333333333d0,
     .-0.3333333333333d0, -0.6666666666667d0,  0.3333333333333d0/
      data isym2/1,0,0,0, 0, 0,0,    2,3,3,3,3,0, 0,    4,5,5,5,6,7,0,
     .8,0,0,0, 9, 0,0,   10,0,0,0,0,0,10,   11,0,0,0,0,0,0,
     .12,0,0,0,13,14,0/

      stdo = lgunit(1)
      if(isym(1).lt.1.or.isym(1).gt.7) call rx(' STPLAT: bad isym(1)')
      if (dabs(ddet33(platcp)).lt.d1mach(3))
     .call rx('STPLAT: bad platcp')

      call dinv33(platcp,1,qlatcp,vol)
      do isym3=7,1,-1
        if (isym2(isym3,isym(1)).ne.0) then
          call dmpy(platcv,3,1,tb(1,isym3),3,1,platst,3,1,3,3,3)
          if (latvec(3,1d-5,qlatcp,platst)) goto 1
        endif
      enddo
    1 isym(3)=isym3
      isym(2)=isym2(isym(3),isym(1))
      if (isym(2).eq.0) call rx('STPLAT: bad isym(3)')

      volst=ddet33(platst)
      if (volst.lt.0.d0) call dscal(3,-1.d0,platst(1,3),1)
      if (dabs(volst).lt.d1mach(3))call rx('STPLAT: bad vol')

      call dinv33(platst,1,qlatst,volst)
      if (iprint().ge.110) write(stdo,300)(isym(i),i=1,3)
      if (iprint().ge.50)  write(stdo,301)
     .((platst(m,k),m=1,3),(qlatst(m,k),m=1,3),k=1,3)

  300 format(/' STPLAT: isym(1,2,3)=',3i3)
  301 format(/' STPLAT: standard unit cell',
     ./17x,'Platst',32x,'Qlatst',3(/2x,3f11.7,5x,3f11.7))
      end

      subroutine rotmat(iopt,li,nrot,symopm,vecg)
C- Converts rotation/rotoinversion matrix <-> (nrot,vecg,li)
C ----------------------------------------------------------------------
Ci Inputs:
Ci   iopt  := -1 to convert (nrot,vecg,li) into symopm
Ci          =  1 to convert symopm into (nrot,vecg,li)
Ci Inputs/Outputs:
Cio  li    :if T: inversion or rotoinversion
Cio  nrot  :rotation angle = 2*pi/nrot
Cio  symopm:symmetry operation matrix
Cio  vecg  :rotation axis
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer iopt,nrot
      double precision vecg(3),symopm(3,3)
      logical li
C Local variables:
      integer i,idamax,in,j
      double precision costbn,detop,ddet33,ddot,omcos,
     .sintbn,sinpb3,tiny,twopi,vfac
      character*144 messg
      parameter(twopi=6.28318530717958648d0)
      parameter(tiny=1.0d-5)
C External calls:
      external daxpy,dcopy,ddet33,dpzero,ddot,dscal,errmsg,idamax,
     .nrmliz
C Intrinsic functions:
      intrinsic  dabs,dacos,dcos,dmax1,dsign,dsin,dsqrt,iabs,idnint

      if (iopt.eq.-1) then
C ----- convert (nrot,vecg,li) into symopm
        call dpzero(symopm,9)
        in = iabs(nrot)
        if (in.eq.1) then
          call dcopy(3,1.d0,0,symopm,4)
        elseif (in.eq.2.or.in.eq.3.or.in.eq.4.or.in.eq.6) then
          sintbn = dsin(twopi/nrot)
          costbn = dcos(twopi/nrot)
          omcos  = 1.d0-costbn
          if (ddot(3,vecg,1,vecg,1).lt.tiny)
     .    call errmsg(' ROTMAT: zero rotation vector.$',4)
          call nrmliz(1,vecg,vecg)
          symopm(1,1)=omcos*vecg(1)*vecg(1)+costbn
          symopm(1,2)=omcos*vecg(1)*vecg(2)-sintbn*vecg(3)
          symopm(1,3)=omcos*vecg(1)*vecg(3)+sintbn*vecg(2)
          symopm(2,1)=omcos*vecg(2)*vecg(1)+sintbn*vecg(3)
          symopm(2,2)=omcos*vecg(2)*vecg(2)+costbn
          symopm(2,3)=omcos*vecg(2)*vecg(3)-sintbn*vecg(1)
          symopm(3,1)=omcos*vecg(3)*vecg(1)-sintbn*vecg(2)
          symopm(3,2)=omcos*vecg(3)*vecg(2)+sintbn*vecg(1)
          symopm(3,3)=omcos*vecg(3)*vecg(3)+costbn
        else
          call errmsg(' ROTMAT: bad nrot.$',5)
        endif
        if (li) call dscal(9,-1.d0,symopm(1,1),1)

      elseif (iopt.eq.1) then
C ----- convert symopm into (nrot,vecg,li)
C ----- First calculate determinant.
        detop=ddet33(symopm)
        if (dabs(dabs(detop)-1.0d0).gt.tiny)
     .  call errmsg(' ROTMAT: determinant is not +/- 1$',5)
        detop=dsign(1.d0,detop)
        li=detop.lt.0.d0
C ----- multiply operation symopm with detop
        call dscal(9,detop,symopm(1,1),1)
C ----- For the rotation angle we have due to the normalization of v:
C ----- sum_i symopm(i,i) = sum_i (1-cos) v_i*v_i+3*cos = 1 + 2 * cos,
        costbn=-0.5d0
        call daxpy(3,0.5d0,symopm(1,1),4,costbn,0)
        if (dabs(costbn-1.d0).lt.tiny) then
          nrot=1
          call dpzero(vecg,3)
        else
          nrot=idnint(twopi/dacos(dmax1(-1.d0,costbn)))
C ------- for nrot > 2 the matrix is non-symmetric and the rotation
C ------- axis can be calculated from the antisymmetric part.
C ------- for nrot = 2 this not possible. However, the squared vector
C ------- components are given by:  mat(i,i) = 2 v_i * v_i - 1.
C ------- This is used for the largest component. The others are taken
C ------- from: mat(i,j) = 2 v_i * v_j for i ne j. This way we also
C ------- get the right phases between the components.
          if (nrot.eq.2) then
            do i=1,3
              vecg(i)=0.5d0*(symopm(i,i)+1.0d0)
            enddo
            j=idamax(3,vecg,1)
            if (vecg(j).lt.0.0d0) then
              write(messg,400)j,symopm(j,j)
              call errmsg(messg,4)
            endif
            vecg(j)=dsqrt(vecg(j))
            vfac=0.5d0/vecg(j)
            do i=1,3
              if (i.ne.j) vecg(i)=vfac*symopm(i,j)
            enddo
          elseif (nrot.eq.3.or.nrot.eq.4.or.nrot.eq.6) then
            vecg(1)=symopm(3,2)-symopm(2,3)
            vecg(2)=symopm(1,3)-symopm(3,1)
            vecg(3)=symopm(2,1)-symopm(1,2)
          else
            call errmsg(' ROTLAT: bad nrot$',5)
          endif
C ------- next renormalize at least one component to 1 in order to
C ------- allow for abbreviations as 'D', 'X', 'Y' or 'Z'
          sinpb3=dsqrt(.75d0)
          if (dabs((sinpb3-dabs(vecg(1)))*(sinpb3-dabs(vecg(2)))*
     .    (sinpb3-dabs(vecg(3)))).gt.tiny) then
            do j=3,1,-1
              vfac=dabs(vecg(j))
              if(vfac.gt.tiny) call dscal(3,1.d0/vfac,vecg,1)
            enddo
          endif
        endif
        call dscal(9,detop,symopm(1,1),1)
      endif

  400 format(' ROTMAT: Bad component ',i1,' of operation ',
     .'. Diagonal element =',f9.5,'$')
      end
      subroutine nrmliz(n,r,rn)
C- Normalizes a vector
C ----------------------------------------------------------------------
Ci Inputs
Ci   n     :number of vectors
Ci   r     :vector
Co Outputs:
Co   rn    :normalized vector
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      integer n
      double precision r(3,*),rn(3,*)
C Local variables:
      integer i
      double precision d,d2
C External calls:
      external dcopy,dscal

      call dcopy(3*n,r,1,rn,1)
      do i=1,n
        d2=r(1,i)*r(1,i)+r(2,i)*r(2,i)+r(3,i)*r(3,i)
        d=dsqrt(d2)
        if (d.ne.0.d0) call dscal(3,1.d0/d,rn(1,i),1)
      enddo

      end

      double precision function ddet33(matrix)
C- Calculates the determinant of a 3X3 matrix
C ----------------------------------------------------------------------
Ci Inputs:
Ci   matrix:input matrix
Co Outputs:
Co   ddet33:determinant
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      double precision matrix(9)
C Local variables:
      double precision ddot,m1cm2(3)
C External calls:
      external cross,ddot

      call cross(matrix(4),matrix(7),m1cm2)
      ddet33 = ddot(3,matrix(1),1,m1cm2,1)

      end
      double precision function cosvec(r1,r2)
C- Cosine of angle between two vectors
C ----------------------------------------------------------------------
Ci Inputs:
Ci   r1    :vector
Ci   r2    :vector
Co Outputs:
Co   cosvec:cosine of angle between r1 and r2
Cr Remarks:
C ----------------------------------------------------------------------
C     implicit none
C Passed variables:
      double precision r1(3),r2(3)
C Local variables:
      double precision ddot,d1,d2
C External calls:
      external rx,ddot

      d1 = ddot(3,r1,1,r1,1)
      d2 = ddot(3,r2,1,r2,1)
      if (d1.eq.0.d0 .or. d2.eq.0.d0) then
        call rx('COSVEC: vector is zero')
        cosvec = 0
      else
        cosvec = ddot(3,r1,1,r2,1)/dsqrt(d1*d2)
      endif
      end

