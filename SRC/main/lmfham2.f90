program lmfham2 ! Get the Hamiltonian of the MTO-based localized orbital |MLO> from
  ! that of the MTO-projected basis |MTP>. Conversion from MTP(hmmr1,ommr1,nband) to MLO(hmmr2,ommr2,nMLO).
  ! In advance, run lmfham1 to get |MTP> (MTPare given by a projection from MTOs to PMT space.
  ! That is, |MTP_i> = M |PMT_i>, where M is a mapping from MTP to the space of PMT.
  !  
  ! We use a modified procedure of this method of  [2]I.Souza, N.Marzari and D.Vanderbilt, PRB65,035109(2002) 
  !
  ! Main part of lmfham2 is Step1loop. 
  ! Among the space spanned by |MTonly>, we extract minimum basis space.
  ! For example, we have 25+25 MTOonlys for Si;then we extract 9+9 space spanned by |MLO>.
  !
  ! We use diffent idea of connectivity from [2]. Roughly speaking, we define connectivitiy of eigenfunctions between k and k+b,
  ! not by the overlap of periodic part of eigenfunctions, but by the coefficients on |MLO>.
  !
  use m_ftox
  use m_lgunit,only: stdo
  use m_keyvalue,only: getkeyvalue
  use m_zhev,only:zhev_tk4
  use m_MPItk,only:    m_MPItk_init, m_MPItk_finalize, nsize, master_mpi !  use m_ext,only:      m_ext_init,sname
  use m_readqplist,only: eferm,qplistsy,ndat,xdat, Readqplistsy !qplist.dat is generated by job_band
  use m_HamPMT,only: ReadHamPMTInfo, nspin=>nsp, natom=>nbas,plat,alat,npair,nlat,nqwgt, ldim, nqbz=>nkp,qbz=>qplist,&
       n1=>nkk1,n2=>nkk2,n3=>nkk3,pos,npairmx,nspx !,ib_table,l_table,k_table
  use m_read_Worb,only:s_read_Worb,nclass_mlwf,cbas_mlwf,norb=>nbasclass_mlwf,classname_mlwf ! iclassin,iphi,iphidot,nphi,nphix
  use m_HamRsMTO,only: ReadHamRsMTO,hmmr1=>hammr,ommr1=>ovlmr,nband=>ndimMTO,ib_tableM,l_tableM,k_tableM !Real-space Hamiltonian on the basis |MTo>.
  !      Main output of lmfham2 is  hmmr2,       ommr2,       nMLO,         ib_tableM(idmto(1:nwf)),... for |MLO>
  implicit none
  integer:: i,iq,is,ix,j,ifbb,ifoc,nbb,isc,ifq0p, nox,iko_ix,iko_fx,nsc1,ndz,nin,nout,nsc2,ibb
  integer:: inii,if102,iwf2,ib,itmp,itmp2,nqbz2,nspin2,ib1,ib2,iqb,iqbz,it,jsp,nmx,nev,isyml!,nqbz!,n1,n2,n3
  integer:: nMLO,ikx,ikxx,iadd,i1q,i2q,i1,i2,imp,inp,inx,imx,ibas,ibold,ibx,iorb
  integer,parameter:: nlinex=100
  integer::nline,np(nlinex), iwf,ldim2,ixx,npin,ifuumat,job
  real(8),parameter:: pi = 4d0*datan(1d0)
  real(8) :: tpia,vol,voltot,rs,alpha, rydberg,hartree,qlat(3,3),tripl,wbbsum,bb(3,12),eimax ,wbbs,WTbandqsum,WTinnerqsum,&
       evalssold,qi(3,nlinex),qf(3,nlinex), omgi,omgiold,conv1,alpha1,zesumold,zesi,emm,einnerL,einnerH,einnerLeV,einnerHeV,&
       emin,evalss,sss,qiin(3),qfin(3),qold(3),enwfmax,qxx(3),eeee,enwfmaxi, epsovl=1d-8,ginv(3,3),einner,ewid,WTinner,ecenter,&
       eee,etest,egap,WTband
  character(8) :: xt
  real(8),allocatable    :: q(:,:)
  real(8),allocatable:: ku(:,:),kbu(:,:,:),eunk(:,:),eval(:), eks(:),wbb(:)
  integer,allocatable:: ikbidx(:,:),iko_i(:),iko_f(:)
  real(8),allocatable:: omgik(:),zesum(:),evals(:),WTbandq(:),WTinnerq(:)
  real(8),allocatable:: xq(:),eval1(:,:),eval2(:,:),eval3(:,:),eval_w(:,:,:)
  integer,allocatable:: m_indx(:),n_indx(:),l_indx(:),ibas_indx(:),ibasiwf(:),idmto(:),idmto_(:)
  real(8),allocatable:: evl(:,:),ovl(:), bbv(:,:),wbz(:)
  complex(8),allocatable:: upu(:,:,:,:), zmn(:,:),zmn0(:,:),WTbandii(:),WTinnerii(:)
  complex(8),parameter:: img=(0d0,1d0)
  complex(8),allocatable::ovlm(:,:),ovlmx(:,:),hamm(:,:),ovec(:,:)!,emat(:,:)
  complex(8),allocatable:: uumat(:,:,:,:),evecc(:,:), amnk(:,:,:),cnk(:,:,:),umnk(:,:,:),evecc1(:,:,:),evecc2(:,:,:)
  complex(8),allocatable:: hmmr2(:,:,:,:),ommr2(:,:,:,:),wmat(:,:),wmat2(:,:)
  character(256):: fband,fband1
  logical:: cmdopt2,noinner
  real(8):: WTseed,eoffset
  character:: outs*20
  character(256):: aaa='',bbb=''
  integer:: nband_,nqbz_,iko_ix_,iko_fx_,nMLO_
  call m_MPItk_init('lmfham2') ! mpi initialization
  job=-1
  if(cmdopt2('--job=',outs)) read(outs,*) job
  if(job/=0.and.job/=1) call rx0(' Set --job=0 or 1')
  write(stdo,ftox)'=== Start lmfham2 --job=',job
  call mpibc1_int(job,1,'lmfham2_job') !set job of --job=job in arguments of lmf-MPIK.
  hartree=2d0*rydberg()
  call ReadHamPMTInfo()! Read infomation for Hamiltonian (lattice structures and index of basis).
  call ReadHamRsMTO()  ! Read Real-space |MTo>-basis Hamiltonian and overlap.
!  nqbz=nkp!  call minv33tp(plat,qlat)!  voltot = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))
  call pshpr(30)
  tpia = 2d0*pi/alat
  ginv   = transpose(plat)
  call readqplistsy()
  ReadInfoFromGWinput: block
    call s_read_Worb() ! Input orbital index for MLO, stored into idmto (s,p,d=1,2,3,4,5,6,7,8,9)
    nMLO=sum(norb(1:nclass_mlwf)) !number of MLO
    allocate(idmto(nMLO)) 
    ibx=0
    ibold=-999
    iorb=0
    SETidmto:do i = 1,nband !for example, allocate(idmto,source=[(i,i=1,9),(i+25,i=1,9)]) for Si
       if(ibold/=ib_tableM(i)) ibx=0
       ibas=ib_tableM(i)
       ibx=ibx+1
       if(findloc([(ibx==cbas_mlwf(ix,ibas),ix=1,norb(ibas))],dim=1,value=.true.)/=0) then
          iorb=iorb+1
          idmto(iorb)=i
       endif       !write(stdo,"('MHAM: i ib(atom) l m k(EH,EH2,PZ)=',5i3)") i,ib_table(i),ibx
       ibold=ib_tableM(i)
    enddo SETidmto
    write(stdo,ftox)' idmto=',idmto
    call getkeyvalue("GWinput","mlo_maxit",nsc1,default=10)
    call getkeyvalue("GWinput","mlo_conv",conv1,default=1d-4)
    call getkeyvalue("GWinput","mlo_mix",alpha1,default=.5d0) 
    call getkeyvalue("GWinput",'mlo_WTseed',WTseed,default=0d0)   !WTseed
    call getkeyvalue("GWinput","mlo_WTband"  ,WTband,default=32d0)    ! Weight to minimize band energies
    call getkeyvalue("GWinput","mlo_WTinner", WTinner,default=8192d0/WTband)  ! inner energy window WeighTing
    call getkeyvalue("GWinput","mlo_EWinner", ewid, default=.1d0)     ! inner energy window softing eV
    call getkeyvalue("GWinput","mlo_ELinner", einnerLeV,default=-1d8) ! inner energy window lower eV relative to efermi (or VBM)
    call getkeyvalue("GWinput","mlo_EUinner", einnerHeV,default= 1d8) ! inner energy window upper eV relative to efermi
    call getkeyvalue("GWinput","mlo_EUinneradd",eoffset,default=3d0)   !bandgap+3eV is default Einner
    if(master_mpi) then
       write(stdo,ftox)' Reading: mlo_ maxit conv mix=',nsc1,ftof(conv1),ftof(alpha1)
       write(stdo,ftox)' Reading: mlo_WTseed =',ftof(WTseed,2)
       write(stdo,ftox)' Reading: mlo_WTband =',ftof(WTband,2)
       write(stdo,ftox)' Reading: mlo_WTinner=',ftof(WTinner,2)        ! WTband,WTinner=32,256 for Si888, =8,1024 for Si666
       write(stdo,ftox)' Reading: mlo_EUinner mlo_ELinner _EWinner(eV)=',ftof(einnerHeV,2),ftof(einnerLeV,2),ftof(ewid,2)
! --- Our test show WTband,WTinner=4,1024 is good for Si666(spd model); =32,256 is for Si888 ---'
       write(stdo,ftox)' Rule of thumb: WTband x WTinner ~ 8192 to respect nabla term (smooth continuity).' 
       write(stdo,ftox)'    mlo_WTband push down bands when we use low mlo_WTinner: WTband maybe 4,8,16,32'
       write(stdo,ftox)'    mlo_WTinner: (soft)128,256,512,1024,2048(Hard). '
    endif
    ewid= ewid/rydberg() !in Ry.
  endblock ReadInfoFromGWinput
  bbvector: block !Get connecting vectors bb, bb connects k and k+bb, where both k and k+bb are on mesh points nqbz.
    allocate(wbb(12))
    call getbb(plat,alat,n1,n2,n3, nbb,wbb,wbbsum,bb) ! b vectors (connecting vectors).
    allocate (ku(3,nqbz),kbu(3,nbb,nqbz),ikbidx(nbb,nqbz))
    call kbbindx(qbz,ginv,bb, nqbz,nbb, ikbidx,ku,kbu) ! index for k and k+bb
    allocate(iko_i(nqbz),iko_f(nqbz)) !, ikbo_i(nbb,nqbz),ikbo_f(nbb,nqbz)) !, ikbi_i(nbb,nqbz),ikbi_f(nbb,nqbz))
    call writebb2(ifbb,wbb(1:nbb),bb(1:3,1:nbb), ikbidx,ku,kbu, nqbz,nbb)
    write(stdo,ftox)' nbb wbb(in unit of 2pi/alat)=',nbb,ftof(wbb(1:nbb),3)
    allocate(bbv,source=bb)
  endblock bbvector
  iko_i=1; iko_f=nband ! outer window nband is the number of MLO
  iko_ix=minval(iko_i)
  iko_fx=maxval(iko_f) !  nox = iko_fx - iko_ix + 1
  if(job==1) goto 1011 !Goto Souza's iteration job=1 mode
  
  GetCNmatFile: block  !job=0 mode to get CNmat file (connection matrix uumat and so on).
    real(8):: qp(3),evl(nband,nqbz),ovl(nband)
    complex(8):: emat(nband,nband),osq(1:nband,1:nband),o2al(1:nband,1:nband,nqbz),phase,ovlmm(nband,nMLO),&
         evec(nband,nband,nqbz),evecx(1:nband,1:nband), ovec(nband,nband),amnk(iko_ix:iko_fx,nMLO,nqbz),&
         ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband), hamm(1:nband,1:nband),uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz)
    write(stdo,ftox)'Going to get CNmat ... : nband for |MLO1>=',nband,'iko_i iko_f=',iko_ix,iko_fx
    open(newunit=ifuumat,file='CNmat',form='unformatted')
    uuispinloop: do 1010 is = 1,nspin
       write(stdo,ftox)'Generating connection matrix ispinloop: is =',is,'  out of',nspin
       emat=0d0
       forall(i=1:nband) emat(i,i)=1d0
       do iqbz=1,nqbz
          qp=qbz(:,iqbz)
          ovlm = 0d0
          hamm = 0d0
          do i=1,nband !this is for MLO0 Hamiltonian. PMT is already reduced to be MLO0-only Hamiltonian, hamm and ovlm below.
             do j=1,nband
                ib1 = ib_tableM(i) !atomic-site index in the primitive cell
                ib2 = ib_tableM(j)
                do it =1,npair(ib1,ib2) !real-space to H,O at qp
                   phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                   hamm(i,j)= hamm(i,j)+ hmmr1(i,j,it,is)*phase 
                   ovlm(i,j)= ovlm(i,j)+ ommr1(i,j,it,is)*phase
                enddo
             enddo
          enddo
          nmx=nband
          ovlmx=ovlm
          call zhev_tk4(nband,ovlm,emat,nmx,nev, ovl, ovec, epsovl) !Diangonale overlap matrix. (ovlm - e ) ovec=0
          ovlm=ovlmx
          call zhev_tk4(nband,hamm,ovlm,nmx,nev, evl(:,iqbz), evec(:,:,iqbz), epsovl) !Diangonale (hamm- evl ovlm) z=0
          do concurrent (i=1:nband,j=1:nband)
             osq(i,j)=sum(ovec(i,:)*ovl(:)**0.5d0*dconjg(ovec(j,:))) !O^(1/2)
          enddo
          o2al(:,:,iqbz) = matmul(osq, evec(:,:,iqbz)) !o2al(basis index, band index, iqbz index) O^(1/2)*evec
          forall(i=1:nband) ovlmm(i,:) = ovlmx(i,idmto(:))
          amnk(:,:,iqbz)= matmul(transpose(dconjg(evec(1:nband,iko_ix:iko_fx,iqbz))),ovlmm) !amnk= <psi|MTO> minimum basis MTO =9+9
       enddo
       do iqbz=1,nqbz
          do ibb=1,nbb
             iqb = ikbidx(ibb,iqbz)             !q1(:) = qbz(:,iqbz)             !q2(:) = q1(:) + bbv(:,ibb)
             do concurrent(ib1=iko_ix:iko_fx, ib2=iko_ix:iko_fx) !ib1,ib2 band index of outer-inner window
                uumat(ib1,ib2,ibb,iqbz)= sum(dconjg(o2al(1:nband,ib1,iqbz))*o2al(1:nband,ib2,iqb)) ! define connection <q ib1| q+b ib2>
             enddo
          enddo
       enddo
       write(ifuumat) nband,nqbz,iko_ix,iko_fx,nMLO,idmto
       write(ifuumat) evl   !eigenvalue
       write(ifuumat) uumat !connection matrix
       write(ifuumat) amnk  !initial projection
1010 enddo uuispinloop
    close(ifuumat)
    if(job==0) call rx0('OK! end of lmhfam2 job=0 for generating CNmat')
  endblock GetCNmatFile

1011 continue !=== job==1 mode start ========================================
  open(newunit=ifuumat,file='CNmat',form='unformatted')
  allocate(hmmr2(nMLO,nMLO,npairmx,nspin),ommr2(nMLO,nMLO,npairmx,nspin),source=(0d0,0d0))
  allocate(ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband),hamm(1:nband,1:nband))
  allocate(evl(nband,nqbz), ovec(nband,nband),ovl(nband))
  allocate(amnk(iko_ix:iko_fx,nMLO,nqbz),idmto_(nMLO))
  allocate(wbz(nqbz),source=1d0/nqbz)
  allocate (uumat(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz))
  ispinloop: do 1000 is = 1,nspin
     read(ifuumat) nband_,nqbz_,iko_ix_,iko_fx_,nMLO_,idmto_
     if(nMLO/=nMLO.or.sum(abs(idmto-idmto_))/=0) call rx0('lmfham2: idmto error: Repeat --job=1 with the same <Worb> in GWinput!')
     read(ifuumat) evl
     read(ifuumat) uumat
     read(ifuumat) amnk
     emm=9999d0
     emin=9999d0
     do iqbz=1,nqbz 
        emm = min(emm,minval(evl(:,iqbz),mask=evl(:,iqbz)>eferm+0.01d0))  != min(evl(nMLO/2,iqbz),emm) 
     enddo !emm is at CBM
     write(stdo,ftox)' bandgap(on mesh point) eV=',ftof((emm-eferm)*rydberg(),3)
     if(einnerHeV> 1d7) einnerHeV= (emm-eferm)*rydberg()+eoffset  !einnerHeV= CBM + eoffset (eV)
     einnerH= einnerHeV/rydberg()+eferm
     einnerL= einnerLeV/rydberg()+eferm
     if(master_mpi) then
        write(stdo,ftox)' einnerH from VBM=',ftof((einnerH-eferm)*rydberg(),3),' eV'
        write(stdo,ftox)' einnerL from VBM=',ftof((einnerL-eferm)*rydberg(),3),' eV'
     endif   
     if(master_mpi) then
        write(stdo,ftox)'isploop: is=',is,'out of',nspin,'ChooseSpace by cnk(init:iend,1:nMLO,1:nqbz)=',iko_ix,iko_fx,nMLO,nqbz
     endif   
     allocate ( upu(iko_ix:iko_fx,iko_ix:iko_fx,nbb,nqbz), cnk(iko_ix:iko_fx,nMLO,nqbz), omgik(nqbz),evals(nqbz))!,zesum(nqbz)) !cnk2(iko_ix:iko_fx,nMLO,nqbz)
     allocate( WTbandq(nqbz),WTinnerq(nqbz))
     cnk  = 0d0
     call amnk2unk(amnk,iko_ix,iko_fx,iko_i,iko_f, nMLO,nqbz,  cnk)! amnk was in Eq.22 in Ref.II. <psi|Gaussian>. Now amnk=< psi(it,iqbz) | MTO(nMLO) >
     zesumold=1d10
     alpha = 1d0
     upu   = 0d0
     wbbs=sum(wbb(1:nbb)) !we assume iko_i(iq)=1. If not, use evl(iko_i(iq),iq)
     SouzaStep1loop: do isc = 1,nsc1 ! choose Hilbert space -- determine cnk
        iqloop: do iq = 1,nqbz 
           nout = iko_f(iq) - iko_i(iq) + 1 !outer
           ndz  = nout 
           if(isc /= 1) alpha = alpha1
           allocate(wmat(iko_ix:iko_fx,iko_ix:iko_fx), wmat2(iko_ix:iko_fx,iko_ix:iko_fx))
           i1q=iko_i(iq)
           i2q=iko_f(iq)
           do ibb = 1,nbb
              iqb = ikbidx(ibb,iq)
              i1= iko_i(iqb)
              i2= iko_f(iqb)
              do concurrent(inp=i1:i2, imp=i1:i2) !wmat = cnk * cnk^{*} is projector to 'wannier space'.
                 wmat(inp,imp)= sum(dconjg(cnk(inp,1:nMLO,iqb))*cnk(imp,1:nMLO,iqb)) !BUG-> range of sum was nin+1,nMLO before 2023-6-8(miyake)
              enddo
              do concurrent(inx=i1q:i2q, imp=i1:i2)
                 wmat2(imp,inx)= sum( wmat(i1:i2,imp)*dconjg(uumat(inx,i1:i2,ibb,iq)) ) !wmat*uumat
              enddo
              do concurrent(imx=i1q:i2q, inx=i1q:i2q)!      upu=   uumat* wmat * uumat ! (1-2) <u_mk | P_k+b | u_nk>
                 upu(imx,inx,ibb,iq)= (1d0-alpha)*upu(imx,inx,ibb,iq) + alpha*sum(uumat(imx,i1:i2,ibb,iq)*wmat2(i1:i2,inx))
              enddo
           enddo
           deallocate(wmat,wmat2)
           
           ! Omega= 1/2 \sum_b,k Tr {|\nabla Pk|^2} + WTband*Tr{Pk H} - WTinner*Tr{Pk EinnerW} + WTseed * Tr {Pk <psi_m|seed_i><seed_i|psi_n|}
           ! zmn = \frac{\delta Omega}{\delta Pmn^k}
           allocate (zmn0(ndz,ndz),source=(0d0,0d0)) ! (1-3) Zmn(k) > phi,eval
           allocate (zmn(ndz,ndz), evecc(ndz,ndz),eval(ndz),WTbandii(ndz),WTinnerii(ndz))
           do ibb = 1,nbb
              zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) - 2d0*wbb(ibb)*upu(iko_i(iq):iko_f(iq),iko_i(iq):iko_f(iq),ibb,iq)
           enddo
           zmn=zmn0
           do concurrent(i=iko_i(iq):iko_f(iq))
              WTbandii(i)= WTband*(evl(i,iq))   !lower eigenvalue for higher energy
              zmn(i,i)=zmn0(i,i) + WTbandii(i)!Add penalty part to emphasize lower/innner window
           enddo   
           do concurrent(i=iko_i(iq):iko_f(iq))
              WTinnerii(i)=-WTinner/(exp((evl(i,iq)-einnerH)/ewid)+1d0)/(exp(-(evl(i,iq)-einnerL)/ewid)+1d0) !inner window enhancement 
              zmn(i,i)=zmn(i,i) + WTinnerii(i)!Add penalty part to emphasize lower/innner window
           enddo
           if(WTseed/=0d0) zmn=zmn-WTseed*matmul(amnk(iko_i(iq):iko_f(iq),1:nMLO,iq), & !projection to Seed functions
                dconjg(transpose(amnk(iko_i(iq):iko_f(iq),1:nMLO,iq)))) 
           ! do i=iko_i(iq),iko_f(iq) !Hard inner window
           !    if(evl(i,iq)<einnerH.and.evl(i,iq)>einnerL) then 
           !       zmn(i,i)       = 9999d0; zmn(i,1:i-1   )= 0d0;  zmn(i,i+1:ndz )= 0d0; zmn(1:i-1, i  )= 0d0; zmn(i+1:ndz,i )= 0d0
           !    endif   
           ! enddo
           call diag_hm(zmn,ndz,eval,evecc)
           ! eval(i)/wbbs is normalized. If all eval(i)/wbbs=1, P_k=P_{k+b}.
           forall(iwf = 1:nMLO) cnk(iko_i(iq):iko_f(iq),iwf,iq) = evecc(1:ndz,iwf) !ndz+1-iwf)
           evals(iq)= sum(eval(1:nMLO)) 
           omgik(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*matmul(zmn0,evecc(1:ndz,i))),i=1,nMLO)])  
           WTbandq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTbandii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !2nd energy term
           WTinnerq(iq)= sum([(sum(dconjg(evecc(1:ndz,i))*WTinnerii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !
           !write(stdo,ftox)'iq=',iq,'eval=',ftof(eval)
           deallocate (zmn,evecc,eval,zmn0,WTbandii,WTinnerii)
        enddo iqloop
        omgi  = sum(omgik(:)*wbz(:)) 
        WTbandqsum=sum(WTbandq(:)*wbz(:))
        WTinnerqsum=sum(WTinnerq(:)*wbz(:))
        evalss= sum(evals(:)*wbz(:))   
        ! \sum eval = \sum zmn0 term + WTbandq + WTinnerq
        !    write(stdo,ftox)'#SC-loop, OmegaI_a Zsum=',isc,ftof(omgi),'=',ftof(zesi-evalss+WTbandqsum+WTinnerqsum)
        if(WTinner/=0d0) aaa='Pinner='//trim(ftof(-WTinnerqsum/WTinner/nMLO))
        if(WTband/=0d0) bbb='Emean(eV)='//trim(ftof((WTbandqsum/WTband/nMLO-eferm)*rydberg()))
        write(stdo,ftox)'#SC-loop:isc=',isc,'Omega/nMLO=',ftof( (wbbs+omgi/2d0/nMLO)/tpia**2 + WTbandqsum/nMLO + WTinnerqsum/nMLO),&
             'Nabla2/nMLO(a.u.**2)=',ftof((wbbs+omgi/2d0/nMLO)/tpia**2/2d0 ),&
             'MeanOverlap=',ftof(-omgi/2d0/nMLO/wbbs),trim(bbb),trim(aaa) !Omega corresponds to Omega_I in Eq.34 Mazari.
        !NOTE: nMLO \sim omgi=\sum_b wb \sum_{m=1}^N \sum_{n=1}^N |Mmn^{k,b}|^2 (See Eq.7 in Souza paper).
        !      But Mnm here is only for coefficienets parts of eigenfunctions.
        if(isc>=2 .and. dabs(evalssold-evalss)<conv1) then   ! (1-6) check self-consistency
           write(stdo,ftox) ' Step1: converged!'
           exit
        endif
        evalssold = evalss
        if(isc==nsc1) write(stdo,ftox)' Step1: not converged'
     enddo SouzaStep1loop
     deallocate(upu) 
     !! NOTE: cnk(iko_ix:iko_fx,nMLO,nqbz) is the final results of Step1loop, which minimize Omega_I (Wannier space)
     !!   cnk(iko_i(iq):iko_f(iq),nMLO,iq) gives nMLO-dimentional space.
     GetHamiltonianforMTObyProjection: block  !We do not use Marzari's unitary rotation
       real(8):: qq(3)
       integer:: il,im,in,ib1,ib2,jsp
       complex(8):: ham(nMLO,nMLO),ovlx(nMLO,nMLO),phase,proj(iko_ix:iko_fx,iko_ix:iko_fx),pa(iko_ix:iko_fx,nMLO)
       jsp=is
       do iqbz = 1,nqbz
          qq(:) = qbz(:,iqbz) !          write(6,*)' xxxx iq q=',iq,qq
          do concurrent(i=iko_ix:iko_fx, j=iko_ix:iko_fx)     !outer bandindex
             proj(i,j) = sum(cnk(i,:,iqbz)*dconjg(cnk(j,:,iqbz))) !sum for MLOindex
          enddo
          pa(iko_ix:iko_fx,1:nMLO) = matmul(proj,amnk(iko_ix:iko_fx,1:nMLO,iqbz))
          do concurrent(i=1:nMLO,j=1:nMLO)
             ham(i,j)  = sum(dconjg(pa(:,i))*evl(:,iqbz)*pa(:,j)) !sum(dconjg(pa(:,i))*pa(:,j))!
             ovlx(i,j) = sum(dconjg(pa(:,i))*pa(:,j))
          enddo
          do concurrent(i=1:nMLO,j=1:nMLO) !Real space Hamiltonian. H(k)->H(T) FT to real space
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                phase = 1d0/dble(nqbz)* exp(img*2d0*pi* sum(qq*matmul(plat,nlat(:,it,ib1,ib2))))
                hmmr2(i,j,it,jsp)= hmmr2(i,j,it,jsp)+ ham(i,j)*phase
                ommr2(i,j,it,jsp)= ommr2(i,j,it,jsp)+ ovlx(i,j)*phase
             enddo
          enddo
       enddo
     endblock GetHamiltonianforMTObyProjection
     write(6,*)' get hmmr2. Goto band_lmfham2.dat ---------'
     bandplotMLO: block
       real(8):: qp(3),evlm(nMLO,ndat)
       complex(8):: phase,hamm(nMLO,nMLO),ovlm(nMLO,nMLO),evec(nMLO,nMLO)
       integer:: iband
       jsp=is
       fband='band_lmfham2_spin'//char(48+jsp)//'.dat'
       fband1='band_lmfham1_spin'//char(48+jsp)//'.dat'
       open(newunit=iband,file=trim(fband))
       do iq= 1,ndat
          qp=qplistsy(:,iq) 
          ovlm = 0d0
          hamm = 0d0
          do concurrent(i=1:nMLO,j=1:nMLO)
             ib1 = ib_tableM(i) 
             ib2 = ib_tableM(j) 
             do it =1,npair(ib1,ib2)
                phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                hamm(i,j)= hamm(i,j)+ hmmr2(i,j,it,is)*phase
                ovlm(i,j)= ovlm(i,j)+ ommr2(i,j,it,is)*phase
             enddo
          enddo
          nmx =nMLO
          call zhev_tk4(nMLO,hamm,ovlm,nmx,nev, evlm(:,iq), evec, epsovl)! Diangonale (hamm - evl ovlm ) evec=0
          if(iq<6)  write(stdo,"(' iq q=',i3,*(a))") iq,' ',ftof(qp,3),' e=',ftof(evlm(1:12,iq),3)
          if(iq==6) write(stdo,"(' iq q= ...')") 
          do i=1,nev
             write(iband,ftox)  ftof(xdat(iq)),ftof(evlm(i,iq)), is,i
          enddo
       enddo
       close(iband)
     endblock bandplotMLO
     write(stdo,ftox)'einner ewid (eV)=',ftof((einner-eferm)*rydberg()),ftof(ewid*rydberg())
     Modifiedbandplotglt: block
       integer:: ifglt1,ifglt
       character(256):: aline,fname,fname2
       jsp = is
       fname2='bandplot.lmfham2.isp'//char(48+jsp)//'.glt'
       fname ='bandplot.isp'//char(48+jsp)//'.glt'
       open(newunit=ifglt,  file=trim(fname))
       open(newunit=ifglt1, file=trim(fname2))
       do 
          read(ifglt,"(a)",err=989,end=989)aline
          if(trim(aline)=="plot \") then !"
             write(ifglt1,ftox)"ef=",ftof(eferm)  
             write(ifglt1,ftox)trim(aline)
             write(ifglt1,ftox)'"'//trim(fband1)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'  
             write(ifglt1,ftox)'"'//trim(fband)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'  
          else
             write(ifglt1,ftox)trim(aline)
          endif   
       enddo
989    continue
       close(ifglt)
       close(ifglt1)
       write(stdo,ftox)'OK! Run gnuplot -p '//trim(fname2)//'.Red points are by hmmr2 for Hamiltonian on {|MLO2>}'
    endblock Modifiedbandplotglt
    deallocate(cnk,omgik,evals,wtbandq,wtinnerq)
1000 enddo ispinloop
  call rx0('OK! end of lmfham2 -----------------')
END PROGRAM lmfham2

     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ! ! --- Readin nlam index
     ! open(newunit=ifoc,file ='@MNLA_CPHI')
     ! ldim2 = ldim !nlmto
     ! read(ifoc,*)
     ! if(allocated(m_indx)) deallocate(m_indx,n_indx,l_indx,ibas_indx,ibasiwf)
     ! allocate(m_indx(ldim2),n_indx(ldim2),l_indx(ldim2),ibas_indx(ldim2))
     ! do ix =1,ldim2
     !    read(ifoc,*)m_indx(ix),n_indx(ix),l_indx(ix),ibas_indx(ix),ixx
     !    if(ixx/=ix) call rx('failed to readin @MNLA_CPHI')
     ! enddo
     ! close(ifoc)
     ! allocate(ibasiwf(nwf))
     ! do iwf=1,nwf
     !    ibasiwf(iwf) = ibas_indx(iphi(1,iwf))
     ! enddo

     ! !! write HrotRS
     ! ifh=ifile_handle()
     ! if(is==1) open(ifh,file='HrotRS.up',form='unformatted')
     ! if(is==2) open(ifh,file='HrotRS.dn',form='unformatted')
     ! write(ifh)alat,plat,natom
     ! write(ifh)pos
     ! write(ifh)ef
     ! write(ifh)nwf,nrws,n1,n2,n3
     ! write(ifh) irws,rws,drws,hrotr, ibasiwf !drws added by okumura Aug28,2017
     ! close(ifh)

!     call write_hopping_output(is, hrotr, &
!          rws,irws,alat,plat,qlat,pos,natom, &
!          ibasiwf, nwf,nrws,spid , m_indx, l_indx, &
!          nphix, iphi, ldim2)
     !      close(ifh)

     !! TEST okumura: iq=1,nq, q->qbz?   (2017/06/10)
!!! qtt -> q, nqtt -> nqbz
     ! ! data list for wannier
     ! ifh=ifile_handle()
     ! open(ifh,file="wan4chi.d",form="unformatted")
     ! write(ifh) nwf,nspin,nqbz
     ! close(ifh)

     ! ! generate eigenvalue and eigenvector of Wannier Hamiltonian
     ! ! Index:: evecc_w (orbital,band,q-point,spin)
     ! write(6,*)
     ! if (is==1) allocate(eval_w(nwf,nqbz,nspin),evecc_w(nwf,nwf,nqbz,nspin))
     ! do iq = 1,nqbz
     !    if(iq<5 .OR. iq>nqbz-3)write(6,*)' got get_hrotkp_ws iq =',iq
     !    if(iq==5)write(6,*)' ...'
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,qbz(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval_w(1:nwf,iq,is)=eval
     !    evecc_w(1:nwf,1:nwf,iq,is)=evecc
     ! enddo

     ! if(is==2) then
     !    ifh=ifile_handle()
     !    open(ifh,file='EValue_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) eval_w(1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     !    ifh=ifile_handle()
     !    open(ifh,file='EVec_w',form='unformatted')
     !    write(ifh) nwf,nqbz,nspin
     !    write(ifh) qbz(1:3,1:nqbz)
     !    write(ifh) evecc_w(1:nwf,1:nwf,1:nqbz,1:nspin)
     !    close(ifh)
     ! endif
     ! ! end okumura

     ! !! other k-points
     ! write(ifbnd,*)ef,' ef'
     ! write(iftb,*)ef,' ef'
     ! write(iffb,*)'#',ef,' ef'
     ! if (lsh) write(ifsh,*)ef,' ef'
     ! allocate(eval1(nwf,nq),eval3(nwf,nq),evecc1(nwf,nwf,nq))
     ! if(lsh) allocate(eval2(nwf,nq),evecc2(nwf,nwf,nq))
     ! do iq = 1,nq
     !    !     write(6,*)' got get_hrotkp_ws iq =',iq
     !    ! (3-3) Hrot_mn(k')
     !    call get_hrotkp_ws(hrotr,rws,drws,irws,q(:,iq), &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    ! (3-4) diagonalize
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval1(1:nwf,iq)=eval
     !    evecc1(1:nwf,1:nwf,iq)=evecc
     !    !     (3-4) diagonalize  -- Small Hamiltonian --
     !    if (lsh) then
     !       hrotkps(1:nsh,1:nsh) = hrotkp(nsh1:nsh2,nsh1:nsh2)
     !       call diag_hm(hrotkps,nsh,evals,eveccs)
     !       write(ifsh,*)'iq =',iq
     !       write(ifsh,990)q(1:3,iq)
     !       eval2(1:nsh,iq)= evals(1:nsh)
     !       evecc2(1:nwf,1:nwf,iq)=eveccs
     !    endif                 ! lsh
     !    ! (3-3) Hrot_mn(k')  -- Tight-binding ---
     !    call get_hrotkp_tb_ws(rcut,plat,alat, &
     !         hrotr,rws,drws,irws,q(:,iq),  ibasiwf,pos,natom, &
     !         nwf,nqbz,nrws, &
     !         hrotkp)
     !    !     (3-4) diagonalize -- Tight-binding --
     !    call diag_hm(hrotkp,nwf,eval,evecc)
     !    eval3(1:nwf,iq)=eval
     ! enddo
     ! do iband = 1,nwf
     !    do iq = 1,nq
     !       write(ifbnd,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       write(iftb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !            iq,q(1:3,iq),  xq(iq),(eval3(iband,iq)-ef)*rydberg(),iband
     !       write(iffb,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' ')",ADVANCE='NO') &
     !            iq,q(1:3,iq),  xq(iq),(eval1(iband,iq)-ef)*rydberg(),iband
     !       do iwf=1,nwf
     !          write(iffb,"(f13.6)",ADVANCE='NO') (abs(evecc1(iwf,iband,iq)))**2
     !       enddo
     !       write(iffb,*)
     !    enddo
     !    write(ifbnd,*)
     !    write(iftb,*)
     !    write(iffb,*)
     !    write(iffb,*)
     ! enddo
!     deallocate(eval1,eval3,evecc1)
     ! if(lsh) then
     !    do iband = 1,nsh
     !       do iq = 1,nq
     !          write(ifsh,"(i5,3f13.5,'  ',f13.6,f13.6,i5,' !eee! x eval-ef(ev) iband' )") &
     !               iq,q(1:3,iq),  xq(iq),(eval2(iband,iq)-ef)*rydberg(),iband
     !       enddo
     !    enddo
     ! endif
!     call writeham(ifham,is,ef,alat,plat,pos,qbz,wbz,rws,irws,hrotk,nspin,natom,nwf,nqbz,nrws)
!     deallocate(cnk,umnk,eunk,hrotk,hrotr,hrotkp,evecc,eval,irws,rws,drws, &
!          ibasiwf,m_indx,n_indx,l_indx,ibas_indx)
!     if (lsh) deallocate(hrotkps,eveccs,evals,evecc2)
!     close(ifbnd)
!     close(iftb)
!     close(iffb)
!1000 enddo ispinloop
!950 format(a14,3f23.16)
!990 format(3f12.6)
!  call cputid(0)
!  call rx0s('lmfham2: ixc=2 ok')
!END PROGRAM lmfham2
