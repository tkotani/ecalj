      subroutine orbl(ib,ldimp,ldim,iprmb,norb,ltab,ktab,off,offl,ndim)
      use m_lmfinit,only: nl,nkaph

C- Extract a list of l's in given hamiltonian block for one site
C ----------------------------------------------------------------------
Ci Inputs
Ci   ib    :site for which to extract list of l's and k's
Ci   ldimp :hamiltonian block consists of orbitals betw. ldimp and ldim
Ci   ldim  :see ldimp, above
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Co Outputs
Co   norb  :number of orbital types for ib; see Remarks
Co   ltab  :table of l-quantum numbers for each type
Co   ktab  :table of energy index for each type
Co   off   :offset to first orbital for site ib (see Remarks).
Co   offl  :offl(norb) offset in h to this block of orbitals
Co   ndim  :dimension of hamiltonian for this site
Cr Remarks
Cr   Each orbital type is label by a 'l' and a 'k' index
Cr   Each orbital corresponds to a unique radial wave function at the
Cr   site where the orbit is centered.  There can be multiple 'k'
Cr   indices (radial wave function shapes) for a particular l.
Cr
Cr   This routine returns the proper value of  'off'  only for ldim
Cr   = size of hamiltonian lower block.  Determining off through
Cr   iprmb for other blocks requires a loop over site index, which
Cr   is too expensive.  Better to use offH generated by makidx.
Cu Updates
Cu    8 Jun 00 Handles multiple-kappa case, ktab now used
Cu   13 Mar 00 order ltab in downfolding order
Cu    2 Mar 00 offl arranged by iorb=1..norb, not by l
Cu   17 Oct 99 routine revised to use iprmb, rather than old offH
Cu   12 Dec 99 routine generates offl
C ----------------------------------------------------------------------
C     implicit none
      integer ib,ldimp,ldim,iprmb(1),norb,ndim,n0,nkap0
      parameter (n0=10,nkap0=3)
      integer off,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)
      integer ik,l,lmr,ltabi(n0*nkap0),ktabi(n0*nkap0),
     .offli(n0*nkap0+1),iwk(n0*nkap0)
C --- Make ltab,offl in l order, followed by k order ---
      norb = 0
      ndim = 0
      off = -1
      lmr = nl*nl*nkaph*(ib-1)
      do  ik = 1, nkaph
        do  l = 0, nl-1
          offli(norb+1) = -1
          if (iprmb(lmr+1) .gt. ldimp .and. iprmb(lmr+1) .le. ldim) then
            offli(norb+1) = iprmb(lmr+1) - 1
            if (off .eq. -1) off = offli(norb+1)
            off = min(off,offli(norb+1))
            norb = norb+1
            ndim = ndim + 2*l+1
            ltabi(norb) = l
            ktabi(norb) = ik
          endif
          lmr = lmr + 2*l+1
        enddo
      enddo
C --- Permute to downfolding order ---
      if (norb .gt. n0*nkap0) call rx('orbl: norb .gt. n0')
      call ivheap(1,norb,offli,iwk,1)
      do  l = 1, norb
        ltab(l) = ltabi(iwk(l))
        ktab(l) = ktabi(iwk(l))
        offl(l) = offli(iwk(l))
      enddo
      end

