      program rdata4gw_v2
C- Generate input files for GW calculations from DATA4GW_V2 and so.
C-------------------------------------------------------------------------
Ci Input files
Ci  QIBZ      : irreducible q point.  Given by qg4gw.
Ci  QGpsi     : q and G vector for the Coulomb matrix. Given by qg4gw.
Ci  QGcou     : q and G vector for the Coulomb matrix. Given by qg4gw.
Ci  Q0P       : q points near q=0 instead of q=0. Given by qg4gw.
Ci  GWIN0     : required inputs for GW only read its nband.
Ci  SYMOPS    : points group operation.
Ci  DATA4GW_V2:  main input, which contains eigenfunctions, radial functions...
Ci
Co Output files  *U means for upper spin. *D means for down spin.
Co  hbe.d   :  datasize
Co  CPHI    :  Coefficients of eigenfun for augmentation wave in each MT
Co  EV[UD]  : valence eigen value
Co  PHIVC   : valence phi phidot, local core
Co  ECORE   : core eigenvalue
Co  VXCFP   : LDA Vxc. VXCFPV which contains Vxc(nval) is generated for NoCore case.
Co  PLN     : Plane wave related parts for interstitial.
Co  LMTO    : basic date for the crystal.
Co  HVCCIN  : required inputs for hvccfp0. Informations in this files
Co            are also in GWIN (duplicated--it shuold be improved in future.)
Co
Co   NQIBZ             : number of q point ---used only for hparainfo.
Co @MNLA_CPHI  : Checkwrite. check write. Ording of index for CPHI.
Co @MNLA_core  : Checkwrite. index for core
c
c-------------------------------------------------------------------------
c
Cr For GW calculation, you have to execute the command h* below sucsessively after
Cr you write GWIN_V2 and QPNT, whose tamplates are generated by mkGWIN_lmf.
Cr See gw_lmf, which is the script to do the procedure automatically.
Cr
Cr  hchknw  : calculate the number of real axis mesh nw (this is a simple program).
Cr  hbasfp0 : mode 0. generate product basis for each sites
Cr          : mode 3. generate product basis for each sites for core exchange.
Cr  hvccfp0 : Coulomb matrix V.
Cr  hx0fp0  : W-V, W means screened coulomb interaction
c
Cr  hsfp0 mode 1 : exchange self-energy.
Cr  hsfp0 mode 2 : correlated part of the self-energy.
Cr  hsfp0 mode 3 : exhchange self-energy for core.
c
c--------------------------------------------------------------
c
c--   From GWIN0.
Cr  n1 n2 n3: give the BZ mesh
c
c--   From QGpsi
Cr  QpGcut_psi  : Maxmum of |q+G| in a.u. for eigenfunction
Cr  ngp         : the number of the IPW (it is k-dependent)
Cr  ngvec
c--   From QGcou
Cr  QpGcut_cou  : Maxmum of |q+G| in a.u. for Coulomb matrix
Cr  ngc         : the number of the IPW (it is k-dependent)
c
Cr--- From DATA4GW_V2 -----
Cr   nbas            : the number atom in the primitive cell
Cr   bas(1:3,1:nbas) : atomic posion in Cartesian coordinate (alat unit),.
Cr   lmxa(1:nbas)    : maximum l number for each atom for augmentation.
c
Cr  alat        : lattice constant in a.u.
Cr  plat(1:3,1) : 1st primitive translation vector in the unit of alat
Cr  plat(1:3,2) : 2nd primitive translation vector
Cr  plat(1:3,3) : 3rd primitive translation vector
c
c--   eigenfunctions for all q points.
Cr  evl (1:nband)          :  eigenvalue
Cr  cphi(1:ldim2,1:nband) : the coefficienets of eigenfunction for phi(augmentation wave)
Cr  geig(1:ngp,  1:nband) : the coefficienets of eigenfunction for IPW
Cr
Cr   nindx   (1;ldim2) : n index (phi=1 phidot=2 localorbital=3)
Cr   lindx   (1:ldim2) : l index
Cr   ibasindx(1:ldim2) : ibas index . These are used to re-ordering cphi.
Cr                     :  mindx(1:ldim2)  is generated under the asuumption that
Cr                        m=-l:l is successively ordered.
Cr
Cr  vxclda (1:nband) : lda XC potential <psi|Vxc(n)|psi> for each eigenfunctions
c
Cr  vxcldav(1:nband) : lda XC potential <psi|Vxc(n_valence)|psi> for each eigenfunctions
c     Now no core code is not supported...
C
c--   Atomic data for all the atom in the cell, ibas=1,nbas
Cr   Z:
Cr   nr a,b; mesh is r(i)=b*(exp(a(i-1))-1)
Cr   ncore: number of core.
Cr   konf(0:lmxa): principle quantum number of valence electron.
Cr   ec(1:ncore)
Cr   gx : radial wave function phi.
Cr
C
Ch     - Apr 2002 takao kotani ver.2 ; generalized to include multiple-augmentation waves in each MT.
C------------------------------------------------------------------
c     implicit real*8 (a-h,o-z)
      use keyvalue
c      use m_anf,only: anfcond
c     &  ,iantiferro               !for check
      implicit none
      integer(4) ::
     &     ifigw0,n1q,n2q,n3q,ifiqg,ifiqc,nqnum,ngpmx,nq0i,i,ifi
     &     ,nsp,nbas,nclass,nrmx,ncoremx,lmxamx,nband,nqtti,nxx,lxx,ibxx
     &     ,ifnlax,inum,ibas,ic,k,icore,kkkmx,kkk,n,mmm,ix,irr,nradmx,irad
     &     ,ifhbed,ndble,mrecb,mrece,ifcphi,ifec,ife0,if0c,nmax,lx,nx
     &     ,mx,nnc,lmxax,ic1,irad1,irad2,l1,n1,l2,n2,nn,ierr,i1,i2,nnv,ikp
     &     ,iband,ib,m,nm,ikpisp,ngp,ngc,ifhvccfp,ngrp,ig,ifiqibz
     &     ,nqibz,iqibz,ifnqibz,iqi,iq,ifigwin  !,ippovl,ngc2mx,ngc2
     &     ,ifiqgc,nqnumc,ngcmx,l,ifoc,ir,isp,iopen,  iqi2
      real(8):: qpgcut_psi,qpgcut_cou,ovvxx,ovvx,qpgcut_psi2,dummy
      integer(4),parameter:: nspx=2
      real(8) :: qlat(3,3) ,qm(3,3),ginv(3,3),det
      character*30 :: symgrpo='UseSYMOPSfile'
      real(8):: qqq(3),qqqa(3),qqqb(3),qx(3),qxx(3),volumxx,ecx(2)
      integer(4)::              !ifrb (nspx),ifcb(nspx),ifrhb(nspx),ifchb(nspx)
     &     ifphi,ifev !ifev(nspx)
     &     ,ifv,ifplane
      character*4,allocatable:: clablx(:)
      real(8),allocatable:: rofi(:)
      integer(4),allocatable:: lmxaa(:),nncx(:,:),nrGG(:)
     &     ,ngvecp(:,:),ngvecc(:,:),indxk(:),ipq(:)
     &     ,lcutmx(:) !,ngcx(:),ngveccf(:,:,:),ngc2x(:),ngvecc2(:,:,:)
      real(8),allocatable :: rmax(:),gen(:,:),wgt(:)
     &     ,symgr(:,:,:),qibze(:,:)
      integer(4) :: idxk,nword
      complex(8),allocatable :: ppovl(:,:),ppx(:,:),ppovlinv(:,:)
      real(8),allocatable :: wt(:),q0i(:,:)
      real(8),allocatable :: qibz(:,:)

      integer(4):: nqbz ,icore1,nnn(3),nnnn, mrecg,nqi
      integer,allocatable:: invgx(:)
      real(8),allocatable:: shtvg(:,:)

c----------------------------------------------
      real(8) ::
     &     alat,                ! Lattice constant in a.u.
     &     efermi               ! dummy not used now
      logical :: 
     &     nocore               ! Flag file NoCore exist or not.
      ! nocore is obtained by inquire(file='NoCore',exist=nocore) in the upper routine.
      ! If nocore exist. you have to supply
      !  <psi|Vxc(n_valence)|psi>  to  vxclda (nband, nqtti).
      ! If not, <psi|Vxc(n_total)|psi>  to  vxclda.
c
c     v2
      integer(4):: nphi,        ! number of augmentation nRl channels, as distinct from:
     &     ldim2,               ! number of nRLm channels = 2*ldim for phi+phidot case.
     &     nphimx               ! Maxmum number of phi for all l ---  2 for phi+phidot case.
c
      integer(4),allocatable::
     &     iclass(:),
     &     lmxa  (:),
     &     nr(:),
     &     konf(:,:), vkonf(:,:), !ckonf(:,:),
     &     ncore(:),
c     v2
     &     nindx(:),            ! n    index
     &     lindx(:),            ! l    index
     &     ibasindx(:),         ! ibas index
     &     mindx(:)

      real(8),allocatable ::
     &     zz(:),
     &     aa(:),bb(:),
     &     bas(:,:),
     &     plat(:,:),
     &     qtti(:,:),
     &     ec(:,:,:),
     &     evl    (:,:,:),
     &     vxclda (:,:,:),      gxcopy (:,:,:,:,:),
     &     gx_orth (:,:,:,:,:), gx_raw(:,:,:,:,:), gx_in(:,:,:,:,:), 
     &     gcore(:,:,:,:),  
     &     ovv(:,:,:,:,:),zzp(:,:,:,:,:),zzpi(:,:,:,:,:),eb(:)
      complex(8),allocatable::
     &     cphi(:,:,:,:),
     &     geig(:,:,:,:), cphix(:,:),zzpx(:,:)
c
      integer(4),allocatable::
     &     nrad(:),nindx_r(:,:),lindx_r(:,:),ncindx(:),lcindx(:)

      integer(4),allocatable::
     &     iord(:,:,:,:),nvmax(:,:)

      logical:: core_orth,cccxxx !readgwinput,
      real(8)::ovcv
      character*20 fcore
      character*3 charnum3
      integer(4),allocatable:: ifcore(:)

c     nc takao
c      integer(4),allocatable::ngvecpf(:,:,:),ngpcx(:) ,ngpx(:)
      real(8)::xx(5)
!     for normcheck on eigenfunctions.
      real(8),allocatable:: sumc(:,:,:)
      integer(4):: inorm ,ib1,ib2,itest,inormo
      logical ::checknorm=.true. !Write normchk.* or not. 
     &     , checkdia=.true.    !only write normchk.dia This is relevant only for checknorm=T

c      logical :: cphigeigmode,cphigeig_mode
      complex(8),allocatable:: cphir(:,:),geigr(:,:,:)
      integer(4)::ificg

c     logical:: ifgeigb
      integer(4)::iff,iffx
      integer(4),allocatable:: iffg(:)


      integer(4):: ifgeig,iadd,normcheck,verbose !,bzcase
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     complex(8)::ddd
c     itest= 225
c     open(itest, file = "eigtest")
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      integer(4)::version

c     gg test
      character(8):: xt
      integer(4):: l_given,m_given,ic_given,isp_given,iffr,ixx
      complex(8),allocatable :: gg(:)

c     reduced weight
      real(8),allocatable:: www(:,:,:)
c
      logical(8):: ppovl0l=.false.
      integer(4):: ippovl0=2301

      logical::  ngczero=.false.,qreduce
      integer(4):: nqnumt,imx     ,ix1     ,idum1,idum2,idum3, idum4 !ingczero
      real(8),allocatable::qsave(:,:)
      logical :: debug=.false.

      integer(4):: nqini,iq0pin
c      logical :: ippovlc_test
      integer:: ippovlc=501, zvztest

      logical:: rmeshrefine
      integer(4):: nr_n
      real(8):: aa_n,bb_n,rmaxx,ab_n,delr,delrset,qu(3)
      real(8),allocatable:: rofi_n(:), gx_raw_n (:,:,:,:,:), 
     &     gcore_n  (:,:,:,:) , aann(:)
      integer(4),allocatable:: nrnn(:)

      integer(4):: igp1,igp2,   icold,nbandx,ifnband,iread
      real(8),allocatable:: qtt(:,:)
      integer:: nqtt,igg,iorb, igc
      real(8):: platt(3,3),qtarget(3)
      logical:: newaniso, noo
      integer:: ngcB,iqx,iqindx,iq0i
      real(8):: quu(3),pi,dQpG,abq0i,dQQ
      integer,allocatable:: ngveccB(:,:)
      integer:: idummy11(1,1)

      integer:: nxxx(1:3)=0,ngggmx,ngcgpmx,ippovlg,ippovli,ippovlgg
      real(8):: QpGcutggg,QpGcutgcgp
      complex(8),allocatable:: ggg(:)
      integer,allocatable:: nvggg(:,:),nvgcgp(:,:),iantiferro(:)
      integer:: nggg,ngcgp !q independent 

c---------------------------------------------------
      pi         = 4d0*datan(1d0)
      if(verbose()>50 ) debug=.true.
c      if(zvztest()==1) then
c        ippovlc_test = .true.
c      endif
c      if(ippovlc_test) open (ippovlc,form='unformatted',file='PPOVLC')
      if(ppovl0l)        open (ippovl0,form='unformatted',file='PPOVL0')
      call readin6(ix1,idum2,idum3,idum4) ! ingczero)
      call headver('rdata4gw_v2',ix1)
      mmm=normcheck()
      if(mmm==0) then
        checknorm=.false.
      elseif(mmm==1) then
        checknorm=.true.
        checkdia=.true.
      elseif(mmm==2) then
        checknorm=.true.
        checkdia=.false.
      endif

      call getkeyvalue("GWinput", "n1n2n3", nnn,3) !Readin nx ny nz for k-points for GW calculations from "GWinput" file
      n1q=nnn(1); n2q=nnn(2); n3q = nnn(3)

!! --- Readin QGpsi and QGcou ---
      ifiqg  = 101
      ifiqgc = 102
      open(ifiqg ,file='QGpsi',form='unformatted')
      open(ifiqgc,file='QGcou',form='unformatted')
      read(ifiqg  ) nqnum , ngpmx, QpGcut_psi,nnnn
      read(ifiqgc ) nqnumc, ngcmx, QpGcut_Cou
      nqtt=nqnum
      allocate(qtt(3,nqtt))
      do iq=1,nqtt
        read(ifiqg) qtt(1:3,iq)
        read(ifiqg)
        write(*,"(' qtt =',i4,3f9.5)")iq, qtt(1:3,iq)
      enddo

!! ---- rewind QGpsi ----
      rewind ifiqg
      read(ifiqg  ) nqnum , ngpmx, QpGcut_psi,nnnn,nqi,imx,nqibz

      write(6,*) 'QpGcut_psi QpGcutCou nnnn nqi from QGpsi QGcou='
     &     , QpGcut_psi,QpGcut_Cou ,nnnn,nqi

!! --- Readin Q0P
      print *, 'reading QOP'
      open (103,file='Q0P')
      read (103,*) nq0i,iq0pin
      allocate( wt(nq0i),q0i(1:3,nq0i) )
      read (103,*) ( wt(i),q0i(1:3,i),i=1,nq0i)
      close(103)

!! --- Readin DATA4GW_V2
      ifi = 104
      open(ifi,file='DATA4GW_V2',form='unformatted')
      call gwinput0_v2(ifi,
     &     nsp,   nbas,   nclass, nrmx,   ncoremx,
     &     lmxamx,ngpmx,  nband,  ldim2,   nqtti, !ldim2
     &     nphi, nphimx)
      write(6,*)' DATA4GW_V2 size=',nsp,   nbas,   nclass, nrmx, ncoremx
      write(6,*)'                =',lmxamx,ngpmx,  nband,  ldim2,  nqtti
      write(6,*)'                =',nphi,nphimx

!! -- allocate ------------------------
      allocate(
     &     iclass(nbas),        ! class is starting from 1.
     &     lmxa  (nclass),      ! Maximum l number for each atom for augmentation.
     &     nr(nclass),          ! Size of radial mesh.
     &     konf(0:lmxamx,nclass), ! Principle quantum numbers of valence electron.
      ! For example, 4s4p3d means konf(0)=4, konf(1)=4, konf(2)=3.
      ! Core orbitals are specified by
      !   1, 2,... konf(0)-1 for s
      !   2, 3,... konf(1)-1 for p
      !   3, 4,... konf(2)-1 for d, and so on.
      !   
     &     vkonf(0:lmxamx,nclass), ! konf
!     &  ckonf(0:lmxamx,nclass),! konf for core
     &     ncore(nclass),       ! ncore = \sum_l  (konf(l)-1) - l
      ! Number of different core orbitals for each atom.
c     real(8) ::
     &     zz(nclass),          ! Atomic number.
     &     aa(nclass),bb(nclass), ! Radial mesh are specified by these parameters with nr.
     &     bas(3,nbas),         ! Atomic posion in the Cartesian coordinate (alat unit),.
     &     plat(3,3),           ! Primitive translation vector in the unit of alat. plat(1:3,1) is 1st vector, ans so on.
     &     qtti(3,nqtti),         ! q points given by qg4gw
c 
     &     ec(ncoremx, nclass, nsp), ! Eigenvalues for core
     &     evl    (nband, nqtti, nsp), ! Eigenvalues
     &     vxclda (nband, nqtti, nsp), ! Lda XC potential <psi|Vxc(n_total)  |psi>
      !  or   <psi|Vxc(n_valence)|psi>. See nocore.
c     v2
     &     gx_raw (nrmx, 0:lmxamx, nphimx, nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
     &     ovv(nphimx,nphimx,0:lmxamx, nclass,nsp) ,
c     &  gx (nrmx, 0:lmxamx, 2, nclass,nsp), ! Radial function. gx (nrmx, lmxamx, 1, nclass,nsp) is phi
      !                  gx (nrmx, lmxaxm, 2, nclass,nsp) is phidot
     &     gcore(nrmx, ncoremx, nclass,nsp), ! Core radial function.
c
!     &  geig(ngpmx,  nband, nqtti,nsp),! Coefficienets of eigenfunction for IPW.
!     &  cphi(ldim2, nband, nqtti,nsp), ! Coefficienets of eigenfunction 
     &     nindx(ldim2),        ! n    index
     &     lindx(ldim2),        ! l    index
     &     ibasindx(ldim2) )    ! ibas index
!     nphi is the number of different augmentation functions= nRla
!     ldim2 ->nRlma

      ificg=421
      open(ificg,file='CphiGeig',form='unformatted')

!! --- readin ---
      call gwinput_v2x(ifi,
     &     nsp,   nbas,   nclass, nrmx,   ncoremx,
     &     lmxamx,ngpmx,  nband,  ldim2,  nqtti , !ldim2
c     
     &     nphi,nphimx,nindx,lindx,ibasindx,
c     
     &     iclass,lmxa,nr,konf,ncore,
     &     zz,aa,bb,bas,alat,plat,
     &     qtti,efermi,ec,evl,vxclda,gx_raw,gcore,nocore) !,cphi,geig
      allocate(iantiferro(nbas))
      read(ifi) iantiferro !may2015
      nocore=.false. ! we fixe nocore=yes for simplicity. See lmf2gw also.
      print *,' iclass=',iclass
      print *,' nqtti nbas',nqtti,nbas
      write(6,"(a,100i4)") ' iantiferro=',iantiferro(1:nbas)
      do iq=1,nqtti
        write(*,"(' qtti=',i4,3f9.5)")iq, qtti(1:3,iq)
      enddo

cccc  TEST2ccccccccccccccccccccccccccccccccccccccccccccc
c     print *, '############# gxcopy TEST2 ##########'
c     allocate(gxcopy(nrmx, 0:lmxamx, nphimx, nclass,nsp))
c     gxcopy = gx
c     deallocate(gx)
c     nphimx = 3
c     allocate(gx (nrmx, 0:lmxamx, nphimx, nclass,nsp))
c     gx= 0d0
c     gx(:,:, 2:3, :,:) = gxcopy
c     do ie=1,ldim2
c     nindx(ie) = nindx(ie)+1
c     enddo
c
cccc  TEST1cccccccccccccccccccccccccccccccccccccccccccccc
c     test to change the n label.
c     if(.true.) then
c     lxx=0;  nxx=3; nyy=1; icxx=1
c     print *, '############# xychange TEST ##########'
c     do ibxx = 1,nbas
c     if(iclass(ibxx)==icxx) then
c     do ie = 1,ldim2
c     if(lindx(ie)==lxx.and.ibasindx(ie)==ibxx ) then
c     if(nindx(ie)==nxx) then
c     ixx=ie
c     exit
c     endif
c     endif
c     enddo
c     do ie = 1,ldim2
c     if(lindx(ie)==lxx.and.ibasindx(ie)==ibxx ) then
c     if(nindx(ie)==nyy) then
c     iyy=ie
c     exit
c     endif
c     endif
c     enddo
c     print *,' Test to exchange n :ixx iyy=',ixx,iyy
c     call xychangei(nindx(ixx:ixx+2*lxx),nindx(iyy:iyy+2*lxx),2*lxx+1)
c     endif
c     enddo
c
c     call xychange ( gx(1:nrmx,lxx:lxx,nxx:nxx,icxx,1:nsp),
c     &                gx(1:nrmx,lxx:lxx,nyy:nyy,icxx,1:nsp),
c     &               nrmx*nsp)
c     call xychange (cphi(ixx:ixx+2*lxx, 1:nband, 1:nqtti,1:nsp),
c     &               cphi(iyy:iyy+2*lxx, 1:nband, 1:nqtti,1:nsp),
c     &               2*nband*nqtti*nsp*(2*lxx+1))
c
c     endif
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c$$$      if(nocore) then           ! NoCore or not? inquire(file='NoCore',exist=nocore)
c$$$        write(6,"(a)")' NoCore case. So we use Vxc(nvalence)'
c$$$      endif
c     write(6,*) ' smooth mixed basis=',smbasis()

      call dinv33 ( plat,1,qlat,volumxx )
      call dinv33(qlat,0,ginv,det)
      allocate(lmxaa(1:nbas))
      lmxaa(1:nbas) = lmxa(iclass(1:nbas))


!! --- Make index-file @MLNA  ------------------------------------
      nxx= -999; lxx= -999; ibxx=-999
      allocate(nrad(nbas), nindx_r(ldim2,nbas),lindx_r(ldim2,nbas))
      nrad = 0
      ifnlax = iopen('@MNLA_core',1,-1,0)
      write(ifnlax,"(a)") '    m    n    l  icore ibas   ' ! Index for core
      write(ifnlax,'(" ------- core ------------")')
      inum = 0
      do ibas = 1,nbas;  ic  = iclass(ibas)
        do l = 0, lmxa(ic)
          vkonf(l,ic) = mod(konf(l,ic),10)
          !only 1th digit of konf has original meaning of atomic configulation
          !Mark use 10th digit for local orbital
        enddo
      enddo
      do ibas = 1,nbas
        ic   = iclass(ibas) 
        icore = 0                ! --- core
        do l   = 0, lmxa(ic)
          kkkmx = vkonf(l,ic) - 1
          do kkk = l+1,kkkmx  ! kkkmx is the principle quantum number for core.
            icore = icore+1
            n    = kkk - l   ! n is starting from 1 for any l.
            ! kkk is the usual quantum principle number in text book
            do mmm=-l,l
              inum = inum+1
              write(ifnlax,'(10i5)')
     &                 mmm, n, l, icore, ibas
            enddo
          enddo
        enddo
        if(ncore(ic)/=icore) then
          write(6,*)ncore(ic),icore
Cstop2rx 2013.08.09 kino          stop ' rdata xxx1: ncore(ic)/=icore'
          call rx( ' rdata xxx1: ncore(ic)/=icore')
        endif
      enddo
!! -------------------------------------------------------------
      inum=0  !    write(ifnlax,'(" ------- valence ------------")')
      allocate(mindx(ldim2))
      do ix = 1,ldim2
        if(ix>1.and. nxx == nindx(ix) .and. lxx == lindx(ix) .and. ibxx== ibasindx(ix)) then
          mmm=mmm+1
        else
          lxx = lindx(ix)
          ibxx= ibasindx(ix)
          nxx = nindx(ix)
          nrad(ibxx)  = nrad(ibxx)+1
          irr = nrad(ibxx)
          nindx_r(irr,ibxx) = nxx
          lindx_r(irr,ibxx) = lxx
          mmm = -lxx
        endif
        mindx(ix) = mmm
        inum = inum+1
      enddo
!! -------------------------------


!! --- radial function indexing  ----
      nradmx= maxval(nrad)
      write(6,*)
      write(6,*) " --- Radial function indexing --- "
      write(6,"(' nradmx=',i5)") nradmx
      do ibas=1,nbas
        write(6,*)' ---- ibas nrad(ibas) =', ibas, nrad(ibas)
        do irad = 1,nrad(ibas)
          write(6,'("      irad=",i3," nindx_r lindx_r=",2i3)')
     &           irad, nindx_r(irad,ibas), lindx_r(irad,ibas)
        enddo
      enddo
!! ... hbe.d
      ifhbed = iopen('hbe.d',1,-1,0)
      nqbz  = n1q*n2q*n3q
      ndble = 8
c     nword = 4
      write(6,'( " ldim2 nband=",3i5)') ldim2, nband
      mrecb = 2*ldim2*nband *ndble/nword()
      mrece = nband         *ndble/nword()
      mrecg = 2*ngpmx*nband *ndble/nword()
      write(ifhbed,"(1x,i3,6i12)") ndble,mrecb,mrece,ldim2,nqbz,nband,mrecg
      write(ifhbed,*)' precision, mrecl of b, mrecl of eval, ldim2(p+d+l)  nqbz  nband mrecg'
      close(ifhbed)

!!--- save eigenvalues to EValue, qtti, nqtti also ---
      ifev= iopen('EValue',0,-1,0)    !feb2012takao
      write(ifev) nband, nqtti, nsp
      write(ifev) qtti(1:3,1:nqtti) !qtti
      write(ifev) evl(1:nband, 1:nqtti, 1:nsp )
      close(ifev)
!!
      ifec   = iopen('ECORE', 1,-1,0) ! Core eigenvalues
      ifphi  = iopen('PHIVC', 0,-1,0) ! PHIV+PHIC  valence augmentation radial function and core
      ife0   = iopen('eig0.chk', 1,-1,0) ! chech write for eigenfunction at gamma.
      ifcphi = iopen('CPHI', 0,-1,mrecb) !  the augmentation wave.
      ifgeig = iopen('GEIG', 0,-1,mrecg) ! Coefficienets of eigenfunction for q+G wave.
      ifv    = iopen('VXCFP',0,-1,0)
      write(ifv) nband,nqi ! mar2012takao  write(ifv) nband,nqtti    !feb2012takao

!! --- augmentation wave numbering--- idxnlmc in index.f order
!     m,n,l,ic order. On the other hand, fplmto gives m l n ic  for valence!
!     This ordering is important for psi2b_v2 and psibc_v2 in x0kf_v2 and sxcf_v2, and so on.
      ifoc = iopen('@MNLA_CPHI',1,-1,0)
      write(ifoc,"('    m    n    l ibas')")
      allocate(nvmax(0:lmxamx,nclass))
      nvmax=0
      do ix =1,ldim2
        nxx = nindx(ix)
        l   = lindx(ix)
        ibas =ibasindx(ix)
        ic = iclass(ibas)
        if( nxx> nvmax(l,ic) ) nvmax(l,ic) = nxx
      enddo
      nmax = maxval(nvmax)
      allocate( iord(-lmxamx:lmxamx,nmax,0:lmxamx,nbas))
      ix=0
      iorb=0
      do ibas = 1,nbas
        ic = iclass(ibas)
        do lx = 0,lmxa(ic)
          do nx = 1,nvmax(lx,ic)
            iorb=iorb+1
            do mx = -lx,lx
              ix = ix+1
              iord(mx,nx,lx,ibas)=ix
              write(ifoc,"(10i6)")mx,nx,lx,ibas,ix,iorb
            enddo
          enddo
        enddo
      enddo
      if(ix/=ldim2) then
        print *,ix,ldim2
Cstop2rx 2013.08.09 kino        stop 'rdata4gw_v2:ix/=ldim2'
        call rx( 'rdata4gw_v2:ix/=ldim2')
      endif

C --- Mesh refining  ! nov2005
!     Get new
!     nrmx, gx_raw, gcore, aa(ic),bb(ic),nr(ic)
!     These are replaced during this if-block.
!
!     For given two conditions;
!     a. dr/dI (delrset() in switches.F) and the
!     b. keeping dr/dI at r=0 (= a*b),
!     we can deternie required nr(ic), a(ic), b(ic).
      if(rmeshrefine()) then
        print *,'rmeshrefine:'
        delr = delrset()       !delr is dr/di at rmax in a.u.
        print *,' delr nclass=',delr,nclass
        allocate(nrnn(nclass),aann(nclass))
        do ic = 1,nclass
          if(minval(abs(iclass-ic))/=0) cycle !jan2008
          rmaxx = bb(ic)*(exp((nr(ic)-1)*aa(ic))-1d0)
          aa_n= (delr-aa(ic)*bb(ic))/rmaxx
          bb_n= aa(ic)*bb(ic)/aa_n
          write(6,"(' ic aa bb=',i5,2d13.6,i5)") ic, aa(ic),bb(ic),nr(ic)
          write(6,"(' rmaxx aa_n bb_n=',3d13.6)")rmaxx,aa_n,bb_n
          ir =0
          do
            ir = ir + 1
            if( bb_n*( exp(aa_n*(ir-1))-1d0 ) >rmaxx ) exit
          enddo
          nrnn(ic) = (ir/2)*2 + 1 !odd for simplson integral later on.
          aann(ic) = aa_n
        enddo
        nrmx = maxval(nrnn(1:nclass))
        write(6,*) ' New nrmx =',nrmx
        allocate( gx_raw_n (nrmx, 0:lmxamx, nphimx, nclass,nsp), 
     &        gcore_n  (nrmx, ncoremx, nclass,nsp) )
        do ic = 1,nclass
          if(minval(abs(iclass-ic))/=0) cycle !jan2008
          write(6,"('  input  nr a b =',i5,3d13.6)") nr(ic),aa(ic),bb(ic)
          allocate(rofi(nr(ic)))
          do ir=1,nr(ic)
            rofi(ir) = bb(ic)*(exp((ir-1)*aa(ic))-1d0)
          enddo
          nr_n = nrnn(ic)
          aa_n = aann(ic)
          bb_n = rofi(nr(ic))/(exp(aa_n*(nr_n-1))-1d0)
!     aa_n = aa(ic) !initial guess
!     bb_n = bb(ic) !initial guess
!     call getab(nr_n,nr(ic),  aa_n,bb_n) !return new a b
          allocate(rofi_n(1:nr_n))
          do ir=1,nr_n
            rofi_n(ir) = bb_n*(exp((ir-1)*aa_n)-1d0)
          enddo
          do isp = 1, nsp
            do lx = 0,lmxa(ic)
              do nx = 1,nvmax(lx,ic)
                call rrefine(rofi,nr(ic),rofi_n,nr_n,
     i                    gx_raw(1, lx, nx, ic,isp),
     o                    gx_raw_n(1, lx, nx, ic,isp) )
              enddo
            enddo
            do icore = 1,ncore(ic)
              call rrefine(rofi,nr(ic),rofi_n,nr_n,
     i                 gcore(1,icore, ic,isp),
     o                 gcore_n(1,icore, ic,isp) )
            enddo
          enddo
          aa(ic) = aa_n
          bb(ic) = bb_n
          nr(ic) = nr_n
          deallocate(rofi,rofi_n)
          write(6,"(' output  nr a b =',i5,3d13.6)") nr(ic),aa(ic),bb(ic)
        enddo
        deallocate( gcore )
        deallocate( gx_raw)
        allocate  ( gx_raw (nrmx, 0:lmxamx, nphimx, nclass,nsp), 
     &        gcore  (nrmx, ncoremx, nclass,nsp) )
        gx_raw = gx_raw_n
        gcore  = gcore_n
        print *,'rmeshrefine: end'
      endif
      allocate(
     &     gx_in  (nrmx, 0:lmxamx, nphimx, nclass,nsp), !scaled gx_raw to avoid degeneracy of overalp mat.
     &     gx_orth(nrmx, 0:lmxamx, nphimx, nclass,nsp)  ) ! OrthoNormalized


C --- ATOMIC PART ic = ibas scheme -------------------------------
      write(6,*) '########## goto atomic part ##############'
      nnc = 0
      lmxax = lmxamx
      allocate(clablx(nbas))
      allocate( zzp (nmax,nmax,0:lmxax,nclass,nsp),
     &     zzpi(nmax,nmax,0:lmxax,nclass,nsp),
     &     eb(nmax))
      allocate(nncx(0:lmxax,nbas),rmax(nbas))
      do ibas=1,nbas
        ic   = iclass(ibas)
        do l  = 0,lmxa(ic)
          nncx(l,ibas) = vkonf(l,ic) -1 -(l+1) +1
          nnc          = max(nnc,nncx(l,ibas))
        enddo
      enddo
      allocate(ncindx(ncoremx),lcindx(ncoremx))
      ncindx=-9999;lcindx=-9999

C ... PHIVC initial
      write(ifphi) nbas, nradmx,ncoremx,nrmx
      write(ifphi) nrad(1:nbas)
      write(ifphi) nindx_r(1:nradmx,1:nbas),lindx_r(1:nradmx,1:nbas)

C ... ibas loop
      do ibas = 1,nbas
        ic   = iclass(ibas)
        clablx(ibas) = "AT"//char( 48+ibas )
        ic1   = ibas
        allocate(rofi(nr(ic)))
        do ir=1,nr(ic)
          rofi(ir) = bb(ic)*(exp((ir-1)*aa(ic))-1d0)
        enddo
        rmax(ibas) = rofi(nr(ic))
c
        write(6,*)
        write(6,*)' ### ibas ic =',ibas,ic
        write(6,"(4i4,2d14.6)")  nr(ic),lmxa(ic), nsp
     &        , ncore(ic), aa(ic), bb(ic)
c
C ... ECORE
        write(ifec,*)          !ECORE
        write(ifec,*) clablx(ibas) !ECORE
        write(ifec,*) ' z,atom=class,nr,a,b,nsp ' !ECORE
        write(ifec,6200) zz(ic),ic1,nr(ic),aa(ic),bb(ic),nsp !ECORE
c     6200   format(1x,f5.1,2i5,f13.5,d13.6,i4)                   !ECORE
 6200   format(1x,f5.1,2i10,f13.5,d14.6,i4) !ECORE 31jan2006 a and b can be negative
!     i10 May2006
        write(ifec,*)' configuration   !!! LocalOrbital 2=upper 1=lower' !ECORE
        write(ifec,"($,1x,10i3)") (vkonf(l,ic),  l=0,lmxa(ic)) !ECORE
        ! principl quantum  number of valence minimum
        write(ifec,"('      ',10i3)") (konf(l,ic)/10,l=0,lmxa(ic)) !ECORE
        ! related to LocalOrbital part lower(=1) upper(=2).
        write(ifec,*)' l,n, ecore(up), ecore(down) ' !ECORE
c
        icore = 0
        do l  = 0,lmxa(ic)
          do kkk = l+1 ,vkonf(l,ic)-1
            icore = icore+1
            n    = kkk - l
            ncindx(icore)= n
            lcindx(icore)= l
            write(ifec,"(1x,2i3,2d17.6)") l,n,ec(icore,ic,1:nsp) !ECORE
c     do isp=1,nsp
c     write(ifphi) ic1,l,n,isp
c     wr ite(ifphi) gcore(1:nr(ic),icore,ic,isp)
c     enddo
          enddo
        enddo

c----------------------------------------------------------------------


C ... PHIVC
        write(ifphi) ncore(ic), ncoremx !core
        write(ifphi) ncindx,lcindx !core
        write(ifphi) ic1,zz(ic),nr(ic),aa(ic),bb(ic)
        write(ifphi) rofi(1:nr(ic))

c==========================================
        print *,' gx_raw normcheck ======================'
        ovv=0d0
        do isp = 1, nsp
          do irad1 = 1,nrad(ibas)
            do irad2 = 1,nrad(ibas)
              l1 = lindx_r (irad1,ibas)
              n1 = nindx_r (irad1,ibas)
              l2 = lindx_r (irad2,ibas)
              n2 = nindx_r (irad2,ibas)
              if(l1/=l2) cycle
              call gintxx( gx_raw(1, l1, n1, ic,isp), 
     &                 gx_raw(1, l1, n2, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovvxx )
              if(n1==n2) then
                write(6,"(' l isp n1 n2 = ',4i3,' ',d14.6)")
     &                    l1, isp,n1,n2,ovvxx
              else
                write(6,"(' l isp n1 n2 = ',4i3,' ',14x,d14.6)")
     &                    l1, isp,n1,n2,ovvxx
              endif
            enddo
          enddo
        enddo
        print *,' end of gx_raw normcheck =============='
c============================================


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     if(ic==1)then
c     do isp = 1, nsp
c     do l1  = 0,lmxa(ic)
c     do nn = 1, nvmax(l1,ic)
c     write(4001,*) 'isp l1 nn= ',isp, l1, nn
c     write(4001,'(2d13.5)') (rofi(ir),
c     &      gx_raw (ir,l1,nn,ic,isp),ir=1,nr(ic))
c     enddo
c     enddo
c     enddo
c     endif
cccccccccccccccccccccccccccccccccccccccccccccccccccccccc



C --- This section it to keep the numerical stability when we have degeneracy.
c     (mainly in the case of orthnormalized input)
        do isp = 1, nsp
          do l1  = 0,lmxa(ic)
            do nn = 1, nvmax(l1,ic)
              gx_in (1:nr(ic),l1,nn,ic,isp) =
     &                 gx_raw(1:nr(ic),l1,nn,ic,isp)      * sqrt(1d0+0.1d0*nn)

cccccccccccccccccccccccccccctestx
c     if(ibas==1.and.l1==2) then
c     gx_in (1:nr(ic),l1,nn,ic,isp) =
c     &    gx_raw(1:nr(ic),l1,nn,ic,isp)      / sqrt(1d0+50d0**nn)
c     endif
ccccccccccccccccccccccccccc

            enddo
          enddo
        enddo

c --- this section moved int the eigensection
c     if(.not.cphigeig) then
c     do ix = 1,ldim2
c     if(ibasindx(ix)==ibas)
c     &    cphi (ix, :,:,:)= cphi(ix, :,:,:)  /sqrt(1d0+0.1d0*nindx(ix))
c     enddo
c     endif
c----------------------------------------------

c
C ... Get overlap matrix ovv of radial functions.
c     write(6,*)
c     &  ' --- norm for given  radial functions devided by 1+0.1n --- '
        ovv=0d0
        do isp = 1, nsp
          do irad1 = 1,nrad(ibas)
            do irad2 = 1,nrad(ibas)
              l1 = lindx_r (irad1,ibas)
              n1 = nindx_r (irad1,ibas)
              l2 = lindx_r (irad2,ibas)
              n2 = nindx_r (irad2,ibas)
              if(l1/=l2) cycle
              call gintxx( gx_in(1, l1, n1, ic,isp), 
     &                 gx_in(1, l1, n2, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovv(n1,n2,l1,ic,isp) )
c     if(n1==n2) then
c     write(6,"(' l isp n1 n2 = ',4i3,' ',d14.6)")
c     &        l1, isp,n1,n2,ovv(n1,n2,l1,ic,isp)
c     else
c     write(6,"(' l isp n1 n2 = ',4i3,' ',14x,d14.6)")
c     &        l1, isp,n1,n2,ovv(n1,n2,l1,ic,isp)
c     endif
            enddo
          enddo
        enddo

!     ------------------------------------------------------------------
!     ovv(1:nm,1:nm,l1,ic,isp) ---> zzp (1:nm,1:nm,l1,ic,isp),
!     where nm = nvmax(l1,ic)
!     \sum_j ovv(i,j)*zzp0(j,k)= e_k zzp0(i,k)
!     zzp(i,j) = zzp0(i,k)  /sqrt(e_k)
!     zzpi = inverse of zzp
c     ------------------------------------------------------------------
        do isp = 1, nsp
          do l1  = 0,lmxa(ic)
            n1 = nvmax(l1,ic)
C ... Get zzp : eigenfunctions of ovv
c     print *,ovv(1:n1,1:n1,l1,ic,isp)
c     print *,' goto rs: isp l1 n1=',isp,l1,n1
            call rs(n1, ovv(1:n1,1:n1,l1,ic,isp), eb, 
     &              zzp(1:n1,1:n1,l1,ic,isp), ierr)
            write(6,"(' eb=',10f12.6)") eb(1:n1)
            if(ierr/=0 ) then
              write(6,*)' rdata4gw_v2: error in rs ierr=',ierr
Cstop2rx 2013.08.09 kino              stop ' rdata4gw_v2: error in rs '
              call rx( ' rdata4gw_v2: error in rs ')
            endif
            do i1=1,n1
              do i2=1,n1
                zzp(i1,i2,l1,ic,isp) = zzp(i1,i2,l1,ic,isp) /sqrt(eb(i2))
              enddo
            enddo
c     print *,' zzp=',zzp(1:n1,1:n1,l1,ic,isp)
C ... Get zzpi : inverse of zzp
            allocate(zzpx(1:n1,1:n1))
            zzpx = zzp(1:n1,1:n1,l1,ic,isp)
            call matcinv(n1,zzpx)
            zzpi(1:n1,1:n1,l1,ic,isp) = dreal(zzpx)
            deallocate(zzpx)
c     print *,' zzpi=',zzpi(1:n1,1:n1,l1,ic,isp)
            do ir=1,nr(ic)
              gx_orth(ir,l1,1:n1,ic,isp) = 
     &                 matmul(gx_in(ir,l1,1:n1,ic,isp),zzp(1:n1,1:n1,l1,ic,isp))
            enddo
          enddo
        enddo


c=====================================================================
C ... core normalization check ---
        cccxxx=core_orth()
        write(6,*)
        write(6,*)' core_orth=', core_orth()
        if(minval( abs(iclass(1:ibas-1)-ic))==0.and.core_orth()) then
          write(6,*)
          write(6,*)' ### core of ic=',ic,' is already renormalized. Skipped'
          write(6,*)
          goto 980
        endif
C ... check
        write(6,*)' -- norm check: <core|core> ----------------- '
        do isp = 1, nsp
          do icore = 1,ncore(ic)
            do icore1 = 1,ncore(ic)
              n1= ncindx(icore1)
              l1= lcindx(icore1)
              n2= ncindx(icore)
              l2= lcindx(icore)
              if(l1/=l2) cycle
              call gintxx( gcore(1:nr(ic),icore1, ic,isp),
     &                 gcore(1:nr(ic),icore, ic,isp), !gx_orth(1:nr(ic), l1, n2, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovvx)
              if(icore==icore1) then
                write(6,"(' ---',
     &                    ' isp l=',2i3,' icore1 icore = ',2i3,' ',d14.6)")
     &                    isp, l1, icore1, icore, ovvx
              else
                write(6,"(' ---',
     &                    ' isp l=',2i3,' icore1 icore = ',2i3,' ',14x,d14.6)")
     &                    isp, l1, icore1, icore, ovvx
              endif
            enddo
          enddo
        enddo

C ... norm check: <gx_orth|core>
        write(6,*)' -- norm check: <gx_orth|core> -------------- '
        do isp = 1, nsp
          do icore = 1,ncore(ic)
            l2= lcindx(icore)
            n2= ncindx(icore)
            do irad1 = 1,nrad(ibas)
              l1 = lindx_r (irad1,ibas)
              n1 = nindx_r (irad1,ibas)
              if(l1/=l2) cycle
              call gintxx( gx_orth(1:nr(ic), l1, n1, ic,isp), 
     &                 gcore(1:nr(ic),icore, ic,isp), !gx_orth(1:nr(ic), l1, n2, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovcv)
              write(6,"(' ---',
     &                 ' isp  l1 n1=',3i3,' icore = ',i3,' ',d14.6)")
     &                 isp, l1, n1, icore, ovcv
            enddo
          enddo
        enddo                  !end of isp loop

C ... Renormalization of gcore (orthogonalized to gx_orth)
        if(core_orth()) then
          write(6,*)' -- orthogonalize cores with gx_orth ------------ '
          do isp = 1, nsp
            do icore = 1,ncore(ic)
              l2= lcindx(icore)
              n2= ncindx(icore)
              do irad1 = 1,nrad(ibas)
                l1 = lindx_r (irad1,ibas)
                n1 = nindx_r (irad1,ibas)
                if(l1/=l2) cycle
                call gintxx( gx_orth(1:nr(ic), l1, n1, ic,isp), 
     &                    gcore(1:nr(ic),icore, ic,isp), !gx_orth(1:nr(ic), l1, n2, ic,isp),
     &                    aa(ic),bb(ic), nr(ic), ovcv)
                gcore(  1:nr(ic),icore, ic,isp)=  
     &                    gcore(1:nr(ic),icore, ic,isp)  
     &                    - ovcv* gx_orth(1:nr(ic),l1, n1, ic,isp)
              enddo
              call gintxx( gcore(1:nr(ic),icore, ic,isp),
     &                 gcore(1:nr(ic),icore, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovcv)
              gcore(1:nr(ic),icore, ic,isp)=1d0/sqrt(ovcv)*
     &                 gcore(1:nr(ic),icore, ic,isp)
            enddo
          enddo               !end of isp loop

C ... norm check new gx_orth x core once more -----------
          write(6,*)' -- norm check: <gx_orth| renormalized gcore> ------ '
          do isp = 1, nsp
            do icore = 1,ncore(ic)
              l2= lcindx(icore)
              n2= ncindx(icore)
              do irad1 = 1,nrad(ibas)
                l1 = lindx_r (irad1,ibas)
                n1 = nindx_r (irad1,ibas)
                if(l1/=l2) cycle
                call gintxx( gx_orth(1:nr(ic), l1, n1, ic,isp), 
     &                    gcore(1:nr(ic),icore, ic,isp), !gx_orth(1:nr(ic), l1, n2, ic,isp),
     &                    aa(ic),bb(ic), nr(ic), ovcv)
                write(6,"(' ---',
     &                    ' isp  l1 n1=',3i3,' icore = ',i3,' ',d14.6)")
     &                    isp, l1, n1, icore, ovcv
              enddo
            enddo
          enddo               !end of isp loop
        endif
 980    continue


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     do irad1 = 1,nrad(ibas)
c     l1 = lindx_r (irad1,ibas)
c     n1 = nindx_r (irad1,ibas)
c     if(l1==2) then
c     write(9023,"(' -----------------------',
c     &               ' ibas l1 n1 = ',4i3,' ',14x,d14.6)")ibas,l1,n1
c     do ir=1,nr(ic)
c     write(9023,"(3d15.6)") rofi(ir),gx_raw(ir,l1,n1,ic,1:nsp)
c     enddo
c     endif
c     enddo
c
        allocate(ifcore(0:lmxa(ic)))
        ifcore=-99
        do icore = 1,ncore(ic)
          n2= ncindx(icore)
          l2= lcindx(icore)
          if(ifcore(l2)==-99) then
            ifcore(l2)=9022 +l2
            fcore='Core_ibas'//charnum3(ibas)//'_l'//char(48+l2)//'.chk'
            open(ifcore(l2),file=fcore)
          endif
          write(ifcore(l2),"(' --- --- --- --- n=',i5)") n2
          do ir=1,nr(ic)
            write(ifcore(l2),"(3d15.6)") rofi(ir),gcore(ir,icore, ic,1:nsp)
          enddo
        enddo
        do l2 = 0, lmxa(ic)
          if(ifcore(l2)/=-99) close(ifcore(l2))
        enddo
        deallocate(ifcore)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc




c----------------------------------------------------------------------
        do isp = 1, nsp
          do icore = 1, ncore(ic)
            write(ifphi) gcore(1:nr(ic),icore, ic,isp) ! core
          enddo
          do irad = 1,nrad(ibas)
            l = lindx_r (irad,ibas)
            n = nindx_r(irad,ibas)
            write(ifphi) gx_orth(1:nr(ic),l, n, ic,isp) ! valence orthogonalized
            write(ifphi) gx_raw (1:nr(ic),l, n, ic,isp) ! valence raw
          enddo
          nnv = maxval(nindx(1:ldim2))
        enddo

C ... norm check
        write(6,*)
        write(6,*)' --- norm check: normalized  gx_orth --- '
        do isp = 1, nsp
          do irad1 = 1,nrad(ibas)
            do irad2 = 1,nrad(ibas)
              l1 = lindx_r (irad1,ibas)
              n1 = nindx_r (irad1,ibas)
              l2 = lindx_r (irad2,ibas)
              n2 = nindx_r (irad2,ibas)
              if(l1/=l2) cycle
              call gintxx( gx_orth(1:nr(ic), l1, n1, ic,isp), 
     &                 gx_orth(1:nr(ic), l1, n2, ic,isp),
     &                 aa(ic),bb(ic), nr(ic), ovvx)
              if(n1==n2) then
                write(6,"(' l isp n1 n2 = ',4i3,' ',d14.6)")
     &                    l1, isp,n1,n2,ovvx
              else
                write(6,"(' l isp n1 n2 = ',4i3,' ',14x,d14.6)")
     &                    l1, isp,n1,n2,ovvx
              endif
            enddo
          enddo
        enddo  ! end of isp loop
        deallocate(rofi)
      enddo    ! end of ibas loop
! --- end of atomic part --------------------------------------------

      if(checknorm) then
        inorm = 222
        inormo= 223
        open(inorm, file = "normchk.dia")
        open(inormo,file = "normchk.off")
        write(inorm,849)
        write(inormo,849)
 849    format('#       IPW    ',
     .        '     IPW(diag)',
     .        '   Onsite(tot)',
     .        '   Onsite(phi)',
     .        '      Total  #check in rdata4gw ')
        allocate(sumc(nband,nband,nsp))
      endif


c-------------------------------------------------------------------------------
      write(6,*) '########## goto Eigfun part ############## '
      allocate( cphix(ldim2,nband), !ngveccf(3,ngcmx,nqtti) ,ngcx(nqtti),
     &     cphir(ldim2,nband),geigr(1:ngpmx,1:nband,1:nsp))

!     nc normalization check
c      allocate( ngvecpf(3,ngpmx,nqtti) ,ngpx(nqtti))

c---
c     if(ifgeigb()) then
c     allocate(iffg(0:nq0i))
c     do iff=0,nq0i
c     iffg(iff)=5300+iff
c     open (iffg(iff),file='geigB_'//charnum3(iff),form='unformatted') !
c     enddo
c     endif

      ifnband = iopen('NBANDikp',1,-1,0)
      write(ifnband,"(2i12,' !nband(larger than any)  nqtti')")nband,nqtti
      write(ifnband,"('------ nband ------  ikp ---')")


!!----------------------------------------------------------------------
      do 1200 ikp = 1,nqtti  !irreducible points.
        if(mod(ikp,10)==1.or.ikp>nqtti-5) write(6,*) ' ikp=',ikp
C... determined nbandx, 1:nbandx is meaningful.
        nbandx = nband
        isp=1
        do iband=1,nband
c         print *,' iband evl=',iband,evl
          if( evl(iband, ikp, isp )>1d10 ) then  !<--- See lmf2gw.F evl=1d20 when iband> nbandx
            nbandx=iband-1
            exit
          endif
        enddo
        print *,' nbandx=',nbandx
        write(ifnband,"(2i12)")nbandx,ikp

        do isp =1,nsp
c
c          if(cphigeigmode) then
c            print *,'xxx1'
          read(ificg) cphir(1:ldim2,1:nband)
c            print *,'xxx2'
c          else
c            cphir(:,:) = cphi(:,:, ikp,isp)
c          endif

C ---  reduced cphi corresponding to normaliztion in gx_in.
          do ibas=1,nbas
            do ix = 1,ldim2
              if(ibasindx(ix)==ibas)
     &          cphir (ix,1:nbandx)= cphir(ix, 1:nbandx)/sqrt(1d0+0.1d0*nindx(ix))
            enddo
          enddo
c          print *,' xxx3:'

c          do iband=1,nbandx
c          print *,'sum cphir=',iband, sum(abs(cphir(:,iband)))
c          enddo

c------------------
c     write(ifrb(isp), rec=ikp) dreal(cphi(1:ldim,1,1:nband,ikp,isp))
c     write(ifcb(isp), rec=ikp) dimag(cphi(1:ldim,1,1:nband,ikp,isp))
c     write(ifrhb(isp),rec=ikp) dreal(cphi(1:ldim,2,1:nband,ikp,isp))
c     write(ifchb(isp),rec=ikp) dimag(cphi(1:ldim,2,1:nband,ikp,isp))
c---  Augmentation wave part
          cphix=0d0
          do iband = 1,nbandx
            do ix= 1,ldim2
              l  = lindx(ix)
              ib = ibasindx(ix)
              n  = nindx(ix)
              m  = mindx(ix)
              ic = iclass(ib)
              nm = nvmax(l,ic)
cccccccccccccccccccccccccccccccc
c     if(n/=3)
c     &       cphix(iord(m,1:nm,l,ib),iband) =
c     &       cphix(iord(m,1:nm,l,ib),iband)
c     &       +  zzpi(1:nm,n,l,ic,isp) * cphi(ix,iband,ikp,isp)
cccccccccccccccccccccccccccccccc
              cphix(iord(m,1:nm,l,ib),iband) =
     &                 cphix(iord(m,1:nm,l,ib),iband)
c     &       +  zzpi(1:nm,n,l,ic,isp) * cphi(ix,iband,ikp,isp)
     &                 +  zzpi(1:nm,n,l,ic,isp) * cphir(ix,iband)
            enddo
          enddo
          ikpisp= isp + nsp*(ikp-1)

cccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     testx
c     do ix = 1,ldim2
c     if(ibasindx(ix)==1
c     &       .and. lindx(ix)==2 .and. nindx(ix)==1 )
c     &    cphix (ix, 1:nband)= 0d0
c     enddo
cccccccccccccccccccccccccccccccccccccccccccccccccccccc

          write(ifcphi, rec=ikpisp) cphix(1:ldim2,1:nband) !cphi(1:ldim2,1:nband,ikp,isp)
c     write(ifcphi) cphix(1:ldim2,1:nband) !cphi(1:ldim2,1:nband,ikp,isp)
c          print *,' ikp isp writing evl',ikp,isp
c          write(ifev(isp), rec=ikp) evl(1:nband,ikp,isp)


ccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     do ib= 1, nband
c     do ix= 1,ldim2
c     l  = lindx(ix)
c     n  = nindx(ix)
c     m  = mindx(ix)
c     ibas = ibasindx(ix)
c     ic   = iclass(ibas)
c     ixx  = iord(m,n,l,ibas)
c     if(abs(cphix(ixx,ib))>1d-4)
c     &          write(6,"('ib m n l  cphix=',4i5,2d13.4)") ib,m,n,l,cphix(ixx,ib)
c     enddo
c     write(6,*)
c     enddo
c     stop
c     if(ikp==18) then
          if(.false.) then
            isp_given=1
            l_given  =1
            m_given  =0
            ic_given =1
c     ic=ic_given
            allocate(rofi(nr(ic)),gg(nr(ic)))
            do ir=1,nr(ic)
              rofi(ir) = bb(ic)*(exp((ir-1)*aa(ic))-1d0)
            enddo
            do ib= 1, nbandx
              gg=0d0
              open(iffr,file='radial_ib'//xt(ib))
              write(6,*) " radial_ib=", ib
              do ix= 1,ldim2
                l  = lindx(ix)
                n  = nindx(ix)
                m  = mindx(ix)
                ibas = ibasindx(ix)
                ic   = iclass(ibas)
                ixx  = iord(m,n,l,ibas)
c     write(6,"('ix ixx  m n l  =',10i5)") ix,ixx,  m,n,l !,ic,isp
c     if(ix/=ixx) then
c     print *,'ix ixx=',ix,ixx
c     stop 'ixx/=ixx'
c     endif

c     if(abs(cphix(ixx,ib))>1d-2) then
c     write(6,"('ixx  m n l  cphix=',4i5,2d13.4)") ixx,m,n,l,cphix(ixx,ib)
c     endif

                if (l   /= l_given) cycle
                if (m   /= m_given) cycle
                if (ic  /= ic_given) cycle
                if (isp /= isp_given) cycle
                if(abs(cphix(ixx,ib))>1d-2) then
                  write(6,"('ixx  m n l  cphix=',4i5,2d13.4)") ixx,m,n,l,cphix(ixx,ib)
                endif
                gg = gg +  cphix(ixx,ib)*gx_orth(1:nr(ic), l,n,ic,isp)
              enddo

              do ir=1,nr(ic)
                write(iffr,"(4d15.6)") rofi(ir),abs(gg(ir))**2,gg(ir)
              enddo
              close(iffr)
            enddo
Cstop2rx 2013.08.09 kino            stop 'test end. radial function plot ###########'
            call rx( 'test end. radial function plot ###########')
          endif
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc



cccccccccccccccccccccccccccccccccccccccccccc
c     if(ikp==1.and.isp==1) then
c     do ib1=1,nband
c     ddd= cphix(2,ib1)
c     c     &        evl(ib1,ikp,isp), abs(ddd), abs(cphix(1:16,ib1)/ddd)
c     write(itest,"('===',d10.2,' @',2d10.2,'!',200d10.2)")
c     &        evl(ib1,ikp,isp), ddd,abs(cphix(1:16,ib1))
c     write(itest,"('              @',2d10.2,'!',200d10.2)")
c     &          ddd,dreal(cphix(1:16,ib1))/abs(cphix(1:16,ib1))
c
c     c            write(itest,"('===',d10.2,' @',200d10.2)")
c     c     &        evl(ib1,ikp,isp), abs(cphix(1:16,ib1))
c     enddo
c     endif
cccccccccccccccccccccccccccccccccccccccccccc

c     nc -------------------------------
          if(checknorm) then
            do ib1=1,nbandx
              do ib2=1,nbandx
                if(ib1/=ib2.and.checkdia) cycle
                sumc(ib1,ib2,isp) = sum(dconjg(cphix(1:ldim2,ib1))*cphix(1:ldim2,ib2))
              enddo
            enddo
          endif
c----------------------------------

C ---  check weight
          if(.false.) then
            allocate( www(-lmxamx:lmxamx,0:lmxamx,nbas))
            www=0d0
            do ix =1,ldim2
              l  = lindx(ix)
              n  = nindx(ix)
              m  = mindx(ix)
              ibas = ibasindx(ix)
              ic   = iclass(ibas)
              ixx  = iord(m,n,l,ibas)
              do ib1=1,nbandx
                www(m,l,ibas)=www(m,l,ibas)+abs(cphix(ixx,ib1))**2
              enddo
            enddo
            do ibas = 1,nbas;    ic = iclass(ibas)
              do lx = 0,lmxa(ic)
                write(6,*)'     ---------'
                do mx = -lx,lx
                  write(6,"('     mnlam=',3i3, ' weight=',f10.6)") mx,lx,ibas,www(mx,lx,ibas)
                enddo
              enddo
              write(6,*)
            enddo
            deallocate(www)
          endif

ccccccccccccccccccccccccc
c     write(ife0,*)
c     do iband=1,nband
c     do ix=1,ldim2
c     l  = lindx(ix)
c     ib = ibasindx(ix)
c     n  = nindx(ix)
c     m  = mindx(ix)
c     if(ib==1.and.l==2.and.n==1.and.m==-2) then
c     write(ife0,"(2i4,2f14.6)") iband,ikp,
c     &          evl(iband,ikp,isp), abs(cphix(ix,iband))**2
c     endif
c     enddo
c     enddo
          if(ikp==1) then
            iband=1
            write(ife0,*)
            write(ife0,"(' q=0 1st eigen --- sum =',f23.16)")
c     &           sum(abs(cphi(1:ldim2,1,ikp,isp))**2)
     &              sum(abs(cphir(1:ldim2,1))**2)
            write(ife0,"('  m  n  l  ib  weight')")
            do ix=1,ldim2
              l  = lindx(ix)
              ib = ibasindx(ix)
              n  = nindx(ix)
              m  = mindx(ix)
              write(ife0,"(4i4,f14.6)") m,n,l,ib
c     &        , abs(cphi(ix,iband,ikp,isp))**2
     &                 , abs(cphir(ix,iband))**2
            enddo
          endif
c          if(cphigeigmode) then
c     write(6,*) ' xxx2'
          geigr(1:ngpmx,1:nband,isp)=0d0
          read(ificg) ngp
ccccccccccccccccc
          print *,'  ikp ngp=',ikp,ngp
ccccccccccccccccc
          read(ificg) geigr(1:ngp,1:nband,isp)
c     write(6,*) ' xxx3 '

c          endif

        enddo                  !end of spin loop
        if(verbose()>50) write(6,*) ' goto GEIG'

!!--- Plane wave part ---
        iread=0
        do           !irr is the flag to judge to check irreducible point or not.
          read (ifiqg, err=1012,end=1012) qqqa, ngp !, irr
          read (ifiqgc         ) qqqb, ngc
c          print *,'zzzz qqqa=',qqqa
          allocate( ngvecp(3,ngp),ngvecc(3,ngc) )
          read (ifiqg ) ngvecp
          read (ifiqgc) ngvecc
          if(sum(abs(qtti(:,ikp)-qqqa))<1d-8) exit
          deallocate(ngvecp,ngvecc)
          cycle
 1012     continue
          if(iread==1) call rx('rdata4gw_v2:readin error on QGpsi QGcou')
          iread=1
          rewind ifiqg
          rewind ifiqgc
          read(ifiqg  ) nqnum , ngpmx, QpGcut_psi,nnnn
          read(ifiqgc ) nqnumc, ngcmx, QpGcut_Cou
        enddo
c        ngcx (ikp) = ngc
c        ngveccf (1:3,1:ngc, ikp) = ngvecc
c        ngpx (ikp) = ngp
c        ngvecpf (1:3,1:ngp, ikp) = ngvecp
Cstop2rx 2013.08.09 kino        if(sum(abs(qtti(:,ikp)-qqqa))>1d-10) stop'rdata4gw_v2:qtti/=qqq wrong QpGphi?'
        if(sum(abs(qtti(:,ikp)-qqqa))>1d-10) call rx( 'rdata4gw_v2:qtti/=qqq wrong QpGphi?')
Cstop2rx 2013.08.09 kino        if(sum(abs(qtti(:,ikp)-qqqb))>1d-10) stop'rdata4gw_v2:qtti/=qqq wrong QpGcou?'
        if(sum(abs(qtti(:,ikp)-qqqb))>1d-10) call rx( 'rdata4gw_v2:qtti/=qqq wrong QpGcou?')
        if(debug) print *,' ikp ngp ngc qtti =',ikp,ngp,qtti(:,ikp)
        if(debug) print *,' ikp ngp ngc qqqa=',ikp,ngp,qqqa
        if(debug) print *,' ikp ngp ngc qqqb=',ikp,ngp,qqqb
c-------

!!#feb2012takao
!!  qtti: irreducible q point only(eigenvalue, eigenfunctions are given).
!!  ifiqg contains all q points in full bz (irr=1 means irreducible point.)
!! thus the following check before feb2012 should not now.
        do isp=1,nsp
          ikpisp= isp + nsp*(ikp-1)
          if(ngpmx/=0) write(ifgeig, rec=ikpisp) geigr(1:ngpmx,1:nband,isp)
          if(verbose()>40) then
            write(6,'("geig sumcheck ",i5,3f9.4,"  ",2i5,2d13.6)')ikp,qqqa,ngpmx,ngp,sum(geigr(1:ngp,1:nbandx,isp))
            do ix=1,nbandx
            write(6,'("geig sumcheck ",i5,2d13.6)') ix,sum(geigr(1:ngp,ix,isp))
            enddo
          endif
        enddo

c---  geigB mode
c     if(ifgeigB()) then
c     do iff=0,nq0i
c     c            kp   = nqbz *(iq - nqibz) + k
c     if( ikp<=nqbz*(iff+1) ) then
c     iffx=iff
c     exit
c     endif
c     enddo
c     write(iffg(iffx)) ikp
c     write(iffg(iffx)) geigr(1:ngp,1:nband,1:nsp)
c     endif

c     if(ikp>nnnn) cycle
c     if(ikp>nqbz) cycle
        write(ifv) qtti(1:3,ikp), vxclda(1:nband,ikp,1:nsp) ! VXCFP

c        do iband=1,nband
c        write(6,"('qtti vxclda=',3f8.4,2f10.5)") qtti(1:3,ikp), vxclda(iband,ikp,1:nsp)
c        enddo

c     nc takao normalization check cccccccccccccccccccccccccccccccccc
        if(checknorm) then
          xx=0d0
c          ngp  = ngpx(ikp)
          qx   = qtti(1:3,ikp)
          allocate(ppovl(ngp,ngp))
!     ppovl = <exp (i (q+G')) | exp (i (q+G))>
!     I think P_{k+G} for eieigenfunction is completele zero (no high-l contribution)
!     Thus we need to use mkppovl2 for normalization check.
c          if(version()==-1) then
c            call mkppovl(alat,plat,qlat, qx, 
cc     &              ngp, ngvecpf(1,1,ikp), 
cc     &              ngp, ngvecpf(1,1,ikp), 
c     &              ngp, ngvecp, 
c     &              ngp, ngvecp, 
c     &              rmax, nbas,  bas, lmxaa, lmxax,  
c     o              ppovl)
c          else
            call mkppovl2(alat,plat,qlat, !22April2004 
c     &              ngp, ngvecpf(1,1,ikp), 
c     &              ngp, ngvecpf(1,1,ikp), 
     &              ngp, ngvecp, 
     &              ngp, ngvecp, 
     &              nbas, rmax, bas,  
     o              ppovl)
c          endif

cccccccccccccccccccccccccccccccc
c     print *,' ----- ngp=',ngp
c     do igp1=1,ngp
c     do igp2=1,ngp
c     if( abs(dimag(ppovl(igp1,igp2)))>1d-11) then
c     write(6,"('igp1 igp2 ppovl=',2i5,2d13.5)") igp1,igp2,ppovl(igp1,igp2)
c     endif
c     enddo
c     enddo
c     stop 'xxxxxxxxxxxxxxxxxxxxxx'
ccccccccccccccccccccccccccccccc

          do isp=1,nsp
            do ib1=1,nbandx
              do ib2=1,nbandx
                if(ib1/=ib2.and.checkdia) cycle
                xx(3)=sum( dconjg(  geigr(1:ngp,ib1,isp))*
     &                    matmul(ppovl,geigr(1:ngp,ib2,isp)) )
                xx(1)=sumc(ib1,ib2,isp)
                if(ib1==ib2) write(inorm, '(5f14.6)') xx(3),xx(4),xx(1),xx(2),xx(1)+xx(3)
                if(ib1/=ib2) write(inormo,'(2i4,5f14.6)') ib1,ib2,xx(3),xx(1),xx(1)+xx(3)
              enddo
            enddo
          enddo
          write(inorm,*)
          write(inormo,*)
          deallocate(ppovl)
        endif
        deallocate( ngvecp,ngvecc )
c     nc---------------------------------------------
 1200 continue
      print *,' end of eigensection-----'
      print *

c$$$!! --- check agreement of ngvecc. Apr2012takao
!! this check is probably not necessary because we use qq=0 for q0i. See hvccfp0.
c$$$      if(newaniso()) then
c$$$        if(sum(qtti(:,1)**2)<1d-10) then
c$$$          continue
c$$$        else
c$$$          stop ' qtti(:,ikp=1)/=0'
c$$$        endif
c$$$        do iq=1,nq0i
c$$$          iqx= iqindx(q0i(:,iq), ginv,qtti,nqtti)
c$$$          write(*,"('newaniso check: iq iqx q=',2i3,3f13.5)") iq,iqx,q0i(:,iq)
c$$$          if(ngcx(iqx)-ngcx(1)/=0) then
c$$$            print *,' iqx=',iqx,ngcx(ikp),ngcx(1)
c$$$            print *,'qtti(:,ikp=1)=',qtti(:,1)
c$$$            print *,'qtti(:,ikp)=',qtti(:,iqx)
c$$$            stop 'ngcx(ikp)-ngc(1)/=0 to avoid this, use smaller deltaq_scale. or different QpGcou to void incidental difference.'
c$$$            do igc=1,ngcx(iqx)
c$$$              if(sum(abs(ngveccf(:,igc,iqx)-ngveccf(:,igc,1)))/=0) then
c$$$                print *,' ikp=', 1,   ngveccf(:,igc,1)
c$$$                print *,' iqx=', iqx, ngveccf(:,igc,iqx)
c$$$                stop 'ngveccf(:,iqx)/=ngveccf(:,1)'
c$$$              endif
c$$$            enddo
c$$$          endif
c$$$        enddo
c$$$      endif

!! --- required Input for hvccfp0 ---
      ifhvccfp  = iopen('HVCCIN',0,-1,0)
      write(ifhvccfp) alat, plat,qlat,nqtti, nbas,nband
      write(ifhvccfp) qtti(:,1:nqtti), bas, rmax
      ifi = 6661

C --- Make q-points in IBZ.
c     mxkp   = n1q*n2q*n3q
c     allocate(qibz(3,mxkp),IPQ(mxkp),WGT(mxkp))
c     symmetry group generator
c     print *,' goto bzmesh'
c     call bzmesh(plat,qm,n1q,n2q,n3q,symgr,ngrp,IPQ,qibz,WGT
c     &,nqibz,mxkp)
c     print *,' end of bzmesh'
c     deallocate(IPQ,WGT)

C ... Readin qibz form QIBZ
      ifiqibz = 6662
      open (ifiqibz, file='QIBZ') !write q-points in IBZ.
      read (ifiqibz,*) nqibz
      allocate(qibz(3,nqibz))
      do iqibz = 1,nqibz
        read(ifiqibz,*) qibz(1:3,iqibz)
      enddo
      write(6,"( ' --- Readin QIBZ --- ')")
      write(6,'("  qibz=",i3,3f12.5)')(i,qibz(1:3,i),i=1,nqibz)
      close(ifiqibz)
!!
      write(ifhvccfp) nqibz
      write(ifhvccfp) qibz(1:3,1:nqibz)
      write(6,*)
      write(6,"('  ngrp   = ',i3)")ngrp
      write(6,"('  symops = ',a30)")symgrpo
      write(6,'("  qibz=",i3,3f12.5)')(i,qibz(1:3,i),i=1,nqibz)
!!
      ifnqibz = 888
      open(ifnqibz,file='NQIBZ')
      write(ifnqibz,"(3i10,'  ! nqibz nq0i nqibz+nq0i')") nqibz,nq0i,nqibz+nq0i
      close(ifnqibz)

c      QpGcut_psi2 = (2d0+1d-2)*QpGcut_psi + 2d0*pi/alat*dQpG !dec2012
c      if(QpGcut_psi2<1d-9) QpGcut_psi2=0d0 !may2013

!! === make <Gc-Gp1+Gp2> matrix ===
      iadd=0
c      if(bzcase==2) iadd=1
      if(ix==1) nqibz=0
      dQpG=0d0
      do iq0i =1,nq0i
        abq0i= sum(q0i(1:3,iq0i)**2)**.5
        if(abq0i>dQpG ) dQpG=abq0i
      enddo
      allocate(qibze(3,nqibz + nq0i+iadd)) !,ngc2x(nqibz + nq0i+iadd)) !nq0i+1 is for gamma point for bzcase==2
      do iqi =1,nqibz + nq0i
        if( iqi <=nqibz) then
          qibze(1:3,iqi)  = qibz(1:3,iqi)
        elseif( iqi > nqibz) then
          qibze(1:3,iqi)  = q0i (1:3,iqi-nqibz)
        endif
        write(6,"(' iqi qibze=',i4,3f9.5)")iqi,qibze(:,iqi)
      enddo
c      if(bzcase()==2) qibze(1:3,nqibz+nq0i+iadd)=0d0
      nqnumt= nqibz+nq0i+iadd
      write(6,"(' nqnumt nqibz nq0i iadd =',4i6)")nqnumt,nqibz,nq0i,iadd

!     We assuem qibze(iqi<=nqibz) are not changed.
c     if( qreduce() ) then
c     allocate(qsave(3,nqnumt))
c      call dinv33(qlat,0,ginv,det)
c
c     imx=0
c     do iq= 1,nqnumt
c     call qqsave(qibze(1:3,iq),nqnumt,ginv,qsave,imx)
c     enddo
c     qibze(:,1:imx)=qsave(:,1:imx)
c     nqnumt = imx !nqnumt is changed
c     deallocate(qsave)
c     endif


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      QpGcutggg = (2d0+1d-2)*QpGcut_psi + QpGcut_cou+ 2d0*pi/alat*dQpG 
      if(QpGcutggg<1d-9) QpGcutggg=0d0
c      dQQ = (sum((qlat(:,1)+qlat(:,2)+qlat(:,3))/2d0)**2)**.5
c      dQQ = max( sum((qlat(:,1)/2d0)**2)**.5,
c     &           sum((qlat(:,2)/2d0)**2)**.5,
c     &           sum((qlat(:,3)/2d0)**2)**.5)
      dQQ=0d0
      do iqi =1,nqnumt
      do iqi2=1,nqnumt
        dQQ= max( sum(qibze(1:3,iqi)**2)**.5 + sum(qibze(1:3,iqi2)**2)**.5, dQQ)
      enddo
      enddo
      QpGcutgcgp = (1d0+1d-2)*QpGcut_psi + QpGcut_cou+ 2d0* 2d0*pi/alat*dQQ

      if(QpGcutgcgp<1d-9) QpGcutgcgp=0d0
c      QpGcutgcgp = (1d0+1d-2)*QpGcut_psi + QpGcut_cou+ 2d0*pi/alat*dQpG 
c      if(QpGcutgcgp<1d-9) QpGcutgcgp=0d0
c      allocate(ngcgp(nqnumt), nggg(nqnumt))
c      do iqi =1, nqnumt         !nqibz + nq0i +iadd
      qx = 0d0
      nggg=1 !dummy
      ngcgp=1 !dummy
      call getgv2( alat,plat,qlat,qx, QpGcutggg, 1,nggg,  idummy11) 
      call getgv2( alat,plat,qlat,qx, QpGcutgcgp,1,ngcgp, idummy11) 
      if(debug) write(6,"(' iqi qx nggg ngcgp=',i5,3f8.3,2i8)") iqi,qx,nggg,ngcgp
c      enddo
c      ngggmx  = maxval( nggg(1:nqnumt)  )
c      ngcgpmx = maxval( ngcgp(1:nqnumt) )
      allocate( nvggg(3,nggg) )
      allocate(nvgcgp(3,ngcgp))
!! Here the range of G for nvggg is |Gc+Gp+Gp|< |Gcou|+ |Gphi|+ |Gphi| !triangle inequality.
c      do iqi =1, nqnumt         !nqibz + nq0i +iadd
         qx = 0d0
         call getgv2( alat,plat,qlat,qx, QpGcutggg,  2, nggg,  nvggg  )
         call getgv2( alat,plat,qlat,qx, QpGcutgcgp, 2, ngcgp, nvgcgp )
         write(6,"(' getgv2--> iqi qx nggg ngcgp=',i5,3f9.3,2i7)") iqi,qx,nggg,ngcgp
c      enddo
        allocate(ggg(nggg))
        call mkppovl2(alat,plat,qlat, 
     &        1,  (/0,0,0/),          !dummy 
     &        nggg,  nvggg, 
     &        nbas, rmax, bas,  
     o        ggg)


cccccccccccccccccccccccccccccccccccccccccccccccccccccc
!!
c$$$      do iqi =1, nqnumt         !nqibz + nq0i +iadd
c$$$        qx  = qibze(1:3,iqi)
c$$$ccommented out at apr2013takao
c$$$c        if(iqi>nqibz) then !dec2012
c$$$c          qx=0d0
c$$$c        endif
c$$$        call getgv2( alat,plat,qlat,qx, QpGcut_psi2,1,ngc2x(iqi), idummy11) 
c$$$        write(6,"(' job1 iqi qx ngc2x=',i5,3f8.3,i8)") iqi,qx,ngc2x(iqi)
c$$$      enddo
c$$$      ngc2mx = maxval(ngc2x(1:nqnumt))
c$$$      print *,' ngc2mx nqnumt=',ngc2mx,nqnumt
c$$$      if(ngc2mx>0) then !may2013
c$$$         allocate(ngvecc2(3,ngc2mx,nqnumt)) !nqibz + nq0i+iadd))
c$$$         if(debug)print *,' end of  allocate(ngvecc2(3,ngc2mx,nqnumt))'
c$$$         do iqi =1, nqnumt      !nqibz + nq0i +iadd
c$$$            if(debug)  write(6,"(' job2 iqi qx=',i5,3f8.3)") iqi,qx
c$$$            qx = qibze(1:3,iqi)
c$$$c     commented out at apr2013takao
c$$$c     if(iqi>nqibz) then !dec2012
c$$$c     qx=0d0
c$$$c     endif
c$$$            call getgv2( alat,plat,qlat,qx, QpGcut_psi2, 2, ngc2x(iqi),ngvecc2(1,1,iqi)) ! for Coulomb
c$$$            print *,' minval ngvecc2',
c$$$     &           minval(ngvecc2(1,1:ngc2x(iqi),iqi)),minval(ngvecc2(2,1:ngc2x(iqi),iqi)),minval(ngvecc2(3,1:ngc2x(iqi),iqi))
c$$$            print *,' maxval ngvecc2',
c$$$     &           maxval(ngvecc2(1,1:ngc2x(iqi),iqi)),maxval(ngvecc2(2,1:ngc2x(iqi),iqi)),maxval(ngvecc2(3,1:ngc2x(iqi),iqi))
c$$$         enddo
c$$$      endif

!! ... IPW(interstitial-plane-wave) overlap matrix
      nqini =1
      if(iq0pin==2) nqini=nqibz+1
c      if(debug) print *,' goto PPOVL section'
c      ippovl = 221
c      open(ippovl,file= "PPOVL",form='unformatted')
c      write(ippovl ) ngcmx, ngc2mx, nqnumt-nqini+1 !nqibz + nq0i+iadd
c      do ix= nqini, nqnumt
c        write(6,"(' qibze= ',3f10.4)") qibze(1:3,ix)
c      enddo
      write(6,*)
      do ix=1,nqtti
        write(6,"(' qtti  = ',3f10.4)") qtti(1:3,ix)
      enddo

!! PPOVLGG,PPOVLG oct2012
      if(debug) print *,' --- goto PPOVLG section ---',nggg,ngcgp,nqnumt-nqini+1
      open(ippovlgg,file= "PPOVLGG",form='unformatted')
      write(ippovlgg) nggg, ngcgp, nqnumt-nqini+1,nqini,nqnumt
      write(ippovlgg) nvgcgp(1:3,1:ngcgp)
      write(ippovlgg) nvggg(1:3,1:nggg)
      write(ippovlgg) ggg(1:nggg)
      deallocate(ggg,nvggg,nvgcgp)
      close(ippovlgg)

!! ==  New version. apr2013takao . Not use ngveccf. ==
      rewind ifiqg
      rewind ifiqgc
      read(ifiqg  ) nqnum , ngpmx, QpGcut_psi,nnnn
      read(ifiqgc ) nqnumc, ngcmx, QpGcut_Cou
      print *
      print *,' --- Write PPOVLG ----'
      do 2010 iqi = nqini, nqnumt    !nqibz + nq0i + iadd

        ippovlg = 1221+iqi
        inquire(unit=ippovlg, opened=noo)
        if(noo) call rx('rdata4gw_v2: ippovlg poor assignment of file id. Fix it')
        open( ippovlg,file= "PPOVLG."//charnum3(iqi),form='unformatted')
        ippovli = 3221+iqi
        inquire(unit=ippovli, opened=noo)
        if(noo) call rx('rdata4gw_v2: ippovli poor assignment of file id. Fix it')
        open( ippovli,file= "PPOVLI."//charnum3(iqi),form='unformatted')

        qx  = qibze(1:3,iqi)
        if(debug) write(*,"('init do 2010 qx=',3f13.5)")qx
!!      iq is removed at apr2013takao   --> iq=idxk(qibze(1:3,iqi), qtti,nqtti) !feb2012takao
        iread=0
!!      do loop to readin ngc,ngp,ngvecp,ngvecc for give qx. apr2013takao
        do           !irr is the flag to judge to check irreducible point or not.
          read (ifiqg, err=1013,end=1013) qqqa, ngp !, irr
          if(debug) write(*,"('qqqa=',3f13.5)")qqqa
          read (ifiqgc         ) qqqb, ngc
c          print *,'iqi,qqqa,ngp=',iqi,qqqa,ngp
          allocate( ngvecp(3,ngp),ngvecc(3,ngc) )
          read (ifiqg ) ngvecp
          read (ifiqgc) ngvecc
          if(sum(abs(qx-qqqa))<1d-8) exit
          deallocate(ngvecp,ngvecc)
          cycle
 1013     continue
          if(iread==1) call rx('rdata4gw_v2:readin error on QGpsi QGcou 22222')
          iread=1
          rewind ifiqg
          rewind ifiqgc
          read(ifiqg  ) nqnum , ngpmx, QpGcut_psi,nnnn
          read(ifiqgc ) nqnumc, ngcmx, QpGcut_Cou
        enddo
        if(sum(abs(qx-qqqa))>1d-10) call rx( 'rdata4gw_v2:qx/=qqq wrong QpGphi?')
        if(sum(abs(qx-qqqb))>1d-10) call rx( 'rdata4gw_v2:qx/=qqq wrong QpGcou?')
c        ngcx (ikp) = ngc
c        ngveccf (1:3,1:ngc, ikp) = ngvecc
c        ngpx (ikp) = ngp
c        ngvecpf (1:3,1:ngp, ikp) = ngvecp

c apr2013takao nov 2012 these if below are not necessary.
c        if( iqi <=nqibz.or.ngczero) then !jun2005 ngczero
c        iq = idxk (qibze(1:3,iqi), qtti,nqtti) !feb2012takao
c        elseif( iqi > nqibz) then !     iq0=0 !iq0 is added on 8/18/2005
c          iq = idxk ((/0d0,0d0,0d0/), qtti,nqtti)! We use the G-vector(for Coul) at q=0 for q0i vector.
c        endif

!!
c        ngc2 = ngc2x(iqi)
c        write(ippovl) qx, ngc,ngc2 
c        write(6,"('   iqi qx ngc ngc2=',i5,3f7.4,4i5)" ) iqi,qx,ngc,ngc2

c        if(ippovlc_test)  write(ippovlc) qx,ngc
        write(ippovli) qx,ngc
        write(ippovlg) qx,ngc
        write(6,"(' iqi qx ngc=',i5,3f7.4,4i5)" ) iqi,qx,ngc
        if(ppovl0l) write(ippovl0)   qx,ngc
        if(ngc==0) then
          deallocate(ngvecc,ngvecp)
          cycle
        endif  
        allocate(ppovl(ngc,ngc),ppovlinv(ngc,ngc)) !This is necessary for matcinv

!     oct2005
c     if(smbasis()) then
c     call mkppmt(alat,plat,qlat, qx,
c     &    ngc, ngveccf(1,1,iq),
c     &    rmax, nbas,  bas, lmxaa, lmxax,
c     o    ppmt) ! ppmt contains derivatives of PW at MT boundaries.
c     ! ppmt(lmxaa,nbas),ppdmt(lmxaa,nbas)
c     write(ippmt) ppmt
c     endif
c------------------
c        if(version()==-1) then
c          call mkppovl(alat,plat,qlat, qx, 
c     &           ngc, ngvecc,
c     &           ngc, ngvecc, 
c     &           rmax, nbas,  bas, lmxaa, lmxax,
c     o           ppovl)
c        else
          call mkppovl2(alat,plat,qlat, 
     &        ngc,  ngvecc, 
     &        ngc,  ngvecc, 
     &        nbas, rmax, bas,  
     o        ppovl)
c        endif
        if(debug) print *,' ttt: end of mkppovl2 ...'
c        if(ippovlc_test)  write(ippovlc) ppovl(1:ngc,1:ngc)
        if(ppovl0l)  write(ippovl0) ppovl(1:ngc,1:ngc)
!     replace cinvrx(no pvot version) with matcinv !oct2005
!     call cinvrx(ppovl,ppovlinv,ngc,1,1)   ! inverse of ppovl
!     Note the size of ppovlinv and ppovl are the same
        ppovlinv = ppovl
        if(debug) print *,' ttt222 ...'
        call matcinv(ngc,ppovlinv)
        if(debug) print *,' ttt3 ...'
c        if(ippovlc_test) write(ippovlc) ppovlinv(1:ngc,1:ngc)
        deallocate(ppovl)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!! ggg= < exp(i G r) > integral in the interstitial region.
c        write(6,"(' iqi qx nggg ngcgp ngc=',i5,3f8.4,4i7)" ) iqi,qx,nggg,ngcgp,ngc
        if(ngc/=0) write(ippovlg) ngvecc(1:3,1:ngc)
        if(ngc/=0) write(ippovli) ppovlinv(1:ngc,1:ngc) 
        if(debug) print *,' ttt4 ...'
c        allocate(ppovl(ngc,ngc2),ppx(ngc,ngc2))
c        if(debug) print *,' ttt5 ...'
c        call mkppovl2(alat,plat,qlat, 
c     &        ngc,  ngvecc, 
c     &        ngc2, ngvecc2(1,1,iqi), 
c     &        nbas, rmax, bas,  
c     o        ppovl)
c        call matm(ppovlinv,ppovl,ppx,ngc,ngc,ngc2) !may2013. this  chanes definition of zmelt
c        if(debug)print *,' writing ppovl(ngc ngc2) ...'
c        write(ippovl) ngvecc2(1:3,1:ngc2,iqi),ppx !iqi added at 18Aug2005
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c        deallocate(ppovl,ppx,ppovlinv)
        deallocate(ppovlinv,ngvecc,ngvecp)
c        print *,'end do 2010'
      close(ippovlg)
      close(ippovli)
 2010 continue
c      close(ippovl)
      if(ppovl0l) close(ippovl0)
c      if(ippovlc_test)  close(ippovlc)
c      print *,'vvvvvvv1 nbas=',nbas
c     if(smbasis()) deallocate(ppmt)


!! ===  Write LMTO file ===
      print *
      write(6,*) " --- Write LMTO file(crystal structure and so on) ---"
      ifigwin=888
      open (ifigwin,file='LMTO')
!     > SYMMETRY
      write(ifigwin,*)"SYMMETRY---------------------------------------"
      write(ifigwin,*)"symmetry group (symgrp)"
      write(ifigwin,"(a30)") symgrpo
      write(ifigwin,*)
c     > STRUCTURE
      write(ifigwin,*)"STRUCTURE---------------------------------------"
      write(ifigwin,*)"lattice constant in a.u. (alat)"
      write(ifigwin,*) alat
      write(ifigwin,*)"primitive lattice vectors (plat)"
      write(ifigwin,"(3d24.16)") plat(1,1),plat(2,1),plat(3,1)
      write(ifigwin,"(3d24.16)") plat(1,2),plat(2,2),plat(3,2)
      write(ifigwin,"(3d24.16)") plat(1,3),plat(2,3),plat(3,3)
c     write(ifigwin,"(a)") " number of classes (nclass)
c     &  WARN! We assume nclass=natom! the CLASS file contains
c     & the numbers to identify the equivalent atoms
c     & (true class information)."
c     nclass = nbas
c     write(ifigwin,*) nclass
      write(ifigwin,*)"number of atoms (natom)"
      write(ifigwin,*) nbas
      write(ifigwin,*)"positions of atoms (pos(3,natom))"
      do ibas =1,nbas
        write(ifigwin,"(3d24.16)") bas(1,ibas), bas(2,ibas), bas(3,ibas)
      enddo
      write(ifigwin,*)
c     LMTO
      write(ifigwin,*)"LMTO ------------------------------"
      write(ifigwin,*)"spin (1=paramagnetic  2=ferromagnetic)"
      write(ifigwin,*) nsp
      write(ifigwin,*)"maximum number of valence and core l (l+1)"
      write(ifigwin,*) lmxax+1
      write(ifigwin,"(a)") 
     &     " Maximum number radial functions"//
     &     " per l-channel (nnv nnc)"
      write(ifigwin,*) nnv, nnc
      write(ifigwin,*)" max. number of radial mesh (nrx)"
      write(ifigwin,*) nrmx
      write(ifigwin,*)"atom          z                   nr "
!     ibas = ic
      do ibas =1,nbas
        write(ifigwin,*) "'"//clablx(ibas)//"'"
     &        ,zz(iclass(ibas)),nr(iclass(ibas))
      enddo
      write(ifigwin,*)
c     BZ
      write(ifigwin,*)"BZ----------------------------------------------"
      write(ifigwin,*)"divisions along G1 G2 G3 (n1 n2 n3)"
      write(ifigwin,"(4i5)") n1q,n2q,n3q
      write(ifigwin,*)"AFcond-------------------------"
      write(ifigwin,"(200i6)")iantiferro(1:nbas)
      close(ifigwin)

!! check for anf mode
c      call anfcond()

      print *, " OK! end of rdata4gw_v2 "
      call rx0( ' OK! rdata4gw_v2')
      end


!! #######################################################################3
      subroutine xychange(x,y,n)
      real(8):: x(n),y(n),z(n)
      z=x
      x=y
      y=z
      end
      subroutine xychangei(x,y,n)
      integer(4):: x(n),y(n),z(n)
      z=x
      x=y
      y=z
      end
      subroutine rrefine(rofio,nro,rofin,nrn,
     i          go,
     o          gn )
      implicit none
      integer(4):: nro,nrn,ir
      real(8):: polinta,rofio(*),rofin(*),go(*),gn(*) ! MIZUHO-IR
      do ir=1, nrn
        gn(ir) = polinta(rofin(ir), rofio,go,nro)
      enddo
      end
!! ########################
      subroutine getab( nr_n, nr,
C- determie a and b, for give ab nr rmax
     i       a ,b)
c Solve rmax/(ab) = (exp( a(nr-1)) - 1))/a
c a b are input and output
      implicit none
      integer(4):: nr_n,nr,i
      real(8):: delta,ab,a,b,rmax,eps,ao,aini,diff
      delta = 0.1
      ab=a*b
      rmax = b *(exp(a*(nr-1))-1d0)
c      write(6,"(' ab nr rmax=',d13.6,i5,d13.6)")ab,nr,rmax
      write(6,"('  getab: input   nr a b =',i5,3d13.6)") nr,a,b,rmax
      eps= a
      ao=0d0
      do
        eps= eps/10d0
        aini = ao
        i=0
        do
          i=i+1
          a = aini + eps*i
          diff = (nr_n-1)*exp(a*(nr_n-1)) - rmax/ab
c          write(6,"(' ddd =',d13.6)") diff
          if(diff>0) exit
          ao=a
        enddo
        if(eps<1d-14) exit
      enddo
      b = rmax/(exp(a*(nr_n-1))-1d0)
c      write(6,"('getab: new a b nr=',2d13.6,i5,d13.6)") a,b,nr_n
      if(abs((rmax-b*(exp(a*(nr_n-1))-1d0)))>1d-13) then
        write(6,"('getab: new nr_n rmax=',2d13.6,i5,2d13.6)")nr_n
     &   ,rmax,b*(exp(a*(nr_n-1))-1d0)
Cstop2rx 2013.08.09 kino        stop ' getab: rmax is reproduced'
        call rx( ' getab: rmax is reproduced')
      endif
      rmax = b *(exp(a*(nr_n-1))-1d0)
      write(6,"('  getab: output  nr a b =',i5,3d13.6)") nr_n,a,b,rmax
c      stop 'test end'
      end














