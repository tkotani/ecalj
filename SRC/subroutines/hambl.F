      subroutine hambl ( mode , nbas , ssite , sspec !, slat !, sham 
     .   , isp , qin , k1 , k2 , k3 , smpot , vconst , sv_p_osig , sv_p_otau 
     .   , sv_p_oppi , lcplxp , alfa , ndimh , napw , igvapwin , h , s , 
     .     hso )
      use m_suham,only: iv_a_oindxo
      use m_struc_def,only: s_rv1, s_site, s_spec!,  s_lat !s_ham,
      use m_lmfinit,only:lat_qlat


      use m_lattic,only:lat_plat
      implicit none
C- Make the LDA hamiltonian and overlap for one k-point.
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :1s digit specifies LDA matrix elements
Ci         :  0 compute LDA hamiltonian and overlap
Ci         :  1 compute the overlap only
Ci         :10s digit
Ci         :  0 do not compute hso
Ci         :  1 compute hs0
Ci         :    Note: only a portion of hso is computed for a
Ci         :    particular isp.  The total hso is assembled
Ci         :    after isp loops from 1..2.  hso should not be
Ci         :    initialized between isp=1 and isp=2 loops.
Ci   nbas  :size of basis
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: plat
Ci     Stored:    *
Ci     Passed to: augmbl smhsbl hsibl
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: oindxo
Ci     Stored:    *
Ci     Passed to: *
Ci   isp   :spin index
Ci   q     :Bloch vector (k-point)
Ci   k1,k2,k3 dimensions of smpot
Ci   smpot :smooth potential on uniform mesh (mkpot.f)
Ci   vconst:additional constant potential
Ci   osig,otau,oppi  augmentation matrices
Ci   alfa  :add alfa * overlap to hamiltonian
Ci         :This is for stability in evals.  Preferably alfa=0
Ci   ndimh :dimension of hamiltonian and ovrlap h,s
Co Outputs
Co   h     :Hamiltonian matrix
Co   s     :overlap matrix
Co   hso   :spin off-diagonal block of spin-orbit hamiltonian
Cr Remarks
Cu Updates
Cu   04 Jul 08 (T. Kotani) New PW addition to basis
Cu   03 Feb 05 (A. Chantis) calculate hso
Cu    1 Sep 04 Adapted to handle complex ppi; S.O. put into ppi
Cu   25 Aug 04 modifications for extended local orbitals
Cu   15 Jul 04 (Chantis) Add Lz.Sz spin-orbit coupling
Cu   10 Jan 03 Remove addition from hambl.  See hambls.f
Cu   10 Jan 03 put sigma back into Bloch transform only
Cu   14 Aug 02 Added overlap-only option and option for orthog sigm
Cu   20 Jul 02 Can add Bloch transform of sigma matrix to ham
Cu   18 May 00 Adapted from nfp mk_hamiltonian.f
C ----------------------------------------------------------------------
      integer mode,nbas,isp,k1,k2,k3,ndimh,lcplxp,napw,igvapwin(3,napw),igvapw(3,napw)
      type(s_rv1) :: sv_p_oppi(3,nbas)
      type(s_rv1) :: sv_p_otau(3,nbas)
      type(s_rv1) :: sv_p_osig(3,nbas)
      double precision alfa
      real(8):: q(3) , vconst
      type(s_site)::ssite(*)
      type(s_spec)::sspec(*)
c      type(s_ham)::sham
c      type(s_lat)::slat
      double complex smpot(k1,k2,k3),h(ndimh,ndimh),s(ndimh,ndimh)
      double complex hso(ndimh,ndimh)
      integer mode0,mode1,ipr,inn(3),ig
      double precision vavg
      real(8):: qin(3),plat(3,3),qlat(3,3),qlatinv(3,3)
!! ---------------------------------------------------
      call tcn('hambl')
      mode0 = mod(mode,10)
      mode1 = mod(mode/10,10)
      plat = lat_plat
      qlat = lat_qlat
!! Originally Given q should be shorted becasue (takao think)
!! hamble ->smhsbl-->hhibl-->hklbl ---> hsmq requires
!! lat_rv_a_o_dlv and lat_rv_a_o_qlv, generated by lattic.F (call lattc)  where we assume q is shortened. I think.
!! But we need extensive test to improve this part...
!! Easier way to manage any q with shorbz.

!! input and output
!!   qpg(ig) = tpiba * ( qin + matmul(qlat,igapwin(1:3,ig))) for h,o,hso
!! internal
!!   qpg(ig) = tpiba * ( q  + matmul(qlat,igapw(1:3,ig)))
!!  NOTE: both qpg are the same for given ig.

!! qlat*igapw = qlat*igqwin + (qin-q) ---> igvapw = igvapwin + matmul(qlatinv,qin-q)
      qlatinv = transpose(plat)
      call shorbz(qin,q,qlat,plat)
      call rtoint(matmul(qlatinv,qin-q),inn,3)
      do ig=1,napw
        igvapw(:,ig) = inn + igvapwin(:,ig)
      enddo  


C ... Initialization of quantities to be computed
      if (mode0 .eq. 0) call dpzero(h,ndimh*ndimh*2)
      if (mode0 .le. 1) call dpzero(s,ndimh*ndimh*2)
      if (mode1 .eq. 1 .and. isp .eq. 1) call dpzero(hso,ndimh*ndimh*2)
C ... Skip LDA H, S
      if (mode0 .gt. 1) goto 100

C --- Augmentation part of hamiltonian and overlap ---
      call augmbl ( mode0 + 10 * mode1 , ssite , sspec , isp !slat , 
     .    , lcplxp , q , sv_p_osig , sv_p_otau , sv_p_oppi , iv_a_oindxo 
     .    , ndimh , napw , igvapw , h , hso , s )


C --- Add alfa S+ S ---
      if (dabs(alfa) .gt. 1d-10 .and. mode0 .eq. 0)  then
        call z2herm('U',ndimh,ndimh,s)
        call zgemm('C','N',ndimh,ndimh,ndimh,dcmplx(alfa,0d0),
     .  s,ndimh,s,ndimh,dcmplx(1d0,0d0),h,ndimh)
      endif

C ... Optionally set average istl potential to zero
      vavg = 0
      call smhsbl ( mode0 , ssite , sspec ,  vavg + vconst , !slat ,
     . q , ndimh , iv_a_oindxo , napw , igvapw , h , s )
      if (mode0 .eq. 1) goto 100
      call hsibl ( ssite , sspec ,  k1 , k2 , k3 , smpot , isp !slat ,
     . , q , ndimh , iv_a_oindxo , napw , igvapw , h )

C --- Alternatively, smoothed H and S done completely numerically ---
C      call upack1('lat nabc',slat,ngabc)
C      call hsmi_q(ssite,sspec,slat,n1,n2,n3,k1,k2,k3,smpot,
C     .  vconst,q,ndimh,h,s)

C ... End of assembling LDA H, S
  100 continue

C     if (mode0 .eq. 1) goto 200
C --- Bloch transform sigma matrix and add to h ---
C      call upack('ham ndhrs ontabs oiaxs ohrs',sham,
C     .  ndhrs,ontabs,oiaxs,ohrs,0)
C      lrsig = mod(mode/10,10)
Ckino isanrg is logical function, C      call isanrg(lrsig,0,2,'hambl:','10s digit mode',.true.)
C      l_dummy_isanrg=isanrg(lrsig,0,2,'hambl:','10s digit mode',.true.)
C      if (lrsig .ne. 0 .and. ohrs .ne. 0) then
C        hreal = 2-mod(lrsig,4)
C        nl = nglob('nl')
C        mxorb = nglob('mxorb')
C        nttabs = ival(w(ontabs),nbas+1)
C        nsp  = nglob('nsp')
Ckino isanrg is logical function, C        call isanrg(isp,1,nsp,'hambl:','isp',.true.)
C        l_dummy_isanrg=isanrg(isp,1,nsp,'hambl:','isp',.true.)
C        call upack('lat plat',slat,plat,0,0,0,0)
C
C        call defcc(oh,ndimh**2)
C        call dcopy(2*ndimh**2,h,1,w(oh),1)
C        call zprm('h',2,h,ndimh,ndimh,ndimh)
C
CC       Call bloch : 104010=perm orb, transpose, c*16
C        i = 100000 + 4000 + 40*(1-hreal) + 10
C        call bloch(i,q,nl,plat,mxorb,w(oiprmb),1,nttabs,w(oiaxs),
C     .    w(ohrs),ndhrs,isp,nsp,ndimh,ndimh,0,ndimh,0,ndimh,0,h,w,w)
C        call zprm('sigm-orth',2,h,ndimh,ndimh,ndimh)
C
CC       try to work with orthogonalized basis.
CC       Rotation to orthogonalized basis doesn't work well.
CC        call defcc(os,ndimh**2)
CC        call dcopy(2*ndimh**2,s,1,w(os),1)
CCC       call zhev2(5,ndimh,ndimh,ndimh,.true.,h,w(os))
CCC       call zprm('L sigm-orth L+',2,h,ndimh,ndimh,ndimh)
CC        call defcc(oz,ndimh**2)
CC        call zhev3(5,ndimh,h,w(os),w(oz))
CC        call rlse(os)
CC
CC        call daxpy(2*ndimh**2,1d0,w(oh),1,h,1)
CCC       call zprm('h(lda)+sig',2,h,ndimh,ndimh,ndimh)
C
C      endif

C --- Fill second half of matrix ---
C 200 continue
      if (mode0 .eq. 0) call z2herm('U',ndimh,ndimh,h)
      if (mode0 .le. 1) call z2herm('U',ndimh,ndimh,s)

C     Test routine that doctors hamiltonian
C     call pvhmb2(ndimh,h,s)

      call getpr(ipr)
      if (ipr .ge. 90) then
        call info(0,0,0,' h and s for q=%3:1;6,6d',q,0)
        if (mode0 .eq. 0) call zprm('h',12,h,ndimh,ndimh,ndimh)
        if (mode0 .le. 1) call zprm('s',12,s,ndimh,ndimh,ndimh)
        if (mode1 .eq. 1) call zprm('hso',2,hso,ndimh,ndimh,ndimh)
      endif
      call tcx('hambl')
      end subroutine hambl


      subroutine pvhmb1(mode,k1,k2,k3,smpot,vavg) !slat,
      use m_lmfinit,only:lat_nabc


      use m_struc_def  !Cgetarg
C- Add subtract a constant from smooth potential
C ----------------------------------------------------------------------
Ci Inputs
Ci    mode :0 do not adjust smpot; just return avg smpot
Ci         :1 add vavg to smpot
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: nabc
Ci   k1,k2,k3 dimensions of smpot
Cio Inputs/Outputs
Cio  smpot :(input for mode=0, altered for mode=1)
Cio        :smooth potential on uniform mesh (mkpot.f)
Cio  vavg  :(output for mode=0, input for mode=1) average potential
Cr Remarks
Cr
Cu Updates
Cu   16 Aug 04 First created
C ----------------------------------------------------------------------
      implicit none
      integer mode,k1,k2,k3
c      type(s_lat)::slat
      double complex smpot(k1,k2,k3)
C ... Local parameters
      double precision vavg
      double complex xx
      integer ngabc(3),i
      if (mode .eq. 0) then
        ngabc=lat_nabc
        call mshint(1d0,1,ngabc(1),ngabc(2),ngabc(3), k1,k2,k3,smpot,vavg,xx)
      elseif (mode .eq. 1) then
        do i = 1, k1*k2*k3
          smpot(i,1,1) = smpot(i,1,1) + vavg
        enddo
      else
        call rx('pvhmb1: bad mode')
      endif
      end subroutine pvhmb1


C      subroutine pvhmb2(ndimh,h,s)
CC- test routine to doctor hamiltonian
C      implicit none
C      integer ndimh
C      double complex h(ndimh,ndimh),s(ndimh,ndimh)
C
C      integer low,high,i1,i2,k1,k2
C      return
C
CC ... Zeros out off-diagonal blocks between low+1, high
CC      low = 20
CC      high = 23
CC      print *, 'hambl zero out off-diagonal blocks', low+1,high
CC      do  i1 = 1, ndimh
CC        k1 = -1
CC        if (i1 .gt. low) k1 = 0
CC        if (i1 .gt. high) k1 = 1
CC        do  i2 = 1, ndimh
CC          k2 = -1
CC          if (i2 .gt. low) k2 = 0
CC          if (i2 .gt. high) k2 = 1
CC
CC          if (k1 .eq. 0  .neqv.  k2 .eq. 0) then
CC            h(i1,i2) = 0
CC            s(i1,i2) = 0
CC          endif
CC        enddo
CC      enddo
C
C      end

