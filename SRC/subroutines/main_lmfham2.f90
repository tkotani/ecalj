!> PMT --> lmfham1 --> MPO --> lmfham2 --> MLO
module m_lmfham2
  public lmfham2
  private
contains
  subroutine lmfham2() ! Get the Hamiltonian on the MTO-based-Localized orbitals |MLO> from MPO
    ! that of the MTO-projected basis |MPO>. Conversion from MPO(hmmr1,ommr1,nband) to MLO(hmmr2,ommr2,nMLO).
    ! In advance, run lmfham1 to get |MPO> (MPOare given by a projection from MTOs to PMT space.
    ! That is, |MPO_i> = M |PMT_i>, where M is a mapping from MPO to the space of PMT.
    !
    ! We use a modified procedure of this method of  [2]I.Souza, N.Marzari and D.Vanderbilt, PRB65,035109(2002)
    !
    ! Main part of lmfham2 is Step1loop.
    ! Among the space spanned by |MTonly>, we extract minimum basis space.
    ! For example, we have 25+25 MTOonlys for Si;then we extract 9+9 space spanned by |MLO>.
    !
    ! We use diffent idea of connectivity from [2]. Roughly speaking, we define connectivitiy of eigenfunctions between k and k+b,
    ! not by the overlap of periodic part of eigenfunctions, but by the coefficients on |MLO>.
    !
    use m_setqibz_lmfham,only: set_qibz,qibz,irotq,irotg,ndiff,iqbzrep,qbzii,igiqibz,nqibz,iqii,wiqibz
    use m_ftox
    use m_lgunit,only: stdo,m_lgunit_init
    use m_zhev,only:zhev_tk4
    use m_MPItk,only:    m_MPItk_init, nsize, master_mpi !  use m_ext,only:      m_ext_init,sname
    use m_keyvalue,only: getkeyvalue
    use m_lmfinit,only:  m_lmfinit_init,oveps
    use m_ext,only: m_ext_init
    use m_cmdpath,only: Setcmdpath
    use m_readqplist,only: eferm,qplistsy,ndat,xdat, Readqplistsy !qplist.dat is generated by job_band
    use m_HamPMT,only: ReadHamPMTInfo, nspin=>nsp, natom=>nbas,plat,alat,npair,nlat,nqwgt, ldim, nqbz=>nkp,qbz=>qplist,&
         n1=>nkk1,n2=>nkk2,n3=>nkk3,pos,npairmx,nspx,ngrp,symops !,ib_table,l_table,k_table
    use m_read_Worb,only:s_read_Worb,nclass_mlwf,cbas_mlwf,norb=>nbasclass_mlwf,classname_mlwf !,iclassin !,iphi,iphidot,nphi,nphix
    use m_HamRsMPO,only: ReadHamRsMPO,hmmr1=>hammr,ommr1=>ovlmr,nband=>ndimMTO,ib_tableM,l_tableM,k_tableM !Real-space Hamiltonian on the basis |MPO>.
    use m_qplist,only:   m_qplist_init!, m_qplist_qspdivider, nkp
    use m_lattic,only:   m_lattic_init,  qlat=>lat_qlat
    use m_mksym,only:    m_mksym_init,iclasst
    use m_mkqp,only:     m_mkqp_init
    use m_rotwave,only:  rotmatMTO!,rotmatPMT
    use m_prgnam,only: set_prgnam
    use m_nvfortran,only:findloc
    
    implicit none
    integer:: i,iq,is,ix,j,ifbb,ifoc,nbb,isc,ifq0p, nox,iki,ikf,nsc1,ndz,nin,nout,nsc2,ibb
    integer:: inii,if102,iwf2,ib,itmp,itmp2,nqbz2,nspin2,ib1,ib2,iqb,iqbz,it,jsp,nmx,nev,isyml!,nqbz!,n1,n2,n3
    integer:: nMLO,ikx,ikxx,iadd,i1q,i2q,i1,i2,imp,inp,inx,imx,ibas,ibold,ibx,iorb
    integer,parameter:: nlinex=100
    integer::nline,np(nlinex), iwf,ldim2,ixx,npin,ifuumat,job=-1
    real(8),parameter:: pi = 4d0*datan(1d0)
    real(8) :: tpia,vol,voltot,rs,alpha, rydberg,hartree,tripl,wbbsum,bb(3,12),eimax ,wbbs,WTbandqsum,WTinnerqsum,&
         evalssold,qi(3,nlinex),qf(3,nlinex), omgi,omgiold,conv1,alpha1,zesumold,zesi,emm,eLinner,eUinner,eLinnereV,eUinnereV,&
         emin,evalss,sss,qiin(3),qfin(3),qold(3),enwfmax,qxx(3),eeee,enwfmaxi,ginv(3,3),WTinner,ecenter,eLhard,eLhardeV,&
         eee,etest,egap,WTband,eUhardeV
    character(8) :: xt
    real(8),allocatable    :: q(:,:)
    real(8),allocatable:: ku(:,:),kbu(:,:,:),eunk(:,:),eval(:), eks(:),wbb(:)
    integer,allocatable:: ikbidx(:,:),lindex(:)
    real(8),allocatable:: omgik(:),zesum(:),evals(:),WTbandq(:),WTinnerq(:)
    real(8),allocatable:: xq(:),eval1(:,:),eval2(:,:),eval3(:,:),eval_w(:,:,:),evli(:,:)
    integer,allocatable:: m_indx(:),n_indx(:),l_indx(:),ibas_indx(:),ibasiwf(:),idmto(:),idmto_(:)
    real(8),allocatable:: evl(:,:),ovl(:), bbv(:,:),wbz(:),proj(:),projs(:),projss(:)
    complex(8),allocatable:: upu(:,:,:,:), zmn(:,:),zmn0(:,:),WTbandii(:),WTinnerii(:),zmns(:,:),ezmns(:,:)
    complex(8),parameter:: img=(0d0,1d0)
    complex(8),allocatable::ovlm(:,:),ovlmx(:,:),hamm(:,:),ovec(:,:)!,emat(:,:)
    complex(8),allocatable:: uumat(:,:,:,:),evecc(:,:), amnk(:,:,:),cnki(:,:,:),cnkia(:,:,:),umnk(:,:,:),cnkb(:,:,:),&
         evecc1(:,:,:),evecc2(:,:,:),eveci(:,:,:)
    complex(8),allocatable:: hmmr2(:,:,:,:),ommr2(:,:,:,:),wmat(:,:),wmat2(:,:),cnk0i(:,:,:)
    character(256):: fband2,fband1
    logical:: cmdopt2,noinner,eLinnerauto,ELhardauto,eUinnerauto,convn,eUouterauto,skipdfinner,EUautosp,debug=.false.
    real(8):: WTseed,eoffset, projcut,ewid,ewideV,eUinnercut,eouter,CUouter,WTouter,EUouter,CLhard,eUoutereV,CUinner,&
         eLhardeVoffset,eUBinner
    character:: outs*20
    character(256):: aaa='',bbb=''
    integer:: nband_,nqbz_,iki_,ikf_,nMLO_,ilowest,ieLhard,iUinneradd,igrp,ndimmto
    real(8)::qx(3),qtarget(3),eps=1d-8,qp(3)
    integer:: ig,iqibz,icount,ierr
    call setcmdpath()            ! Set self-command path (this is for call system at m_lmfinit)
    call m_ext_init()            ! Get sname, e.g. trim(sname)=si of ctrl.si
    !  call mpi_init(ierr)
    call set_prgnam('lmfham2')
    call m_MPItk_init() ! mpi initialization
    call m_lgunit_init() !set stdo,stdl
    call m_lmfinit_init('LMF')! Read ctrlp into module m_lmfinit.
    call m_lattic_init()      ! lattice setup (for ewald sum)
    call m_mksym_init('LMF')  !symmetry go into m_lattic and m_mksym
    call m_mkqp_init() ! data of BZ go into m_mkqp
    call m_qplist_init(plbnd=0,llmfgw=.false.) ! Get q point list at which we do band calculationsb
    !  call m_qplist_qspdivider()  !generate iqini:iqend,isini,isend  for each rank
    if(cmdopt2('--job=',outs)) read(outs,*) job
    write(stdo,ftox)'=== Start lmfham2 --job=',job
    if(job/=0.and.job/=1) call rx0(' Set --job=0 or 1') !error exit
    call mpibc1_int(job,1,'lmfham2_job') !Set job of --job=job in arguments of lmf-MPIK.
    call ReadHamPMTInfo()! Read infomation for Hamiltonian (lattice structures and index of basis).
    call ReadHamRsMPO()  ! Read Real-space |MTo>-basis Hamiltonian and overlap.
    call pshpr(30)
    call readqplistsy()
    hartree=2d0*rydberg()
    tpia = 2d0*pi/alat
    ginv = transpose(plat)
    ReadInfoFromGWinput: block ! Input orbital index for MLO, stored into idmto (s,p,d=1,2,3,4,5,6,7,8,9)
      call s_read_Worb() !read setting from GWinput
      nMLO=sum(norb(1:nclass_mlwf)) !number of MLO
      allocate(idmto(nMLO),lindex(nMLO))
      ibx=0
      ibold=-999
      iorb=0
      SETidmto:do i = 1,nband !for example, allocate(idmto,source=[(i,i=1,9),(i+25,i=1,9)]) for Si
         if(ibold/=ib_tableM(i)) ibx=0
         ibas=ib_tableM(i)
         ibx=ibx+1
         if(findloc([(ibx==cbas_mlwf(ix,ibas),ix=1,norb(ibas))],dim=1,value=.true.)/=0) then
            iorb=iorb+1
            idmto(iorb)=i
            lindex(iorb)=l_tableM(i)
         endif        !write(stdo,"('MHAM: i ib(atom) l m k(EH,EH2,PZ)=',5i3)") i,ib_table(i),ibx
         ibold=ib_tableM(i)
      enddo SETidmto
      write(stdo,ftox)' idmto=',idmto
      call getkeyvalue("GWinput","mlo_maxit",nsc1,default=20)
      call getkeyvalue("GWinput","mlo_conv",conv1,default=1d-4)
      call getkeyvalue("GWinput","mlo_mix",alpha1,default=.5d0)
      call getkeyvalue("GWinput","mlo_EUinner", eUinnereV,default= 1d8) ! inner energy windowU eV relative to VBM
      call getkeyvalue("GWinput","mlo_CUouter", CUouter,default=0d0) !0.1d0)
      call getkeyvalue("GWinput","mlo_CUinner", CUinner,default=0.9d0)
      call getkeyvalue("GWinput","mlo_WTinner", WTinner,default=2048d0) ! inner energy window WeighTing
      call getkeyvalue("GWinput","mlo_WTband" , WTband,default=0d0) !512d0) !1024d0)    ! Weight to minimize band energies. 64 or less for Cu.
      call getkeyvalue("GWinput",'mlo_WTseed' , WTseed,default=128d0) !0d0)    ! Weight for seed.
      call getkeyvalue("GWinput","mlo_ELinner", eLinnereV,default=-1d8) ! inner energy windowL eV relative to VBM
      call getkeyvalue("GWinput","mlo_ewid",    ewideV, default=1d0)    ! inner energy window softing eV
      call getkeyvalue("GWinput","mlo_WTouter", WTouter,default=2048d0*16d0) ! inner energy window WeighTing
      call getkeyvalue("GWinput","mlo_CLhard",CLhard,default=0.33d0)
      call getkeyvalue("GWinput","mlo_ELhard",ELhardeV,default=-1d8)
      call getkeyvalue("GWinput","mlo_EUinnerAUTOsp",EUautosp,default=.false.) !only test
      ELhardauto=.true.
      if(ELhardeV>-1d7) ELhardauto=.false.
      if(master_mpi) then
         write(stdo,ftox)' Reading: mlo_maxit=',nsc1
         write(stdo,ftox)'        : mlo_conv =',ftod(conv1)
         write(stdo,ftox)'        : mlo_mix  =',ftof(alpha1,2)
         write(stdo,ftox)'        : mlo_WTseed   =',ftof(WTseed,2)
         write(stdo,ftox)'        : mlo_WTband   =',ftof(WTband,2)
         write(stdo,ftox)'        : mlo_WTinner  =',ftof(WTinner,2)
         if(eUinnereV>1d5) then
            write(stdo,ftox)'     :  mlo_CUinner =',ftof(CUinner,2)
         endif
         write(stdo,ftox)'        :  mlo_EUinner(eV)=',ftod(eUinnereV,2)
         write(stdo,ftox)'        :  mlo_ELinner(eV)=',ftod(eLinnereV,2)
         write(stdo,ftox)'        :  mlo_ewid(eV)=',ftof(ewideV,2)
         write(stdo,ftox)'        : mlo_WTouter  =',ftof(WTouter,2)
         write(stdo,ftox)'        :  mlo_CUouter =',ftof(CUouter,2)
         if(.not.ELhardauto) write(stdo,ftox)'        : mlo_ELhard(eV)=',ftof(ELhardeV,2)
         if(ELhardauto)      write(stdo,ftox)'        : mlo_ELhard(eV) = by mlo_CLhard'
         if(ELhardauto)      write(stdo,ftox)'        :  mlo_CLhard =',ftof(CLhard,2)
      endif
      eLinner= eLinnereV/rydberg()+eferm
      eUinner= eUinnereV/rydberg()+eferm
      eUouterauto=.true. !merge(.true.,.false.,eUouter>1d5)
      eUinnerauto=merge(.true.,.false.,eUinner>1d5)
      ewid= ewideV/rydberg() !in Ry.
    endblock ReadInfoFromGWinput
    bbvector: block !Get connecting vectors bb, bb connects k and k+bb, where both k and k+bb are on mesh points nqbz.
      allocate(wbb(12))
      call getbb(plat,alat,n1,n2,n3, nbb,wbb,wbbsum,bb) ! b vectors (connecting vectors). See appendix of Marzari.1997
      allocate (ku(3,nqbz),kbu(3,nbb,nqbz),ikbidx(nbb,nqbz))
      call kbbindx(qbz,ginv,bb, nqbz,nbb, ikbidx,ku,kbu) ! index for k and k+bb
      call writebb2(ifbb,wbb(1:nbb),bb(1:3,1:nbb), ikbidx,ku,kbu, nqbz,nbb)
      write(stdo,ftox)' nbb wbb(in unit of 2pi/alat)=',nbb,ftof(wbb(1:nbb),3)
      allocate(bbv,source=bb)
    endblock bbvector
    iki=1     !minval(iko_i)
    ikf=nband !maxval(iko_f) !  nox = ikf - iki + 1. nband is for MPO Hamiltonian
    call set_qibz(plat,qbz,nqbz,symops,ngrp) !iqibzrep(iqibz) is the representative of iqibz
    if(job==1) goto 1011 !Goto Souza's iteration --job=1 mode
    GetCNmatFile_job0: block  !job=0 mode to get CNmat file (connection matrix uumat and so on).
      real(8):: eps=1d-8
      complex(8):: emat(nband,nband),osq(1:nband,1:nband),o2al(1:nband,1:nband,nqbz),phase,ovlmm(nband,nMLO),&
           evec(nband,nband,nqbz),evecx(1:nband,1:nband), ovec(nband,nband),amnk(iki:ikf,nMLO,nqibz),&
           ovlm(1:nband,1:nband),ovlmx(1:nband,1:nband), hamm(1:nband,1:nband),uumat(iki:ikf,iki:ikf,nbb,nqibz)
      allocate(evl(nband,nqbz),ovl(nband),eveci(1:nband,1:nband,nqbz)) !NOTE: 20230805. When I declear evl in this block, ifort18.05 gives wrong results.
      write(stdo,ftox)'Going to get CNmat ... : nband for |MLO1>=',nband,'iki ikf=',iki,ikf
      open(newunit=ifuumat,file='CNmat',form='unformatted')
      uuispinloop: do 1010 is = 1,nspin
         write(stdo,ftox)'Generating connection matrix ispinloop: is =',is,'  out of',nspin, 'nqbz=',nqbz
         emat=0d0
         forall(i=1:nband) emat(i,i)=1d0
         evecIQBZ: block
           complex(8):: oveci(nband,nband,nqibz),rotmat(nband,nband),ovlmi(nband,nband,nqibz)
           real(8)::ovli(nband,nqibz)
           allocate(evli(nband,nqibz))
           qibzeigen: block
             do iqibz=1,nqibz
                qp = qibz(:,iqibz)
                ovlm = 0d0
                hamm = 0d0
                do i=1,nband !Get MPO Hamiltonian at qp by FF from the real-space MPO Hamiltonian (lmfham1)
                   do j=1,nband
                      ib1 = ib_tableM(i) !atomic-site index in the primitive cell
                      ib2 = ib_tableM(j)
                      do it =1,npair(ib1,ib2) !real-space to H,O at qp
                         phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                         hamm(i,j)= hamm(i,j)+ hmmr1(i,j,it,is)*phase
                         ovlm(i,j)= ovlm(i,j)+ ommr1(i,j,it,is)*phase
                      enddo
                   enddo
                enddo
                nmx=nband
                ovlmi(:,:,iqibz)=ovlm
                ovlmx=ovlm
                call zhev_tk4(nband,ovlm,emat,nmx,nev, ovl,          oveci(:,:,iqibz), oveps) !Diangonale overlap matrix. (ovlm - e ) ovec=0
                ovli(:,iqibz)=ovl
                ovlm=ovlmx
                call zhev_tk4(nband,hamm,ovlm,nmx,nev, evli(:,iqibz), eveci(:,:,iqibz), oveps) !Diangonale (hamm- evl ovlm) z=0
888             continue
             enddo
           endblock qibzeigen
           do iqbz=1,nqbz !; if(mod(iqbz,10)==1) write(6,*)'iqbz=',iqbz
              qp=qbz(:,iqbz)
              iqibz= irotq(iqbz)
              call rotmatMTO(igg=irotg(iqbz),q=qibz(:,iqibz),qtarget=qp+matmul(qlat,ndiff(:,iqibz)),ndimh=nband,rotmat=rotmat)
              ovec=          matmul(rotmat,oveci(:,:,iqibz))
              evec(:,:,iqbz)=matmul(rotmat,eveci(:,:,iqibz))
              ovlmx = matmul(rotmat,matmul(ovlmi(:,:,iqibz),dconjg(transpose(rotmat))))
              ovl = ovli(:,iqibz)
              evl(:,iqbz)=evli(:,iqibz)
              do concurrent (i=1:nband,j=1:nband)
                 osq(i,j)=sum(ovec(i,:)*ovl(:)**0.5d0*dconjg(ovec(j,:))) !O^(1/2)
              enddo
              o2al(:,:,iqbz) = matmul(osq, evec(:,:,iqbz)) !o2al(basis index, band index, iqbz index) O^(1/2)*evec
              forall(i=1:nband) ovlmm(i,:) = ovlmx(i,idmto(:))
!              amnk(:,:,iqbz)= matmul(transpose(dconjg(evec(1:nband,iki:ikf,iqbz))),ovlmm) !amnk(:,:)= <Psi^MPO(:)|MPOseed(:)>
           enddo
           do iqibz=1,nqibz
              iqbz=iqbzrep(iqibz)
              ovlmm(:,:) = ovlmi(:,idmto(:),iqibz)
              amnk(:,:,iqibz)= matmul(transpose(dconjg(eveci(1:nband,iki:ikf,iqibz))),ovlmm) !amnk(:,:)= <Psi^MPO(:)|MPOseed(:)>
              do ibb=1,nbb
                 iqb = ikbidx(ibb,iqbz)             !q1(:) = qbz(:,iqbz)             !q2(:) = q1(:) + bbv(:,ibb)
                 do concurrent(ib1=iki:ikf, ib2=iki:ikf) !ib1,ib2 band index of inner-inner window
                    uumat(ib1,ib2,ibb,iqibz)= sum(dconjg(o2al(1:nband,ib1,iqbz))*o2al(1:nband,ib2,iqb)) ! define connection <q ib1| q+b ib2>
                 enddo
              enddo
           enddo
           write(ifuumat) nband,nqbz,iki,ikf,nMLO,idmto,nqibz
           write(ifuumat) evl,evli,eveci   !eigenvalue
           write(ifuumat) uumat !connection matrix
           write(ifuumat) amnk  !initial projection
         endblock evecIQBZ
         deallocate(evli)
1010  enddo uuispinloop
      close(ifuumat)
      if(job==0) call rx0('OK! end of lmhfam2 job=0 for generating CNmat')
    endblock GetCNmatFile_Job0

1011 continue !=== --job==1 mode start ========================================


    testnlat: block
      use m_mksym_util,only:mptauof
      integer::itr
      real(8):: platn(3),platn0(3),platnn(3),tiat(3,natom,ngrp),shtvg(3,ngrp)
      integer:: invgx(ngrp),miat(natom,ngrp)
      call mptauof(symops,ngrp,plat,natom,pos, iclasst, miat,tiat,invgx,shtvg )
      ! nlat symmetry check
      do ib1=1,natom; do ib2=1,natom
         do it =1,npair(ib1,ib2)
            platn0 =   pos(:,ib2)-pos(:,ib1)+ matmul(plat,nlat(:,it,ib1,ib2))
            write(stdo,ftox) ' nlat=', ib1,ib2,nlat(:,it,ib1,ib2)
            do ig=1,ngrp
               platn = matmul(symops(:,:,ig),platn0)
               do itr=1,npair(ib1,ib2)
                  platnn = pos(:,miat(ib2,ig))-pos(:,miat(ib1,ig)) + tiat(:,ib2,ig)-tiat(:,ib1,ig)+ matmul(plat,nlat(:,itr,ib1,ib2))
                  if( sum(abs(nint(platnn-platn)))==0) goto 889
               enddo
            enddo
            write(stdo,ftox)'no rotation for ig it ib1 ib2',ig,it,ib1,ib2,'nlat=',nlat(:,it,ib1,ib2)
            call rx('xxxxxxxxxx')
889         continue
         enddo
      enddo; enddo
    endblock testnlat
    stop 'xxxxxxxxxxxxxxxxxxxxxx'
    
    open(newunit=ifuumat,file='CNmat',form='unformatted')
    allocate(hmmr2(nMLO,nMLO,npairmx,nspin),ommr2(nMLO,nMLO,npairmx,nspin),source=(0d0,0d0))
    allocate(evl(nband,nqbz), ovec(nband,nband),ovl(nband))
    allocate(amnk(iki:ikf,nMLO,nqibz),idmto_(nMLO))
    allocate(wbz(nqbz),source=1d0/nqbz)
    allocate (uumat(iki:ikf,iki:ikf,nbb,nqibz),evli(nband,nqibz),eveci(nband,nband,nqibz))
    ispinloop: do 1000 is = 1,nspin
       read(ifuumat) nband_,nqbz_,iki_,ikf_,nMLO_,idmto_
       if(nMLO/=nMLO.or.sum(abs(idmto-idmto_))/=0) call rx0('lmfham2: idmto error: Repeat --job=1 with the same <Worb> in GWinput!')
       read(ifuumat) evl,evli,eveci
       read(ifuumat) uumat
       read(ifuumat) amnk
       iqibz=16
       do i=1,nband
          write(stdo,ftox)'evli=',iqibz,i,ftof(evli(i,iqibz))
       enddo
       !     write(6,*)'isp amnksum=',is,sum(abs(amnk))
       if(master_mpi) &
            write(stdo,ftox)'### isploop: is=',is,'out of',nspin,'ChooseSpace by cnk(init:iend,1:nMLO,1:nqbz)=',iki,ikf,nMLO,nqbz
       allocate(upu(iki:ikf,iki:ikf,nbb,nqibz),cnkb(iki:ikf,nMLO,nbb),&
            cnki(iki:ikf,nMLO,nqibz),cnkia(nband,nband,nqibz),omgik(nqibz),evals(nqibz))!,zesum(nqbz)) !cnk2(iki:ikf,nMLO,nqbz)
       allocate(WTbandq(nqibz),WTinnerq(nqibz),proj(iki:ikf),projs(iki:ikf),projss(iki:ikf))
       callamnk2unk: block
         integer:: iko_i(nqibz),iko_f(nqibz)
         iko_i=iki
         iko_f=ikf
         allocate(cnk0i(iki:ikf,nMLO,nqibz))
         call amnk2unk(amnk,iki,ikf,iko_i,iko_f,nMLO,nqibz, cnk0i)
         cnki=cnk0i
       endblock callamnk2unk
       !amnki=amnk
       !amnk=<Psi^MPO(it,iqbz)|MPO(1:nMLO) >.  Note that amnk was in Eq.22 in Ref.II. <psi|Gaussian>. We replace Gaussian with MPO.
       !cnk =<Psi^MPO(it,iqbz)|MPO_orth(1:nMLO)>.  |MPO_orth>= |MPO> O^{-1/2} !initial condition
       zesumold=1d10
       alpha = 1d0
       upu   = 0d0
       wbbs=sum(wbb(1:nbb)) !we assume iko_i(iq)=1. If not, use evl(iko_i(iq),iq)
       convn=.false.
       SouzaStep1loop: do isc = 1,nsc1 ! choose Hilbert space -- determine cnk
          AUTOeLhard:block
            if(eLhardauto) then! Search bottom of MPO Hamiltonian for given MTOsets to generate MLO.
               ieLhard=9999
               do iq = 1,nqibz
                  proj = [ (sum(cnki(i,:,iq)*dconjg(cnki(i,:,iq))),i=iki,ikf) ]
                  ieLhard = min(findloc(proj>CLhard,value=.true.,dim=1),ieLhard) !lowest band index
               enddo
               eLhard = minval(evl(ieLhard,:))- 1d-3 !eLhardeVoffset/rydberg()
            else
               eLhard= eLhardeV/rydberg()+eferm
            endif
            if(isc==1.or.convn.or.isc==nsc1) write(stdo,ftox)' eLhard =',ftof((eLhard-eferm)*rydberg(),3),'eV'
          endblock AUTOeLhard
          AUTOeUblock:block
            integer::ikff,imlo,ik,ibandx,ibandxx,iUinneri,n,nlow,iUinner,iUouter
            real(8):: zmnsa(iki:ikf),nnc(iki:ikf,nMLO)
            if(eUinnerauto) eUinner=-9999d0/rydberg()+eferm
            if(eUouterauto) eUouter=-9999d0/rydberg()+eferm
            iUinner=nband
            do iq=1,nqibz
               proj   = [(sum(cnki(i,:,iq)*dconjg(cnki(i,:,iq))),i=iki,ikf) ]
               projs  = [(sum(proj(i:ikf)),i=iki,ikf)]
               if(eUouterauto) then
                  iUouter = findloc(projs>CUouter,value=.true.,back=.true.,dim=1) +1
                  if(iUouter==0.or.iUouter>nband) iUouter=nband
                  eUouter = max(evli(iUouter,iq),eUouter)
               endif
               if(debug) then!.true.) then !
                  do imlo=1,nMLO
                     proj = [(sum(cnk0i(iki:ik,imlo,iq)*dconjg(cnk0i(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                     write(stdo,ftox)'imlo=',imlo,' weight=',ftof(proj(iki:25),2),' total=',ftof(proj(ikf),3)
                  enddo
               endif
               if(eUinnerauto) then !default
                  iUinner=-999
                  do imlo=1,nMLO  !     proj = [(sum(cnk0(iki:ik,imlo,iq)*dconjg(cnk0(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                     proj = [(sum(cnki(iki:ik,imlo,iq)*dconjg(cnki(iki:ik,imlo,iq))),ik=iki,ikf)] !proj for each imlo
                     !                   iUinner=max(findloc(proj>.5d0,value=.true.,dim=1),iUinner)
                     if(EUautosp.and.lindex(imlo)>=2) cycle
                     iUinner=max(findloc(proj>CUinner,value=.true.,dim=1),iUinner)
                     !write(stdo,ftox)'imlo=',imlo,' weight=',ftof(proj(iki:25),2),' total=',ftof(proj(ikf),3)
                  enddo
                  if(iUinner==-1) iUinner=nband
                  eUinner = max(evli(iUinner,iq),eUinner)  !maximum value
               endif
            enddo
            if((isc==1.or.convn.or.isc==nsc1)) then !.and.iq==1)then
               aaa=merge('auto.given by CUouter='//ftof(CUouter),repeat(' ',256), eUouterauto)
               write(stdo,ftox)' eUouter=',ftof((eUouter-eferm)*rydberg(),3),'eV',trim(aaa)
               aaa=''
               if(eUinnerauto) aaa='auto.default'//' EUinner by proj>CUinner='//ftof(CUinner)
               if(eUautosp)    aaa=trim(aaa)//' EUinnerAUTOsp on.'
               write(stdo,ftox)' eUinner=',ftof((eUinner-eferm)*rydberg(),3),'eV',trim(aaa)
            endif
          endblock AUTOeUblock
          iqloop: do iqibz = 1,nqibz !iq=1,nqbz !nqibz !nqbz
             iq = iqbzrep(iqibz) !iq is the representative of iq
             Getcnkatiqb: block
               integer::iqibzb,iqbzb
               complex(8)::rotmatmlo(nMLO,nMLO), rotmat(nband,nband), drotmat(nband,nband)
               !!cnk(1:nband, 1:nMLO,iqb) <--- mapped from cnk at iqbz
               do ibb = 1,nbb
                 iqb= ikbidx(ibb,iq) ! iqb is the iqbz index for q+b
                 iqibzb=  irotq(iqb) ! iqb belongs to iqibz=iqibzb 
                 ig    =  irotg(iqb) ! iqb is rotated by ig. Thus qb = symops(::,ig),q+b
                 iqbzb = iqbzrep(iqibzb) !iqbz index for iqibzb
                 qp    = qbz(:,iqb)
                 call rotmatMTO(igg=ig,q=qibz(:,iqibzb),qtarget=qp,ndimh=nband, rotmat=rotmat)
                 drotmat = dconjg(transpose(rotmat))            
                 cnkb(:,:,ibb) = matmul(cnki(:,:,iqibzb),drotmat(:,idmto(:))) !,dconjg(transpose(rotmatmlo(idmto_(:),idmto_(:))))) 
!!               cnkb(:,:,ibb) = matmul(rotmat(:,:),cnk(:,:,iqbzb)) !,dconjg(transpose(rotmatmlo(idmto_(:),idmto_(:))))) 
               enddo
!!               do ibb = 1,nbb
!!                  iqb= ikbidx(ibb,iq) ! iqb is the iqbz index for q+b
!!                  cnkb(:,:,ibb) = cnk(:,:,iqb) 
!!                enddo
             endblock Getcnkatiqb
             nout = ikf - iki + 1
             ndz  = nout
             if(isc /= 1) alpha = alpha1
             allocate(wmat(iki:ikf,iki:ikf), wmat2(iki:ikf,iki:ikf))
             i1q=iki!iko_i(iq)
             i2q=ikf!iko_f(iq)
             do ibb = 1,nbb
                iqb = ikbidx(ibb,iq)
                i1= iki!iko_i(iqb)
                i2= ikf!iko_f(iqb)
                do concurrent(inp=i1:i2, imp=i1:i2) !wmat = cnk * cnk^{*} is projector to 'wannier space'.
                   wmat(inp,imp)= sum(dconjg(cnkb(inp,1:nMLO,ibb))*cnkb(imp,1:nMLO,ibb)) !BUG-> sum was for nin+1:nMLO before 2023-6-8(miyake)
                enddo
                do concurrent(inx=i1q:i2q, imp=i1:i2)
                   wmat2(imp,inx)= sum( wmat(i1:i2,imp)*dconjg(uumat(inx,i1:i2,ibb,iqibz)) ) !wmat*uumat
                enddo
                do concurrent(imx=i1q:i2q, inx=i1q:i2q)!      upu=   uumat* wmat * uumat ! (1-2) <u_mk | P_k+b | u_nk>
                   upu(imx,inx,ibb,iqibz)= (1d0-alpha)*upu(imx,inx,ibb,iqibz)+alpha*sum(uumat(imx,i1:i2,ibb,iqibz)*wmat2(i1:i2,inx))
                enddo
             enddo
             deallocate(wmat,wmat2)
!!! Within the space of MPO_n(k) (as function of k), we minimize Omega
!!! Omega = -1/2 \sum_b,k Tr {|\nabla Pk|^2} + WTband*Tr{Pk H}_inner - WTinner*Tr{Pk}_inner - WTseed*Tr{Pk <psi_m|seed_i><seed_i|psi_n|}
             ! zmn = \frac{\delta Omega}{\delta Pmn^k}
             allocate (zmn0(ndz,ndz),source=(0d0,0d0)) ! (1-3) Zmn(k) > phi,eval
             allocate (zmn(ndz,ndz),zmns(ndz,ndz), evecc(ndz,ndz),eval(ndz),WTbandii(ndz),WTinnerii(ndz)) !,ezmns(ndz,ndz)
             do ibb = 1,nbb
                zmn0(1:ndz,1:ndz) = zmn0(1:ndz,1:ndz) - 2d0*wbb(ibb)*upu(iki:ikf,iki:ikf,ibb,iqibz)
             enddo
             zmn=zmn0
             WTbandBlock: do i=iki,ikf
                WTbandii(i)= WTband*evl(i,iq)
             enddo WTbandBlock
             WTseedBlock: block !zmn can be multipled by energy window in future.
               if(WTseed/=0d0) then !projection to Seed functions
                  zmns = matmul(cnk0i(iki:ikf,1:nMLO,iqibz),dconjg(transpose(cnk0i(iki:ikf,1:nMLO,iqibz))))
                  zmn(iki:ikf,iki:ikf)= zmn(iki:ikf,iki:ikf) - WTseed*zmns !gain
               endif
             endblock WTseedBlock
             WTbandinnerBlock: do i=iki,ikf !Add gain for inner window. Soft inner window.
                !This new filter seems dependent too much on pxbarameters.
                !zmn(i,i)= zmn(i,i) + WTband*evl(i,iq) *filter2((evl(i,iq)-eLinner)/ewid) *filter2((eUinner-evl(i,iq))/ewid) !WTband is notso meaninful
                !zmn(i,i)= zmn(i,i) - WTinner          *filter2((evl(i,iq)-eLinner)/ewid) *filter2((eUinner-evl(i,iq))/ewid) !
                !Main difference of following filters are just the shift of cutoff center. For Si666 new one can give better agreements.
                zmn(i,i)=zmn(i,i)+(WTband*evl(i,iq)-WTinner)*(1-filter2((evl(i,iq)-eUinner)/ewid)-filter2((eLinner-evl(i,iq))/ewid)) !inner window
                zmn(i,i)=zmn(i,i)+ WTouter*filter2((evl(i,iq)-eUouter)/ewid)  !outer penaltiy
                WTinnerii(i) =     WTinner*(1-filter2((evl(i,iq)-eUinner)/ewid)-filter2((eLinner-evl(i,iq))/ewid))
             enddo WTbandinnerBlock
             HardInnerBlock: block ! hard innerwindow
               real(8),parameter:: zhard=-1d8, zavoid=1d8
               do i=iki,ikf
                  if(evl(i,iq)<eLhard) then !avoided
                     zmn(i,:)=0d0; zmn(:,i)= 0d0; zmn(i,i)= zavoid !elseif(evl(i,iq)<eUhardeV/rydberg()+eferm) then;zmn(i,:)=0d0; zmn(:,i)= 0d0; zmn(i,i)= zhard
                  endif
               enddo
             endblock HardInnerBlock
             call diag_hm(zmn,ndz,eval,evecc) !take smaller (negative bigger) ones.
             ! eval(i)/wbbs is normalized. If all eval(i)/wbbs=1, P_k=P_{k+b}.
             forall(iwf = 1:nMLO) cnki(iki:ikf,iwf,iqibz) = evecc(1:ndz,iwf)

!!!!!!!!!!!!!!             
!             cnkia(:,:,iqibz) = evecc
             
             evals(iqibz)= sum(eval(1:nMLO))
             omgik(iqibz)= sum([(sum(dconjg(evecc(1:ndz,i))*matmul(zmn0,evecc(1:ndz,i))),i=1,nMLO)])
             WTbandq(iqibz)= sum([(sum(dconjg(evecc(1:ndz,i))*WTbandii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !2nd energy term
             WTinnerq(iqibz)= sum([(sum(dconjg(evecc(1:ndz,i))*WTinnerii(1:ndz)*evecc(1:ndz,i)),i=1,nMLO)]) !
             !write(stdo,ftox)'iq=',iq,'eval=',ftof(eval)
             deallocate (zmn,evecc,eval,zmn0,WTbandii,WTinnerii,zmns)
          enddo iqloop
          omgi        = sum(omgik(:)   *wiqibz(:))
          WTbandqsum  = sum(WTbandq(:) *wiqibz(:))
          WTinnerqsum = sum(WTinnerq(:)*wiqibz(:))
          evalss      = sum(evals(:)   *wiqibz(:))
          ! \sum eval = \sum zmn0 term + WTbandq + WTinnerq
          !    write(stdo,ftox)'#SC-loop, OmegaI_a Zsum=',isc,ftof(omgi),'=',ftof(zesi-evalss+WTbandqsum+WTinnerqsum)
          if(WTinner/=0d0)aaa='Pin='//trim(ftof(WTinnerqsum/WTinner/nMLO))
          if(WTband/=0d0) bbb='Emean(eV)='//trim(ftof((WTbandqsum/WTband/nMLO-eferm)*rydberg()))
          write(stdo,ftox)'#SC:isc=',isc,'Omega/nMLO=',ftof( (wbbs+omgi/2d0/nMLO)/tpia**2 + WTbandqsum/nMLO + WTinnerqsum/nMLO),&
               'Nabla2/nMLO(a.u.**2)=',ftof((wbbs+omgi/2d0/nMLO)/tpia**2/2d0 ),&
               'MeanOverlap=',ftof(-omgi/2d0/nMLO/wbbs),trim(bbb),trim(aaa) !Omega corresponds to Omega_I in Eq.34 Mazari.
          !NOTE: nMLO \sim omgi=\sum_b wb \sum_{m=1}^N \sum_{n=1}^N |Mmn^{k,b}|^2 (See Eq.7 in Souza paper).
          !      But Mnm here is only for coefficienets parts of eigenfunctions.
          if(convn) then
             write(stdo,ftox)' Step1: converged!'
             exit
          endif
          if(isc>=2 .and. dabs(evalssold-evalss)<conv1) then
             write(stdo,ftox) 'evalss_old evalss',ftod(evalssold),ftod(evalss)
             convn=.true.
          endif
          evalssold = evalss
          if(isc==nsc1) write(stdo,ftox)' Step1: not converged'
       enddo SouzaStep1loop
       !! NOTE: cnk(iki:ikf,nMLO,nqbz) is the final results of Step1loop, which minimize Omega_I (Wannier space)
       !!   cnk(iko_i(iq):iko_f(iq),nMLO,iq) gives nMLO-dimentional space.
       GetHamiltonianforMTObyProjection: block  !We do not use Marzari's unitary rotation
         integer:: il,im,in,ib1,ib2,jsp,ificpmtmpo,nPMT,nMPO,ificp,nnqbz,ificmlo
         real(8):: fac0,evll(nMLO)
         complex(8),allocatable:: rotmatr(:,:),cmpoi(:,:),cpmtmlo_i(:,:),cpmtmlo(:,:) !,rmatpmt(:,:)
         complex(8)::img2pi=img*2d0*pi, rotmat(nband,nband)
         complex(8)::phase,proj(iki:ikf,iki:ikf),cmlo(iki:ikf,nMLO),cmloi(iki:ikf,nMLO),cmpomlo(iki:ikf,nMLO),&
              ham(nMLO,nMLO),ovlx(nMLO,nMLO),evecl(nMLO,nMLO),rotmatmlo(nMLO,nMLO),phaseij(natom,natom,npairmx)
         logical:: cmdopt0
         character(8):: xt
         jsp=is
         do iqibz = 1,nqibz
            forall(i=iki:ikf,j=iki:ikf) proj(i,j)=sum(cnki(i,:,iqibz)*dconjg(cnki(j,:,iqibz))) !projector
!            forall(i=iki:ikf,j=iki:ikf) proj(i,j)=sum(cnkia(i,:,iqibz)*dconjg(cnkia(j,:,iqibz))) !projector
            cmloi(iki:ikf,1:nMLO) = matmul(proj,amnk(iki:ikf,1:nMLO,iqibz)) !Get MLO by proj. |FMLO_i> = |PsiMPO_j> Cmloi(j,i)
            ! |PsiMLO_i> =  |PsiMPO_j> cmloi(j,i)*eveci  = |PsiPMT> cmpoi*eveci * cmloi*evecl
            if(cmdopt0('--cmlo')) then
               open(newunit=ificpmtmpo, file='Cmpo' //trim(xt(iqibz))//trim(xt(jsp)),form='unformatted')
               read(ificpmtmpo) nPMT, nMPO
               if( nband/=nMPO) call rx('nband/=nMPO')
               if(allocated(rotmatr)) deallocate(cmpoi,cpmtmlo_i,cpmtmlo,rotmatr) !,rmatpmt)
               allocate(cmpoi(nPMT,nMPO),cpmtmlo_i(1:nPMT,1:nMLO),cpmtmlo(1:nPMT,1:nMLO),rotmatr(nMLO,nMLO)) !,rmatpmt(nPMT,nPMT))
               read(ificpmtmpo) cmpoi(nPMT,nMPO)  !   |FMPO_i>= |PsiPMT_l> Cmpo(l,i)
               close(ificpmtmpo)
               open(newunit=ificmlo, file='Cmlo' //trim(xt(iqibz))//trim(xt(jsp)),form='unformatted')
               nnqbz = count(igiqibz(1:ngrp,iqibz))
               write(ificmlo) nnqbz
               do ig = 1,ngrp
                  if(.not.igiqibz(ig,iqibz)) cycle
                  iqbz= iqii(ig,iqibz)
                  qp  = qbzii(:,ig,iqibz)
                  write(ificmlo) iqbz, qp
               enddo
            endif
            fac0= wiqibz(iqibz)/dble(ngrp) !1d0/dble(nqbz)/ngrp !1d0/dble(nqbz) !
            igloop: do ig = 1,ngrp
               !if(.not.igiqibz(ig,iqibz)) cycle
               !iqbz= iqii(ig,iqibz)
               !qp  = qbzii(:,ig,iqibz)
               do iqbz=1,nqbz
                  qx= matmul(transpose(plat),  qbz(:,iqbz)- matmul(symops(:,:,ig),qibz(:,iqibz)))
                  qx= qx-nint(qx) !qx-ndiff !translation of qx
                  if(sum(abs(qx))<eps) then
                     qp=qbz(:,iqbz)
                     goto 88
                  endif   
               enddo
               call rx('qp can not find')
88             continue
               !fix iqbz, qp ---> all possible ig added to cmlo
               call rotmatMTO(igg=ig,q=qibz(:,iqibz),qtarget=qp,ndimh=nband,   rotmat=rotmat)
               cmlo = matmul(cmloi,dconjg(transpose(rotmat(idmto_(:),idmto_(:))))) ! |FMLO_i> = |PsiMPO_j> cmlo(j,i)
               forall(i=1:nMLO,j=1:nMLO) ham(i,j)  = sum(dconjg(cmlo(:,i))*evli(iki:ikf,iqibz)*cmlo(:,j))
               forall(i=1:nMLO,j=1:nMLO) ovlx(i,j) = sum(dconjg(cmlo(:,i))*cmlo(:,j))
               
               do ib1=1,natom; do ib2=1,natom
                  do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                     phaseij(ib1,ib2,it) = fac0*exp( img2pi*sum(qp*matmul(plat,nlat(:,it,ib1,ib2))) )
                  enddo
               enddo; enddo
               do i=1,nMLO; do j=1,nMLO !Real space Hamiltonian. H(k)->H(T) FT to real space
                  ib1=ib_tableM(i)
                  ib2=ib_tableM(j)
                  do it =1,npair(ib1,ib2)! hammr_ij (T)= \sum_k hamm(k) exp(ikT). it is the index for T
                     hmmr2(i,j,it,jsp)= hmmr2(i,j,it,jsp)+ ham(i,j) *phaseij(ib1,ib2,it)
                     ommr2(i,j,it,jsp)= ommr2(i,j,it,jsp)+ ovlx(i,j)*phaseij(ib1,ib2,it)
                  enddo
               enddo; enddo
               
               if(cmdopt0('--cmlo')) then !at iqibz
                  rotmatmlo(:,:) = dconjg(transpose(rotmat(idmto_(:),idmto_(:))))
                  if(ig==1) then !at irreducible points
                     nmx =nMLO
                     call zhev_tk4(nMLO,ham,ovlx,nmx,nev, evll,evecl,oveps)! Diangonale (hamm - evl ovlm )evec=0
                     write(ificmlo) iqibz,nPMT,nMLO,qibz(:,iqibz)
                     write(ificmlo) matmul(matmul(cmpoi,eveci(:,iki:ikf,iqibz)),cmloi) !c1 !|FMLO_iqibz> = |PsiPMT_iqibz> cmpoi*eveci * cmloi
                  else   !for rotation
                     write(ificmlo) iqbz,nMLO,nMLO,qp
                     write(ificmlo) matmul(rotmatmlo,evecl) !rotation is |PsiMLO_iqbz>= |FMLO_iqibz>*rotmatmlo*evecl
                     !cmlo contains rotation from iqibz to iqbz
                  endif
               endif ! |PsiMLO_iqbz> = |Psi_PMT_iqibz> c1(iqibz)*c2(iqbz)
            enddo igloop
            close(ificmlo)
         enddo
         deallocate(cnki)
       endblock GetHamiltonianforMTObyProjection
       write(6,*)' get hmmr2. Goto band_lmfham2.dat ---------'
       bandplotMLO: block
         real(8):: evlm(nMLO,ndat)
         complex(8):: phase,hamm(nMLO,nMLO),ovlm(nMLO,nMLO),evec(nMLO,nMLO)
         integer:: iband
         jsp=is
         fband2='band_MLO_spin'//char(48+jsp)//'.dat'
         fband1='band_MPO_spin'//char(48+jsp)//'.dat'
         open(newunit=iband,file=trim(fband2))
         do iq= 1,ndat
            qp=qplistsy(:,iq)
            ovlm = 0d0
            hamm = 0d0
            do i=1,nMLO; do j=1,nMLO
               ib1 = ib_tableM(i)
               ib2 = ib_tableM(j)
               do it =1,npair(ib1,ib2)
                  phase= 1d0/nqwgt(it,ib1,ib2)*exp(-img*2d0*pi* sum(qp*matmul(plat,nlat(:,it,ib1,ib2))))
                  hamm(i,j)= hamm(i,j)+ hmmr2(i,j,it,is)*phase
                  ovlm(i,j)= ovlm(i,j)+ ommr2(i,j,it,is)*phase
               enddo
            enddo; enddo
            nmx =nMLO
            call zhev_tk4(nMLO,hamm,ovlm,nmx,nev, evlm(:,iq), evec, oveps)! Diangonale (hamm - evl ovlm ) evec=0
            if(iq<6)  write(stdo,"(' iq q=',i3,*(a))") iq,' ',ftof(qp,3),' e=',ftof(evlm(1:12,iq),3)
            if(iq==6) write(stdo,"(' iq q= ...')")
            do i=1,nev
               write(iband,ftox)  ftof(xdat(iq)),ftof(evlm(i,iq)), is,i
            enddo
         enddo
         close(iband)
       endblock bandplotMLO
       Modifiedbandplotglt: block
         integer:: ifglt1,ifglt
         character(256):: aline,fname,fname2
         jsp = is
         fname2='bandplot_MLO.isp'//char(48+jsp)//'.glt'
         fname ='bandplot.isp'//char(48+jsp)//'.glt'
         open(newunit=ifglt,  file=trim(fname))
         open(newunit=ifglt1, file=trim(fname2))
         do
            read(ifglt,"(a)",err=989,end=989)aline
            if(aline(1:4)=="plot" ) then !"
               write(ifglt1,ftox)"ef=",ftof(eferm)
               write(ifglt1,ftox)trim(aline)
               write(ifglt1,ftox)'"'//trim(fband1)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "green",\'   !'
               write(ifglt1,ftox)'"'//trim(fband2)//'" u ($1):(13.605*($2-ef)) pt 2 lc rgb "red",\'   !'
            else
               write(ifglt1,ftox)trim(aline)
            endif
         enddo
989      continue
         close(ifglt)
         close(ifglt1)
         write(stdo,ftox)'OK! Run gnuplot -p '//trim(fname2)//'.Red points are by hmmr2 for Hamiltonian on {|MLO2>}'
       endblock Modifiedbandplotglt
       deallocate(omgik,evals,wtbandq,wtinnerq,proj,projs,projss,upu,cnk0i,cnkb)
1000 enddo ispinloop
    if(job==0) call rx0('OK! end of lmfham --job=0 --------')
    if(job==1) call rx0('OK! end of lmfham --job=1 --------')
  contains
    pure real(8) function filter2(x) !step like function 0(x<0) to 1(x>0)
      real(8),intent(in) :: x
      if(x<0d0) then
         filter2=0d0
      elseif(x>30d0) then
         filter2= 1d0
      else
         filter2= 1d0*(1d0-2d0/(exp(x)+1d0))
      endif
    end function filter2
  end subroutine lmfham2
end module m_lmfham2
