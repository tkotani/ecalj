      subroutine mstmin(n,w,g1,g2,del,wrk,dspmax,tol,alpha,atol,icom,
     .                  gd1,alpha1,alpha2,alphau,alphal,nsrch,iprint)
      implicit double precision (a-h,o-z)
C- Fletcher-Powell minimisation of a function of n coordinate variables.
C  M.J.Norgett & R.Fletcher, J.Phys.C, 3, L190 (1972)
C  w      = inverse 2nd deriv. matrix supplied on first entry to mstmin
C           and updated at each subsequent iteration. On first entry
C           you may pass a guess (e.g. a unit matrix)
C  g1     = first derivative at current iteration (first iteration only)
C           first derivative of previous iteration (subsequent iter)
C  g2     = first derivative at current iteration (after first iter)
C  del    = coordinate displacements calculated by mstmin
C  wrk    = work array
C  dspmax = step length in search direction
C  tol    = tolerance in minimisation; convergence is achieved when
C           maximum change in any variable is less than tol
C  alpha  = scaling factor to be applied in calling routine:
C           on each exit, the variables of the function being minimised
C           are updated by adding alpha * del(j) to the j'th variable
C  atol   = smallest change in alpha before changing direction
C  n      = first and second dimension of w (number of variables)
C  icom   = call indicator
C         = 0 for first entry (set in calling routine)
C         = 1 when relaxation is complete (returned by mstmin)
C         = 2 when a seeking first point along new direction vector
C         = 3 when an extremum has been bracketed
C  gd1,alpha1,alpha2,alphau,alphal,nsrch: parameters generated by mstmin
C  gd1    = projection of gradient along starting point of dir. vector
C  gd2    = projection of gradient at current pont of dir. vector
C  nsrch  = number of points along current direction vector
C  alphal = lower bound in alpha bracketing extremum
C  alphau = upper bound in alpha bracketing extremum
C  iprint = 0 for suppression of all printing
C         > 0 for some printing to logical unit iprint
      dimension w(n,n),g1(n),g2(n),del(n),wrk(n)
      save delmax
      zero = 0d0
      one = 1d0
      two = 2d0
      half = 0.5d0
      qrter = 0.25d0

      if (icom.gt.0) goto 10

C --- First iteration ---
C     if (iprint.gt.0) write(iprint,100)
C 100 format(/6x,'minimisation set-up.')
      if (iprint.gt.0)
     .  call awrit2(' mstmin: start  xtol=%1;2g  |grad|=%1;3g',' ',80,
     .  i1mach(2),tol,dsqrt(ddot(n,g1,1,g1,1)))
      gd1 = zero
      gd2 = zero
      delmax = zero
      do 2 i = 1,n
      del(i) = zero
      do 1 j = 1,n
      del(i) = del(i) - w(i,j) * g1(j)
    1 continue
      delmax = dmax1(delmax,dabs(del(i)))
      gd1 = gd1 + g1(i) * del(i)
    2 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2
  101 format(6x,'gd1 = ',f10.5,6x,'gd2 = ',f10.5)

      factor = dmin1(one,dspmax/delmax)
      delmax = factor * delmax
      if (gd1.gt.zero) factor = - factor
      gd1 = factor * gd1
      do 3 i = 1,n
      del(i) = factor * del(i)
    3 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2
      alpha = one
      alpha1 = zero
      alpha2 = one
      if (iprint.gt.0) write(iprint,102) alpha,alpha1,alpha2
  102 format(6x,'alpha = ',f10.5,6x,'alpha1= ',f10.5,6x,'alpha2 = ',
     .     f10.5)
      if(delmax.lt.tol) goto 61
      icom = 2
      nsrch = 1
      return

C --- Entry point for subsequent iterations ---
   10 continue
      gd2 = zero
      do 11 i = 1,n
      gd2 = gd2 + g2(i) * del(i)
   11 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2

C ... New direction when step size below tol  or g.del dropped to < 1/4
      if (dabs(alpha).lt.atol) goto 200
      if (dabs(gd2/gd1).gt.qrter) goto 31

C --- New direction ---
  200 if (iprint.gt.0) write(iprint,103)
  103 format(/6x,'change direction')
      alpha = alpha2 - alpha1
      dg = alpha * (gd2 - gd1)
      do 21 i = 1,n
      g1(i) = g2(i) - g1(i)
      del(i) = alpha * del(i)
   21 continue

C ... Update Hessian
      gwg = zero
      do 23 i = 1,n
      wrk(i) = zero
      do 22 j = 1,n
      wrk(i) = wrk(i) + w(i,j) * g1(j)
   22 continue
      gwg = gwg + g1(i) * wrk(i)
   23 continue

      do 24 i = 1,n
      g1(i) = g2(i)
      g2(i) = del(i)
      del(i) = zero
   24 continue

      q = one + gwg/dg
      gd1 = zero
      delmax = zero
      do 26 i = 1,n
      r = - g2(i)/dg
      s = (-wrk(i) + q * g2(i))/dg
      do 25 j = 1,n
      w(i,j) = w(i,j) + r * wrk(j) + s * g2(j)
      del(i) = del(i) - w(i,j) * g1(j)
   25 continue
      delmax = dmax1(delmax,dabs(del(i)))
      gd1 = gd1 + g1(i) * del(i)
   26 continue
      gd2 = zero
      if (iprint.gt.0) write(iprint,101) gd1,gd2

C     This code the same as setup for first iteration; see do 3 above
      if (delmax.lt.tol) goto 61
      factor = dmin1(one,dspmax/delmax)
      delmax = factor * delmax
      if (gd1.gt.zero) factor = - factor
      gd1 = factor * gd1
      do 27 i = 1,n
      del(i) = factor * del(i)
   27 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2
      alpha = one
      alpha1 = zero
      alpha2 = one
      if (iprint.gt.0) write(iprint,102) alpha,alpha1,alpha2
      icom = 2
      nsrch = 1
      return

C --- Continue along current direction vector ---
   31 continue
C ... Jump when an extremum bracketed
      if (icom.eq.3) goto 51
C ... Jump if the curvature is reduced
      if (gd2.gt.gd1) goto 41

      if (iprint.gt.0) write(iprint,104)
  104 format(/6x,'negative curvature')
      nsrch = nsrch + 1
      if (nsrch.gt.5) goto 71

      gd1 = gd2
      do 32 i = 1,n
      g1(i) = g2(i)
   32 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2

      alpha = two * alpha
      if ((alpha * delmax).gt.dspmax) alpha = dspmax/delmax
      alpha1 = alpha2
      alpha2 = alpha1 + alpha
      if (iprint.gt.0) write(iprint,102) alpha,alpha1,alpha2
      return

C ... Curvature is reduced
   41 continue
C ... Has an extremum has been bracketed?
      if (gd2.gt.zero) goto 45

C ... Extremum still not bracketed
      if (iprint.gt.0) write(iprint,105)
  105 format(/6x,'go further in this direction')
      alpha = (alpha1 - alpha2) * gd2/(gd2 - gd1)
      if ((alpha * delmax).gt.dspmax) alpha = dspmax/delmax
      alpha1 = alpha2
      alpha2 = alpha1 + alpha

      gd1 = gd2
      do 42 i = 1,n
      g1(i) = g2(i)
   42 continue
      if (iprint.gt.0) write(iprint,101) gd1,gd2
      if (iprint.gt.0) write(iprint,102) alpha,alpha1,alpha2
      return

C ... First time an extremum has been bracketed; set bounds on minimum
   45 continue
      if (iprint.gt.0) write(iprint,106)
  106 format(/6x,'set bounds on minimum')
      alphal = alpha1
      alphau = alpha2
      if (iprint.gt.0) write(iprint,107) alphal,alphau
  107 format(6x,'lower bound = ',f10.5,10x,'upper bound = ',f10.5)
      icom = 3
      goto 55

C ... Shrink window of extremum
   51 continue
      if (iprint.gt.0) write(iprint,108)
  108 format(/6x,'reset bounds')
      if (gd2.gt.zero) alphau = alpha2
      if (gd2.lt.zero) alphal = alpha2
      if (iprint.gt.0) write(iprint,107) alphal,alphau

C ... Interpolate for new alpha
   55 continue
      if (iprint.gt.0) write(iprint,109)
  109 format(/6x,'interpolate')
      alpha0 = ( - gd1 * alpha2 + gd2 * alpha1)/(gd2 - gd1)
      if (alpha0.gt.alphau) alpha0 = half * (alphau + alphal)
      if (alpha0.lt.alphal) alpha0 = half * (alphau + alphal)
      alpha = alpha0 - alpha2
      if (dabs(gd2).gt.dabs(gd1)) goto 57
      alpha1 = alpha2
      gd1 = gd2
      do 56 i = 1,n
      g1(i) = g2(i)
   56 continue
   57 continue
      alpha2 = alpha0
      if (iprint.gt.0) write(iprint,101) gd1,gd2
      if (iprint.gt.0) write(iprint,102) alpha,alpha1,alpha2
      return

C --- Exit: Minimization converged to tolerance ---
   61 continue
      icom = 1
      if (iprint.gt.0) write(iprint,110)
  110 format(/6x,'valid minimisation.')
      return

C --- Exit: Curvature is of the wrong sign ---
   71 continue
      icom = 1
      write(*,111)
  111 format(/6x,'**** invalid minimisation - persistent positive',1x,
     .     'curvature ****')
      end

