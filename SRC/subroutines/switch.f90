real(8) function tolq()
  tolq=1d-4 !tolerance to judge identical q vectors when rotated
END function tolq

logical function mtosigmaonly() !this is also in fpgw/gwsrc/switches.
  mtosigmaonly=.true.
end function mtosigmaonly
real(8) function epsnevec()
  epsnevec=1d-8 !it was 1d-6
END function epsnevec

logical function mixrealsmooth()
  logical,save :: init=.true.
  integer:: iprint
  ! Takao think mixrho should give a correct guess from informations
  ! of |rho_in - f(rho_in)|**2
  ! In our procedure now, takao think the weight from smooth part is rather small.
  ! Thus our mixing procedure is mainly controlled by atoic part.
  ! This works OK but may be not best...
  !   How to choose wgtsmooth? or it will be better to take correct weighting for
  !   mixing.
  !      mixrealsmooth=.false.
  !===================
  ! ixrealsmooth=T is added on 28Aug2010 -->
  ! ixrealsmooth=F on 24dec2012 (why?) -->
  ! ixrealsmooth=T (move it back) on 16Jan2013.
  mixrealsmooth=.true. !
  if(init) then
     if(iprint()>10) print *,'mixrealsmooth=',mixrealsmooth
     init=.false.
  endif
end function mixrealsmooth

!logical function noelind()
!  noelind=.true. !in mixrho.F. If T, ELIND procedure is not.
!  ! Does elind really works fine? It works for LiC2 case.
!  ! Probably, we first have to modify mixrho.
!end function noelind

logical function enforce_positive_smrho()
  !      enforce smrho to positive in mkpot.F
  enforce_positive_smrho=.true.
end function enforce_positive_smrho

!-----------
!r   1. newsigmasw=F : new result               (test mode)
!r   1. newsigmasw=T (then pmtsig is irrelevant): new result (run mode)
!r Note: you also need to use sigswitch=0 if you want to reproduce old results.

!      logical function newsigmasw()
! newsigmasw: in this case, we only use emax_sigm in hqpe.sc.m.F when we construct sigma.
!!       T: newsigma rotation, and interpolation. !this is still problematic
!        O: old version
!      newsigmasw=.true.
!! in future, I like to modify the interpolation scheme, but not yet.
!      newsigmasw=.true.
!      newsigmasw=.false.
!      end

integer function debugmode()
  debugmode=0
end function debugmode


integer function sigswitch()
  ! sigma interpolation
  !r This switch is effective only when newsigmasw=F.
  !r This is used in hambls.F.

  ! sigswitch=0: old version
  ! sigswitch=1: new version of sigma interpolation. (asig bsig are unused).
  !              Readin constant shift given in ESEAVR, generated by hqpe.
  !              new interpolation mode for self-energy: Neglect asig and bsig
  !      sigswitch=0
  sigswitch=1
end function sigswitch

logical function fullmesh()
  !      fullmesh=.true. !including all G vector to expand charge density. I think this did not work well.
  fullmesh=.false.
end function fullmesh

!      logical function nomshsiz()
!      nomshsiz=.true.
!      end


!! we now use 'noshorbz=T' mode. (exactly speaking, shorbz is now embedded in hamble.F.)
!$$$      logical function noshorbz()
!$$$!! shorbz is confusing (pull back k vector to 1st BZ). Especially, in the case of PMT, where we use exp(i (q+G)r).
!$$$!! It is better to use different algolism in future if required.
!$$$c      noshorbz=.false.
!$$$      noshorbz=.true. !<--- i think this is better in future.
!$$$      end

!integer function matmul_pwhovl()
!  ! switch used in gwd/pwmat.F
!  !  matmul_pwhovl=1 uses matmul,
!  !  matmul_pwhovl=2 and matmul_pwhovl=3 uses BLAS. In cases, it fails in centos(gfortran and so) in core-i7.
!  matmul_pwhovl=2
!end function matmul_pwhovl

logical function oncewrite(id)
  integer:: id
  integer,save:: idx(1:100)=1
  if(id<1 .OR. id >100 ) call rx("oncewrite index out of range")
  oncewrite=.false.
  if( idx(id) ==1)  then
     oncewrite=.true.
     idx(id)=0
  endif
end function oncewrite
