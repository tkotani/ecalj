      subroutine orbl(ib,ldimp,ldim,iprmb,norb,ltab,ktab,off,offl,ndim)
      use m_lmfinit,only: globalvariables
C- Extract a list of l's in given hamiltonian block for one site
C ----------------------------------------------------------------------
Ci Inputs
Ci   ib    :site for which to extract list of l's and k's
Ci   ldimp :hamiltonian block consists of orbitals betw. ldimp and ldim
Ci   ldim  :see ldimp, above
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Co Outputs
Co   norb  :number of orbital types for ib; see Remarks
Co   ltab  :table of l-quantum numbers for each type
Co   ktab  :table of energy index for each type
Co   off   :offset to first orbital for site ib (see Remarks).
Co   offl  :offl(norb) offset in h to this block of orbitals
Co   ndim  :dimension of hamiltonian for this site
Cr Remarks
Cr   Each orbital type is label by a 'l' and a 'k' index
Cr   Each orbital corresponds to a unique radial wave function at the
Cr   site where the orbit is centered.  There can be multiple 'k'
Cr   indices (radial wave function shapes) for a particular l.
Cr
Cr   This routine returns the proper value of  'off'  only for ldim
Cr   = size of hamiltonian lower block.  Determining off through
Cr   iprmb for other blocks requires a loop over site index, which
Cr   is too expensive.  Better to use offH generated by makidx.
Cu Updates
Cu    8 Jun 00 Handles multiple-kappa case, ktab now used
Cu   13 Mar 00 order ltab in downfolding order
Cu    2 Mar 00 offl arranged by iorb=1..norb, not by l
Cu   17 Oct 99 routine revised to use iprmb, rather than old offH
Cu   12 Dec 99 routine generates offl
C ----------------------------------------------------------------------
C     implicit none
      integer ib,ldimp,ldim,iprmb(1),norb,ndim,n0,nkap0
      parameter (n0=10,nkap0=3)
      integer off,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)
C Local
      integer ik,l,lmr,ltabi(n0*nkap0),ktabi(n0*nkap0),
     .offli(n0*nkap0+1),iwk(n0*nkap0)
      integer nl,nkaph,nglob
      save nl,nkaph
      data nl /-1/, nkaph /-1/

C     if (mxorb .eq. -1) mxorb = nglob('mxorb')
Changenglob      if (nl .eq. -1) nl = nglob('nl')
      if (nl .eq. -1) nl = globalvariables%nl
Changenglob      if (nkaph .eq. -1) nkaph = nglob('nkaph')
      if (nkaph .eq. -1) nkaph = globalvariables%nkaph

C --- Make ltab,offl in l order, followed by k order ---
      norb = 0
      ndim = 0
      off = -1
C     lmr = mxorb*(ib-1)
      lmr = nl*nl*nkaph*(ib-1)
      do  ik = 1, nkaph
        do  l = 0, nl-1
          offli(norb+1) = -1
          if (iprmb(lmr+1) .gt. ldimp .and. iprmb(lmr+1) .le. ldim) then
            offli(norb+1) = iprmb(lmr+1) - 1
            if (off .eq. -1) off = offli(norb+1)
            off = min(off,offli(norb+1))
            norb = norb+1
            ndim = ndim + 2*l+1
            ltabi(norb) = l
            ktabi(norb) = ik
          endif
          lmr = lmr + 2*l+1
        enddo
      enddo

C --- Permute to downfolding order ---
      if (norb .gt. n0*nkap0) call rx('orbl: norb .gt. n0')
      call ivheap(1,norb,offli,iwk,1)
      do  l = 1, norb
        ltab(l) = ltabi(iwk(l))
        ktab(l) = ktabi(iwk(l))
        offl(l) = offli(iwk(l))
      enddo

C      call awrit6(' ib %i  ndim,norb= %i %i %-1j ltab=%n:1i'//
C     .  '  offl=%n:1i',' ',80,6,ib,ndim,norb,ltab,norb,offl)
      end

      subroutine iprmsb(mode,ib1,ib2,nbas,offH,indxsh,indxi,offl,norb)
      use m_lmfinit,only: globalvariables
C- Create a permutation table for a hamiltonian subblock
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :1s digit nonzero make indxi
Ci         10s digit:
Ci         :0 do not make offl
Ci         :1  make offl
Ci   ib1   :permutation table generated for subblock in sites ib1..ib2
Ci   ib2   :                  - // -
Ci   nbas  :size of basis
Ci   offH :Offsets to hamiltonian matrix (makidx.f)
Ci  indxsh:permutations ordering orbitals in l+i+h blocks (makidx.f)
Co Outputs
Co  indxi :permutation table for array containing subblock
Co  offl  :offsets to hamiltonian subblock, for each orbital
Co  norb  :number of orbitals in hamiltonian subblock
Cr Remarks
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
      integer nkap0,n0H,n0
      parameter (nkap0=3,n0H=5,n0=10)
      integer mode,ib1,ib2,nbas,indxsh(1),indxi(*),offh(n0H,nkap0,nbas)
      integer offl(*),norb
      integer hdimg,hdimi,horbi,idimg,idimi,iorbi,ldimg,ldimi,lhdimg,
     .lidimg,lmr,lorbi,mxorb,nglob,nlmr,offlm,ib,i,nlm,
     .offnow,norbi,iwk(n0*nkap0),ltab(n0*nkap0),ktab(n0*nkap0)

      ldimg = offH(1,1,nbas+1)
      idimg = offH(2,1,nbas+1)
      hdimg = offH(3,1,nbas+1)
      lidimg = ldimg+idimg
      lhdimg = ldimg+idimg+hdimg
      ldimi = offH(1,1,ib2+1) - offH(1,1,ib1)
      idimi = offH(2,1,ib2+1) - offH(2,1,ib1)
      hdimi = offH(3,1,ib2+1) - offH(3,1,ib1)
      lorbi = 0
      iorbi = ldimi
      horbi = ldimi+idimi
      norbi = ldimi+idimi+hdimi
Changenglob      mxorb = nglob('mxorb')
      mxorb = globalvariables%mxorb
      if (mod(mode,10) .eq. 1) then
        offlm = mxorb*(ib1-1)
        nlmr = mxorb*ib2 - offlm
        do  10  lmr = 1, nlmr
          if (indxsh(lmr+offlm) .le. ldimg) then
            lorbi = lorbi+1
            indxi(lmr) = lorbi
          else if (indxsh(lmr+offlm) .le. lidimg) then
            iorbi = iorbi+1
            indxi(lmr) = iorbi
          else if (indxsh(lmr+offlm) .le. lhdimg) then
            horbi = horbi+1
            indxi(lmr) = iorbi
          else
            norbi = norbi+1
            indxi(lmr) = norbi
          endif
   10   continue
      endif
      if (mod(mode/10,10) .eq. 1) then
        norb = 0
        offnow = 0
C   ... Lower block
        do  20  ib = ib1, ib2
          call orbl(ib,0,ldimg,indxsh,norbi,ltab,ktab,i,iwk,nlm)
          do  22  iorbi = 1, norbi
            norb = norb+1
            offl(norb) = offnow
            offnow = offnow + 2*ltab(iorbi) + 1
   22     continue
   20   continue
        do  30  ib = ib1, ib2
          call orbl(ib,ldimg,lidimg,indxsh,norbi,ltab,ktab,i,iwk,nlm)
          do  32  iorbi = 1, norbi
            norb = norb+1
            offl(norb) = offnow
            offnow = offnow + 2*ltab(iorbi) + 1
   32     continue
   30   continue
        do  40  ib = ib1, ib2
          call orbl(ib,lidimg,lhdimg,indxsh,norbi,ltab,ktab,i,iwk,nlm)
          do  42  iorbi = 1, norbi
            norb = norb+1
            offl(norb) = offnow
            offnow = offnow + 2*ltab(iorbi) + 1
   42     continue
   40   continue
      endif
      end

      subroutine offsHp(iprmb,ib1,ib2,lfast,ldimp,ldim,off,ld)
      use m_lmfinit,only: globalvariables
C- Hamiltonian offset and last orbital for a block of sites
C ----------------------------------------------------------------------
Ci Inputs
Ci   ib1   :first site in subblock
Ci   ib2   :last site  in subblock
Ci   lfast :0 no assumption is made about orbital ordering
Ci         :1 it is assumed that the hamiltonian is ordered by
Ci            site for sites ib1..ib2, i.e. orbitals for site ib1
Ci            occur before orbitals for site ib1+1, etc., and also
Ci            that orbitals between ldimp and ldim span a single
Ci            downfolding subblock.
Ci         :2 an independent mode, which returns the largest number
Ci         :  of orbitals connected to one site.
Ci   ldimp :hamiltonian block consists of orbitals betw. ldimp and ldim
Ci   ldim  :see ldimp, above
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Co Outputs
Co   off   :(lfast=0,1) offset to hamiltonian subblock.
Co         :            off+1 points to first orbital in subblock.
Co         :(lfast=2)   off is not used.
Co   ld    :(lfast=0,1) number of orbitals in subblock
Co         :(lfast=2)   maximum number of orbitals connected with
Co         :            any site in range ib1..ib2.
Cr Remarks
Cr   This routine avoids the use of offH. It is suitable for cases
Cr   when the hamiltonian array is not ordered by site.
Cu Updates
Cu   22 Jun 02 Added lfast=2 mode.
Cu   26 Feb 02 Written by MvS
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer ib1,ib2,lfast,ldimp,ldim,iprmb(*),off,ld
C ... Local parameters
      integer nglob,mxorb,i,k,ib
      save mxorb
      data mxorb /-1/

Changenglob      if (mxorb .eq. -1) mxorb = nglob('mxorb')
      if (mxorb .eq. -1) mxorb = globalvariables%mxorb
      ld = 0

C ... Brute force (no assumption about site ordering)
      if (lfast .eq. 0 .or. lfast .lt. 2 .and. ib1+1 .ge. ib2) then
        if (lfast .eq. 2) return
        call imxmnx((ib2-ib1+1)*mxorb,iprmb(1+mxorb*(ib1-1)),1,1+ldimp,
     .  ldim,i,k)
        off = i-1
        if (i .le. ldim) ld  = k - (i-1)

C ... Fast (assume hamiltonian is ordered by site)
      else
C      Find the first site for which an orbital exists in this block
        do  ib = ib1, ib2
          call imxmnx(mxorb,iprmb(1+mxorb*(ib-1)),1,1+ldimp,ldim,i,k)
C        After a site found with nonzero basis, jump out of loop
          if (lfast .eq. 1) then
            off = i-1
            if (i .le. ldim) goto 10
          endif
C        lfast = 2: loop over all ib1..ib2, ld = max val of k-off
          ld = max(ld,k-i+1)
        enddo
C      No orbitals found ; just exit
        return
   10   continue
C      Find the last site for which an orbital exists in this block
        do  ib = ib2, ib1, -1
          call imxmnx(mxorb,iprmb(1+mxorb*(ib-1)),1,1+ldimp,ldim,i,k)
          if (i .le. ldim) then
            ld  = k - off
            return
          endif
        enddo
      endif

      end

      subroutine imxmnx(n,idx,incx,ilow,ihigh,imin,imax)
C- Min and max value of an integer array, subject to constraints
C  imxmnx returns the largest and smallest values of elements
C  idx(1), idx(1+incx), idx(1+2*incx) .. idx(1+n*incx)
C  which satisfy ilow<=idx(1)<=ihigh
C     implicit none
      integer n,idx(n),incx,ilow,ihigh,imin,imax
      integer i,ix

      imin = ihigh+1
      imax = ilow-1
      ix = 1
      do  10  i = 1, n
        if (ilow .le. idx(ix) .and. idx(ix) .le. ihigh) then
          imin = min(idx(ix),imin)
          imax = max(idx(ix),imax)
        endif
        ix = ix + incx
   10 continue
      end

C      integer function offsH(ib,ldimp,ldim,iprmb)
CC- Returns hamiltonian offset for a particular site and block
CC ----------------------------------------------------------------------
CCi Inputs
CCi   ib    :site
CCi   ldimp :hamiltonian block consists of orbitals betw. ldimp and ldim
CCi   ldim  :see ldimp, above
CCi   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
CCo Outputs
CCo   offsH :hamiltonian offset?
CCr Remarks
CCr   This routine was designed to recover offH info without using it.
CCr   It's not been debugged.  Better to use offH.
CCu Updates
CC ----------------------------------------------------------------------
C      implicit none
C      integer ib,ldimp,ldim,iprmb(1)
CC Local
C      integer nl,mxorb,nglob,ndim,off,lmr,l
C      save nl,mxorb
C      data nl /-1/, mxorb /-1/
C
C      if (mxorb .eq. -1) mxorb = nglob('mxorb')
C      if (nl .eq. -1) nl = nglob('nl')
C
C      if (ib .eq. 1) then
C        offsH = 0
C        return
C      endif
C
CC     Find number of orbitals in prior ib
C      ndim = 0
C      off = -1
C      lmr = mxorb*(ib-2)
C      do  10  l = 0, nl-1
C        if (iprmb(lmr+1) .gt. ldimp .and. iprmb(lmr+1) .le. ldim) then
C          if (off .eq. -1) off = iprmb(lmr+1) - 1
C          ndim = ndim + 2*l+1
C        endif
C        lmr = lmr + 2*l+1
C   10 continue
C
C      offsH = off + ndim
C      end

