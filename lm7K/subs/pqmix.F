      subroutine pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxp,cnst,
     .pold,qold,xold,pnu,qnu,xnew)
C- Iteration-dependent Anderson or Broyden mixing of P and Q
C ------------------------------------------------------------------
Ci Inputs:
Ci   nclass:number of classes, atoms in same class are symmetry-related
Ci   nsp,nl,lmx:number of spins, l's, and lmax for each site
Ci   xold,xnew,nx: vector of extra numbers to include in mix
Ci   mixmod: string containing iteration-dependent mixing.  (See parmxp)
Ci   fnam: file name containing previous iterations
Ci   pold,qold: princ quantum number and moms that generated pnu,qnu
Ci   mxsav:
Ci   mmix:
Ci   cnst  if 0th element is le zero, do nothing.  Else,
Ci         for each cnst(i) nonzero, leave class i out of mixing.
Cio Inputs/Outputs:
Ci   dmxp  : holds a vector of default values for mixing parms,
Ci           and also some output generated by pqmix.
Ci    Mixing parameters, and entries to dmxp holding default values:
Ci    1(I): mixing mode (assigned to local variable broy)
Ci          0, use Anderson mixing
Ci          1  use Broyden mixing, D. Johnson's approach
Ci          2, use C. G. mixing
Ci    2: beta (linear and Anderson mixing only) weighting of output to
Ci           input in making new vector: beta*output + (1-beta)*input
Ci    3: wc  Broyden mixing parameter (see routine Broyden).
Ci           wc<0: set wc_true = abs(wc) * RMS DQ, where RMS DQ is the
Ci           inverse of the RMS difference of input and output vector
Ci    4,5:wt(1,2):(nsp=2 only): pqmix mixes sum (up+down) and difference
Ci                (up-down) of the two spin channels.  They are weighted
Ci                by wt(1) and wt(2) in the mixing.  As special cases,
Ci                wt(2)=0 freezes the moments and mixes the charge only
Ci                wt(1)=0 freezes the charge and mixes the moments only
Ci    6(I): mxsav retain on disc a maximum of mxsav previous iterations.
Ci    7(I): mmix  mix this iteration a maximum of nmix prior iterations.
Ci                If mmix<0, choose a default.
Ci    8(I): nkill if nonzero, mixing file is killed after each multiple
Ci                of nkill iterations
Ci    9: betv
Ci   10: rmscst
Ci   34: wa       (AKA wt(3)) weight with which to include extra numbers
Ci                into the mixing procedure
Co   ... 11-20 are outputs.
Co   11: rmsdel   rms change in mixing vector
Co   12: rms2     rms change in Q only
Co   13: nmix     number of prior iter actually included in the mix
Co   14: broy
Co   15: actual mixing beta used (may be changed interactively)
Co   16-24: tj    Anderson mixing, linear combination of prior iter;
Co                Broyden mixing, Actual wc used
Co   25:          1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
Co
Cio  pnu,qnu:princ quantum number generated generated by hamiltonian
Co Outputs:
Cio  pnu,qnu:mixed principal quantum number and moments
Cr Remarks:
Cr   Original Broyden version written by C. T. Chan, Ames Laboratory.
Cr   See D. Vanderbilt, S. G. Louie in Phys. Rev B 30, 6118 (1984).
Cr   The Broyden method requires a first estimation for the Jacobian
Cr   if no prior information is available.  Therefore, for the first
Cr   iteration, linear mixing is applied to calculate a first
Cr   Jacobian matrix J^(1) as well as beta^(1) and gamma^(1).
Cu Updates
Cu   04 Sep 03 Allow default wa to have independent value
Cu   26 Apr 03 Added MPI calls
C ----------------------------------------------------------------
C     implicit none
C Passed variables:
      integer broy
      character*(*) mixmod
      integer nclass,nl,nsp,nx,lmx(nclass),iter,cnst(0:nclass)
      double precision dmxp(34),
     .pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C Local variables
C mmix: max no. prior iterations available from disk.
      logical parmxp,lcnst
      integer mmix,nda,ic,l,nelts,idum,fopna,j,mxsav,nmix,na,naa,
     .nkill,awrite,lgunit,iprint,ifi,oa,oaa,npq,i1,i2
      integer mpipid,procid
      character outs*80,fnam*8
      double precision wt(3),rmsdel,rms2,wc,beta,beta0,elind,rms2f
C heap:
c      integer w(1)
c      common /w/ w

      real(8),allocatable:: woa(:),w_oa(:),w_oaa(:)


C ... MPI: only master does mixing
      procid = mpipid(1)
      if (procid .eq. 0) then

        if (iprint() .gt. 30) print *, ' '
        lcnst = cnst(0) .gt. 0

C --- Count number of mixing elements; get rms err for parmxp ---
        npq = 0
        rms2 = 0
        do  10  ic = 1, nclass
          if (lcnst) then
            if (cnst(ic) .ne. 0) goto 10
          endif
          do  12  l = 0, lmx(ic)
            npq = npq+1
   12     continue
   10   continue
        npq = npq*4
        nda = npq*nsp
        nda = nda + nx
C ... this call reads nothing from disk since mxsav=0
        nmix = 0
c        call defdr(oa,-nda*(0+2)*2)
        allocate(woa(nda*(0+2)*2))
        woa=0d0
        call pqmxio(nmix,nmix,1,.true.,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qold,xnew,xold,cnst,nda,woa,na,rms2)
C     if (na .ne. nda) call fexit2(-1,1,
C    .  'Exit -1 PQMIX: na=%i but nda=%i',na,nda)
c        call rlse(oa)
        deallocate(woa)

C --- Iteration-dependent mixing parameters ---
        broy  = dmxp(1)
        beta  = dmxp(2)
        wc    = dmxp(3)
        wt(1) = dmxp(4)
        wt(2) = dmxp(5)
        wt(3) = dmxp(34)
        if (nx .eq. 0) wt(3) = -9
        mxsav = nint(dmxp(6))
        nmix  = nint(dmxp(7))
        nkill = nint(dmxp(8))
        elind = dmxp(33)
        fnam  = 'mixm'
        rmsdel = dmxp(11)
        if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,elind,
     .  fnam,wc,nkill,dmxp(9),rms2)) call rx(
     .  'PQMIX: parse in parmxp failed')
C ... Interactively reset mix-parms block
        i1 = 0
        i2 = 0
        call query('mix-parms-block',2,i1)
        call query('block-iter',2,i2)
        if (i1 .gt. 0 .or. i2 .gt. 0) then
          if (i2 .le. 0) i2 = 1
          call parmx0(i1,i2,0d0)
          if (.not. parmxp(iter,mixmod,len(mixmod),broy,nmix,wt,beta,
     .    elind,fnam,wc,nkill,dmxp(9),rms2)) call rx(
     .    'PQMIX: parse in parmxp failed')
        endif
        if (nsp .eq. 1) wt(2) = 0
        if (wt(1)**2+wt(2)**2+wt(3)**2 .eq. 0)
     .  call fexit(-1,111,' Exit -1 PQMIX: '//
     .  'bad mixing weights w =%3:1;6d',wt)
        call dscal(3,1/dsqrt(wt(1)**2+wt(2)**2+wt(3)**2),wt,1)

C --- Determine number of previous iterations available from disk ---
        mmix = 0
        ifi = fopna(fnam,-1,4)
        rewind ifi
        read(ifi,err=30,end=30) idum, nelts
        if (nelts .ne. na) then
          call awrit2(' PQMIX: expecting %i elements but found %i ... '//
     .    'discarding file',' ',80,lgunit(1),na,nelts)
          goto 30
        endif
        if (iprint() .gt. 40) call awrit1(' PQMIX: file '//fnam//
     .  '%a contains %i elements',' ',80,lgunit(1),nelts)
        mmix = idum
   30   continue

C --- Copy new P,Q into work a, read prior iter from disk ---
c        call defdr(oa,-nda*(mxsav+2)*2)
        allocate(w_oa(nda*(mxsav+2)*2))
        w_oa=0d0
        call pqmxio(mmix,mxsav,ifi,.true.,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qold,xnew,xold,cnst,nda,w_oa,na,rms2)

C --- Initial printout ---
        if (iprint() .ge. 20) then
          j = awrite(' PQMIX:  read %i iter from file',
     .    outs,len(outs),0,mmix,0,0,0,0,0,0,0)
          outs(j+2:len(outs)) = fnam
          call awrit1('%a.  RMS DQ=%1,3;3e',outs,80,0,rms2)
          if (rmsdel .ne. 0)
     .    call awrit1('%a  last it=%1,3;3e',outs,80,0,rmsdel)
          do  15  j = 1, 2
            call awrit0('%a',outs,-len(outs),-lgunit(j))
   15     continue
        endif
        rmsdel = rms2

C --- Save updated P,Q on disk ---
        rewind ifi
        write(ifi) min(mmix+1,mxsav), na
        call pqmxio(mmix+1,mxsav,-ifi,.true.,nclass,nl,nsp,nx,lmx,
     .  pnu,pold,qnu,qold,xnew,xold,cnst,nda,w_oa,na,rms2)
        if (nkill .lt. 0) then
          if (iprint() .ge. 20) then
            outs = '    ...  deleting file '//fnam
            call awrit1('%a : nkill=%i',outs,80,-lgunit(1),-nkill)
          endif
          call dfclos(ifi)
        else
          call fclose(ifi)
        endif

C --- Spin polarized case: shuffle average and delta moments ---
        if (nsp .eq. 2 .or. nx .gt. 0) then
          if (wt(2) .ne. 0 .and. nsp .eq. 1) call rx('pqmix bug in wt(2)')
          naa = 0
          if (wt(1) .ne. 0) naa = naa+npq
          if (wt(2) .ne. 0) naa = naa+npq
          if (wt(3) .ne. 0) naa = naa+nx
c          call defdr(oaa,-naa*(mxsav+2)*2)
          allocate(w_oaa(naa*(mxsav+2)*2))
          call pqsclf(0,nda,npq,npq*nsp,(nsp-1)*npq,nx,naa,mxsav,wt,w_oa,
     .    w_oaa,rms2f)
        else
c          oaa = oa
          naa = na
          allocate(w_oaa(naa*(mxsav+2)*2))
          w_oaa=w_oa
        endif

C --- Broyden mixing, Duane Johnson's approach ---
        if (broy .eq. 1 .and. mmix .ne. 0)
     .  call pqmixb(naa,nmix,mmix,mxsav,beta,wc,rms2,w_oaa,dmxp(16))

C --- Broyden mixing, old style ---
C      if (broy .and. mmix .ne. 0)
C     .  call pqmixb(naa,nmix,mmix,mxsav,wc,rms2,w_oaa,dmxp(16))

        if (broy .eq. 2)
     .  call pqmixc(naa,nmix,mmix,mxsav,beta,rms2,w_oaa,dmxp(16))

C --- Anderson mixing ---
        beta0 = beta
        if (broy .eq. 0 .or.
     .  (broy .eq. 1 .and. (mmix .eq. 0 .or. nmix .eq. 0))) then
          call pqmixa(naa,nmix,mmix,mxsav,beta,rms2,w_oaa,dmxp(16))
          broy = 0
        endif

C --- Spin polarized case: undo shuffle ---
        if (nsp .eq. 2 .or. nx .gt. 0) then
          call pqsclb(nda,npq,npq*nsp,(nsp-1)*npq,nx,naa,mxsav,wt,w_oa,
     .    w_oaa)
        endif

C --- Copy mixed P,Q from holding array into P,Q arrays ---
        call pqmxup(na,mxsav,nclass,nl,nsp,nx,lmx,pnu,qnu,xnew,
     .  pold,qold,xold,cnst,nda,w_oa,rms2)

C --- Clean up and exit ---
        if (nmix .lt. 0) dmxp(7) = -nmix
        if (beta0 .ne. beta) dmxp(2) = beta
        dmxp(11) = rmsdel
        dmxp(12) = rms2
        dmxp(13) = iabs(nmix)
        dmxp(14) = broy
        dmxp(15) = beta
        if (broy .eq. 1) dmxp(15) = 1
c        call rlse(oa)
        deallocate(w_oa,w_oaa)

        dmxp(25) = 0
        if (wt(1) .ne. 0 .or. wt(2) .ne. 0) dmxp(25) = 1
        if (wt(3) .ne. 0) dmxp(25) = dmxp(25) + 10
        call parmx0(0,0,rmsdel)

      endif

C --- MPI broadcast everything passed out of pqmix ---
      call mpibc1(pnu,nl*nsp*nclass,4,.false.,'pqmix','pnu')
      call mpibc1(qnu,3*nl*nsp*nclass,4,.false.,'pqmix','qnu')
      call mpibc1(xnew,nx,4,.false.,'pqmix','xnew')
      call mpibc1(dmxp,34,4,.false.,'pqmix','dmxp')

      end
      subroutine pqsclf(mode,nda,npq,offx,off2,nx,na,mxsav,wt,a,a2,rms2)
C- Split into (a+ + a-) and (a+ - a-); include extra data
C ------------------------------------------------------------------
Ci Inputs
Ci   mode  :1 a is already split into (a+ + a-) and (a+ - a-)
Ci   nda   :leading dimension of a
Ci   npq   :number of elements to spin-split with wt(1),wt(2)
Ci   offx  :(nx>0)offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data to weight with w3
Ci   na    :dimension of a2 and number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a     :(na,1:2,i,1) output vector for prev. iteration i
Ci         :(na,1:2,i,2) input  vector for prev. iteration i
Co Outputs
Co   a2    :(*,i,1) output charge and moments, scaled by weights
Co         :(*,i,2) input  charge and moments, scaled by weights
Co   rms2  :root mean square of a2(:,0,1)-a2(:,0,2)
Cr Remarks
Cr   q = a2(1) = wt1*(a(1)+a(2)) and mom = a2(2) = wt2*(a(1)-a(2))
Cr   If wt(1) or wt(2) is zero, a2 holds q or mom only.
Cr   na: no. elts to mix: 2*na if wt1,wt2 ne 0, otherwise na
C ------------------------------------------------------------------
C     implicit none
      integer mode,nda,npq,nx,mxsav,na,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),a2(na,0:mxsav+1,2),
     .rms2,ddot
      integer is,ia,ja

C      print *, '!!'; wt(1) = 1 ; wt(2) = 1
      ja = 0
      if (wt(1) .eq. 0 .and. wt(2) .eq. 0) goto 11
      do  10  is = 0, mxsav+1
        ja = 0
        do  12  ia = 1, npq

C         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
C           print *, 'hi',ia,wt(1:2)
C           print 987, 'rhold+,-',a(ia,is,2),a(ia+off2,is,2)
C           print 987, 'rhnew+,-',a(ia,is,1),a(ia+off2,is,1)
C  987      format(a,2x,4f12.6)
CC          pause
C         endif

          if (wt(1) .ne. 0 .and. mode .eq. 0) then
            ja = ja+1
C           Given (rhnew+ + rhnew-)*wt(1) ,  (rhold+ + rhold-)*wt(1)
            a2(ja,is,1) = (a(ia,is,1) + a(ia+off2,is,1))*wt(1)
            a2(ja,is,2) = (a(ia,is,2) + a(ia+off2,is,2))*wt(1)
          elseif (wt(1) .ne. 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia,is,1)*wt(1)
            a2(ja,is,2) = a(ia,is,2)*wt(1)
          endif
          if (wt(2) .ne. 0 .and. mode .eq. 0) then
            ja = ja+1
C           Given (rhnew+ - rhnew-)*wt(2) ,  (rhold+ - rhold-)*wt(2)
            a2(ja,is,1) = (a(ia,is,1) - a(ia+off2,is,1))*wt(2)
            a2(ja,is,2) = (a(ia,is,2) - a(ia+off2,is,2))*wt(2)
          elseif (wt(2) .ne. 0) then
            ja = ja+1
            a2(ja,is,1) = a(ia+off2,is,1)*wt(2)
            a2(ja,is,2) = a(ia+off2,is,2)*wt(2)
          endif
   12   continue
   10 continue
   11 continue

      if (wt(3) .ne. 0) then
        do  20  ia = 1, nx
          ja = ja+1
          do  22  is = 0, mxsav+1
            a2(ja,is,1) = a(ia+offx,is,1)*wt(3)
            a2(ja,is,2) = a(ia+offx,is,2)*wt(3)
   22     continue
   20   continue
      endif

      rms2 = dsqrt(dabs(ddot(na,a2,1,a2,1)     -
     .2*ddot(na,a2,1,a2(1,0,2),1) +
     .ddot(na,a2(1,0,2),1,a2(1,0,2),1))/(na-0))

      if (ja .ne. na) call rx('pqsclf: element mismatch')

      end
      subroutine pqsclb(nda,npq,offx,off2,nx,na,mxsav,wt,a,a2)
C- Undo split into wt1*q and wt2*mom done by pqsclf
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   offx  :offset to location in a of extra elements
Ci   off2  :offset to spin-down (should be 0 for nsp=1)
Ci   nx    :number of extra data
Ci   na    :dimensions a2; number of data with nonzero weight
Ci   wt    :1,2 for P,Q (up+dn) and (up-dn), and wt(3) for extra
Ci   a2    :mixed q,mom scaled by weights, or portion of a with nonzero weights
Co Outputs
Co   a     :a2 is unscaled and restored into a
Cr Remarks
Cu Updates
Cu   10 Dec 08
C ----------------------------------------------------------------------
C     implicit none
      integer nda,na,npq,nx,mxsav,offx,off2
      double precision wt(3),a(nda,0:mxsav+1,2),
     .a2(na,0:mxsav+1,2),sum,diff
      integer is,ia,ja

      if (wt(1) .eq. 0 .and. wt(2) .eq. 0) then
        ja = 0
      elseif (wt(1) .ne. 0 .and. wt(2) .ne. 0) then
        do  is = 0, mxsav+1
          ja = 1
          do  ia = 1, npq
C          if ((ia .eq. 3221 .or. ia .eq. -3) .and. is .eq. 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'mxold+,-',
C     .        (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2,
C     .        (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
C            print 987, 'mxnew+,-',
C     .        (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2,
C     .        (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
CC 987       format(a,2x,4f12.6)
CC           pause
C          endif
C         mixed  rhonew+,rhold+
            a(ia,is,1)     = (a2(ja,is,1)/wt(1) + a2(ja+1,is,1)/wt(2))/2
            a(ia,is,2)     = (a2(ja,is,2)/wt(1) + a2(ja+1,is,2)/wt(2))/2
C         mixed  rhonew-,rhold-
            a(ia+npq,is,1) = (a2(ja,is,1)/wt(1) - a2(ja+1,is,1)/wt(2))/2
            a(ia+npq,is,2) = (a2(ja,is,2)/wt(1) - a2(ja+1,is,2)/wt(2))/2
            ja = ja+2
          enddo
        enddo
        ja = 2*npq
      elseif (wt(1) .ne. 0) then
        diff = 0
        do  ia = 1, npq
          do  is = 0, mxsav+1
            ja = ia+off2
            sum  = a2(ia,is,1)/wt(1)
            diff = (a(ia,is,1) - a(ja,is,1))
            a(ia,is,1) = (sum + diff)/2
            a(ja,is,1) = (sum - diff)/2
            sum  = a2(ia,is,2)/wt(1)
            diff = (a(ia,is,2) - a(ja,is,2))
            a(ia,is,2) = (sum + diff)/2
            a(ja,is,2) = (sum - diff)/2
          enddo
        enddo
        ja = npq
      elseif (wt(2) .ne. 0) then
        do  ia = 1, npq
          do  is = 0, mxsav+1
            ja = ia+npq

C         if ((ia .eq. -3221 .or. ia .eq. 1) .and. is .eq. 0) then
C            print *, 'hi',ia,wt(1:2)
C            print 987, 'given qold, mixed (+)-(-)',
C     .        (a(ia,is,2) + a(ja,is,2)),a2(ia,is,2)
C            sum  = (a(ia,is,2) + a(ja,is,2))
C            diff = a2(ia,is,2)/wt(2)
C            print 987, 'mixed +,-                ',
C     .        (sum + diff)/2, (sum - diff)/2
C  987       format(a,2x,4f12.6)
C          endif

C         given rhnew+ + rhnew- ; mixed  rhnew+ - rhnew-
            sum  = (a(ia,is,1) + a(ja,is,1))
            diff = a2(ia,is,1)/wt(2)
            a(ia,is,1) = (sum + diff)/2
            a(ja,is,1) = (sum - diff)/2
C         sum = given rhold+ + rhold- ; diff = mixed  rhold+ - rhold-
            sum  = (a(ia,is,2) + a(ja,is,2))
            diff = a2(ia,is,2)/wt(2)
            a(ia,is,2) = (sum + diff)/2
            a(ja,is,2) = (sum - diff)/2
          enddo
        enddo
        ja = npq
      endif

C --- Extra mixing data ---
      if (wt(3) .ne. 0) then
        do  is = 0, mxsav+1
          do  ia = 1, nx
            a(ia+offx,is,1) = a2(ia+ja,is,1)/wt(3)
            a(ia+offx,is,2) = a2(ia+ja,is,2)/wt(3)
          enddo
        enddo
      endif

      end

      subroutine pqsclc(nda,npq,nx,mxsav,a)
C- Copy a(:,0,2) into a(:,0,1)
C ----------------------------------------------------------------------
Ci Inputs
Ci   nda   :leading dimension of a
Ci   npq   :number of P,Q
Ci   nx    :number of extra data
Cio Inputs/Outputs
Cio  a     :On input
Cio        :(*,0,1) mixed output vector
Cio        :(*,0,2) mixed input vector
Cio        :On output
Cio        :(*,0,2) -> (*,0,1)
Cr Remarks
Cu Updates
Cu   10 Dec 08 First created
C ----------------------------------------------------------------------
C     implicit none
      integer nda,npq,nx,mxsav
      double precision a(nda,0:mxsav+1,2)
      integer is,ia

      is = 0
      do  ia = 1, npq+nx
C        if (a(ia,is,1) .ne. a(ia,is,2)) then
C          call rx('pqsclc: oops')
C        endif
        a(ia,is,1) = a(ia,is,2)
      enddo
C     stop 'here'

      end

      subroutine pqmixa(nda,nmix,mmix,mxsav,beta,rms2,a,tj)
C- Anderson mixing of a vector
Ci  mmix: number of iterates available to mix
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
C     implicit none
      integer nda,nmix,mmix,mxsav
      double precision rms2,tj(1),a(nda,0:mxsav+1,2),beta
      integer:: im , imix , jmix , iprint , i1mach , amix
      real(8) ,allocatable :: norm_rv(:)
      integer ,allocatable :: kpvt_iv(:)
      real(8) ,allocatable :: a_rv(:)

      double precision tjmax
      parameter (tjmax = 10d0)
c heap
c      integer w(1)
c      common /w/ w

C ... default nmix
      if (nmix .lt. 0) nmix = 2
      nmix = min(mmix,nmix)
      allocate(norm_rv(mxsav**2))
Ctakao_ZeroClear_NotRequiered        if (mxsav**2<0) norm_rv(:)=0.0d0

      allocate(kpvt_iv(mxsav))
Ctakao_ZeroClear_NotRequiered        if (mxsav<0) kpvt_iv(:)=0

      if (beta .lt. 0) nmix = -nmix
C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix
C ... save PQ array
      allocate(a_rv(nda*(mxsav+2)*2))
Ctakao_ZeroClear_NotRequiered        if (nda*(mxsav+2)*2<0) a_rv(:)=0.0d0

      call dcopy ( nda * ( mxsav + 2 ) * 2 , a , 1 , a_rv , 1 )


C ... for iterations 1,2,... amix needs F-x
    1 continue
      do  10  jmix = 1, nmix
        call daxpy(nda,-1d0,a(1,jmix,2),1,a(1,jmix,1),1)
   10 continue

      call query('beta',4,beta)
      jmix = min(mmix,iabs(imix))
      imix = amix ( nda , jmix , mxsav , 0 , dabs ( beta ) , iprint 
     .( ) , tjmax , norm_rv , kpvt_iv , a , tj , rms2 )

      im = imix
      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. im)
     .call awrit1(' (warning) only %i iter available',
     .' ',80,i1mach(2),mmix)
      if (im .ne. imix) then
        call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

        goto 1
      endif
      nmix = imix

C ... Restore PQ array, updating new x
      call dpscop ( a , a_rv , nda , 1 + nda * ( mxsav + 2 ) , 1 
     .+ nda * ( mxsav + 2 ) , 1d0 )

      call dcopy ( nda * ( mxsav + 2 ) * 2 , a_rv , 1 , a , 1 )

      if (allocated(a_rv)) deallocate(a_rv)
      if (allocated(kpvt_iv)) deallocate(kpvt_iv)
      if (allocated(norm_rv)) deallocate(norm_rv)


      end
C      subroutine pqmixb(nda,nmix,mmix,mxsav,wc,rms2,a,wctrue)
CC- Broyden mixing of a vector, old style
CC ------------------------------------------------------------------
CCi  mmix: number of iterates available to mix
CCi  a:    (*,i,1)  output values for prev. iteration i
CCi        (*,i,2)  input  values for prev. iteration i
CCio nmix: nmix > 0: number of iter to try and mix
CCi        nmix < 0: use mmix instead of nmix.
CCo  nmix: (abs)  number of iter actually mixed.
CCo        (sign) <0, intended that caller update nmix for next call.
CCr  Notations:
CCr  x^(m): input vector for iteration m
CCr  F^(m): difference between output and input vector in iteration m
CC ------------------------------------------------------------------
C      implicit none
C      integer nda,nmix,mmix,mxsav
C      double precision wc,rms2,wctrue,a(nda,0:mxsav+1,2)
C      double precision tol,ddot,dFm,diff,dval
C      parameter (tol=1d-12)
C      integer im,info,i,j,iprint,i1mach,imix,jmix,
C     .  obt,obtx,ojac,obet,ogam,okpvt,oFmp1,oxmp1,odFm,odxm
Cc heap
C      integer w(1)
C      common /w/ w
C
CC --- Allocate some arrays ---
C      call defdr(obt,nda)
C      call defdr(obtx,nda)
C      call defdr(ojac,nda**2)
C      call defdr(obet,nda**2)
C      call defdr(ogam,nda**2)
C      call defdr(oFmp1,nda)
C      call defdr(oxmp1,nda)
C      call defdr(odFm,nda)
C      call defdr(odxm,nda)
C      okpvt = obt
C      wctrue = 0
CC ... imix is a local copy of nmix
C      imix = nmix
C      if (imix .lt. 0) imix = mmix
C
CC --- First Jacobian matrix ---
CC ... See Eq. A6; for beta, eq. A14; for gamma, eq. A15.
CC ... x^(2) = x^(1) + [J^(1)]**(-1) * F^(m), so
CC     J^(1) = F^(1) / [x^(2) - x^(1)]
CC     Also, beta^(1) = 1 and gamma^(1) = J^(1)
C    1 continue
C      call dpzero(w(ojac),nda**2)
C      call dpzero(w(obet),nda**2)
C      call dpzero(w(ogam),nda**2)
C      call dcopy(nda,a(1,mmix,1),1,w(odFm),1)
C      call daxpy(nda,-1d0,a(1,mmix,2),1,w(odFm),1)
C      call dcopy(nda,a(1,mmix-1,2),1,w(oxmp1),1)
C      call dcopy(nda,a(1,mmix,2),1,w(odxm),1)
C      j = 1
C      do  20  i = 1, nda
C        call dvset(w(ogam),j,j,1d0)
C        call dvset(w(obet),j,j,1d0)
C        diff = dval(w(oxmp1),i) - dval(w(odxm),i)
C        dFm  = dval(w(odFm),i)
C        if (dabs(diff) .gt. tol .and. dFm .ne. 0)
C     .    call dvset(w(ogam),j,j,dFm/diff)
C        j = j + 1 + nda
C   20 continue
C
CC --- Starting from iteration mmix, build the Jacobian matrix ---
C      jmix = min(mmix,iabs(imix))
C      do  10  im = jmix, 1, -1
CC  ...  F^(m+1) -> a(*,im-1,1)  x^(m+1) -> a(*,im-1,2)
CC  ...  dF^(m)  -> a(*,im,1)    dx^(m)  -> a(*,im,2)
C        call dcopy(nda,a(1,im-1,2),1,w(oxmp1),1)
C        call dcopy(nda,a(1,im-1,1),1,w(oFmp1),1)
C        call daxpy(nda,-1d0,w(oxmp1),1,w(oFmp1),1)
C        call dcopy(nda,w(oxmp1),1,w(odxm),1)
C        call dcopy(nda,w(oFmp1),1,w(odFm),1)
C        call daxpy(nda,-1d0,a(1,im,2),1,w(odxm),1)
C        call daxpy(nda,-1d0,a(1,im,1),1,w(odFm),1)
C        call daxpy(nda, 1d0,a(1,im,2),1,w(odFm),1)
C        rms2 = dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/(nda-0))
C
CC ---   Determine wc_true if wc < 0 ---
C        if (wc .lt. 0) then
C          wctrue = -wc/dsqrt(nda*rms2**2)
C        else
C          wctrue = wc
C        endif
C
CC ---   Broyden updates gamma,beta,J, making J^(m+1) ---
C        call broydn(w(ojac),w(odFm),w(odxm),w(obet),w(ogam),
C     .    w(obt),w(obtx),nda,wctrue)
C
CC ---   Factor Jacobian; linear mixing if singular ---
C        call dgefa(w(ojac),nda,nda,w(okpvt),info)
C        if (info .ne. 0) then
C          if (iprint() .ge. 30)
C     .      call awrit1(' PQMIXB Broyden iter %i: Jacobian matrix '//
C     .      'singular',' ',80,i1mach(2),jmix-im+1)
C        else
CC     ... Solve J^(m+1) * y = F^(m+1)  with  y = x^(m+2) - x^(m+1)
C          call dgesl(w(ojac),nda,nda,w(okpvt),w(oFmp1),0)
CC     ... Make x^(m+2) = y + x^(m+1)
C          call daxpy(nda,1d0,w(oFmp1),1,w(oxmp1),1)
C          if (iprint() .gt. 40 .or. iprint() .ge. 30 .and. im .eq. 1)
C     .      call awrit5(' PQMIXB  Broyden iter %i:  rms(F-x)='//
C     .      '%1;3e  rms(dx)=%1;3e  wc=%1;3g  nelts=%i',' ',80,i1mach(2),
C     .      jmix-im+1,dsqrt(ddot(nda,w(oFmp1),1,w(oFmp1),1)/nda),
C     .      rms2,wctrue,nda)
C        endif
C
C   10 continue
C
CC --- Check for interactive change of nmix ---
CC NB negative sign signals request for permanent change in nmix
C      im = imix
C      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
C      if (iabs(imix) .gt. mmix .and. imix .ne. im)
C     .  call awrit1(' (warning) only %i iter available',
C     .  ' ',80,i1mach(2),mmix)
C      if (im .ne. imix) goto 1
C      nmix = imix
CC ... If no prior iter allowed, give up on nmix
C      if (nmix .eq. 0) return
C
CC --- Printout ---
C      if (iprint() .gt. 40) then
C        print 310
C        do  12  i = 1, nda
C          if (dabs(a(i,0,1)-a(i,0,2)) .ge. 5d-9)  print 311, i,
C     .      a(i,0,2),a(i,0,1),a(i,0,1)-a(i,0,2),dval(w(oxmp1),i)
C   12   continue
C  311   format(i5,4f14.6)
C  310   format(14x,'Old',11x,' New',9x,'Diff',10x,'Mixed')
C      endif
C
CC --- Save x^(m+2) into a(*,0,2) and exit ---
C      if (info .ne. 0) then
C        nmix = 0
C        return
C      endif
C      call dcopy(nda,w(oxmp1),1,a(1,0,2),1)
C      call rlse(obt)
C      end
      subroutine pqmixb(nda,nmix,mmix,mxsav,beta,wc,rms2,a,wctrue)
C- Broyden mixing of a vector, Duane Johnson's approach
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
C     implicit none
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,wctrue,a(nda,0:mxsav+1,2)
      double precision ddot,dval,wc
      integer:: im , km , i , iprint , i1mach , imix , jmix
      real(8) ,allocatable :: xmp1_rv(:)

      integer:: broyj
      real(8) ,allocatable :: f_rv(:)
      real(8) ,allocatable :: ui_rv(:)
      real(8) ,allocatable :: vti_rv(:)
      real(8) ,allocatable :: xold_rv(:)
      real(8) ,allocatable :: df_rv(:)
      real(8) ,allocatable :: dx_rv(:)
      real(8) ,allocatable :: wk_rv(:)


c heap
c      integer w(1)
c      common /w/ w

C --- Allocate some arrays ---
      allocate(xmp1_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) xmp1_rv(:)=0.0d0

      allocate(f_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) f_rv(:)=0.0d0

      allocate(ui_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) ui_rv(:)=0.0d0

      allocate(vti_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) vti_rv(:)=0.0d0

      allocate(xold_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) xold_rv(:)=0.0d0

      allocate(df_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) df_rv(:)=0.0d0

      allocate(dx_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) dx_rv(:)=0.0d0


C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
    1 jmix = min(mmix,iabs(imix))
      allocate(wk_rv(nda*2*(jmix+2)))
Ctakao_ZeroClear_NotRequiered        if (nda*2*(jmix+2)<0) wk_rv(:)=0.0d0

      do  10  km = 1, jmix
C   ... this loops from most-distant to most-recent
        im = jmix-km+1
C   ... this loops from most-recent to most-distant
C       im = km

        call dcopy ( nda , a ( 1 , im - 1 , 1 ) , 1 , dx_rv , 1 )

        call daxpy ( nda , - 1d0 , a ( 1 , im - 1 , 2 ) , 1 , dx_rv 
     .  , 1 )

        rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( 
     .  nda - 0 ) )


C ---   Determine wc_true if wc < 0 ---
        if (wc .lt. 0) then
          wctrue = -wc/100/dsqrt(nda*rms2**2)
          wctrue = min(max(wctrue,1d0),1d4)
        else
          wctrue = wc
        endif
        if (km .eq. 1) wctrue = .01d0

        i = iprint()
        if (km .ne. jmix) i = i-20
        i = broyj ( nda , a ( 1 , im - 1 , 2 ) , dx_rv , km , 0 , 
     .  i , beta , 0d0 , 0d0 , 0d0 , wctrue , wk_rv , nda , xmp1_rv 
     .  )

   10 continue

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      im = imix
      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. im)
     .call awrit1(' (warning) only %i iter available',
     .' ',80,i1mach(2),mmix)
      if (im .ne. imix) goto 1
      nmix = imix
C ... If no prior iter allowed, give up on nmix
Cki#error, have return with len(w_varlist)>0 at line 769
      if ( nmix .eq. 0 ) then
        if (allocated(wk_rv)) deallocate(wk_rv)
        if (allocated(dx_rv)) deallocate(dx_rv)
        if (allocated(df_rv)) deallocate(df_rv)
        if (allocated(xold_rv)) deallocate(xold_rv)
        if (allocated(vti_rv)) deallocate(vti_rv)
        if (allocated(ui_rv)) deallocate(ui_rv)
        if (allocated(f_rv)) deallocate(f_rv)
        if (allocated(xmp1_rv)) deallocate(xmp1_rv)
        return
      endif


C --- Printout ---
      if (iprint().gt.60 .or. (iprint().ge.40 .and. nda.le.100)) then
        print 310
        do  12  i = 1, nda
          if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) .ge. 5d - 9 ) 
     .    print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 
     .    , 1 ) - a ( i , 0 , 2 ) , dval ( xmp1_rv , i )

   12   continue
  311   format(i5,4f14.6)
  310   format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
      endif

C --- Save x^(m+2) into a(*,0,2) and exit ---
      call dcopy ( nda , xmp1_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

      if (allocated(xmp1_rv)) deallocate(xmp1_rv)

      if (allocated(f_rv)) deallocate(f_rv)
      if (allocated(ui_rv)) deallocate(ui_rv)
      if (allocated(vti_rv)) deallocate(vti_rv)
      if (allocated(xold_rv)) deallocate(xold_rv)
      if (allocated(df_rv)) deallocate(df_rv)
      if (allocated(dx_rv)) deallocate(dx_rv)
      if (allocated(wk_rv)) deallocate(wk_rv)

      end
      subroutine pqmixc(nda,nmix,mmix,mxsav,beta,rms2,a,xn)
C- C. G. mixing of a vector
C ------------------------------------------------------------------
Ci  mmix: number of iterates available to mix
Ci  a:    (*,i,1)  output values for prev. iteration i
Ci        (*,i,2)  input  values for prev. iteration i
Cio nmix: nmix > 0: number of iter to try and mix
Ci        nmix < 0: use mmix instead of nmix.
Co  nmix: (abs)  number of iter actually mixed.
Co        (sign) <0, intended that caller update nmix for next call.
Co  xn:   projection along line minimization.
Co        (sign) <0, new line minimization
Cr  Notations:
Cr  x^(m): input vector for iteration m
Cr  F^(m): difference between output and input vector in iteration m
C ------------------------------------------------------------------
C     implicit none
      integer nda,nmix,mmix,mxsav
      double precision beta,rms2,xn,a(nda,0:mxsav+1,2)
C Local variables
      double precision ddot,dval,dxmx,xtoll,grfac,wk(0:26)
      save wk
      real(8) ,allocatable :: p_rv(:)
      real(8) ,allocatable :: dx_rv(:)

      integer ir,imix,jmix,km,iprint,i1mach,i,idx,idamax
c heap
c      integer w(1)
c      common /w/ w

C --- Allocate some arrays ---
      allocate(p_rv(nda*6))
Ctakao_ZeroClear_NotRequiered        if (nda*6<0) p_rv(:)=0.0d0

      allocate(dx_rv(nda))
Ctakao_ZeroClear_NotRequiered        if (nda<0) dx_rv(:)=0.0d0


C ... imix is a local copy of nmix
      imix = nmix
      if (imix .lt. 0) imix = mmix

C --- Starting from iteration mmix, build the Jacobian matrix ---
    1 jmix = min(mmix,iabs(imix))
      ir = 0
      do  10  km = jmix, 0, -1

        call dcopy ( nda , a ( 1 , km , 2 ) , 1 , dx_rv , 1 )

        call daxpy ( nda , - 1d0 , a ( 1 , km , 1 ) , 1 , dx_rv , 
     .  1 )

        rms2 = dsqrt ( ddot ( nda , dx_rv , 1 , dx_rv , 1 ) / ( 
     .  nda - 0 ) )

        idx = idamax ( nda , dx_rv , 1 )

        dxmx = beta * abs ( dval ( dx_rv , idx ) )

        xtoll = dxmx/10
        grfac = min(2d0,1/beta)
        call pshpr(80)
        wk(0) = xn
        call drgrzr ( nda , a ( 1 , km , 2 ) , dx_rv , p_rv , w 
     .  , xtoll , dxmx , 1d - 10 , 1d - 10 , grfac , wk , ' ' , 00040 
     .  , ir )

        xn = wk(0)
        call poppr

   10 continue
      if (ir .eq. -1) xn = -xn

C --- Check for interactive change of nmix ---
C NB negative sign signals request for permanent change in nmix
      km = imix
      if (iprint() .gt. 30) call query('redo, nmix=',2,imix)
      if (iabs(imix) .gt. mmix .and. imix .ne. km)
     .call awrit1(' (warning) only %i iter available',
     .' ',80,i1mach(2),mmix)
      if (km .ne. imix) goto 1
      nmix = imix

C --- Printout ---
      if (iprint() .gt. 40) then
        print 310
        do  12  i = 1, nda
          if ( dabs ( a ( i , 0 , 1 ) - a ( i , 0 , 2 ) ) .ge. 5d - 9 ) 
     .    print 311 , i , a ( i , 0 , 2 ) , a ( i , 0 , 1 ) , a ( i , 0 
     .    , 1 ) - a ( i , 0 , 2 ) , dval ( p_rv , i )

   12   continue
  311   format(i5,4f14.6)
  310   format(14x,'Old',11X,' New',9X,'Diff',10X,'Mixed')
      endif

C --- Save x^(m+2) into a(*,0,2) and exit ---
      call dcopy ( nda , p_rv , 1 , a ( 1 , 0 , 2 ) , 1 )

      if (allocated(dx_rv)) deallocate(dx_rv)
      if (allocated(p_rv)) deallocate(p_rv)

      end
      subroutine pqmxup(na,mxsav,nclass,nl,nsp,nx,lmx,
     .pnu,qnu,xnew,pold,qold,xold,cnst,nda,a,rms2)
C- Copy from holding array into P,Q
C     implicit none
      integer nda,mxsav,nclass,nl,nsp,nx,lmx(nclass),cnst(0:*)
      double precision a(nda,0:mxsav+1,2),rms2,
     .pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx),ddot
      integer ic,isp,l,na,i
      logical lcnst

      lcnst = cnst(0) .gt. 0
      na = 1
      rms2 = 0
      do  11  isp = 1, nsp
        do  11  ic = 1, nclass
          if (lcnst) then
            if (cnst(ic) .ne. 0) goto 11
          endif
          do  12  l = 0, lmx(ic)
C       print *, pold(l+1,isp,ic) - a(na,0,2)
            pnu(l+1,isp,ic) = a(na,0,2)
            rms2 = rms2 + (qold(1,l+1,isp,ic) - a(na+1,0,2))**2
            do  21  i = 1, 3
C       print *, i, qold(i,l+1,isp,ic) -  a(na+i,0,2)
              qnu(i,l+1,isp,ic) = a(na+i,0,2)
   21       continue
            na = na+4
   12     continue
   11 continue

      call dcopy(nx,a(na,0,2),1,xnew,1)
      rms2 =  rms2 + ddot(nx,xnew,1,xnew,1) -
     .2*ddot(nx,xnew,1,xold,1) +
     .ddot(nx,xold,1,xold,1)
      na = na + nx
      rms2 = dsqrt(4*rms2/(na-0))
      end
      subroutine pqmxio(nmix,mxsav,ifi,lbin,nclass,nl,nsp,nx,lmx,
     .pnu,pold,qnu,qold,xnew,xold,cnst,nda,a,na,rms2)
C- Copy P,Q into holding array, read prior P,Q from disk
C -----------------------------------------------------------------
Ci  nmix  number of prior iterations sought; returns no. actually read
Ci  mxsav maximum number of prior iter to save, and dimensions a
Ci  ifi   : >0, copy pnu,qnu to a(1..nda,0,1), pold,qold to a(1..nda,0,2)
Ci          read prior iter into a(1..nda,1..nmix,1..2)
Ci          <0  write a(1..nda,1..nmix,1..2) to disk
Ci          (NB: Does not update pnu,qnu from a)
Ci  lbin  :T: read prior iterations from binary file, else ascii file
Ci  nclass:number of inequivalent classes
Ci  nl    :(global maximum l) + 1
Ci  nsp   :2 for spin-polarized case, otherwise 1
Ci  nx    :number of p,q and number of extra data xnew,xold
Ci  lmx   :lmx(j) = maximum l for atom j
Ci  pnu   :boundary conditions.  If Dl = log. deriv. at rmax,
Ci         pnu = .5 - atan(Dl)/pi + (princ.quant.number).
Ci  qnu   :energy-weighted moments of the sphere charges
Ci  qold  :old moments
Ci  xnew  :additional parameters to be included in mix
Ci  xold  :additional parameters to be included in mix
Ci  cnst  :for each class, if nonzero, copy pold->pnu
Ci  nda   :leading dimension of a (must be at least na)
Cio Inputs/Outputs
Cio (Inputs for ifi<0, outputs for ifi>0)
Cio  a    :array containing input,output of prior iterations.
Cio       :a is updated with input,output from last iteration.
Cio       :and prior iterations are read from file ifi
Cio  na   :number of values included into mix
Co Outputs
Ci  rms2  :rms change in parameters to be mixed.
C -----------------------------------------------------------------
C     implicit none
      logical lbin
      integer nda,nmix,mxsav,ifi,nclass,nl,nsp,lmx(nclass),nx,cnst(0:*)
      double precision a(nda,0:mxsav+1,2),rms2,
     .pnu(nl,nsp,nclass), qnu(3,nl,nsp,nclass), xnew(nx),
     .pold(nl,nsp,nclass),qold(3,nl,nsp,nclass),xold(nx)
C Local variables
      double precision ddot
      integer i1mach,ic,na,isp,i,j,k,l,iprint,mmix
      logical lcnst

      lcnst = cnst(0) .gt. 0

C --- Copy p,q to a; calc. RMS error; read prior iter from ifi ---
      if (ifi .gt. 0) then
        na = 1
        do  10  isp = 1, nsp
          do  10  ic = 1, nclass
            if (lcnst) then
              if (cnst(ic) .ne. 0) then
                do  21  l = 0, lmx(ic)
                  pnu(l+1,isp,ic) = pold(l+1,isp,ic)
                  do  21  i = 1, 3
                    qnu(i,l+1,isp,ic) = qold(i,l+1,isp,ic)
   21           continue
                goto 10
              endif
            endif
            do  11  l = 0, lmx(ic)
              a(na,0,1) = pnu(l+1,isp,ic)
              a(na,0,2) = pold(l+1,isp,ic)
              do  20  i = 1, 3
                a(na+i,0,1) = qnu(i,l+1,isp,ic)
                a(na+i,0,2) = qold(i,l+1,isp,ic)
   20         continue
              na = na+4
   11       continue
   10   continue

C   ... Append extra vector to a
        call dcopy(nx,xnew,1,a(na,0,1),1)
        call dcopy(nx,xold,1,a(na,0,2),1)
        na = na + nx - 1
        rms2 =  dsqrt(dabs(ddot(na,a,1,a,1) - 2*ddot(na,a,1,a(1,0,2),1)
     .  + ddot(na,a(1,0,2),1,a(1,0,2),1))/(na-0))
C        call prmx('a1',a,na,na,1)
C        call prmx('a2',a(1,0,2),na,na,1)
        mmix = 0
        if (lbin) then
          do  30  j = 1, min(nmix,mxsav)
            read(ifi,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
            mmix = j
   30     continue
        else
          do  33  j = 1, min(nmix,mxsav)
            read(ifi,333,err=31,end=31) ((a(i,j,k), i=1,na), k=1,2)
            mmix = j
   33     continue
        endif
        goto 32
   31   if (iprint() .ge. 30)
     .  call awrit2(' PQMXIO:  sought %i mixing iter from disk, but'//
     .  ' read %i',' ',80,i1mach(2),nmix,mmix)
   32   continue
        nmix = mmix
C --- Save iterations to disk ---
      else
        if (lbin) then
          do  34  j = 0, min(nmix,mxsav)-1
            write(-ifi) ((a(i,j,k), i=1,na), k=1,2)
   34     continue
        else
          do  35  j = 0, min(nmix,mxsav)-1
            write(-ifi,333) ((a(i,j,k), i=1,na), k=1,2)
   35     continue
  333     format(1p,4e20.13)
        endif
      endif
      end
C testing ...
C      subroutine fmain
C      implicit none
C      integer nclass,nl,nsp
C      parameter (nclass=2,nl=3,nsp=2)
C      integer lmx(nclass),fadd,mxsav,mmix,nmix,ifi,nlspc,fopn,i,wksize,
C     .  nx,iter,fopna
C      double precision pnu(nl,nsp,nclass),pold(nl,nsp,nclass),
C     .  qnu(3,nl,nsp,nclass),qold(3,nl,nsp,nclass),wj(10),rms2,
C     .  rmsdel,pwk(nl,nsp,nclass),qwk(3,nl,nsp,nclass),
C     .  xnew(100),xold(100),dmxprm(20)
C      character*82 mixmod
C      parameter (wksize=250000)
C      integer w(wksize)
C      common /w/ w
C
C      call wkinit(wksize)
C      call finits(2,0,0,ifi)
C      call initqu(.true.)
C      i = 51
C      call pshpr(i)
C
C      mixmod = 'B,w=0,1,wa=1,fn=mm,k=2'
C      mixmod = 'B,n=3,w=0,1,wa=1,fn=mm,k=3'
C      mixmod = 'B,w=1,2,wa=1,b=.4,n=3;B,b=.02,w=2,1,n=3'
C      dmxprm(1) = 0.0d0
C      dmxprm(2) = 1.0d0
C      dmxprm(3) = -1.0d0
C      dmxprm(4) = 1.0d0
C      dmxprm(5) = 1.0d0
C      dmxprm(6) = 50.0d0
C      dmxprm(7) = -1.0d0
C      dmxprm(8) = -1.0d0
C      dmxprm(9) = 1.0d0
C      dmxprm(10) = -1.0d0
C      dmxprm(11) = 0.0d0
C      dmxprm(12) = 0.0d0
C      dmxprm(13) = 0.0d0
C      dmxprm(14) = 0.0d0
C      dmxprm(15) = 0.0d0
C      dmxprm(16) = 0.0d0
C      dmxprm(17) = 0.0d0
C      dmxprm(18) = 0.0d0
C      dmxprm(19) = 0.0d0
C      dmxprm(20) = 0.0d0
C      print *, 'iter?'
C      read(*,*) iter
C*     iter = 5
C      nx = 9*nclass
C
C      ifi = fadd('LOG',10,0)
C      nlspc = nl*nsp*nclass
C      do  2  i = 1, nclass
C    2 lmx(i) = 2
C
C      ifi = fopna('MIXV',-1,0)
C      do  10  i = 1, 1
C      call dfdump(pnu,nlspc,ifi)
C      call dfdump(pold,nlspc,ifi)
C      call dfdump(qnu,3*nlspc,ifi)
C      call dfdump(qold,3*nlspc,ifi)
C      call dfdump(xnew,nx,ifi)
C      call dfdump(xold,nx,ifi)
C      if (i .gt. 1) then
C        call snot(1*nl*nsp*nclass,pwk,pold)
C        call snot(3*nl*nsp*nclass,qwk,qold)
C      endif
C      call pqmix(nclass,nl,lmx,nsp,nx,iter,mixmod,dmxprm,0,
C     .  pold,qold,xold,pnu,qnu,xnew)
C      stop 'patch call to shoctl'
C      call shoctl(nclass,'xx',nl,nsp,lmx,pnu,qnu,
C     .  0,pnu,fopn('LOG'))
C
C   10 continue
C      end
C      subroutine snot(n,f1,f2)
C      implicit none
C      integer n,i
C      double precision f1(n),f2(n)
C
C      write(*,110)
C      do  12  i = 1, n
C        if (dabs(f1(i)-f2(i)) .ge. 5d-9)
C     .  write(*,111) i,f1(i),f2(i),f1(i)-f2(i)
C   12 continue
C  111 format(i5,4f14.6)
C  110 format(14x,'OLD',11X,' NEW',9X,'DIFF',10X,'MIXED')
C      end

